
NUCLEO-N657X0-Q_GettingStarted_ImageClassification.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000034c  34000400  34000400  00000400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0001ddc4  34000750  34000750  00000750  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .gnu.sgstubs  00000020  3401e520  3401e520  0001e520  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000026cc  3401e540  3401e540  0001e540  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM.extab    00000000  34020c0c  34020c0c  00020e28  2**0
                  CONTENTS
  5 .ARM          00000008  34020c0c  34020c0c  00020c0c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .preinit_array 00000000  34020c14  34020e28  00020e28  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  7 .init_array   00000004  34020c14  34020c14  00020c14  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .fini_array   00000004  34020c18  34020c18  00020c18  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .data         0000020c  34020c1c  34020c1c  00020c1c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .bss          000006d8  34020e28  34020e28  00020e28  2**2
                  ALLOC
 11 ._user_heap_stack 00004200  34021500  34021500  00020e28  2**0
                  ALLOC
 12 .ARM.attributes 0000003a  00000000  00000000  00020e28  2**0
                  CONTENTS, READONLY
 13 .debug_info   00043e97  00000000  00000000  00020e62  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00006414  00000000  00000000  00064cf9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 000032d0  00000000  00000000  0006b110  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 000027a3  00000000  00000000  0006e3e0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00079fc7  00000000  00000000  00070b83  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0003f9dc  00000000  00000000  000eab4a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    003a2891  00000000  00000000  0012a526  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000043  00000000  00000000  004ccdb7  2**0
                  CONTENTS, READONLY
 21 .debug_frame  0000e928  00000000  00000000  004ccdfc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 00000155  00000000  00000000  004db724  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

34000750 <__do_global_dtors_aux>:
34000750:	b510      	push	{r4, lr}
34000752:	4c05      	ldr	r4, [pc, #20]	@ (34000768 <__do_global_dtors_aux+0x18>)
34000754:	7823      	ldrb	r3, [r4, #0]
34000756:	b933      	cbnz	r3, 34000766 <__do_global_dtors_aux+0x16>
34000758:	4b04      	ldr	r3, [pc, #16]	@ (3400076c <__do_global_dtors_aux+0x1c>)
3400075a:	b113      	cbz	r3, 34000762 <__do_global_dtors_aux+0x12>
3400075c:	4804      	ldr	r0, [pc, #16]	@ (34000770 <__do_global_dtors_aux+0x20>)
3400075e:	f3af 8000 	nop.w
34000762:	2301      	movs	r3, #1
34000764:	7023      	strb	r3, [r4, #0]
34000766:	bd10      	pop	{r4, pc}
34000768:	34020e28 	.word	0x34020e28
3400076c:	00000000 	.word	0x00000000
34000770:	3401e4fc 	.word	0x3401e4fc

34000774 <frame_dummy>:
34000774:	b508      	push	{r3, lr}
34000776:	4b03      	ldr	r3, [pc, #12]	@ (34000784 <frame_dummy+0x10>)
34000778:	b11b      	cbz	r3, 34000782 <frame_dummy+0xe>
3400077a:	4903      	ldr	r1, [pc, #12]	@ (34000788 <frame_dummy+0x14>)
3400077c:	4803      	ldr	r0, [pc, #12]	@ (3400078c <frame_dummy+0x18>)
3400077e:	f3af 8000 	nop.w
34000782:	bd08      	pop	{r3, pc}
34000784:	00000000 	.word	0x00000000
34000788:	34020e2c 	.word	0x34020e2c
3400078c:	3401e4fc 	.word	0x3401e4fc

34000790 <strlen>:
34000790:	4603      	mov	r3, r0
34000792:	f813 2b01 	ldrb.w	r2, [r3], #1
34000796:	2a00      	cmp	r2, #0
34000798:	d1fb      	bne.n	34000792 <strlen+0x2>
3400079a:	1a18      	subs	r0, r3, r0
3400079c:	3801      	subs	r0, #1
3400079e:	4770      	bx	lr

340007a0 <__aeabi_uldivmod>:
340007a0:	b953      	cbnz	r3, 340007b8 <__aeabi_uldivmod+0x18>
340007a2:	b94a      	cbnz	r2, 340007b8 <__aeabi_uldivmod+0x18>
340007a4:	2900      	cmp	r1, #0
340007a6:	bf08      	it	eq
340007a8:	2800      	cmpeq	r0, #0
340007aa:	bf1c      	itt	ne
340007ac:	f04f 31ff 	movne.w	r1, #4294967295	@ 0xffffffff
340007b0:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
340007b4:	f000 b9b0 	b.w	34000b18 <__aeabi_idiv0>
340007b8:	f1ad 0c08 	sub.w	ip, sp, #8
340007bc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
340007c0:	f000 f806 	bl	340007d0 <__udivmoddi4>
340007c4:	f8dd e004 	ldr.w	lr, [sp, #4]
340007c8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
340007cc:	b004      	add	sp, #16
340007ce:	4770      	bx	lr

340007d0 <__udivmoddi4>:
340007d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340007d4:	9d09      	ldr	r5, [sp, #36]	@ 0x24
340007d6:	4688      	mov	r8, r1
340007d8:	4604      	mov	r4, r0
340007da:	468e      	mov	lr, r1
340007dc:	2b00      	cmp	r3, #0
340007de:	d14a      	bne.n	34000876 <__udivmoddi4+0xa6>
340007e0:	428a      	cmp	r2, r1
340007e2:	4617      	mov	r7, r2
340007e4:	d95f      	bls.n	340008a6 <__udivmoddi4+0xd6>
340007e6:	fab2 f682 	clz	r6, r2
340007ea:	b14e      	cbz	r6, 34000800 <__udivmoddi4+0x30>
340007ec:	f1c6 0320 	rsb	r3, r6, #32
340007f0:	fa01 fe06 	lsl.w	lr, r1, r6
340007f4:	40b7      	lsls	r7, r6
340007f6:	40b4      	lsls	r4, r6
340007f8:	fa20 f303 	lsr.w	r3, r0, r3
340007fc:	ea43 0e0e 	orr.w	lr, r3, lr
34000800:	ea4f 4817 	mov.w	r8, r7, lsr #16
34000804:	fa1f fc87 	uxth.w	ip, r7
34000808:	0c23      	lsrs	r3, r4, #16
3400080a:	fbbe f1f8 	udiv	r1, lr, r8
3400080e:	fb08 ee11 	mls	lr, r8, r1, lr
34000812:	fb01 f20c 	mul.w	r2, r1, ip
34000816:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
3400081a:	429a      	cmp	r2, r3
3400081c:	d907      	bls.n	3400082e <__udivmoddi4+0x5e>
3400081e:	18fb      	adds	r3, r7, r3
34000820:	f101 30ff 	add.w	r0, r1, #4294967295	@ 0xffffffff
34000824:	d202      	bcs.n	3400082c <__udivmoddi4+0x5c>
34000826:	429a      	cmp	r2, r3
34000828:	f200 8154 	bhi.w	34000ad4 <__udivmoddi4+0x304>
3400082c:	4601      	mov	r1, r0
3400082e:	1a9b      	subs	r3, r3, r2
34000830:	b2a2      	uxth	r2, r4
34000832:	fbb3 f0f8 	udiv	r0, r3, r8
34000836:	fb08 3310 	mls	r3, r8, r0, r3
3400083a:	fb00 fc0c 	mul.w	ip, r0, ip
3400083e:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
34000842:	4594      	cmp	ip, r2
34000844:	d90b      	bls.n	3400085e <__udivmoddi4+0x8e>
34000846:	18ba      	adds	r2, r7, r2
34000848:	f100 33ff 	add.w	r3, r0, #4294967295	@ 0xffffffff
3400084c:	bf2c      	ite	cs
3400084e:	2401      	movcs	r4, #1
34000850:	2400      	movcc	r4, #0
34000852:	4594      	cmp	ip, r2
34000854:	d902      	bls.n	3400085c <__udivmoddi4+0x8c>
34000856:	2c00      	cmp	r4, #0
34000858:	f000 813f 	beq.w	34000ada <__udivmoddi4+0x30a>
3400085c:	4618      	mov	r0, r3
3400085e:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
34000862:	eba2 020c 	sub.w	r2, r2, ip
34000866:	2100      	movs	r1, #0
34000868:	b11d      	cbz	r5, 34000872 <__udivmoddi4+0xa2>
3400086a:	40f2      	lsrs	r2, r6
3400086c:	2300      	movs	r3, #0
3400086e:	e9c5 2300 	strd	r2, r3, [r5]
34000872:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34000876:	428b      	cmp	r3, r1
34000878:	d905      	bls.n	34000886 <__udivmoddi4+0xb6>
3400087a:	b10d      	cbz	r5, 34000880 <__udivmoddi4+0xb0>
3400087c:	e9c5 0100 	strd	r0, r1, [r5]
34000880:	2100      	movs	r1, #0
34000882:	4608      	mov	r0, r1
34000884:	e7f5      	b.n	34000872 <__udivmoddi4+0xa2>
34000886:	fab3 f183 	clz	r1, r3
3400088a:	2900      	cmp	r1, #0
3400088c:	d14e      	bne.n	3400092c <__udivmoddi4+0x15c>
3400088e:	4543      	cmp	r3, r8
34000890:	f0c0 8112 	bcc.w	34000ab8 <__udivmoddi4+0x2e8>
34000894:	4282      	cmp	r2, r0
34000896:	f240 810f 	bls.w	34000ab8 <__udivmoddi4+0x2e8>
3400089a:	4608      	mov	r0, r1
3400089c:	2d00      	cmp	r5, #0
3400089e:	d0e8      	beq.n	34000872 <__udivmoddi4+0xa2>
340008a0:	e9c5 4e00 	strd	r4, lr, [r5]
340008a4:	e7e5      	b.n	34000872 <__udivmoddi4+0xa2>
340008a6:	2a00      	cmp	r2, #0
340008a8:	f000 80ac 	beq.w	34000a04 <__udivmoddi4+0x234>
340008ac:	fab2 f682 	clz	r6, r2
340008b0:	2e00      	cmp	r6, #0
340008b2:	f040 80bb 	bne.w	34000a2c <__udivmoddi4+0x25c>
340008b6:	1a8b      	subs	r3, r1, r2
340008b8:	ea4f 4e12 	mov.w	lr, r2, lsr #16
340008bc:	b2bc      	uxth	r4, r7
340008be:	2101      	movs	r1, #1
340008c0:	0c02      	lsrs	r2, r0, #16
340008c2:	b280      	uxth	r0, r0
340008c4:	fbb3 fcfe 	udiv	ip, r3, lr
340008c8:	fb0e 331c 	mls	r3, lr, ip, r3
340008cc:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
340008d0:	fb04 f20c 	mul.w	r2, r4, ip
340008d4:	429a      	cmp	r2, r3
340008d6:	d90e      	bls.n	340008f6 <__udivmoddi4+0x126>
340008d8:	18fb      	adds	r3, r7, r3
340008da:	f10c 38ff 	add.w	r8, ip, #4294967295	@ 0xffffffff
340008de:	bf2c      	ite	cs
340008e0:	f04f 0901 	movcs.w	r9, #1
340008e4:	f04f 0900 	movcc.w	r9, #0
340008e8:	429a      	cmp	r2, r3
340008ea:	d903      	bls.n	340008f4 <__udivmoddi4+0x124>
340008ec:	f1b9 0f00 	cmp.w	r9, #0
340008f0:	f000 80ec 	beq.w	34000acc <__udivmoddi4+0x2fc>
340008f4:	46c4      	mov	ip, r8
340008f6:	1a9b      	subs	r3, r3, r2
340008f8:	fbb3 f8fe 	udiv	r8, r3, lr
340008fc:	fb0e 3318 	mls	r3, lr, r8, r3
34000900:	fb04 f408 	mul.w	r4, r4, r8
34000904:	ea40 4203 	orr.w	r2, r0, r3, lsl #16
34000908:	4294      	cmp	r4, r2
3400090a:	d90b      	bls.n	34000924 <__udivmoddi4+0x154>
3400090c:	18ba      	adds	r2, r7, r2
3400090e:	f108 33ff 	add.w	r3, r8, #4294967295	@ 0xffffffff
34000912:	bf2c      	ite	cs
34000914:	2001      	movcs	r0, #1
34000916:	2000      	movcc	r0, #0
34000918:	4294      	cmp	r4, r2
3400091a:	d902      	bls.n	34000922 <__udivmoddi4+0x152>
3400091c:	2800      	cmp	r0, #0
3400091e:	f000 80d1 	beq.w	34000ac4 <__udivmoddi4+0x2f4>
34000922:	4698      	mov	r8, r3
34000924:	1b12      	subs	r2, r2, r4
34000926:	ea48 400c 	orr.w	r0, r8, ip, lsl #16
3400092a:	e79d      	b.n	34000868 <__udivmoddi4+0x98>
3400092c:	f1c1 0620 	rsb	r6, r1, #32
34000930:	408b      	lsls	r3, r1
34000932:	fa08 f401 	lsl.w	r4, r8, r1
34000936:	fa00 f901 	lsl.w	r9, r0, r1
3400093a:	fa22 f706 	lsr.w	r7, r2, r6
3400093e:	fa28 f806 	lsr.w	r8, r8, r6
34000942:	408a      	lsls	r2, r1
34000944:	431f      	orrs	r7, r3
34000946:	fa20 f306 	lsr.w	r3, r0, r6
3400094a:	0c38      	lsrs	r0, r7, #16
3400094c:	4323      	orrs	r3, r4
3400094e:	fa1f fc87 	uxth.w	ip, r7
34000952:	0c1c      	lsrs	r4, r3, #16
34000954:	fbb8 fef0 	udiv	lr, r8, r0
34000958:	fb00 881e 	mls	r8, r0, lr, r8
3400095c:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
34000960:	fb0e f80c 	mul.w	r8, lr, ip
34000964:	45a0      	cmp	r8, r4
34000966:	d90e      	bls.n	34000986 <__udivmoddi4+0x1b6>
34000968:	193c      	adds	r4, r7, r4
3400096a:	f10e 3aff 	add.w	sl, lr, #4294967295	@ 0xffffffff
3400096e:	bf2c      	ite	cs
34000970:	f04f 0b01 	movcs.w	fp, #1
34000974:	f04f 0b00 	movcc.w	fp, #0
34000978:	45a0      	cmp	r8, r4
3400097a:	d903      	bls.n	34000984 <__udivmoddi4+0x1b4>
3400097c:	f1bb 0f00 	cmp.w	fp, #0
34000980:	f000 80b8 	beq.w	34000af4 <__udivmoddi4+0x324>
34000984:	46d6      	mov	lr, sl
34000986:	eba4 0408 	sub.w	r4, r4, r8
3400098a:	fa1f f883 	uxth.w	r8, r3
3400098e:	fbb4 f3f0 	udiv	r3, r4, r0
34000992:	fb00 4413 	mls	r4, r0, r3, r4
34000996:	fb03 fc0c 	mul.w	ip, r3, ip
3400099a:	ea48 4404 	orr.w	r4, r8, r4, lsl #16
3400099e:	45a4      	cmp	ip, r4
340009a0:	d90e      	bls.n	340009c0 <__udivmoddi4+0x1f0>
340009a2:	193c      	adds	r4, r7, r4
340009a4:	f103 30ff 	add.w	r0, r3, #4294967295	@ 0xffffffff
340009a8:	bf2c      	ite	cs
340009aa:	f04f 0801 	movcs.w	r8, #1
340009ae:	f04f 0800 	movcc.w	r8, #0
340009b2:	45a4      	cmp	ip, r4
340009b4:	d903      	bls.n	340009be <__udivmoddi4+0x1ee>
340009b6:	f1b8 0f00 	cmp.w	r8, #0
340009ba:	f000 809f 	beq.w	34000afc <__udivmoddi4+0x32c>
340009be:	4603      	mov	r3, r0
340009c0:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
340009c4:	eba4 040c 	sub.w	r4, r4, ip
340009c8:	fba0 ec02 	umull	lr, ip, r0, r2
340009cc:	4564      	cmp	r4, ip
340009ce:	4673      	mov	r3, lr
340009d0:	46e0      	mov	r8, ip
340009d2:	d302      	bcc.n	340009da <__udivmoddi4+0x20a>
340009d4:	d107      	bne.n	340009e6 <__udivmoddi4+0x216>
340009d6:	45f1      	cmp	r9, lr
340009d8:	d205      	bcs.n	340009e6 <__udivmoddi4+0x216>
340009da:	ebbe 0302 	subs.w	r3, lr, r2
340009de:	eb6c 0c07 	sbc.w	ip, ip, r7
340009e2:	3801      	subs	r0, #1
340009e4:	46e0      	mov	r8, ip
340009e6:	b15d      	cbz	r5, 34000a00 <__udivmoddi4+0x230>
340009e8:	ebb9 0203 	subs.w	r2, r9, r3
340009ec:	eb64 0408 	sbc.w	r4, r4, r8
340009f0:	fa04 f606 	lsl.w	r6, r4, r6
340009f4:	fa22 f301 	lsr.w	r3, r2, r1
340009f8:	40cc      	lsrs	r4, r1
340009fa:	431e      	orrs	r6, r3
340009fc:	e9c5 6400 	strd	r6, r4, [r5]
34000a00:	2100      	movs	r1, #0
34000a02:	e736      	b.n	34000872 <__udivmoddi4+0xa2>
34000a04:	fbb1 fcf2 	udiv	ip, r1, r2
34000a08:	0c01      	lsrs	r1, r0, #16
34000a0a:	4614      	mov	r4, r2
34000a0c:	b280      	uxth	r0, r0
34000a0e:	4696      	mov	lr, r2
34000a10:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34000a14:	2620      	movs	r6, #32
34000a16:	4690      	mov	r8, r2
34000a18:	ea40 4301 	orr.w	r3, r0, r1, lsl #16
34000a1c:	4610      	mov	r0, r2
34000a1e:	fbb1 f1f2 	udiv	r1, r1, r2
34000a22:	eba3 0308 	sub.w	r3, r3, r8
34000a26:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
34000a2a:	e74b      	b.n	340008c4 <__udivmoddi4+0xf4>
34000a2c:	40b7      	lsls	r7, r6
34000a2e:	f1c6 0320 	rsb	r3, r6, #32
34000a32:	fa01 f206 	lsl.w	r2, r1, r6
34000a36:	fa21 f803 	lsr.w	r8, r1, r3
34000a3a:	ea4f 4e17 	mov.w	lr, r7, lsr #16
34000a3e:	fa20 f303 	lsr.w	r3, r0, r3
34000a42:	b2bc      	uxth	r4, r7
34000a44:	40b0      	lsls	r0, r6
34000a46:	4313      	orrs	r3, r2
34000a48:	0c02      	lsrs	r2, r0, #16
34000a4a:	0c19      	lsrs	r1, r3, #16
34000a4c:	b280      	uxth	r0, r0
34000a4e:	fbb8 f9fe 	udiv	r9, r8, lr
34000a52:	fb0e 8819 	mls	r8, lr, r9, r8
34000a56:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34000a5a:	fb09 f804 	mul.w	r8, r9, r4
34000a5e:	4588      	cmp	r8, r1
34000a60:	d951      	bls.n	34000b06 <__udivmoddi4+0x336>
34000a62:	1879      	adds	r1, r7, r1
34000a64:	f109 3cff 	add.w	ip, r9, #4294967295	@ 0xffffffff
34000a68:	bf2c      	ite	cs
34000a6a:	f04f 0a01 	movcs.w	sl, #1
34000a6e:	f04f 0a00 	movcc.w	sl, #0
34000a72:	4588      	cmp	r8, r1
34000a74:	d902      	bls.n	34000a7c <__udivmoddi4+0x2ac>
34000a76:	f1ba 0f00 	cmp.w	sl, #0
34000a7a:	d031      	beq.n	34000ae0 <__udivmoddi4+0x310>
34000a7c:	eba1 0108 	sub.w	r1, r1, r8
34000a80:	fbb1 f9fe 	udiv	r9, r1, lr
34000a84:	fb09 f804 	mul.w	r8, r9, r4
34000a88:	fb0e 1119 	mls	r1, lr, r9, r1
34000a8c:	b29b      	uxth	r3, r3
34000a8e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34000a92:	4543      	cmp	r3, r8
34000a94:	d235      	bcs.n	34000b02 <__udivmoddi4+0x332>
34000a96:	18fb      	adds	r3, r7, r3
34000a98:	f109 31ff 	add.w	r1, r9, #4294967295	@ 0xffffffff
34000a9c:	bf2c      	ite	cs
34000a9e:	f04f 0a01 	movcs.w	sl, #1
34000aa2:	f04f 0a00 	movcc.w	sl, #0
34000aa6:	4543      	cmp	r3, r8
34000aa8:	d2bb      	bcs.n	34000a22 <__udivmoddi4+0x252>
34000aaa:	f1ba 0f00 	cmp.w	sl, #0
34000aae:	d1b8      	bne.n	34000a22 <__udivmoddi4+0x252>
34000ab0:	f1a9 0102 	sub.w	r1, r9, #2
34000ab4:	443b      	add	r3, r7
34000ab6:	e7b4      	b.n	34000a22 <__udivmoddi4+0x252>
34000ab8:	1a84      	subs	r4, r0, r2
34000aba:	eb68 0203 	sbc.w	r2, r8, r3
34000abe:	2001      	movs	r0, #1
34000ac0:	4696      	mov	lr, r2
34000ac2:	e6eb      	b.n	3400089c <__udivmoddi4+0xcc>
34000ac4:	443a      	add	r2, r7
34000ac6:	f1a8 0802 	sub.w	r8, r8, #2
34000aca:	e72b      	b.n	34000924 <__udivmoddi4+0x154>
34000acc:	f1ac 0c02 	sub.w	ip, ip, #2
34000ad0:	443b      	add	r3, r7
34000ad2:	e710      	b.n	340008f6 <__udivmoddi4+0x126>
34000ad4:	3902      	subs	r1, #2
34000ad6:	443b      	add	r3, r7
34000ad8:	e6a9      	b.n	3400082e <__udivmoddi4+0x5e>
34000ada:	443a      	add	r2, r7
34000adc:	3802      	subs	r0, #2
34000ade:	e6be      	b.n	3400085e <__udivmoddi4+0x8e>
34000ae0:	eba7 0808 	sub.w	r8, r7, r8
34000ae4:	f1a9 0c02 	sub.w	ip, r9, #2
34000ae8:	4441      	add	r1, r8
34000aea:	fbb1 f9fe 	udiv	r9, r1, lr
34000aee:	fb09 f804 	mul.w	r8, r9, r4
34000af2:	e7c9      	b.n	34000a88 <__udivmoddi4+0x2b8>
34000af4:	f1ae 0e02 	sub.w	lr, lr, #2
34000af8:	443c      	add	r4, r7
34000afa:	e744      	b.n	34000986 <__udivmoddi4+0x1b6>
34000afc:	3b02      	subs	r3, #2
34000afe:	443c      	add	r4, r7
34000b00:	e75e      	b.n	340009c0 <__udivmoddi4+0x1f0>
34000b02:	4649      	mov	r1, r9
34000b04:	e78d      	b.n	34000a22 <__udivmoddi4+0x252>
34000b06:	eba1 0108 	sub.w	r1, r1, r8
34000b0a:	46cc      	mov	ip, r9
34000b0c:	fbb1 f9fe 	udiv	r9, r1, lr
34000b10:	fb09 f804 	mul.w	r8, r9, r4
34000b14:	e7b8      	b.n	34000a88 <__udivmoddi4+0x2b8>
34000b16:	bf00      	nop

34000b18 <__aeabi_idiv0>:
34000b18:	4770      	bx	lr
34000b1a:	bf00      	nop

34000b1c <calcAdresses>:
    memcpy(NNweights, new_weights, Num_weights * sizeof(int8_t));
//    printf("Cleaning weights at %p, size %d\n\r", NNweights, Num_weights);
	SCB_CleanDCache_by_Addr(NNweights, Num_weights * sizeof(int8_t));
}

void calcAdresses(size_t insize, size_t outsize,size_t bytesOfType,volatile Matmul_info* infoStruct){
34000b1c:	b480      	push	{r7}
34000b1e:	b087      	sub	sp, #28
34000b20:	af00      	add	r7, sp, #0
34000b22:	60f8      	str	r0, [r7, #12]
34000b24:	60b9      	str	r1, [r7, #8]
34000b26:	607a      	str	r2, [r7, #4]
34000b28:	603b      	str	r3, [r7, #0]
	infoStruct->bytes = bytesOfType;
34000b2a:	687a      	ldr	r2, [r7, #4]
34000b2c:	683b      	ldr	r3, [r7, #0]
34000b2e:	601a      	str	r2, [r3, #0]
	infoStruct->insize = insize;
34000b30:	68fa      	ldr	r2, [r7, #12]
34000b32:	683b      	ldr	r3, [r7, #0]
34000b34:	605a      	str	r2, [r3, #4]
	infoStruct->outsize = outsize;
34000b36:	68ba      	ldr	r2, [r7, #8]
34000b38:	683b      	ldr	r3, [r7, #0]
34000b3a:	609a      	str	r2, [r3, #8]

	int inBytes = bytesOfType * insize;
34000b3c:	687b      	ldr	r3, [r7, #4]
34000b3e:	68fa      	ldr	r2, [r7, #12]
34000b40:	fb02 f303 	mul.w	r3, r2, r3
34000b44:	617b      	str	r3, [r7, #20]
	int outBytes = bytesOfType * outsize;
34000b46:	687b      	ldr	r3, [r7, #4]
34000b48:	68ba      	ldr	r2, [r7, #8]
34000b4a:	fb02 f303 	mul.w	r3, r2, r3
34000b4e:	613b      	str	r3, [r7, #16]

	infoStruct->weight_start = 0;
34000b50:	683b      	ldr	r3, [r7, #0]
34000b52:	2200      	movs	r2, #0
34000b54:	60da      	str	r2, [r3, #12]
	infoStruct->weight_end   = infoStruct->weight_start + inBytes * outBytes;
34000b56:	683b      	ldr	r3, [r7, #0]
34000b58:	68da      	ldr	r2, [r3, #12]
34000b5a:	697b      	ldr	r3, [r7, #20]
34000b5c:	6939      	ldr	r1, [r7, #16]
34000b5e:	fb01 f303 	mul.w	r3, r1, r3
34000b62:	441a      	add	r2, r3
34000b64:	683b      	ldr	r3, [r7, #0]
34000b66:	611a      	str	r2, [r3, #16]
	infoStruct->weight_limit = infoStruct->weight_end + inBytes;
34000b68:	683b      	ldr	r3, [r7, #0]
34000b6a:	691a      	ldr	r2, [r3, #16]
34000b6c:	697b      	ldr	r3, [r7, #20]
34000b6e:	441a      	add	r2, r3
34000b70:	683b      	ldr	r3, [r7, #0]
34000b72:	615a      	str	r2, [r3, #20]

	infoStruct->input_start = infoStruct->weight_limit ;
34000b74:	683b      	ldr	r3, [r7, #0]
34000b76:	695a      	ldr	r2, [r3, #20]
34000b78:	683b      	ldr	r3, [r7, #0]
34000b7a:	619a      	str	r2, [r3, #24]
	infoStruct->input_end   = infoStruct->input_start + inBytes;
34000b7c:	683b      	ldr	r3, [r7, #0]
34000b7e:	699a      	ldr	r2, [r3, #24]
34000b80:	697b      	ldr	r3, [r7, #20]
34000b82:	441a      	add	r2, r3
34000b84:	683b      	ldr	r3, [r7, #0]
34000b86:	61da      	str	r2, [r3, #28]
	infoStruct->input_limit = infoStruct->input_end + inBytes;
34000b88:	683b      	ldr	r3, [r7, #0]
34000b8a:	69da      	ldr	r2, [r3, #28]
34000b8c:	697b      	ldr	r3, [r7, #20]
34000b8e:	441a      	add	r2, r3
34000b90:	683b      	ldr	r3, [r7, #0]
34000b92:	621a      	str	r2, [r3, #32]

	infoStruct->output_start = infoStruct->input_limit;
34000b94:	683b      	ldr	r3, [r7, #0]
34000b96:	6a1a      	ldr	r2, [r3, #32]
34000b98:	683b      	ldr	r3, [r7, #0]
34000b9a:	625a      	str	r2, [r3, #36]	@ 0x24
	infoStruct->output_end   = infoStruct->output_start + outBytes;
34000b9c:	683b      	ldr	r3, [r7, #0]
34000b9e:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
34000ba0:	693b      	ldr	r3, [r7, #16]
34000ba2:	441a      	add	r2, r3
34000ba4:	683b      	ldr	r3, [r7, #0]
34000ba6:	629a      	str	r2, [r3, #40]	@ 0x28
	infoStruct->output_limit = infoStruct->output_end + outBytes;
34000ba8:	683b      	ldr	r3, [r7, #0]
34000baa:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34000bac:	693b      	ldr	r3, [r7, #16]
34000bae:	441a      	add	r2, r3
34000bb0:	683b      	ldr	r3, [r7, #0]
34000bb2:	62da      	str	r2, [r3, #44]	@ 0x2c
}
34000bb4:	bf00      	nop
34000bb6:	371c      	adds	r7, #28
34000bb8:	46bd      	mov	sp, r7
34000bba:	f85d 7b04 	ldr.w	r7, [sp], #4
34000bbe:	4770      	bx	lr

34000bc0 <getIdentityWeights_int8>:
	LL_ATON_RT_Main(&NN_Instance_int8);

	return (float*)(matmulInfo_Float.output_start);
}

int8_t* getIdentityWeights_int8(size_t insize, size_t outsize) {
34000bc0:	b580      	push	{r7, lr}
34000bc2:	b086      	sub	sp, #24
34000bc4:	af00      	add	r7, sp, #0
34000bc6:	6078      	str	r0, [r7, #4]
34000bc8:	6039      	str	r1, [r7, #0]
    int8_t* identity = malloc(insize * outsize * sizeof(int8_t));
34000bca:	687b      	ldr	r3, [r7, #4]
34000bcc:	683a      	ldr	r2, [r7, #0]
34000bce:	fb02 f303 	mul.w	r3, r2, r3
34000bd2:	4618      	mov	r0, r3
34000bd4:	f01a fe18 	bl	3401b808 <malloc>
34000bd8:	4603      	mov	r3, r0
34000bda:	613b      	str	r3, [r7, #16]
    if (identity == NULL) {
34000bdc:	693b      	ldr	r3, [r7, #16]
34000bde:	2b00      	cmp	r3, #0
34000be0:	d101      	bne.n	34000be6 <getIdentityWeights_int8+0x26>
        return NULL;
34000be2:	2300      	movs	r3, #0
34000be4:	e022      	b.n	34000c2c <getIdentityWeights_int8+0x6c>
    }

    // Initialize to 0
    memset(identity, 0, insize * outsize * sizeof(int8_t));
34000be6:	687b      	ldr	r3, [r7, #4]
34000be8:	683a      	ldr	r2, [r7, #0]
34000bea:	fb02 f303 	mul.w	r3, r2, r3
34000bee:	461a      	mov	r2, r3
34000bf0:	2100      	movs	r1, #0
34000bf2:	6938      	ldr	r0, [r7, #16]
34000bf4:	f01b fdda 	bl	3401c7ac <memset>

    // Identity matrix is defined by: out[i] = in[i]
    // So we need to set W[i][i] = 1, which is at index: i * insize + i
    size_t min_dim = (insize < outsize) ? insize : outsize;
34000bf8:	683a      	ldr	r2, [r7, #0]
34000bfa:	687b      	ldr	r3, [r7, #4]
34000bfc:	4293      	cmp	r3, r2
34000bfe:	bf28      	it	cs
34000c00:	4613      	movcs	r3, r2
34000c02:	60fb      	str	r3, [r7, #12]

    for (size_t i = 0; i < min_dim; i++) {
34000c04:	2300      	movs	r3, #0
34000c06:	617b      	str	r3, [r7, #20]
34000c08:	e00b      	b.n	34000c22 <getIdentityWeights_int8+0x62>
        identity[i * insize + i] = 1;
34000c0a:	687b      	ldr	r3, [r7, #4]
34000c0c:	3301      	adds	r3, #1
34000c0e:	697a      	ldr	r2, [r7, #20]
34000c10:	fb02 f303 	mul.w	r3, r2, r3
34000c14:	693a      	ldr	r2, [r7, #16]
34000c16:	4413      	add	r3, r2
34000c18:	2201      	movs	r2, #1
34000c1a:	701a      	strb	r2, [r3, #0]
    for (size_t i = 0; i < min_dim; i++) {
34000c1c:	697b      	ldr	r3, [r7, #20]
34000c1e:	3301      	adds	r3, #1
34000c20:	617b      	str	r3, [r7, #20]
34000c22:	697a      	ldr	r2, [r7, #20]
34000c24:	68fb      	ldr	r3, [r7, #12]
34000c26:	429a      	cmp	r2, r3
34000c28:	d3ef      	bcc.n	34000c0a <getIdentityWeights_int8+0x4a>
    }

    return identity;
34000c2a:	693b      	ldr	r3, [r7, #16]
}
34000c2c:	4618      	mov	r0, r3
34000c2e:	3718      	adds	r7, #24
34000c30:	46bd      	mov	sp, r7
34000c32:	bd80      	pop	{r7, pc}

34000c34 <npu_tiledmatvec_int8>:
    }

    *nnin_length = LL_Buffer_len(&nn_in_info[0]);
}

int npu_tiledmatvec_int8(int8_t* invec, size_t insize, int8_t* outvec, size_t outsize, int8_t* inMat) {
34000c34:	b590      	push	{r4, r7, lr}
34000c36:	f5ad 7d31 	sub.w	sp, sp, #708	@ 0x2c4
34000c3a:	af04      	add	r7, sp, #16
34000c3c:	f507 742c 	add.w	r4, r7, #688	@ 0x2b0
34000c40:	f5a4 7429 	sub.w	r4, r4, #676	@ 0x2a4
34000c44:	6020      	str	r0, [r4, #0]
34000c46:	f507 702c 	add.w	r0, r7, #688	@ 0x2b0
34000c4a:	f5a0 702a 	sub.w	r0, r0, #680	@ 0x2a8
34000c4e:	6001      	str	r1, [r0, #0]
34000c50:	f507 712c 	add.w	r1, r7, #688	@ 0x2b0
34000c54:	f5a1 712b 	sub.w	r1, r1, #684	@ 0x2ac
34000c58:	600a      	str	r2, [r1, #0]
34000c5a:	f507 722c 	add.w	r2, r7, #688	@ 0x2b0
34000c5e:	f5a2 722c 	sub.w	r2, r2, #688	@ 0x2b0
34000c62:	6013      	str	r3, [r2, #0]
    size_t refSize = 24;
34000c64:	2318      	movs	r3, #24
34000c66:	f8c7 32a0 	str.w	r3, [r7, #672]	@ 0x2a0

    extern volatile Matmul_info matmulInfo_int;

    // Calculate addresses
    calcAdresses(refSize, refSize, 1, &matmulInfo_int);
34000c6a:	4bc5      	ldr	r3, [pc, #788]	@ (34000f80 <npu_tiledmatvec_int8+0x34c>)
34000c6c:	2201      	movs	r2, #1
34000c6e:	f8d7 12a0 	ldr.w	r1, [r7, #672]	@ 0x2a0
34000c72:	f8d7 02a0 	ldr.w	r0, [r7, #672]	@ 0x2a0
34000c76:	f7ff ff51 	bl	34000b1c <calcAdresses>
    int8_t* outp = (int8_t*)(0x34200000UL + matmulInfo_int.output_start);
34000c7a:	4bc1      	ldr	r3, [pc, #772]	@ (34000f80 <npu_tiledmatvec_int8+0x34c>)
34000c7c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34000c7e:	f103 5350 	add.w	r3, r3, #872415232	@ 0x34000000
34000c82:	f503 1300 	add.w	r3, r3, #2097152	@ 0x200000
34000c86:	f8c7 329c 	str.w	r3, [r7, #668]	@ 0x29c

    // Initialize output vector to 0
    memset(outvec, 0, outsize * sizeof(int8_t));
34000c8a:	f507 732c 	add.w	r3, r7, #688	@ 0x2b0
34000c8e:	f5a3 722c 	sub.w	r2, r3, #688	@ 0x2b0
34000c92:	f507 732c 	add.w	r3, r7, #688	@ 0x2b0
34000c96:	f5a3 732b 	sub.w	r3, r3, #684	@ 0x2ac
34000c9a:	6812      	ldr	r2, [r2, #0]
34000c9c:	2100      	movs	r1, #0
34000c9e:	6818      	ldr	r0, [r3, #0]
34000ca0:	f01b fd84 	bl	3401c7ac <memset>

    size_t num_tiles_out = (outsize + refSize - 1) / refSize;
34000ca4:	f507 732c 	add.w	r3, r7, #688	@ 0x2b0
34000ca8:	f5a3 732c 	sub.w	r3, r3, #688	@ 0x2b0
34000cac:	681a      	ldr	r2, [r3, #0]
34000cae:	f8d7 32a0 	ldr.w	r3, [r7, #672]	@ 0x2a0
34000cb2:	4413      	add	r3, r2
34000cb4:	1e5a      	subs	r2, r3, #1
34000cb6:	f8d7 32a0 	ldr.w	r3, [r7, #672]	@ 0x2a0
34000cba:	fbb2 f3f3 	udiv	r3, r2, r3
34000cbe:	f8c7 3298 	str.w	r3, [r7, #664]	@ 0x298
    size_t num_tiles_in  = (insize + refSize - 1) / refSize;
34000cc2:	f507 732c 	add.w	r3, r7, #688	@ 0x2b0
34000cc6:	f5a3 732a 	sub.w	r3, r3, #680	@ 0x2a8
34000cca:	681a      	ldr	r2, [r3, #0]
34000ccc:	f8d7 32a0 	ldr.w	r3, [r7, #672]	@ 0x2a0
34000cd0:	4413      	add	r3, r2
34000cd2:	1e5a      	subs	r2, r3, #1
34000cd4:	f8d7 32a0 	ldr.w	r3, [r7, #672]	@ 0x2a0
34000cd8:	fbb2 f3f3 	udiv	r3, r2, r3
34000cdc:	f8c7 3294 	str.w	r3, [r7, #660]	@ 0x294

    for (size_t i = 0; i < num_tiles_out; i++) {
34000ce0:	2300      	movs	r3, #0
34000ce2:	f8c7 32ac 	str.w	r3, [r7, #684]	@ 0x2ac
34000ce6:	e13d      	b.n	34000f64 <npu_tiledmatvec_int8+0x330>
        int8_t acc[24] = {0};  // Accumulator for output tile
34000ce8:	f507 731b 	add.w	r3, r7, #620	@ 0x26c
34000cec:	2200      	movs	r2, #0
34000cee:	601a      	str	r2, [r3, #0]
34000cf0:	605a      	str	r2, [r3, #4]
34000cf2:	609a      	str	r2, [r3, #8]
34000cf4:	60da      	str	r2, [r3, #12]
34000cf6:	611a      	str	r2, [r3, #16]
34000cf8:	615a      	str	r2, [r3, #20]

        for (size_t j = 0; j < num_tiles_in; j++) {
34000cfa:	2300      	movs	r3, #0
34000cfc:	f8c7 32a8 	str.w	r3, [r7, #680]	@ 0x2a8
34000d00:	e0f2      	b.n	34000ee8 <npu_tiledmatvec_int8+0x2b4>
            // --- Load vector tile (handle partial tiles safely) ---
            int8_t vecTile[24] = {0};
34000d02:	f507 7315 	add.w	r3, r7, #596	@ 0x254
34000d06:	2200      	movs	r2, #0
34000d08:	601a      	str	r2, [r3, #0]
34000d0a:	605a      	str	r2, [r3, #4]
34000d0c:	609a      	str	r2, [r3, #8]
34000d0e:	60da      	str	r2, [r3, #12]
34000d10:	611a      	str	r2, [r3, #16]
34000d12:	615a      	str	r2, [r3, #20]
            size_t vecCopy = (j * refSize + refSize <= insize) ? refSize : (insize - j * refSize);
34000d14:	f8d7 32a8 	ldr.w	r3, [r7, #680]	@ 0x2a8
34000d18:	3301      	adds	r3, #1
34000d1a:	f8d7 22a0 	ldr.w	r2, [r7, #672]	@ 0x2a0
34000d1e:	fb02 f303 	mul.w	r3, r2, r3
34000d22:	f507 722c 	add.w	r2, r7, #688	@ 0x2b0
34000d26:	f5a2 722a 	sub.w	r2, r2, #680	@ 0x2a8
34000d2a:	6812      	ldr	r2, [r2, #0]
34000d2c:	429a      	cmp	r2, r3
34000d2e:	d20c      	bcs.n	34000d4a <npu_tiledmatvec_int8+0x116>
34000d30:	f8d7 32a8 	ldr.w	r3, [r7, #680]	@ 0x2a8
34000d34:	f8d7 22a0 	ldr.w	r2, [r7, #672]	@ 0x2a0
34000d38:	fb02 f303 	mul.w	r3, r2, r3
34000d3c:	f507 722c 	add.w	r2, r7, #688	@ 0x2b0
34000d40:	f5a2 722a 	sub.w	r2, r2, #680	@ 0x2a8
34000d44:	6812      	ldr	r2, [r2, #0]
34000d46:	1ad3      	subs	r3, r2, r3
34000d48:	e001      	b.n	34000d4e <npu_tiledmatvec_int8+0x11a>
34000d4a:	f8d7 32a0 	ldr.w	r3, [r7, #672]	@ 0x2a0
34000d4e:	f8c7 328c 	str.w	r3, [r7, #652]	@ 0x28c
            memcpy(vecTile, &invec[j * refSize], vecCopy);
34000d52:	f8d7 32a8 	ldr.w	r3, [r7, #680]	@ 0x2a8
34000d56:	f8d7 22a0 	ldr.w	r2, [r7, #672]	@ 0x2a0
34000d5a:	fb02 f303 	mul.w	r3, r2, r3
34000d5e:	f507 722c 	add.w	r2, r7, #688	@ 0x2b0
34000d62:	f5a2 7229 	sub.w	r2, r2, #676	@ 0x2a4
34000d66:	6812      	ldr	r2, [r2, #0]
34000d68:	18d1      	adds	r1, r2, r3
34000d6a:	f507 7315 	add.w	r3, r7, #596	@ 0x254
34000d6e:	f8d7 228c 	ldr.w	r2, [r7, #652]	@ 0x28c
34000d72:	4618      	mov	r0, r3
34000d74:	f01b ffa9 	bl	3401ccca <memcpy>
            memcpy((int8_t*)(0x34200000UL + matmulInfo_int.input_start), vecTile, refSize);
34000d78:	4b81      	ldr	r3, [pc, #516]	@ (34000f80 <npu_tiledmatvec_int8+0x34c>)
34000d7a:	699b      	ldr	r3, [r3, #24]
34000d7c:	f103 5350 	add.w	r3, r3, #872415232	@ 0x34000000
34000d80:	f503 1300 	add.w	r3, r3, #2097152	@ 0x200000
34000d84:	4618      	mov	r0, r3
34000d86:	f507 7315 	add.w	r3, r7, #596	@ 0x254
34000d8a:	f8d7 22a0 	ldr.w	r2, [r7, #672]	@ 0x2a0
34000d8e:	4619      	mov	r1, r3
34000d90:	f01b ff9b 	bl	3401ccca <memcpy>

            // --- Load matrix sub-tile (handle edges) ---
            int8_t matTile[24*24] = {0};
34000d94:	f507 732c 	add.w	r3, r7, #688	@ 0x2b0
34000d98:	f5a3 7327 	sub.w	r3, r3, #668	@ 0x29c
34000d9c:	4618      	mov	r0, r3
34000d9e:	f44f 7310 	mov.w	r3, #576	@ 0x240
34000da2:	461a      	mov	r2, r3
34000da4:	2100      	movs	r1, #0
34000da6:	f01b fd01 	bl	3401c7ac <memset>
            size_t sub_rows = (i * refSize + refSize <= outsize) ? refSize : (outsize - i * refSize);
34000daa:	f8d7 32ac 	ldr.w	r3, [r7, #684]	@ 0x2ac
34000dae:	3301      	adds	r3, #1
34000db0:	f8d7 22a0 	ldr.w	r2, [r7, #672]	@ 0x2a0
34000db4:	fb02 f303 	mul.w	r3, r2, r3
34000db8:	f507 722c 	add.w	r2, r7, #688	@ 0x2b0
34000dbc:	f5a2 722c 	sub.w	r2, r2, #688	@ 0x2b0
34000dc0:	6812      	ldr	r2, [r2, #0]
34000dc2:	429a      	cmp	r2, r3
34000dc4:	d20c      	bcs.n	34000de0 <npu_tiledmatvec_int8+0x1ac>
34000dc6:	f8d7 32ac 	ldr.w	r3, [r7, #684]	@ 0x2ac
34000dca:	f8d7 22a0 	ldr.w	r2, [r7, #672]	@ 0x2a0
34000dce:	fb02 f303 	mul.w	r3, r2, r3
34000dd2:	f507 722c 	add.w	r2, r7, #688	@ 0x2b0
34000dd6:	f5a2 722c 	sub.w	r2, r2, #688	@ 0x2b0
34000dda:	6812      	ldr	r2, [r2, #0]
34000ddc:	1ad3      	subs	r3, r2, r3
34000dde:	e001      	b.n	34000de4 <npu_tiledmatvec_int8+0x1b0>
34000de0:	f8d7 32a0 	ldr.w	r3, [r7, #672]	@ 0x2a0
34000de4:	f8c7 3288 	str.w	r3, [r7, #648]	@ 0x288
            size_t sub_cols = (j * refSize + refSize <= insize) ? refSize : (insize - j * refSize);
34000de8:	f8d7 32a8 	ldr.w	r3, [r7, #680]	@ 0x2a8
34000dec:	3301      	adds	r3, #1
34000dee:	f8d7 22a0 	ldr.w	r2, [r7, #672]	@ 0x2a0
34000df2:	fb02 f303 	mul.w	r3, r2, r3
34000df6:	f507 722c 	add.w	r2, r7, #688	@ 0x2b0
34000dfa:	f5a2 722a 	sub.w	r2, r2, #680	@ 0x2a8
34000dfe:	6812      	ldr	r2, [r2, #0]
34000e00:	429a      	cmp	r2, r3
34000e02:	d20c      	bcs.n	34000e1e <npu_tiledmatvec_int8+0x1ea>
34000e04:	f8d7 32a8 	ldr.w	r3, [r7, #680]	@ 0x2a8
34000e08:	f8d7 22a0 	ldr.w	r2, [r7, #672]	@ 0x2a0
34000e0c:	fb02 f303 	mul.w	r3, r2, r3
34000e10:	f507 722c 	add.w	r2, r7, #688	@ 0x2b0
34000e14:	f5a2 722a 	sub.w	r2, r2, #680	@ 0x2a8
34000e18:	6812      	ldr	r2, [r2, #0]
34000e1a:	1ad3      	subs	r3, r2, r3
34000e1c:	e001      	b.n	34000e22 <npu_tiledmatvec_int8+0x1ee>
34000e1e:	f8d7 32a0 	ldr.w	r3, [r7, #672]	@ 0x2a0
34000e22:	f8c7 3284 	str.w	r3, [r7, #644]	@ 0x284

            copy_submatrix(
34000e26:	f8d7 32ac 	ldr.w	r3, [r7, #684]	@ 0x2ac
34000e2a:	f8d7 22a0 	ldr.w	r2, [r7, #672]	@ 0x2a0
34000e2e:	fb02 f103 	mul.w	r1, r2, r3
34000e32:	f8d7 32a8 	ldr.w	r3, [r7, #680]	@ 0x2a8
34000e36:	f8d7 22a0 	ldr.w	r2, [r7, #672]	@ 0x2a0
34000e3a:	fb03 f202 	mul.w	r2, r3, r2
34000e3e:	f107 0014 	add.w	r0, r7, #20
34000e42:	f8d7 3284 	ldr.w	r3, [r7, #644]	@ 0x284
34000e46:	9302      	str	r3, [sp, #8]
34000e48:	f8d7 3288 	ldr.w	r3, [r7, #648]	@ 0x288
34000e4c:	9301      	str	r3, [sp, #4]
34000e4e:	f507 732c 	add.w	r3, r7, #688	@ 0x2b0
34000e52:	f5a3 732a 	sub.w	r3, r3, #680	@ 0x2a8
34000e56:	681b      	ldr	r3, [r3, #0]
34000e58:	9300      	str	r3, [sp, #0]
34000e5a:	4613      	mov	r3, r2
34000e5c:	460a      	mov	r2, r1
34000e5e:	f8d7 12c0 	ldr.w	r1, [r7, #704]	@ 0x2c0
34000e62:	f000 f891 	bl	34000f88 <copy_submatrix>
                insize,              // full row width
                sub_rows,            // rows in this tile
                sub_cols             // cols in this tile
            );

            memcpy((int8_t*)(0x34200000UL + matmulInfo_int.weight_start), matTile, refSize * refSize);
34000e66:	4b46      	ldr	r3, [pc, #280]	@ (34000f80 <npu_tiledmatvec_int8+0x34c>)
34000e68:	68db      	ldr	r3, [r3, #12]
34000e6a:	f103 5350 	add.w	r3, r3, #872415232	@ 0x34000000
34000e6e:	f503 1300 	add.w	r3, r3, #2097152	@ 0x200000
34000e72:	4618      	mov	r0, r3
34000e74:	f8d7 32a0 	ldr.w	r3, [r7, #672]	@ 0x2a0
34000e78:	fb03 f203 	mul.w	r2, r3, r3
34000e7c:	f107 0314 	add.w	r3, r7, #20
34000e80:	4619      	mov	r1, r3
34000e82:	f01b ff22 	bl	3401ccca <memcpy>

            // --- Launch NPU ---
            LL_ATON_RT_Main(&NN_Instance_int8);
34000e86:	483f      	ldr	r0, [pc, #252]	@ (34000f84 <npu_tiledmatvec_int8+0x350>)
34000e88:	f019 fc00 	bl	3401a68c <LL_ATON_RT_Main>
//					(int8_t*)(0x34200000UL + matmulInfo_int.output_start),
//					refSize,
//					(int8_t*)(0x34200000UL + matmulInfo_int.weight_start)
//            );
            // --- Accumulate output from this tile ---
            for (size_t k = 0; k < sub_rows; k++) {
34000e8c:	2300      	movs	r3, #0
34000e8e:	f8c7 32a4 	str.w	r3, [r7, #676]	@ 0x2a4
34000e92:	e01e      	b.n	34000ed2 <npu_tiledmatvec_int8+0x29e>
                acc[k] += outp[k];
34000e94:	f507 721b 	add.w	r2, r7, #620	@ 0x26c
34000e98:	f8d7 32a4 	ldr.w	r3, [r7, #676]	@ 0x2a4
34000e9c:	4413      	add	r3, r2
34000e9e:	f993 3000 	ldrsb.w	r3, [r3]
34000ea2:	b2da      	uxtb	r2, r3
34000ea4:	f8d7 129c 	ldr.w	r1, [r7, #668]	@ 0x29c
34000ea8:	f8d7 32a4 	ldr.w	r3, [r7, #676]	@ 0x2a4
34000eac:	440b      	add	r3, r1
34000eae:	f993 3000 	ldrsb.w	r3, [r3]
34000eb2:	b2db      	uxtb	r3, r3
34000eb4:	4413      	add	r3, r2
34000eb6:	b2db      	uxtb	r3, r3
34000eb8:	b259      	sxtb	r1, r3
34000eba:	f507 721b 	add.w	r2, r7, #620	@ 0x26c
34000ebe:	f8d7 32a4 	ldr.w	r3, [r7, #676]	@ 0x2a4
34000ec2:	4413      	add	r3, r2
34000ec4:	460a      	mov	r2, r1
34000ec6:	701a      	strb	r2, [r3, #0]
            for (size_t k = 0; k < sub_rows; k++) {
34000ec8:	f8d7 32a4 	ldr.w	r3, [r7, #676]	@ 0x2a4
34000ecc:	3301      	adds	r3, #1
34000ece:	f8c7 32a4 	str.w	r3, [r7, #676]	@ 0x2a4
34000ed2:	f8d7 22a4 	ldr.w	r2, [r7, #676]	@ 0x2a4
34000ed6:	f8d7 3288 	ldr.w	r3, [r7, #648]	@ 0x288
34000eda:	429a      	cmp	r2, r3
34000edc:	d3da      	bcc.n	34000e94 <npu_tiledmatvec_int8+0x260>
        for (size_t j = 0; j < num_tiles_in; j++) {
34000ede:	f8d7 32a8 	ldr.w	r3, [r7, #680]	@ 0x2a8
34000ee2:	3301      	adds	r3, #1
34000ee4:	f8c7 32a8 	str.w	r3, [r7, #680]	@ 0x2a8
34000ee8:	f8d7 22a8 	ldr.w	r2, [r7, #680]	@ 0x2a8
34000eec:	f8d7 3294 	ldr.w	r3, [r7, #660]	@ 0x294
34000ef0:	429a      	cmp	r2, r3
34000ef2:	f4ff af06 	bcc.w	34000d02 <npu_tiledmatvec_int8+0xce>
            }
        }

        // --- Write back the accumulated result to outvec ---
        size_t write_count = (i * refSize + refSize <= outsize) ? refSize : (outsize - i * refSize);
34000ef6:	f8d7 32ac 	ldr.w	r3, [r7, #684]	@ 0x2ac
34000efa:	3301      	adds	r3, #1
34000efc:	f8d7 22a0 	ldr.w	r2, [r7, #672]	@ 0x2a0
34000f00:	fb02 f303 	mul.w	r3, r2, r3
34000f04:	f507 722c 	add.w	r2, r7, #688	@ 0x2b0
34000f08:	f5a2 722c 	sub.w	r2, r2, #688	@ 0x2b0
34000f0c:	6812      	ldr	r2, [r2, #0]
34000f0e:	429a      	cmp	r2, r3
34000f10:	d20c      	bcs.n	34000f2c <npu_tiledmatvec_int8+0x2f8>
34000f12:	f8d7 32ac 	ldr.w	r3, [r7, #684]	@ 0x2ac
34000f16:	f8d7 22a0 	ldr.w	r2, [r7, #672]	@ 0x2a0
34000f1a:	fb02 f303 	mul.w	r3, r2, r3
34000f1e:	f507 722c 	add.w	r2, r7, #688	@ 0x2b0
34000f22:	f5a2 722c 	sub.w	r2, r2, #688	@ 0x2b0
34000f26:	6812      	ldr	r2, [r2, #0]
34000f28:	1ad3      	subs	r3, r2, r3
34000f2a:	e001      	b.n	34000f30 <npu_tiledmatvec_int8+0x2fc>
34000f2c:	f8d7 32a0 	ldr.w	r3, [r7, #672]	@ 0x2a0
34000f30:	f8c7 3290 	str.w	r3, [r7, #656]	@ 0x290
        memcpy(&outvec[i * refSize], acc, write_count);
34000f34:	f8d7 32ac 	ldr.w	r3, [r7, #684]	@ 0x2ac
34000f38:	f8d7 22a0 	ldr.w	r2, [r7, #672]	@ 0x2a0
34000f3c:	fb02 f303 	mul.w	r3, r2, r3
34000f40:	f507 722c 	add.w	r2, r7, #688	@ 0x2b0
34000f44:	f5a2 722b 	sub.w	r2, r2, #684	@ 0x2ac
34000f48:	6812      	ldr	r2, [r2, #0]
34000f4a:	4413      	add	r3, r2
34000f4c:	f507 711b 	add.w	r1, r7, #620	@ 0x26c
34000f50:	f8d7 2290 	ldr.w	r2, [r7, #656]	@ 0x290
34000f54:	4618      	mov	r0, r3
34000f56:	f01b feb8 	bl	3401ccca <memcpy>
    for (size_t i = 0; i < num_tiles_out; i++) {
34000f5a:	f8d7 32ac 	ldr.w	r3, [r7, #684]	@ 0x2ac
34000f5e:	3301      	adds	r3, #1
34000f60:	f8c7 32ac 	str.w	r3, [r7, #684]	@ 0x2ac
34000f64:	f8d7 22ac 	ldr.w	r2, [r7, #684]	@ 0x2ac
34000f68:	f8d7 3298 	ldr.w	r3, [r7, #664]	@ 0x298
34000f6c:	429a      	cmp	r2, r3
34000f6e:	f4ff aebb 	bcc.w	34000ce8 <npu_tiledmatvec_int8+0xb4>
    }

    return 0; // Success
34000f72:	2300      	movs	r3, #0
}
34000f74:	4618      	mov	r0, r3
34000f76:	f507 772d 	add.w	r7, r7, #692	@ 0x2b4
34000f7a:	46bd      	mov	sp, r7
34000f7c:	bd90      	pop	{r4, r7, pc}
34000f7e:	bf00      	nop
34000f80:	34020e44 	.word	0x34020e44
34000f84:	34020c1c 	.word	0x34020c1c

34000f88 <copy_submatrix>:



void copy_submatrix(int8_t *dest, int8_t *src,
                    size_t start_row, size_t start_col,
                    size_t src_cols, size_t sub_rows, size_t sub_cols) {
34000f88:	b580      	push	{r7, lr}
34000f8a:	b088      	sub	sp, #32
34000f8c:	af00      	add	r7, sp, #0
34000f8e:	60f8      	str	r0, [r7, #12]
34000f90:	60b9      	str	r1, [r7, #8]
34000f92:	607a      	str	r2, [r7, #4]
34000f94:	603b      	str	r3, [r7, #0]
    for (size_t i = 0; i < sub_rows; i++) {
34000f96:	2300      	movs	r3, #0
34000f98:	61fb      	str	r3, [r7, #28]
34000f9a:	e01a      	b.n	34000fd2 <copy_submatrix+0x4a>
        size_t src_index = (start_row + i) * src_cols + start_col;
34000f9c:	687a      	ldr	r2, [r7, #4]
34000f9e:	69fb      	ldr	r3, [r7, #28]
34000fa0:	4413      	add	r3, r2
34000fa2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34000fa4:	fb02 f303 	mul.w	r3, r2, r3
34000fa8:	683a      	ldr	r2, [r7, #0]
34000faa:	4413      	add	r3, r2
34000fac:	61bb      	str	r3, [r7, #24]
        size_t dest_index = i * sub_cols;
34000fae:	69fb      	ldr	r3, [r7, #28]
34000fb0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
34000fb2:	fb02 f303 	mul.w	r3, r2, r3
34000fb6:	617b      	str	r3, [r7, #20]
        memcpy(&dest[dest_index], &src[src_index], sub_cols * sizeof(int8_t));
34000fb8:	68fa      	ldr	r2, [r7, #12]
34000fba:	697b      	ldr	r3, [r7, #20]
34000fbc:	18d0      	adds	r0, r2, r3
34000fbe:	68ba      	ldr	r2, [r7, #8]
34000fc0:	69bb      	ldr	r3, [r7, #24]
34000fc2:	4413      	add	r3, r2
34000fc4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
34000fc6:	4619      	mov	r1, r3
34000fc8:	f01b fe7f 	bl	3401ccca <memcpy>
    for (size_t i = 0; i < sub_rows; i++) {
34000fcc:	69fb      	ldr	r3, [r7, #28]
34000fce:	3301      	adds	r3, #1
34000fd0:	61fb      	str	r3, [r7, #28]
34000fd2:	69fa      	ldr	r2, [r7, #28]
34000fd4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34000fd6:	429a      	cmp	r2, r3
34000fd8:	d3e0      	bcc.n	34000f9c <copy_submatrix+0x14>
    }
}
34000fda:	bf00      	nop
34000fdc:	bf00      	nop
34000fde:	3720      	adds	r7, #32
34000fe0:	46bd      	mov	sp, r7
34000fe2:	bd80      	pop	{r7, pc}

34000fe4 <LL_ATON_Cache_MCU_Invalidate_Range>:
 */
#if defined(LL_ATON_RT_RELOC) && defined(BUILD_AI_NETWORK_RELOC)
  void LL_ATON_Cache_MCU_Invalidate_Range(uintptr_t virtual_addr, uint32_t size);
#else
  static inline void LL_ATON_Cache_MCU_Invalidate_Range(uintptr_t virtual_addr, uint32_t size)
  {
34000fe4:	b580      	push	{r7, lr}
34000fe6:	b082      	sub	sp, #8
34000fe8:	af00      	add	r7, sp, #0
34000fea:	6078      	str	r0, [r7, #4]
34000fec:	6039      	str	r1, [r7, #0]
    LL_ATON_OSAL_LOCK_MCU_CACHE();
    mcu_cache_invalidate_range(virtual_addr, virtual_addr + size);
34000fee:	687a      	ldr	r2, [r7, #4]
34000ff0:	683b      	ldr	r3, [r7, #0]
34000ff2:	4413      	add	r3, r2
34000ff4:	4619      	mov	r1, r3
34000ff6:	6878      	ldr	r0, [r7, #4]
34000ff8:	f001 f812 	bl	34002020 <mcu_cache_invalidate_range>
    LL_ATON_OSAL_UNLOCK_MCU_CACHE();
  }
34000ffc:	bf00      	nop
34000ffe:	3708      	adds	r7, #8
34001000:	46bd      	mov	sp, r7
34001002:	bd80      	pop	{r7, pc}

34001004 <LL_ATON_Set_User_Input_Buffer_int8>:
/* index=3 file postfix=AXISRAM3 name=npuRAM3 offset=0x34200000  absolute_mode size=458752 READ_WRITE THROUGHPUT=HIGH LATENCY=LOW byte width=8 freq ratio=1.25 burst max length=MAXINT burst penalty=0 pipelined=ON cacheable=OFF read_power=18.531 write_power=16.201 use4initializers=NO score=94  */
/* global pool 0 is ? */
/* index=0 file postfix=AXISRAM6 name=npuRAM6 offset=0x34350000  absolute_mode size=458744 READ_WRITE THROUGHPUT=HIGH LATENCY=LOW byte width=8 freq ratio=1.25 burst max length=MAXINT burst penalty=0 pipelined=ON cacheable=OFF read_power=19.006 write_power=15.79 use4initializers=NO score=94  */

LL_ATON_User_IO_Result_t LL_ATON_Set_User_Input_Buffer_int8(uint32_t num, void* buffer, uint32_t size)
{
34001004:	b480      	push	{r7}
34001006:	b085      	sub	sp, #20
34001008:	af00      	add	r7, sp, #0
3400100a:	60f8      	str	r0, [r7, #12]
3400100c:	60b9      	str	r1, [r7, #8]
3400100e:	607a      	str	r2, [r7, #4]
  {
    return LL_ATON_User_IO_WRONG_INDEX;
34001010:	2303      	movs	r3, #3
  }
}
34001012:	4618      	mov	r0, r3
34001014:	3714      	adds	r7, #20
34001016:	46bd      	mov	sp, r7
34001018:	f85d 7b04 	ldr.w	r7, [sp], #4
3400101c:	4770      	bx	lr

3400101e <LL_ATON_Get_User_Input_Buffer_int8>:

void *LL_ATON_Get_User_Input_Buffer_int8(uint32_t num)
{
3400101e:	b480      	push	{r7}
34001020:	b083      	sub	sp, #12
34001022:	af00      	add	r7, sp, #0
34001024:	6078      	str	r0, [r7, #4]
  {
    return NULL;
34001026:	2300      	movs	r3, #0
  }
}
34001028:	4618      	mov	r0, r3
3400102a:	370c      	adds	r7, #12
3400102c:	46bd      	mov	sp, r7
3400102e:	f85d 7b04 	ldr.w	r7, [sp], #4
34001032:	4770      	bx	lr

34001034 <LL_ATON_Set_User_Output_Buffer_int8>:

LL_ATON_User_IO_Result_t LL_ATON_Set_User_Output_Buffer_int8(uint32_t num, void* buffer, uint32_t size)
{
34001034:	b480      	push	{r7}
34001036:	b085      	sub	sp, #20
34001038:	af00      	add	r7, sp, #0
3400103a:	60f8      	str	r0, [r7, #12]
3400103c:	60b9      	str	r1, [r7, #8]
3400103e:	607a      	str	r2, [r7, #4]
  {
    return LL_ATON_User_IO_WRONG_INDEX;
34001040:	2303      	movs	r3, #3
  }
}
34001042:	4618      	mov	r0, r3
34001044:	3714      	adds	r7, #20
34001046:	46bd      	mov	sp, r7
34001048:	f85d 7b04 	ldr.w	r7, [sp], #4
3400104c:	4770      	bx	lr

3400104e <LL_ATON_Get_User_Output_Buffer_int8>:

void *LL_ATON_Get_User_Output_Buffer_int8(uint32_t num)
{
3400104e:	b480      	push	{r7}
34001050:	b083      	sub	sp, #12
34001052:	af00      	add	r7, sp, #0
34001054:	6078      	str	r0, [r7, #4]
  {
    return NULL;
34001056:	2300      	movs	r3, #0
  }
}
34001058:	4618      	mov	r0, r3
3400105a:	370c      	adds	r7, #12
3400105c:	46bd      	mov	sp, r7
3400105e:	f85d 7b04 	ldr.w	r7, [sp], #4
34001062:	4770      	bx	lr

34001064 <LL_ATON_EC_Network_Init_int8>:

bool LL_ATON_EC_Network_Init_int8(void)
{
34001064:	b480      	push	{r7}
34001066:	af00      	add	r7, sp, #0
  return true;
34001068:	2301      	movs	r3, #1
}
3400106a:	4618      	mov	r0, r3
3400106c:	46bd      	mov	sp, r7
3400106e:	f85d 7b04 	ldr.w	r7, [sp], #4
34001072:	4770      	bx	lr

34001074 <LL_ATON_EC_Inference_Init_int8>:

bool LL_ATON_EC_Inference_Init_int8(void)
{
34001074:	b480      	push	{r7}
34001076:	af00      	add	r7, sp, #0
  return true;
34001078:	2301      	movs	r3, #1
}
3400107a:	4618      	mov	r0, r3
3400107c:	46bd      	mov	sp, r7
3400107e:	f85d 7b04 	ldr.w	r7, [sp], #4
34001082:	4770      	bx	lr

34001084 <LL_ATON_Start_EpochBlock_int8>:
/* scheduling epoch=0    nodes=5   ------------------------------------------------------------------- */

/* scheduling epoch=1    nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_Start_EpochBlock_int8(const void *epoch_block)
{
34001084:	b580      	push	{r7, lr}
34001086:	b0c2      	sub	sp, #264	@ 0x108
34001088:	af00      	add	r7, sp, #0
3400108a:	f507 7384 	add.w	r3, r7, #264	@ 0x108
3400108e:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
34001092:	6018      	str	r0, [r3, #0]

  LL_ATON_LIB_UNUSED(epoch_block);
  extern volatile Matmul_info matmulInfo_int;

  /* CONV_ACC_V2 configuration */
  LL_Convacc_InitTypeDef conv_init = {
34001094:	f107 03cc 	add.w	r3, r7, #204	@ 0xcc
34001098:	223c      	movs	r2, #60	@ 0x3c
3400109a:	2100      	movs	r1, #0
3400109c:	4618      	mov	r0, r3
3400109e:	f01b fb85 	bl	3401c7ac <memset>
340010a2:	f897 30cc 	ldrb.w	r3, [r7, #204]	@ 0xcc
340010a6:	2201      	movs	r2, #1
340010a8:	f362 1305 	bfi	r3, r2, #4, #2
340010ac:	f887 30cc 	strb.w	r3, [r7, #204]	@ 0xcc
340010b0:	f897 30cc 	ldrb.w	r3, [r7, #204]	@ 0xcc
340010b4:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
340010b8:	f887 30cc 	strb.w	r3, [r7, #204]	@ 0xcc
340010bc:	f897 30cc 	ldrb.w	r3, [r7, #204]	@ 0xcc
340010c0:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
340010c4:	f887 30cc 	strb.w	r3, [r7, #204]	@ 0xcc
340010c8:	f897 30cd 	ldrb.w	r3, [r7, #205]	@ 0xcd
340010cc:	f043 0301 	orr.w	r3, r3, #1
340010d0:	f887 30cd 	strb.w	r3, [r7, #205]	@ 0xcd
340010d4:	f897 30cd 	ldrb.w	r3, [r7, #205]	@ 0xcd
340010d8:	2201      	movs	r2, #1
340010da:	f362 0383 	bfi	r3, r2, #2, #2
340010de:	f887 30cd 	strb.w	r3, [r7, #205]	@ 0xcd
340010e2:	f897 30cd 	ldrb.w	r3, [r7, #205]	@ 0xcd
340010e6:	2201      	movs	r2, #1
340010e8:	f362 1305 	bfi	r3, r2, #4, #2
340010ec:	f887 30cd 	strb.w	r3, [r7, #205]	@ 0xcd
340010f0:	f897 30ce 	ldrb.w	r3, [r7, #206]	@ 0xce
340010f4:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
340010f8:	f887 30ce 	strb.w	r3, [r7, #206]	@ 0xce
340010fc:	2301      	movs	r3, #1
340010fe:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
34001102:	2301      	movs	r3, #1
34001104:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
34001108:	2301      	movs	r3, #1
3400110a:	f887 30dc 	strb.w	r3, [r7, #220]	@ 0xdc
3400110e:	2301      	movs	r3, #1
34001110:	f887 30dd 	strb.w	r3, [r7, #221]	@ 0xdd
    .raw_o = 0,
    .fWidth = 1,
    .fHeight = 1,
    .kernelWidth = 1,
    .kernelHeight = 1,
    .nKernels = matmulInfo_int.insize,
34001114:	4b5c      	ldr	r3, [pc, #368]	@ (34001288 <LL_ATON_Start_EpochBlock_int8+0x204>)
34001116:	685b      	ldr	r3, [r3, #4]
  LL_Convacc_InitTypeDef conv_init = {
34001118:	b2db      	uxtb	r3, r3
3400111a:	f887 30de 	strb.w	r3, [r7, #222]	@ 0xde
    .batchDepth = matmulInfo_int.outsize,
3400111e:	4b5a      	ldr	r3, [pc, #360]	@ (34001288 <LL_ATON_Start_EpochBlock_int8+0x204>)
34001120:	689b      	ldr	r3, [r3, #8]
  LL_Convacc_InitTypeDef conv_init = {
34001122:	b29b      	uxth	r3, r3
34001124:	f8a7 30e0 	strh.w	r3, [r7, #224]	@ 0xe0
34001128:	2301      	movs	r3, #1
3400112a:	f887 30e2 	strb.w	r3, [r7, #226]	@ 0xe2
3400112e:	2301      	movs	r3, #1
34001130:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
    .left_crop = 0,
    .right_crop = 0,
    .top_crop = 0,
    .bot_crop = 0,
  };
  LL_Convacc_Init(0, &conv_init);
34001134:	f107 03cc 	add.w	r3, r7, #204	@ 0xcc
34001138:	4619      	mov	r1, r3
3400113a:	2000      	movs	r0, #0
3400113c:	f018 fe5c 	bl	34019df8 <LL_Convacc_Init>

  /* Input vector (1×16 int8) */
  LL_Streng_TensorInitTypeDef input_tensor = {
34001140:	f107 038c 	add.w	r3, r7, #140	@ 0x8c
34001144:	2240      	movs	r2, #64	@ 0x40
34001146:	2100      	movs	r1, #0
34001148:	4618      	mov	r0, r3
3400114a:	f01b fb2f 	bl	3401c7ac <memset>
3400114e:	f897 308c 	ldrb.w	r3, [r7, #140]	@ 0x8c
34001152:	f043 0302 	orr.w	r3, r3, #2
34001156:	f887 308c 	strb.w	r3, [r7, #140]	@ 0x8c
3400115a:	4b4c      	ldr	r3, [pc, #304]	@ (3400128c <LL_ATON_Start_EpochBlock_int8+0x208>)
3400115c:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
    .raw = 1,
    .noblk = 0,
    .align_right = 0,
    .nbits_unsigned = 0,
    .addr_base = { (unsigned char *)(0x34200000UL) },
    .offset_start = matmulInfo_int.input_start,
34001160:	4b49      	ldr	r3, [pc, #292]	@ (34001288 <LL_ATON_Start_EpochBlock_int8+0x204>)
34001162:	699b      	ldr	r3, [r3, #24]
  LL_Streng_TensorInitTypeDef input_tensor = {
34001164:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
    .offset_end = matmulInfo_int.input_end,
34001168:	4b47      	ldr	r3, [pc, #284]	@ (34001288 <LL_ATON_Start_EpochBlock_int8+0x204>)
3400116a:	69db      	ldr	r3, [r3, #28]
  LL_Streng_TensorInitTypeDef input_tensor = {
3400116c:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
    .offset_limit = matmulInfo_int.input_limit,
34001170:	4b45      	ldr	r3, [pc, #276]	@ (34001288 <LL_ATON_Start_EpochBlock_int8+0x204>)
34001172:	6a1b      	ldr	r3, [r3, #32]
  LL_Streng_TensorInitTypeDef input_tensor = {
34001174:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
34001178:	2310      	movs	r3, #16
3400117a:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
3400117e:	2301      	movs	r3, #1
34001180:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
34001184:	2308      	movs	r3, #8
34001186:	f887 30c8 	strb.w	r3, [r7, #200]	@ 0xc8
3400118a:	2308      	movs	r3, #8
3400118c:	f887 30c9 	strb.w	r3, [r7, #201]	@ 0xc9
    .frame_loop_cnt = 0,
    .frame_tot_cnt = 1,
    .nbits_in = 8,
    .nbits_out = 8,
  };
  LL_Streng_TensorInit(1, &input_tensor, 1);
34001190:	f107 038c 	add.w	r3, r7, #140	@ 0x8c
34001194:	2201      	movs	r2, #1
34001196:	4619      	mov	r1, r3
34001198:	2001      	movs	r0, #1
3400119a:	f017 ffbf 	bl	3401911c <LL_Streng_TensorInit>

  /* Weight matrix (16×16 int8) */
  LL_Streng_TensorInitTypeDef weight_tensor = {
3400119e:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
340011a2:	2240      	movs	r2, #64	@ 0x40
340011a4:	2100      	movs	r1, #0
340011a6:	4618      	mov	r0, r3
340011a8:	f01b fb00 	bl	3401c7ac <memset>
340011ac:	f897 304c 	ldrb.w	r3, [r7, #76]	@ 0x4c
340011b0:	f043 0302 	orr.w	r3, r3, #2
340011b4:	f887 304c 	strb.w	r3, [r7, #76]	@ 0x4c
340011b8:	f897 304c 	ldrb.w	r3, [r7, #76]	@ 0x4c
340011bc:	f043 0308 	orr.w	r3, r3, #8
340011c0:	f887 304c 	strb.w	r3, [r7, #76]	@ 0x4c
340011c4:	4b31      	ldr	r3, [pc, #196]	@ (3400128c <LL_ATON_Start_EpochBlock_int8+0x208>)
340011c6:	653b      	str	r3, [r7, #80]	@ 0x50
    .continuous = 1,
    .noblk = 0,
    .align_right = 0,
    .nbits_unsigned = 0,
    .addr_base = { (unsigned char *)(0x34200000UL) },
    .offset_start = matmulInfo_int.weight_start,
340011c8:	4b2f      	ldr	r3, [pc, #188]	@ (34001288 <LL_ATON_Start_EpochBlock_int8+0x204>)
340011ca:	68db      	ldr	r3, [r3, #12]
  LL_Streng_TensorInitTypeDef weight_tensor = {
340011cc:	657b      	str	r3, [r7, #84]	@ 0x54
    .offset_end = matmulInfo_int.weight_end,
340011ce:	4b2e      	ldr	r3, [pc, #184]	@ (34001288 <LL_ATON_Start_EpochBlock_int8+0x204>)
340011d0:	691b      	ldr	r3, [r3, #16]
  LL_Streng_TensorInitTypeDef weight_tensor = {
340011d2:	65bb      	str	r3, [r7, #88]	@ 0x58
    .offset_limit = matmulInfo_int.weight_limit,
340011d4:	4b2c      	ldr	r3, [pc, #176]	@ (34001288 <LL_ATON_Start_EpochBlock_int8+0x204>)
340011d6:	695b      	ldr	r3, [r3, #20]
  LL_Streng_TensorInitTypeDef weight_tensor = {
340011d8:	65fb      	str	r3, [r7, #92]	@ 0x5c
340011da:	2301      	movs	r3, #1
340011dc:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
340011e0:	2308      	movs	r3, #8
340011e2:	f887 3088 	strb.w	r3, [r7, #136]	@ 0x88
340011e6:	2308      	movs	r3, #8
340011e8:	f887 3089 	strb.w	r3, [r7, #137]	@ 0x89
    .frame_loop_cnt = 0,
    .frame_tot_cnt = 1,
    .nbits_in = 8,
    .nbits_out = 8,
  };
  LL_Streng_TensorInit(9, &weight_tensor, 1);
340011ec:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
340011f0:	2201      	movs	r2, #1
340011f2:	4619      	mov	r1, r3
340011f4:	2009      	movs	r0, #9
340011f6:	f017 ff91 	bl	3401911c <LL_Streng_TensorInit>

  /* Output vector (16×1 int8) */
  LL_Streng_TensorInitTypeDef output_tensor = {
340011fa:	f107 030c 	add.w	r3, r7, #12
340011fe:	2240      	movs	r2, #64	@ 0x40
34001200:	2100      	movs	r1, #0
34001202:	4618      	mov	r0, r3
34001204:	f01b fad2 	bl	3401c7ac <memset>
34001208:	7b3b      	ldrb	r3, [r7, #12]
3400120a:	f043 0301 	orr.w	r3, r3, #1
3400120e:	733b      	strb	r3, [r7, #12]
34001210:	7b3b      	ldrb	r3, [r7, #12]
34001212:	f043 0302 	orr.w	r3, r3, #2
34001216:	733b      	strb	r3, [r7, #12]
34001218:	4b1c      	ldr	r3, [pc, #112]	@ (3400128c <LL_ATON_Start_EpochBlock_int8+0x208>)
3400121a:	613b      	str	r3, [r7, #16]
    .raw = 1,
    .noblk = 0,
    .align_right = 0,
    .nbits_unsigned = 0,
    .addr_base = { (unsigned char *)(0x34200000UL) },
    .offset_start = matmulInfo_int.output_start,
3400121c:	4b1a      	ldr	r3, [pc, #104]	@ (34001288 <LL_ATON_Start_EpochBlock_int8+0x204>)
3400121e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  LL_Streng_TensorInitTypeDef output_tensor = {
34001220:	617b      	str	r3, [r7, #20]
    .offset_end = matmulInfo_int.output_end,
34001222:	4b19      	ldr	r3, [pc, #100]	@ (34001288 <LL_ATON_Start_EpochBlock_int8+0x204>)
34001224:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
  LL_Streng_TensorInitTypeDef output_tensor = {
34001226:	61bb      	str	r3, [r7, #24]
    .offset_limit = matmulInfo_int.output_limit,
34001228:	4b17      	ldr	r3, [pc, #92]	@ (34001288 <LL_ATON_Start_EpochBlock_int8+0x204>)
3400122a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  LL_Streng_TensorInitTypeDef output_tensor = {
3400122c:	61fb      	str	r3, [r7, #28]
3400122e:	2310      	movs	r3, #16
34001230:	637b      	str	r3, [r7, #52]	@ 0x34
34001232:	2301      	movs	r3, #1
34001234:	647b      	str	r3, [r7, #68]	@ 0x44
34001236:	2308      	movs	r3, #8
34001238:	f887 3048 	strb.w	r3, [r7, #72]	@ 0x48
3400123c:	2308      	movs	r3, #8
3400123e:	f887 3049 	strb.w	r3, [r7, #73]	@ 0x49
    .frame_loop_cnt = 0,
    .frame_tot_cnt = 1,
    .nbits_in = 8,
    .nbits_out = 8,
  };
  LL_Streng_TensorInit(3, &output_tensor, 1);
34001242:	f107 030c 	add.w	r3, r7, #12
34001246:	2201      	movs	r2, #1
34001248:	4619      	mov	r1, r3
3400124a:	2003      	movs	r0, #3
3400124c:	f017 ff66 	bl	3401911c <LL_Streng_TensorInit>
    // CONV output → DMA
    { LL_Switch_Init_Dest() = ATONN_DSTPORT(STRSWITCH, 0, STRENG, 3, 0),
      LL_Switch_Init_Source(0) = ATONN_SRCPORT(STRSWITCH, 0, CONVACC, 0, 0),
      LL_Switch_Init_Context(0) = 1, LL_Switch_Init_Frames(0) = 0 },
  };
  LL_Switch_Init(switch_init, 3);
34001250:	2103      	movs	r1, #3
34001252:	480f      	ldr	r0, [pc, #60]	@ (34001290 <LL_ATON_Start_EpochBlock_int8+0x20c>)
34001254:	f018 fd7a 	bl	34019d4c <LL_Switch_Init>

  LL_ATON_Cache_MCU_Invalidate_Range((uintptr_t)(0x34200000UL + matmulInfo_int.input_start), matmulInfo_int.output_end - matmulInfo_int.input_start); /// Very Important!!
34001258:	4b0b      	ldr	r3, [pc, #44]	@ (34001288 <LL_ATON_Start_EpochBlock_int8+0x204>)
3400125a:	699b      	ldr	r3, [r3, #24]
3400125c:	f103 5350 	add.w	r3, r3, #872415232	@ 0x34000000
34001260:	f503 1300 	add.w	r3, r3, #2097152	@ 0x200000
34001264:	4a08      	ldr	r2, [pc, #32]	@ (34001288 <LL_ATON_Start_EpochBlock_int8+0x204>)
34001266:	6a91      	ldr	r1, [r2, #40]	@ 0x28
34001268:	4a07      	ldr	r2, [pc, #28]	@ (34001288 <LL_ATON_Start_EpochBlock_int8+0x204>)
3400126a:	6992      	ldr	r2, [r2, #24]
3400126c:	1a8a      	subs	r2, r1, r2
3400126e:	4611      	mov	r1, r2
34001270:	4618      	mov	r0, r3
34001272:	f7ff feb7 	bl	34000fe4 <LL_ATON_Cache_MCU_Invalidate_Range>
    { {STRENG, 3} },
    { {CONVACC, 0} },
    { {STRENG, 1} },
    { {STRENG, 9} },
  };
  LL_ATON_EnableUnits_Init(enable_units, 4);
34001276:	2104      	movs	r1, #4
34001278:	4806      	ldr	r0, [pc, #24]	@ (34001294 <LL_ATON_Start_EpochBlock_int8+0x210>)
3400127a:	f017 fcc5 	bl	34018c08 <LL_ATON_EnableUnits_Init>
}
3400127e:	bf00      	nop
34001280:	f507 7784 	add.w	r7, r7, #264	@ 0x108
34001284:	46bd      	mov	sp, r7
34001286:	bd80      	pop	{r7, pc}
34001288:	34020e44 	.word	0x34020e44
3400128c:	34200000 	.word	0x34200000
34001290:	3401fe84 	.word	0x3401fe84
34001294:	3401feb4 	.word	0x3401feb4

34001298 <LL_ATON_End_EpochBlock_int8>:

static void LL_ATON_End_EpochBlock_int8(const void *epoch_block)
{
34001298:	b580      	push	{r7, lr}
3400129a:	b082      	sub	sp, #8
3400129c:	af00      	add	r7, sp, #0
3400129e:	6078      	str	r0, [r7, #4]

    { LL_Switch_Init_Dest() = ATONN_DSTPORT(STRSWITCH, 0, STRENG, 3, 0),
      LL_Switch_Init_Source(0) = ATONN_SRCPORT(STRSWITCH, 0, CONVACC, 0, 0),
      LL_Switch_Init_Context(0) = 1, LL_Switch_Init_Frames(0) = 0 },
  };
  LL_Switch_Deinit(switch_deinit, 3);
340012a0:	2103      	movs	r1, #3
340012a2:	4805      	ldr	r0, [pc, #20]	@ (340012b8 <LL_ATON_End_EpochBlock_int8+0x20>)
340012a4:	f018 fd84 	bl	34019db0 <LL_Switch_Deinit>
    { {STRENG, 3} },
    { {CONVACC, 0} },
    { {STRENG, 1} },
    { {STRENG, 9} },
  };
  LL_ATON_DisableUnits_Init(disable_units, 4);
340012a8:	2104      	movs	r1, #4
340012aa:	4804      	ldr	r0, [pc, #16]	@ (340012bc <LL_ATON_End_EpochBlock_int8+0x24>)
340012ac:	f017 fd6e 	bl	34018d8c <LL_ATON_DisableUnits_Init>
}
340012b0:	bf00      	nop
340012b2:	3708      	adds	r7, #8
340012b4:	46bd      	mov	sp, r7
340012b6:	bd80      	pop	{r7, pc}
340012b8:	3401fec4 	.word	0x3401fec4
340012bc:	3401fef4 	.word	0x3401fef4

340012c0 <LL_ATON_EpochBlockItems_int8>:

const EpochBlock_ItemTypeDef *LL_ATON_EpochBlockItems_int8(void) {
340012c0:	b480      	push	{r7}
340012c2:	af00      	add	r7, sp, #0
      .flags = EpochBlock_Flags_last_eb,
    },
  };


  return ll_atonn_rt_epoch_block_array;
340012c4:	4b02      	ldr	r3, [pc, #8]	@ (340012d0 <LL_ATON_EpochBlockItems_int8+0x10>)
}
340012c6:	4618      	mov	r0, r3
340012c8:	46bd      	mov	sp, r7
340012ca:	f85d 7b04 	ldr.w	r7, [sp], #4
340012ce:	4770      	bx	lr
340012d0:	3401ff04 	.word	0x3401ff04

340012d4 <LL_ATON_Input_Buffers_Info_int8>:

LL_Buffer_InfoTypeDef *LL_ATON_Input_Buffers_Info_int8(void)
{
340012d4:	b580      	push	{r7, lr}
340012d6:	b09c      	sub	sp, #112	@ 0x70
340012d8:	af00      	add	r7, sp, #0
  static const float buff_info_Gemm_2_conv_4_zero_off_8_quant_scale[] = { 0.00392139703035355 };
  static const int16_t buff_info_Gemm_2_conv_4_zero_off_8_quant_offset[] = { 0 };
  static const uint32_t buff_info__shape_16_1_1[] = { 1, 1, 1, 16 };
  static const uint32_t buff_info__mem_shape_F_16_1_1[] = { 16, 1, 1 };
#endif // LL_ATON_DBG_BUFFER_INFO_EXCLUDED == 0
  LL_Buffer_InfoTypeDef buff_info[] = {
340012da:	463b      	mov	r3, r7
340012dc:	2270      	movs	r2, #112	@ 0x70
340012de:	2100      	movs	r1, #0
340012e0:	4618      	mov	r0, r3
340012e2:	f01b fa63 	bl	3401c7ac <memset>
340012e6:	4b15      	ldr	r3, [pc, #84]	@ (3400133c <LL_ATON_Input_Buffers_Info_int8+0x68>)
340012e8:	603b      	str	r3, [r7, #0]
340012ea:	4b15      	ldr	r3, [pc, #84]	@ (34001340 <LL_ATON_Input_Buffers_Info_int8+0x6c>)
340012ec:	607b      	str	r3, [r7, #4]
    {
      .name = "Input_0_out_0",
      .addr_base = {(unsigned char *)(0x34200000UL) /* Equivalent hex address = 0x34200000UL */},
      .offset_start = matmulInfo_int.input_start,
340012ee:	4b15      	ldr	r3, [pc, #84]	@ (34001344 <LL_ATON_Input_Buffers_Info_int8+0x70>)
340012f0:	699b      	ldr	r3, [r3, #24]
  LL_Buffer_InfoTypeDef buff_info[] = {
340012f2:	60bb      	str	r3, [r7, #8]
      .offset_end = matmulInfo_int.input_end,
340012f4:	4b13      	ldr	r3, [pc, #76]	@ (34001344 <LL_ATON_Input_Buffers_Info_int8+0x70>)
340012f6:	69db      	ldr	r3, [r3, #28]
  LL_Buffer_InfoTypeDef buff_info[] = {
340012f8:	60fb      	str	r3, [r7, #12]
      .offset_limit = matmulInfo_int.input_limit,
340012fa:	4b12      	ldr	r3, [pc, #72]	@ (34001344 <LL_ATON_Input_Buffers_Info_int8+0x70>)
340012fc:	6a1b      	ldr	r3, [r3, #32]
  LL_Buffer_InfoTypeDef buff_info[] = {
340012fe:	613b      	str	r3, [r7, #16]
34001300:	2301      	movs	r3, #1
34001302:	61bb      	str	r3, [r7, #24]
34001304:	4b10      	ldr	r3, [pc, #64]	@ (34001348 <LL_ATON_Input_Buffers_Info_int8+0x74>)
34001306:	61fb      	str	r3, [r7, #28]
34001308:	2302      	movs	r3, #2
3400130a:	843b      	strh	r3, [r7, #32]
3400130c:	2303      	movs	r3, #3
3400130e:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
34001312:	2307      	movs	r3, #7
34001314:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
34001318:	2304      	movs	r3, #4
3400131a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
3400131e:	2308      	movs	r3, #8
34001320:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
34001324:	4b09      	ldr	r3, [pc, #36]	@ (3400134c <LL_ATON_Input_Buffers_Info_int8+0x78>)
34001326:	62fb      	str	r3, [r7, #44]	@ 0x2c
34001328:	4b09      	ldr	r3, [pc, #36]	@ (34001350 <LL_ATON_Input_Buffers_Info_int8+0x7c>)
3400132a:	633b      	str	r3, [r7, #48]	@ 0x30
3400132c:	4b09      	ldr	r3, [pc, #36]	@ (34001354 <LL_ATON_Input_Buffers_Info_int8+0x80>)
3400132e:	637b      	str	r3, [r7, #52]	@ 0x34
    {
      .name = NULL,
    }
  };

  return buff_info;
34001330:	2300      	movs	r3, #0
}
34001332:	4618      	mov	r0, r3
34001334:	3770      	adds	r7, #112	@ 0x70
34001336:	46bd      	mov	sp, r7
34001338:	bd80      	pop	{r7, pc}
3400133a:	bf00      	nop
3400133c:	3401e648 	.word	0x3401e648
34001340:	34200000 	.word	0x34200000
34001344:	34020e44 	.word	0x34020e44
34001348:	3401ff2c 	.word	0x3401ff2c
3400134c:	3401ff34 	.word	0x3401ff34
34001350:	3401ff44 	.word	0x3401ff44
34001354:	3401ff48 	.word	0x3401ff48

34001358 <LL_ATON_Output_Buffers_Info_int8>:

LL_Buffer_InfoTypeDef *LL_ATON_Output_Buffers_Info_int8(void)
{
34001358:	b580      	push	{r7, lr}
3400135a:	b09c      	sub	sp, #112	@ 0x70
3400135c:	af00      	add	r7, sp, #0
	extern volatile Matmul_info matmulInfo_int;
  static const uint32_t buff_info__shape_1_16[] = { 1, 1, 16, 1 };
  static const uint32_t buff_info__mem_shape_U_1_16[] = { 1, 16 };
  static const float buff_info_Quantize_3_out_0_quant_scale[] = { 0.0269236713647842 };
  static const int16_t buff_info_Quantize_3_out_0_quant_offset[] = { -128 };
  LL_Buffer_InfoTypeDef buff_info[] = {
3400135e:	463b      	mov	r3, r7
34001360:	2270      	movs	r2, #112	@ 0x70
34001362:	2100      	movs	r1, #0
34001364:	4618      	mov	r0, r3
34001366:	f01b fa21 	bl	3401c7ac <memset>
3400136a:	4b16      	ldr	r3, [pc, #88]	@ (340013c4 <LL_ATON_Output_Buffers_Info_int8+0x6c>)
3400136c:	603b      	str	r3, [r7, #0]
3400136e:	4b16      	ldr	r3, [pc, #88]	@ (340013c8 <LL_ATON_Output_Buffers_Info_int8+0x70>)
34001370:	607b      	str	r3, [r7, #4]
    {
      .name = "Quantize_3_out_0",
      .addr_base = {(unsigned char *)(0x34200000UL) /* Equivalent hex address = 0x34200000UL */},
      .offset_start = matmulInfo_int.output_start,
34001372:	4b16      	ldr	r3, [pc, #88]	@ (340013cc <LL_ATON_Output_Buffers_Info_int8+0x74>)
34001374:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  LL_Buffer_InfoTypeDef buff_info[] = {
34001376:	60bb      	str	r3, [r7, #8]
      .offset_end = matmulInfo_int.output_end,
34001378:	4b14      	ldr	r3, [pc, #80]	@ (340013cc <LL_ATON_Output_Buffers_Info_int8+0x74>)
3400137a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
  LL_Buffer_InfoTypeDef buff_info[] = {
3400137c:	60fb      	str	r3, [r7, #12]
      .offset_limit = matmulInfo_int.output_limit,
3400137e:	4b13      	ldr	r3, [pc, #76]	@ (340013cc <LL_ATON_Output_Buffers_Info_int8+0x74>)
34001380:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  LL_Buffer_InfoTypeDef buff_info[] = {
34001382:	613b      	str	r3, [r7, #16]
34001384:	2302      	movs	r3, #2
34001386:	82fb      	strh	r3, [r7, #22]
34001388:	2301      	movs	r3, #1
3400138a:	61bb      	str	r3, [r7, #24]
3400138c:	4b10      	ldr	r3, [pc, #64]	@ (340013d0 <LL_ATON_Output_Buffers_Info_int8+0x78>)
3400138e:	61fb      	str	r3, [r7, #28]
34001390:	2302      	movs	r3, #2
34001392:	843b      	strh	r3, [r7, #32]
34001394:	2303      	movs	r3, #3
34001396:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
3400139a:	2307      	movs	r3, #7
3400139c:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
340013a0:	2304      	movs	r3, #4
340013a2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
340013a6:	2308      	movs	r3, #8
340013a8:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
340013ac:	4b09      	ldr	r3, [pc, #36]	@ (340013d4 <LL_ATON_Output_Buffers_Info_int8+0x7c>)
340013ae:	62fb      	str	r3, [r7, #44]	@ 0x2c
340013b0:	4b09      	ldr	r3, [pc, #36]	@ (340013d8 <LL_ATON_Output_Buffers_Info_int8+0x80>)
340013b2:	633b      	str	r3, [r7, #48]	@ 0x30
340013b4:	4b09      	ldr	r3, [pc, #36]	@ (340013dc <LL_ATON_Output_Buffers_Info_int8+0x84>)
340013b6:	637b      	str	r3, [r7, #52]	@ 0x34
    {
      .name = NULL,
    }
  };

  return buff_info;
340013b8:	2300      	movs	r3, #0
}
340013ba:	4618      	mov	r0, r3
340013bc:	3770      	adds	r7, #112	@ 0x70
340013be:	46bd      	mov	sp, r7
340013c0:	bd80      	pop	{r7, pc}
340013c2:	bf00      	nop
340013c4:	3401e658 	.word	0x3401e658
340013c8:	34200000 	.word	0x34200000
340013cc:	34020e44 	.word	0x34020e44
340013d0:	3401ff4c 	.word	0x3401ff4c
340013d4:	3401ff54 	.word	0x3401ff54
340013d8:	3401ff64 	.word	0x3401ff64
340013dc:	3401ff68 	.word	0x3401ff68

340013e0 <LL_ATON_Internal_Buffers_Info_int8>:

LL_Buffer_InfoTypeDef *LL_ATON_Internal_Buffers_Info_int8(void)
{
340013e0:	b580      	push	{r7, lr}
340013e2:	b0aa      	sub	sp, #168	@ 0xa8
340013e4:	af00      	add	r7, sp, #0
  static const uint32_t buff_info__mem_shape_F_1_16_1_1[] = { 1, 16, 1, 1 };
  static const float buff_info_Gemm_2_reshape_x_2_quant_scale[] = { 0.00392139703035355 };
  static const int16_t buff_info_Gemm_2_reshape_x_2_quant_offset[] = { -128 };
  static const float buff_info_Gemm_2_conv_4_off_bias_out_13_quant_scale[] = { 0.0269236713647842 };
  static const int16_t buff_info_Gemm_2_conv_4_off_bias_out_13_quant_offset[] = { -128 };
  LL_Buffer_InfoTypeDef buff_info[] = {
340013e6:	463b      	mov	r3, r7
340013e8:	22a8      	movs	r2, #168	@ 0xa8
340013ea:	2100      	movs	r1, #0
340013ec:	4618      	mov	r0, r3
340013ee:	f01b f9dd 	bl	3401c7ac <memset>
340013f2:	4b2d      	ldr	r3, [pc, #180]	@ (340014a8 <LL_ATON_Internal_Buffers_Info_int8+0xc8>)
340013f4:	603b      	str	r3, [r7, #0]
340013f6:	4b2d      	ldr	r3, [pc, #180]	@ (340014ac <LL_ATON_Internal_Buffers_Info_int8+0xcc>)
340013f8:	607b      	str	r3, [r7, #4]
    {
      .name = "Gemm_2_reshape_x_2",
      .addr_base = {(unsigned char *)(0x34200000UL) /* Equivalent hex address = 0x34200000UL */},
      .offset_start = matmulInfo_int.input_start,
340013fa:	4b2d      	ldr	r3, [pc, #180]	@ (340014b0 <LL_ATON_Internal_Buffers_Info_int8+0xd0>)
340013fc:	699b      	ldr	r3, [r3, #24]
  LL_Buffer_InfoTypeDef buff_info[] = {
340013fe:	60bb      	str	r3, [r7, #8]
      .offset_end = matmulInfo_int.input_end,
34001400:	4b2b      	ldr	r3, [pc, #172]	@ (340014b0 <LL_ATON_Internal_Buffers_Info_int8+0xd0>)
34001402:	69db      	ldr	r3, [r3, #28]
  LL_Buffer_InfoTypeDef buff_info[] = {
34001404:	60fb      	str	r3, [r7, #12]
      .offset_limit = matmulInfo_int.input_limit,
34001406:	4b2a      	ldr	r3, [pc, #168]	@ (340014b0 <LL_ATON_Internal_Buffers_Info_int8+0xd0>)
34001408:	6a1b      	ldr	r3, [r3, #32]
  LL_Buffer_InfoTypeDef buff_info[] = {
3400140a:	613b      	str	r3, [r7, #16]
3400140c:	2301      	movs	r3, #1
3400140e:	82fb      	strh	r3, [r7, #22]
34001410:	2310      	movs	r3, #16
34001412:	61bb      	str	r3, [r7, #24]
34001414:	4b27      	ldr	r3, [pc, #156]	@ (340014b4 <LL_ATON_Internal_Buffers_Info_int8+0xd4>)
34001416:	61fb      	str	r3, [r7, #28]
34001418:	2304      	movs	r3, #4
3400141a:	843b      	strh	r3, [r7, #32]
3400141c:	2301      	movs	r3, #1
3400141e:	f887 3022 	strb.w	r3, [r7, #34]	@ 0x22
34001422:	2303      	movs	r3, #3
34001424:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
34001428:	2307      	movs	r3, #7
3400142a:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
3400142e:	2304      	movs	r3, #4
34001430:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
34001434:	2308      	movs	r3, #8
34001436:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
3400143a:	4b1f      	ldr	r3, [pc, #124]	@ (340014b8 <LL_ATON_Internal_Buffers_Info_int8+0xd8>)
3400143c:	62fb      	str	r3, [r7, #44]	@ 0x2c
3400143e:	4b1f      	ldr	r3, [pc, #124]	@ (340014bc <LL_ATON_Internal_Buffers_Info_int8+0xdc>)
34001440:	633b      	str	r3, [r7, #48]	@ 0x30
34001442:	4b1f      	ldr	r3, [pc, #124]	@ (340014c0 <LL_ATON_Internal_Buffers_Info_int8+0xe0>)
34001444:	637b      	str	r3, [r7, #52]	@ 0x34
34001446:	4b1f      	ldr	r3, [pc, #124]	@ (340014c4 <LL_ATON_Internal_Buffers_Info_int8+0xe4>)
34001448:	63bb      	str	r3, [r7, #56]	@ 0x38
3400144a:	4b18      	ldr	r3, [pc, #96]	@ (340014ac <LL_ATON_Internal_Buffers_Info_int8+0xcc>)
3400144c:	63fb      	str	r3, [r7, #60]	@ 0x3c
      .offset = buff_info_Gemm_2_reshape_x_2_quant_offset,
    },
    {
      .name = "Gemm_2_conv_4_off_bias_out_13",
      .addr_base = {(unsigned char *)(0x34200000UL) /* Equivalent hex address = 0x34200000UL */},
      .offset_start = matmulInfo_int.output_start,
3400144e:	4b18      	ldr	r3, [pc, #96]	@ (340014b0 <LL_ATON_Internal_Buffers_Info_int8+0xd0>)
34001450:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  LL_Buffer_InfoTypeDef buff_info[] = {
34001452:	643b      	str	r3, [r7, #64]	@ 0x40
      .offset_end = matmulInfo_int.output_end,
34001454:	4b16      	ldr	r3, [pc, #88]	@ (340014b0 <LL_ATON_Internal_Buffers_Info_int8+0xd0>)
34001456:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
  LL_Buffer_InfoTypeDef buff_info[] = {
34001458:	647b      	str	r3, [r7, #68]	@ 0x44
      .offset_limit = matmulInfo_int.output_limit,
3400145a:	4b15      	ldr	r3, [pc, #84]	@ (340014b0 <LL_ATON_Internal_Buffers_Info_int8+0xd0>)
3400145c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
  LL_Buffer_InfoTypeDef buff_info[] = {
3400145e:	64bb      	str	r3, [r7, #72]	@ 0x48
34001460:	2302      	movs	r3, #2
34001462:	f8a7 304e 	strh.w	r3, [r7, #78]	@ 0x4e
34001466:	2310      	movs	r3, #16
34001468:	653b      	str	r3, [r7, #80]	@ 0x50
3400146a:	4b12      	ldr	r3, [pc, #72]	@ (340014b4 <LL_ATON_Internal_Buffers_Info_int8+0xd4>)
3400146c:	657b      	str	r3, [r7, #84]	@ 0x54
3400146e:	2304      	movs	r3, #4
34001470:	f8a7 3058 	strh.w	r3, [r7, #88]	@ 0x58
34001474:	2301      	movs	r3, #1
34001476:	f887 305a 	strb.w	r3, [r7, #90]	@ 0x5a
3400147a:	2303      	movs	r3, #3
3400147c:	f887 305b 	strb.w	r3, [r7, #91]	@ 0x5b
34001480:	2307      	movs	r3, #7
34001482:	f887 305c 	strb.w	r3, [r7, #92]	@ 0x5c
34001486:	2304      	movs	r3, #4
34001488:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
3400148c:	2308      	movs	r3, #8
3400148e:	f887 3060 	strb.w	r3, [r7, #96]	@ 0x60
34001492:	4b09      	ldr	r3, [pc, #36]	@ (340014b8 <LL_ATON_Internal_Buffers_Info_int8+0xd8>)
34001494:	667b      	str	r3, [r7, #100]	@ 0x64
34001496:	4b0c      	ldr	r3, [pc, #48]	@ (340014c8 <LL_ATON_Internal_Buffers_Info_int8+0xe8>)
34001498:	66bb      	str	r3, [r7, #104]	@ 0x68
3400149a:	4b0c      	ldr	r3, [pc, #48]	@ (340014cc <LL_ATON_Internal_Buffers_Info_int8+0xec>)
3400149c:	66fb      	str	r3, [r7, #108]	@ 0x6c
    {
      .name = NULL,
    }
  };

  return buff_info;
3400149e:	2300      	movs	r3, #0
}
340014a0:	4618      	mov	r0, r3
340014a2:	37a8      	adds	r7, #168	@ 0xa8
340014a4:	46bd      	mov	sp, r7
340014a6:	bd80      	pop	{r7, pc}
340014a8:	3401e66c 	.word	0x3401e66c
340014ac:	34200000 	.word	0x34200000
340014b0:	34020e44 	.word	0x34020e44
340014b4:	3401ff6c 	.word	0x3401ff6c
340014b8:	3401ff7c 	.word	0x3401ff7c
340014bc:	3401ff8c 	.word	0x3401ff8c
340014c0:	3401ff90 	.word	0x3401ff90
340014c4:	3401e680 	.word	0x3401e680
340014c8:	3401ff94 	.word	0x3401ff94
340014cc:	3401ff98 	.word	0x3401ff98

340014d0 <Fuse_Programming>:
/**
  * @brief  Check specific fuse configuration and update it if needed.
  * @retval None
  */
void Fuse_Programming(void)
{
340014d0:	b580      	push	{r7, lr}
340014d2:	b086      	sub	sp, #24
340014d4:	af00      	add	r7, sp, #0
  uint32_t fuse_id, bit_mask, data;

  BSEC_HandleTypeDef sBsecHandler;

  sBsecHandler.Instance = BSEC;
340014d6:	4b21      	ldr	r3, [pc, #132]	@ (3400155c <Fuse_Programming+0x8c>)
340014d8:	607b      	str	r3, [r7, #4]

  /* Read current value of fuse */
  fuse_id = BSEC_FUSE_ADDRESS;
340014da:	237c      	movs	r3, #124	@ 0x7c
340014dc:	617b      	str	r3, [r7, #20]
  if (HAL_BSEC_OTP_Read(&sBsecHandler, fuse_id, &data) == HAL_OK)
340014de:	f107 020c 	add.w	r2, r7, #12
340014e2:	1d3b      	adds	r3, r7, #4
340014e4:	6979      	ldr	r1, [r7, #20]
340014e6:	4618      	mov	r0, r3
340014e8:	f002 fde4 	bl	340040b4 <HAL_BSEC_OTP_Read>
340014ec:	4603      	mov	r3, r0
340014ee:	2b00      	cmp	r3, #0
340014f0:	d12e      	bne.n	34001550 <Fuse_Programming+0x80>
  {
    /* Check if bit has already been set */
    bit_mask = BSEC_FUSE_MASK;
340014f2:	f44f 33c0 	mov.w	r3, #98304	@ 0x18000
340014f6:	613b      	str	r3, [r7, #16]
    if ((data & bit_mask) != bit_mask)
340014f8:	68fa      	ldr	r2, [r7, #12]
340014fa:	693b      	ldr	r3, [r7, #16]
340014fc:	4013      	ands	r3, r2
340014fe:	693a      	ldr	r2, [r7, #16]
34001500:	429a      	cmp	r2, r3
34001502:	d027      	beq.n	34001554 <Fuse_Programming+0x84>
    {
      data |= bit_mask;
34001504:	68fa      	ldr	r2, [r7, #12]
34001506:	693b      	ldr	r3, [r7, #16]
34001508:	4313      	orrs	r3, r2
3400150a:	60fb      	str	r3, [r7, #12]
      /* Bitwise programming of lower bits */
      if (HAL_BSEC_OTP_Program(&sBsecHandler, fuse_id, data, HAL_BSEC_NORMAL_PROG) == HAL_OK)
3400150c:	68fa      	ldr	r2, [r7, #12]
3400150e:	1d38      	adds	r0, r7, #4
34001510:	2300      	movs	r3, #0
34001512:	6979      	ldr	r1, [r7, #20]
34001514:	f002 fe06 	bl	34004124 <HAL_BSEC_OTP_Program>
34001518:	4603      	mov	r3, r0
3400151a:	2b00      	cmp	r3, #0
3400151c:	d115      	bne.n	3400154a <Fuse_Programming+0x7a>
      {
        /* Read lower bits to verify the correct programming */
        if (HAL_BSEC_OTP_Read(&sBsecHandler, fuse_id, &data) == HAL_OK)
3400151e:	f107 020c 	add.w	r2, r7, #12
34001522:	1d3b      	adds	r3, r7, #4
34001524:	6979      	ldr	r1, [r7, #20]
34001526:	4618      	mov	r0, r3
34001528:	f002 fdc4 	bl	340040b4 <HAL_BSEC_OTP_Read>
3400152c:	4603      	mov	r3, r0
3400152e:	2b00      	cmp	r3, #0
34001530:	d108      	bne.n	34001544 <Fuse_Programming+0x74>
        {
          if ((data & bit_mask) != bit_mask)
34001532:	68fa      	ldr	r2, [r7, #12]
34001534:	693b      	ldr	r3, [r7, #16]
34001536:	4013      	ands	r3, r2
34001538:	693a      	ldr	r2, [r7, #16]
3400153a:	429a      	cmp	r2, r3
3400153c:	d00a      	beq.n	34001554 <Fuse_Programming+0x84>
          {
            /* Error : Fuse programming not taken in account */
            ErrorHandler();
3400153e:	f000 f80f 	bl	34001560 <ErrorHandler>
  else
  {
    /* Error  : Fuse read unsuccessful */
    ErrorHandler();
  }
}
34001542:	e007      	b.n	34001554 <Fuse_Programming+0x84>
          ErrorHandler();
34001544:	f000 f80c 	bl	34001560 <ErrorHandler>
}
34001548:	e004      	b.n	34001554 <Fuse_Programming+0x84>
        ErrorHandler();
3400154a:	f000 f809 	bl	34001560 <ErrorHandler>
}
3400154e:	e001      	b.n	34001554 <Fuse_Programming+0x84>
    ErrorHandler();
34001550:	f000 f806 	bl	34001560 <ErrorHandler>
}
34001554:	bf00      	nop
34001556:	3718      	adds	r7, #24
34001558:	46bd      	mov	sp, r7
3400155a:	bd80      	pop	{r7, pc}
3400155c:	56009000 	.word	0x56009000

34001560 <ErrorHandler>:
/**
  * @brief  Handle error which occurs when calling HAL API
  * @retval None
  */
static void ErrorHandler(void)
{
34001560:	b480      	push	{r7}
34001562:	af00      	add	r7, sp, #0
  while(1);
34001564:	bf00      	nop
34001566:	e7fd      	b.n	34001564 <ErrorHandler+0x4>

34001568 <LL_MEM_EnableClock>:
  *         @arg @ref LL_MEM_CACHEAXIRAM
  *         @arg @ref LL_MEM_VENCRAM
  * @retval None
  */
__STATIC_INLINE void LL_MEM_EnableClock(uint32_t Memories)
{
34001568:	b480      	push	{r7}
3400156a:	b085      	sub	sp, #20
3400156c:	af00      	add	r7, sp, #0
3400156e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->MEMENSR, Memories);
34001570:	4a07      	ldr	r2, [pc, #28]	@ (34001590 <LL_MEM_EnableClock+0x28>)
34001572:	687b      	ldr	r3, [r7, #4]
34001574:	f8c2 3a4c 	str.w	r3, [r2, #2636]	@ 0xa4c
  /* Delay after an RCC memories clock enabling */
  tmpreg = READ_REG(RCC->MEMENR);
34001578:	4b05      	ldr	r3, [pc, #20]	@ (34001590 <LL_MEM_EnableClock+0x28>)
3400157a:	f8d3 324c 	ldr.w	r3, [r3, #588]	@ 0x24c
3400157e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34001580:	68fb      	ldr	r3, [r7, #12]
}
34001582:	bf00      	nop
34001584:	3714      	adds	r7, #20
34001586:	46bd      	mov	sp, r7
34001588:	f85d 7b04 	ldr.w	r7, [sp], #4
3400158c:	4770      	bx	lr
3400158e:	bf00      	nop
34001590:	56028000 	.word	0x56028000

34001594 <LL_MEM_EnableClockLowPower>:
  *         @arg @ref LL_MEM_CACHEAXIRAM
  *         @arg @ref LL_MEM_VENCRAM
  * @retval None
  */
__STATIC_INLINE void LL_MEM_EnableClockLowPower(uint32_t Memories)
{
34001594:	b480      	push	{r7}
34001596:	b085      	sub	sp, #20
34001598:	af00      	add	r7, sp, #0
3400159a:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->MEMLPENSR, Memories);
3400159c:	4a07      	ldr	r2, [pc, #28]	@ (340015bc <LL_MEM_EnableClockLowPower+0x28>)
3400159e:	687b      	ldr	r3, [r7, #4]
340015a0:	f8c2 3a8c 	str.w	r3, [r2, #2700]	@ 0xa8c
  /* Delay after an RCC memories clock enabling */
  tmpreg = READ_REG(RCC->MEMLPENR);
340015a4:	4b05      	ldr	r3, [pc, #20]	@ (340015bc <LL_MEM_EnableClockLowPower+0x28>)
340015a6:	f8d3 328c 	ldr.w	r3, [r3, #652]	@ 0x28c
340015aa:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
340015ac:	68fb      	ldr	r3, [r7, #12]
}
340015ae:	bf00      	nop
340015b0:	3714      	adds	r7, #20
340015b2:	46bd      	mov	sp, r7
340015b4:	f85d 7b04 	ldr.w	r7, [sp], #4
340015b8:	4770      	bx	lr
340015ba:	bf00      	nop
340015bc:	56028000 	.word	0x56028000

340015c0 <LL_AHB2_GRP1_EnableClock>:
  *         @arg @ref LL_AHB2_GRP1_PERIPH_MDF1
  *         @arg @ref LL_AHB2_GRP1_PERIPH_ADF1
  * @retval None
  */
__STATIC_INLINE void LL_AHB2_GRP1_EnableClock(uint32_t Periphs)
{
340015c0:	b480      	push	{r7}
340015c2:	b085      	sub	sp, #20
340015c4:	af00      	add	r7, sp, #0
340015c6:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB2ENSR, Periphs);
340015c8:	4a07      	ldr	r2, [pc, #28]	@ (340015e8 <LL_AHB2_GRP1_EnableClock+0x28>)
340015ca:	687b      	ldr	r3, [r7, #4]
340015cc:	f8c2 3a54 	str.w	r3, [r2, #2644]	@ 0xa54
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB2ENR);
340015d0:	4b05      	ldr	r3, [pc, #20]	@ (340015e8 <LL_AHB2_GRP1_EnableClock+0x28>)
340015d2:	f8d3 3254 	ldr.w	r3, [r3, #596]	@ 0x254
340015d6:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
340015d8:	68fb      	ldr	r3, [r7, #12]
}
340015da:	bf00      	nop
340015dc:	3714      	adds	r7, #20
340015de:	46bd      	mov	sp, r7
340015e0:	f85d 7b04 	ldr.w	r7, [sp], #4
340015e4:	4770      	bx	lr
340015e6:	bf00      	nop
340015e8:	56028000 	.word	0x56028000

340015ec <LL_AHB3_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB3_GRP1_EnableClock(uint32_t Periphs)
{
340015ec:	b480      	push	{r7}
340015ee:	b085      	sub	sp, #20
340015f0:	af00      	add	r7, sp, #0
340015f2:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB3ENSR, Periphs);
340015f4:	4a07      	ldr	r2, [pc, #28]	@ (34001614 <LL_AHB3_GRP1_EnableClock+0x28>)
340015f6:	687b      	ldr	r3, [r7, #4]
340015f8:	f8c2 3a58 	str.w	r3, [r2, #2648]	@ 0xa58
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB3ENR);
340015fc:	4b05      	ldr	r3, [pc, #20]	@ (34001614 <LL_AHB3_GRP1_EnableClock+0x28>)
340015fe:	f8d3 3258 	ldr.w	r3, [r3, #600]	@ 0x258
34001602:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34001604:	68fb      	ldr	r3, [r7, #12]
}
34001606:	bf00      	nop
34001608:	3714      	adds	r7, #20
3400160a:	46bd      	mov	sp, r7
3400160c:	f85d 7b04 	ldr.w	r7, [sp], #4
34001610:	4770      	bx	lr
34001612:	bf00      	nop
34001614:	56028000 	.word	0x56028000

34001618 <LL_AHB3_GRP1_ForceReset>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB3_GRP1_ForceReset(uint32_t Periphs)
{
34001618:	b480      	push	{r7}
3400161a:	b083      	sub	sp, #12
3400161c:	af00      	add	r7, sp, #0
3400161e:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB3RSTSR, Periphs);
34001620:	4a04      	ldr	r2, [pc, #16]	@ (34001634 <LL_AHB3_GRP1_ForceReset+0x1c>)
34001622:	687b      	ldr	r3, [r7, #4]
34001624:	f8c2 3a18 	str.w	r3, [r2, #2584]	@ 0xa18
}
34001628:	bf00      	nop
3400162a:	370c      	adds	r7, #12
3400162c:	46bd      	mov	sp, r7
3400162e:	f85d 7b04 	ldr.w	r7, [sp], #4
34001632:	4770      	bx	lr
34001634:	56028000 	.word	0x56028000

34001638 <LL_AHB3_GRP1_ReleaseReset>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB3_GRP1_ReleaseReset(uint32_t Periphs)
{
34001638:	b480      	push	{r7}
3400163a:	b083      	sub	sp, #12
3400163c:	af00      	add	r7, sp, #0
3400163e:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB3RSTCR, Periphs);
34001640:	4b06      	ldr	r3, [pc, #24]	@ (3400165c <LL_AHB3_GRP1_ReleaseReset+0x24>)
34001642:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34001646:	461a      	mov	r2, r3
34001648:	687b      	ldr	r3, [r7, #4]
3400164a:	f8c2 3218 	str.w	r3, [r2, #536]	@ 0x218
}
3400164e:	bf00      	nop
34001650:	370c      	adds	r7, #12
34001652:	46bd      	mov	sp, r7
34001654:	f85d 7b04 	ldr.w	r7, [sp], #4
34001658:	4770      	bx	lr
3400165a:	bf00      	nop
3400165c:	56028000 	.word	0x56028000

34001660 <LL_AHB5_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_EnableClock(uint32_t Periphs)
{
34001660:	b480      	push	{r7}
34001662:	b085      	sub	sp, #20
34001664:	af00      	add	r7, sp, #0
34001666:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34001668:	4a07      	ldr	r2, [pc, #28]	@ (34001688 <LL_AHB5_GRP1_EnableClock+0x28>)
3400166a:	687b      	ldr	r3, [r7, #4]
3400166c:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB5ENR);
34001670:	4b05      	ldr	r3, [pc, #20]	@ (34001688 <LL_AHB5_GRP1_EnableClock+0x28>)
34001672:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
34001676:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34001678:	68fb      	ldr	r3, [r7, #12]
}
3400167a:	bf00      	nop
3400167c:	3714      	adds	r7, #20
3400167e:	46bd      	mov	sp, r7
34001680:	f85d 7b04 	ldr.w	r7, [sp], #4
34001684:	4770      	bx	lr
34001686:	bf00      	nop
34001688:	56028000 	.word	0x56028000

3400168c <LL_AHB5_GRP1_ForceReset>:
  *         @arg @ref LL_AHB5_GRP1_PERIPH_CACHEAXI
  *         @arg @ref LL_AHB5_GRP1_PERIPH_NPU
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_ForceReset(uint32_t Periphs)
{
3400168c:	b480      	push	{r7}
3400168e:	b083      	sub	sp, #12
34001690:	af00      	add	r7, sp, #0
34001692:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34001694:	4a04      	ldr	r2, [pc, #16]	@ (340016a8 <LL_AHB5_GRP1_ForceReset+0x1c>)
34001696:	687b      	ldr	r3, [r7, #4]
34001698:	f8c2 3a20 	str.w	r3, [r2, #2592]	@ 0xa20
}
3400169c:	bf00      	nop
3400169e:	370c      	adds	r7, #12
340016a0:	46bd      	mov	sp, r7
340016a2:	f85d 7b04 	ldr.w	r7, [sp], #4
340016a6:	4770      	bx	lr
340016a8:	56028000 	.word	0x56028000

340016ac <LL_AHB5_GRP1_ReleaseReset>:
  *         @arg @ref LL_AHB5_GRP1_PERIPH_CACHEAXI
  *         @arg @ref LL_AHB5_GRP1_PERIPH_NPU
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_ReleaseReset(uint32_t Periphs)
{
340016ac:	b480      	push	{r7}
340016ae:	b083      	sub	sp, #12
340016b0:	af00      	add	r7, sp, #0
340016b2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
340016b4:	4b06      	ldr	r3, [pc, #24]	@ (340016d0 <LL_AHB5_GRP1_ReleaseReset+0x24>)
340016b6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
340016ba:	461a      	mov	r2, r3
340016bc:	687b      	ldr	r3, [r7, #4]
340016be:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220
}
340016c2:	bf00      	nop
340016c4:	370c      	adds	r7, #12
340016c6:	46bd      	mov	sp, r7
340016c8:	f85d 7b04 	ldr.w	r7, [sp], #4
340016cc:	4770      	bx	lr
340016ce:	bf00      	nop
340016d0:	56028000 	.word	0x56028000

340016d4 <LL_AHB5_GRP1_EnableClockLowPower>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_EnableClockLowPower(uint32_t Periphs)
{
340016d4:	b480      	push	{r7}
340016d6:	b085      	sub	sp, #20
340016d8:	af00      	add	r7, sp, #0
340016da:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB5LPENSR, Periphs);
340016dc:	4a07      	ldr	r2, [pc, #28]	@ (340016fc <LL_AHB5_GRP1_EnableClockLowPower+0x28>)
340016de:	687b      	ldr	r3, [r7, #4]
340016e0:	f8c2 3aa0 	str.w	r3, [r2, #2720]	@ 0xaa0
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB5LPENR);
340016e4:	4b05      	ldr	r3, [pc, #20]	@ (340016fc <LL_AHB5_GRP1_EnableClockLowPower+0x28>)
340016e6:	f8d3 32a0 	ldr.w	r3, [r3, #672]	@ 0x2a0
340016ea:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
340016ec:	68fb      	ldr	r3, [r7, #12]
}
340016ee:	bf00      	nop
340016f0:	3714      	adds	r7, #20
340016f2:	46bd      	mov	sp, r7
340016f4:	f85d 7b04 	ldr.w	r7, [sp], #4
340016f8:	4770      	bx	lr
340016fa:	bf00      	nop
340016fc:	56028000 	.word	0x56028000

34001700 <LL_APB2_GRP1_EnableClock>:
  *         @arg @ref LL_APB2_GRP1_PERIPH_UART9
  *         @arg @ref LL_APB2_GRP1_PERIPH_USART10
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
34001700:	b480      	push	{r7}
34001702:	b085      	sub	sp, #20
34001704:	af00      	add	r7, sp, #0
34001706:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB2ENSR, Periphs);
34001708:	4a07      	ldr	r2, [pc, #28]	@ (34001728 <LL_APB2_GRP1_EnableClock+0x28>)
3400170a:	687b      	ldr	r3, [r7, #4]
3400170c:	f8c2 3a6c 	str.w	r3, [r2, #2668]	@ 0xa6c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB2ENR);
34001710:	4b05      	ldr	r3, [pc, #20]	@ (34001728 <LL_APB2_GRP1_EnableClock+0x28>)
34001712:	f8d3 326c 	ldr.w	r3, [r3, #620]	@ 0x26c
34001716:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34001718:	68fb      	ldr	r3, [r7, #12]
}
3400171a:	bf00      	nop
3400171c:	3714      	adds	r7, #20
3400171e:	46bd      	mov	sp, r7
34001720:	f85d 7b04 	ldr.w	r7, [sp], #4
34001724:	4770      	bx	lr
34001726:	bf00      	nop
34001728:	56028000 	.word	0x56028000

3400172c <LL_APB5_GRP1_EnableClockLowPower>:
  *         @arg @ref LL_APB5_GRP1_PERIPH_LTDC
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_EnableClockLowPower(uint32_t Periphs)
{
3400172c:	b480      	push	{r7}
3400172e:	b085      	sub	sp, #20
34001730:	af00      	add	r7, sp, #0
34001732:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB5LPENSR, Periphs);
34001734:	4a07      	ldr	r2, [pc, #28]	@ (34001754 <LL_APB5_GRP1_EnableClockLowPower+0x28>)
34001736:	687b      	ldr	r3, [r7, #4]
34001738:	f8c2 3abc 	str.w	r3, [r2, #2748]	@ 0xabc
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB5LPENR);
3400173c:	4b05      	ldr	r3, [pc, #20]	@ (34001754 <LL_APB5_GRP1_EnableClockLowPower+0x28>)
3400173e:	f8d3 32bc 	ldr.w	r3, [r3, #700]	@ 0x2bc
34001742:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34001744:	68fb      	ldr	r3, [r7, #12]
}
34001746:	bf00      	nop
34001748:	3714      	adds	r7, #20
3400174a:	46bd      	mov	sp, r7
3400174c:	f85d 7b04 	ldr.w	r7, [sp], #4
34001750:	4770      	bx	lr
34001752:	bf00      	nop
34001754:	56028000 	.word	0x56028000

34001758 <LL_RCC_SetCpuClkSource>:
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_HSE
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_IC1
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetCpuClkSource(uint32_t Source)
{
34001758:	b480      	push	{r7}
3400175a:	b083      	sub	sp, #12
3400175c:	af00      	add	r7, sp, #0
3400175e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, Source);
34001760:	4b06      	ldr	r3, [pc, #24]	@ (3400177c <LL_RCC_SetCpuClkSource+0x24>)
34001762:	6a1b      	ldr	r3, [r3, #32]
34001764:	f423 3240 	bic.w	r2, r3, #196608	@ 0x30000
34001768:	4904      	ldr	r1, [pc, #16]	@ (3400177c <LL_RCC_SetCpuClkSource+0x24>)
3400176a:	687b      	ldr	r3, [r7, #4]
3400176c:	4313      	orrs	r3, r2
3400176e:	620b      	str	r3, [r1, #32]
}
34001770:	bf00      	nop
34001772:	370c      	adds	r7, #12
34001774:	46bd      	mov	sp, r7
34001776:	f85d 7b04 	ldr.w	r7, [sp], #4
3400177a:	4770      	bx	lr
3400177c:	56028000 	.word	0x56028000

34001780 <LL_RCC_SetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_HSE
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_IC2_IC6_IC11
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetSysClkSource(uint32_t Source)
{
34001780:	b480      	push	{r7}
34001782:	b083      	sub	sp, #12
34001784:	af00      	add	r7, sp, #0
34001786:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, Source);
34001788:	4b06      	ldr	r3, [pc, #24]	@ (340017a4 <LL_RCC_SetSysClkSource+0x24>)
3400178a:	6a1b      	ldr	r3, [r3, #32]
3400178c:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
34001790:	4904      	ldr	r1, [pc, #16]	@ (340017a4 <LL_RCC_SetSysClkSource+0x24>)
34001792:	687b      	ldr	r3, [r7, #4]
34001794:	4313      	orrs	r3, r2
34001796:	620b      	str	r3, [r1, #32]
}
34001798:	bf00      	nop
3400179a:	370c      	adds	r7, #12
3400179c:	46bd      	mov	sp, r7
3400179e:	f85d 7b04 	ldr.w	r7, [sp], #4
340017a2:	4770      	bx	lr
340017a4:	56028000 	.word	0x56028000

340017a8 <enableTiming_Cyc>:
int NPU_MatMul_int8(size_t insize,size_t outsize);
int NPU_MatMul_float(size_t insize,size_t outsize);
int ARM_MatMul_int8(size_t insize,size_t outsize);
int ARM_MatMul_float(size_t insize,size_t outsize);

void enableTiming_Cyc(void){
340017a8:	b480      	push	{r7}
340017aa:	af00      	add	r7, sp, #0
	CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
340017ac:	4b08      	ldr	r3, [pc, #32]	@ (340017d0 <enableTiming_Cyc+0x28>)
340017ae:	68db      	ldr	r3, [r3, #12]
340017b0:	4a07      	ldr	r2, [pc, #28]	@ (340017d0 <enableTiming_Cyc+0x28>)
340017b2:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
340017b6:	60d3      	str	r3, [r2, #12]
	DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;  // Enable cycle counter
340017b8:	4b06      	ldr	r3, [pc, #24]	@ (340017d4 <enableTiming_Cyc+0x2c>)
340017ba:	681b      	ldr	r3, [r3, #0]
340017bc:	4a05      	ldr	r2, [pc, #20]	@ (340017d4 <enableTiming_Cyc+0x2c>)
340017be:	f043 0301 	orr.w	r3, r3, #1
340017c2:	6013      	str	r3, [r2, #0]
}
340017c4:	bf00      	nop
340017c6:	46bd      	mov	sp, r7
340017c8:	f85d 7b04 	ldr.w	r7, [sp], #4
340017cc:	4770      	bx	lr
340017ce:	bf00      	nop
340017d0:	e000edf0 	.word	0xe000edf0
340017d4:	e0001000 	.word	0xe0001000

340017d8 <startTiming_Cyc>:

void startTiming_Cyc(void){
340017d8:	b480      	push	{r7}
340017da:	af00      	add	r7, sp, #0
	DWT->CYCCNT = 0; // Reset counter
340017dc:	4b03      	ldr	r3, [pc, #12]	@ (340017ec <startTiming_Cyc+0x14>)
340017de:	2200      	movs	r2, #0
340017e0:	605a      	str	r2, [r3, #4]
}
340017e2:	bf00      	nop
340017e4:	46bd      	mov	sp, r7
340017e6:	f85d 7b04 	ldr.w	r7, [sp], #4
340017ea:	4770      	bx	lr
340017ec:	e0001000 	.word	0xe0001000

340017f0 <getTiming_Cyc>:

uint32_t getTiming_Cyc(){
340017f0:	b480      	push	{r7}
340017f2:	b083      	sub	sp, #12
340017f4:	af00      	add	r7, sp, #0
	uint32_t cycles = DWT->CYCCNT;
340017f6:	4b05      	ldr	r3, [pc, #20]	@ (3400180c <getTiming_Cyc+0x1c>)
340017f8:	685b      	ldr	r3, [r3, #4]
340017fa:	607b      	str	r3, [r7, #4]
	return cycles;
340017fc:	687b      	ldr	r3, [r7, #4]
}
340017fe:	4618      	mov	r0, r3
34001800:	370c      	adds	r7, #12
34001802:	46bd      	mov	sp, r7
34001804:	f85d 7b04 	ldr.w	r7, [sp], #4
34001808:	4770      	bx	lr
3400180a:	bf00      	nop
3400180c:	e0001000 	.word	0xe0001000

34001810 <main>:

int main(void)
{
34001810:	b580      	push	{r7, lr}
34001812:	af00      	add	r7, sp, #0
	Hardware_init();
34001814:	f000 f95c 	bl	34001ad0 <Hardware_init>
	enableTiming_Cyc();
34001818:	f7ff ffc6 	bl	340017a8 <enableTiming_Cyc>
	preformanceMeasurment_int8();
3400181c:	f000 f86c 	bl	340018f8 <preformanceMeasurment_int8>
34001820:	2300      	movs	r3, #0
//	tiledMatVec();

}
34001822:	4618      	mov	r0, r3
34001824:	bd80      	pop	{r7, pc}
	...

34001828 <tiledMatVec>:
	printVector_int8("DFT Real:",outReal,N);
	printVector_int8("DFT Imag:",outImag,N);
}


int tiledMatVec(size_t insize,size_t outsize){
34001828:	e92d 4f90 	stmdb	sp!, {r4, r7, r8, r9, sl, fp, lr}
3400182c:	b091      	sub	sp, #68	@ 0x44
3400182e:	af02      	add	r7, sp, #8
34001830:	6178      	str	r0, [r7, #20]
34001832:	6139      	str	r1, [r7, #16]
34001834:	466b      	mov	r3, sp
34001836:	461c      	mov	r4, r3
    int8_t inVec[insize];
34001838:	697b      	ldr	r3, [r7, #20]
3400183a:	461a      	mov	r2, r3
3400183c:	3a01      	subs	r2, #1
3400183e:	633a      	str	r2, [r7, #48]	@ 0x30
34001840:	2200      	movs	r2, #0
34001842:	60bb      	str	r3, [r7, #8]
34001844:	60fa      	str	r2, [r7, #12]
34001846:	2200      	movs	r2, #0
34001848:	603b      	str	r3, [r7, #0]
3400184a:	607a      	str	r2, [r7, #4]
3400184c:	3307      	adds	r3, #7
3400184e:	08db      	lsrs	r3, r3, #3
34001850:	00db      	lsls	r3, r3, #3
34001852:	ebad 0d03 	sub.w	sp, sp, r3
34001856:	ab02      	add	r3, sp, #8
34001858:	3300      	adds	r3, #0
3400185a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    int8_t outVec[outsize];
3400185c:	693b      	ldr	r3, [r7, #16]
3400185e:	461a      	mov	r2, r3
34001860:	3a01      	subs	r2, #1
34001862:	62ba      	str	r2, [r7, #40]	@ 0x28
34001864:	2200      	movs	r2, #0
34001866:	469a      	mov	sl, r3
34001868:	4693      	mov	fp, r2
3400186a:	2200      	movs	r2, #0
3400186c:	4698      	mov	r8, r3
3400186e:	4691      	mov	r9, r2
34001870:	3307      	adds	r3, #7
34001872:	08db      	lsrs	r3, r3, #3
34001874:	00db      	lsls	r3, r3, #3
34001876:	ebad 0d03 	sub.w	sp, sp, r3
3400187a:	ab02      	add	r3, sp, #8
3400187c:	3300      	adds	r3, #0
3400187e:	627b      	str	r3, [r7, #36]	@ 0x24

    printf("Tiled MatVec Size: %4d\n\r",insize);
34001880:	6979      	ldr	r1, [r7, #20]
34001882:	481b      	ldr	r0, [pc, #108]	@ (340018f0 <tiledMatVec+0xc8>)
34001884:	f01a fe4a 	bl	3401c51c <iprintf>
    for (int i = 0; i < insize; i++) {
34001888:	2300      	movs	r3, #0
3400188a:	637b      	str	r3, [r7, #52]	@ 0x34
3400188c:	e00e      	b.n	340018ac <tiledMatVec+0x84>
    	inVec[i] = (int8_t)((i) % 256);  // Example input: cycles through -128 to 127
3400188e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34001890:	425a      	negs	r2, r3
34001892:	b2db      	uxtb	r3, r3
34001894:	b2d2      	uxtb	r2, r2
34001896:	ea53 b342 			@ <UNDEFINED> instruction: 0xea53b342
3400189a:	b259      	sxtb	r1, r3
3400189c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3400189e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
340018a0:	4413      	add	r3, r2
340018a2:	460a      	mov	r2, r1
340018a4:	701a      	strb	r2, [r3, #0]
    for (int i = 0; i < insize; i++) {
340018a6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
340018a8:	3301      	adds	r3, #1
340018aa:	637b      	str	r3, [r7, #52]	@ 0x34
340018ac:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
340018ae:	697a      	ldr	r2, [r7, #20]
340018b0:	429a      	cmp	r2, r3
340018b2:	d8ec      	bhi.n	3400188e <tiledMatVec+0x66>
    }

    int8_t* identityWeights = getIdentityWeights_int8(insize,outsize);
340018b4:	6939      	ldr	r1, [r7, #16]
340018b6:	6978      	ldr	r0, [r7, #20]
340018b8:	f7ff f982 	bl	34000bc0 <getIdentityWeights_int8>
340018bc:	6238      	str	r0, [r7, #32]
	startTiming_Cyc();
340018be:	f7ff ff8b 	bl	340017d8 <startTiming_Cyc>
	npu_tiledmatvec_int8(inVec,insize,outVec,outsize,identityWeights);
340018c2:	6a3b      	ldr	r3, [r7, #32]
340018c4:	9300      	str	r3, [sp, #0]
340018c6:	693b      	ldr	r3, [r7, #16]
340018c8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
340018ca:	6979      	ldr	r1, [r7, #20]
340018cc:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
340018ce:	f7ff f9b1 	bl	34000c34 <npu_tiledmatvec_int8>
	uint32_t cycles = getTiming_Cyc();
340018d2:	f7ff ff8d 	bl	340017f0 <getTiming_Cyc>
340018d6:	61f8      	str	r0, [r7, #28]
	printf("Cycles Tiled MatVec: %4d\n\r", cycles);
340018d8:	69f9      	ldr	r1, [r7, #28]
340018da:	4806      	ldr	r0, [pc, #24]	@ (340018f4 <tiledMatVec+0xcc>)
340018dc:	f01a fe1e 	bl	3401c51c <iprintf>
340018e0:	46a5      	mov	sp, r4
//	for(size_t i = 0;i < outsize;i++){
//		float output = outVec[i];
//		printf("Output %2d: %4.0f\n\r",i,output);
//	}

}
340018e2:	bf00      	nop
340018e4:	4618      	mov	r0, r3
340018e6:	373c      	adds	r7, #60	@ 0x3c
340018e8:	46bd      	mov	sp, r7
340018ea:	e8bd 8f90 	ldmia.w	sp!, {r4, r7, r8, r9, sl, fp, pc}
340018ee:	bf00      	nop
340018f0:	3401e6b8 	.word	0x3401e6b8
340018f4:	3401e6d4 	.word	0x3401e6d4

340018f8 <preformanceMeasurment_int8>:


int preformanceMeasurment_int8(void){
340018f8:	b580      	push	{r7, lr}
340018fa:	b084      	sub	sp, #16
340018fc:	af00      	add	r7, sp, #0
	size_t insize = 64;
340018fe:	2340      	movs	r3, #64	@ 0x40
34001900:	60bb      	str	r3, [r7, #8]
	size_t outsize = 64;
34001902:	2340      	movs	r3, #64	@ 0x40
34001904:	607b      	str	r3, [r7, #4]
	size_t base = 16;
34001906:	2310      	movs	r3, #16
34001908:	603b      	str	r3, [r7, #0]
	for(int i  = 0; i< 7;i++){
3400190a:	2300      	movs	r3, #0
3400190c:	60fb      	str	r3, [r7, #12]
3400190e:	e01b      	b.n	34001948 <preformanceMeasurment_int8+0x50>

		insize  = base << i;
34001910:	683a      	ldr	r2, [r7, #0]
34001912:	68fb      	ldr	r3, [r7, #12]
34001914:	fa02 f303 	lsl.w	r3, r2, r3
34001918:	60bb      	str	r3, [r7, #8]
		outsize = base << i;
3400191a:	683a      	ldr	r2, [r7, #0]
3400191c:	68fb      	ldr	r3, [r7, #12]
3400191e:	fa02 f303 	lsl.w	r3, r2, r3
34001922:	607b      	str	r3, [r7, #4]
		printf("========");
34001924:	480c      	ldr	r0, [pc, #48]	@ (34001958 <preformanceMeasurment_int8+0x60>)
34001926:	f01a fdf9 	bl	3401c51c <iprintf>
		printf("Size: %4d\n\r",insize);
3400192a:	68b9      	ldr	r1, [r7, #8]
3400192c:	480b      	ldr	r0, [pc, #44]	@ (3400195c <preformanceMeasurment_int8+0x64>)
3400192e:	f01a fdf5 	bl	3401c51c <iprintf>
		ARM_MatMul_int8(insize,outsize);
34001932:	6879      	ldr	r1, [r7, #4]
34001934:	68b8      	ldr	r0, [r7, #8]
34001936:	f000 f813 	bl	34001960 <ARM_MatMul_int8>
//		NPU_MatMul_int8(insize,outsize);
		tiledMatVec(insize,outsize);
3400193a:	6879      	ldr	r1, [r7, #4]
3400193c:	68b8      	ldr	r0, [r7, #8]
3400193e:	f7ff ff73 	bl	34001828 <tiledMatVec>
	for(int i  = 0; i< 7;i++){
34001942:	68fb      	ldr	r3, [r7, #12]
34001944:	3301      	adds	r3, #1
34001946:	60fb      	str	r3, [r7, #12]
34001948:	68fb      	ldr	r3, [r7, #12]
3400194a:	2b06      	cmp	r3, #6
3400194c:	dde0      	ble.n	34001910 <preformanceMeasurment_int8+0x18>
//		ARM_MatMul_float(insize,outsize);
//		NPU_MatMul_float(insize,outsize);
	}
}
3400194e:	bf00      	nop
34001950:	4618      	mov	r0, r3
34001952:	3710      	adds	r7, #16
34001954:	46bd      	mov	sp, r7
34001956:	bd80      	pop	{r7, pc}
34001958:	3401e6f0 	.word	0x3401e6f0
3400195c:	3401e6fc 	.word	0x3401e6fc

34001960 <ARM_MatMul_int8>:
//	}
	free(identityWeights);
}


int ARM_MatMul_int8(size_t insize,size_t outsize) {
34001960:	e92d 4f90 	stmdb	sp!, {r4, r7, r8, r9, sl, fp, lr}
34001964:	b091      	sub	sp, #68	@ 0x44
34001966:	af02      	add	r7, sp, #8
34001968:	6178      	str	r0, [r7, #20]
3400196a:	6139      	str	r1, [r7, #16]
3400196c:	466b      	mov	r3, sp
3400196e:	461c      	mov	r4, r3

    int8_t inVec[insize];
34001970:	697b      	ldr	r3, [r7, #20]
34001972:	461a      	mov	r2, r3
34001974:	3a01      	subs	r2, #1
34001976:	633a      	str	r2, [r7, #48]	@ 0x30
34001978:	2200      	movs	r2, #0
3400197a:	60bb      	str	r3, [r7, #8]
3400197c:	60fa      	str	r2, [r7, #12]
3400197e:	2200      	movs	r2, #0
34001980:	603b      	str	r3, [r7, #0]
34001982:	607a      	str	r2, [r7, #4]
34001984:	3307      	adds	r3, #7
34001986:	08db      	lsrs	r3, r3, #3
34001988:	00db      	lsls	r3, r3, #3
3400198a:	ebad 0d03 	sub.w	sp, sp, r3
3400198e:	ab02      	add	r3, sp, #8
34001990:	3300      	adds	r3, #0
34001992:	62fb      	str	r3, [r7, #44]	@ 0x2c
    for (int i = 0; i < insize; i++) {
34001994:	2300      	movs	r3, #0
34001996:	637b      	str	r3, [r7, #52]	@ 0x34
34001998:	e009      	b.n	340019ae <ARM_MatMul_int8+0x4e>
    	inVec[i] = (int8_t)(i);  // e.g., 0, 16, 32, ..., 112
3400199a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3400199c:	b259      	sxtb	r1, r3
3400199e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
340019a0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
340019a2:	4413      	add	r3, r2
340019a4:	460a      	mov	r2, r1
340019a6:	701a      	strb	r2, [r3, #0]
    for (int i = 0; i < insize; i++) {
340019a8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
340019aa:	3301      	adds	r3, #1
340019ac:	637b      	str	r3, [r7, #52]	@ 0x34
340019ae:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
340019b0:	697a      	ldr	r2, [r7, #20]
340019b2:	429a      	cmp	r2, r3
340019b4:	d8f1      	bhi.n	3400199a <ARM_MatMul_int8+0x3a>
    	}
    int32_t outVec[outsize];
340019b6:	693b      	ldr	r3, [r7, #16]
340019b8:	461a      	mov	r2, r3
340019ba:	3a01      	subs	r2, #1
340019bc:	62ba      	str	r2, [r7, #40]	@ 0x28
340019be:	2200      	movs	r2, #0
340019c0:	469a      	mov	sl, r3
340019c2:	4693      	mov	fp, r2
340019c4:	2200      	movs	r2, #0
340019c6:	4698      	mov	r8, r3
340019c8:	4691      	mov	r9, r2
340019ca:	009b      	lsls	r3, r3, #2
340019cc:	3307      	adds	r3, #7
340019ce:	08db      	lsrs	r3, r3, #3
340019d0:	00db      	lsls	r3, r3, #3
340019d2:	ebad 0d03 	sub.w	sp, sp, r3
340019d6:	ab02      	add	r3, sp, #8
340019d8:	3303      	adds	r3, #3
340019da:	089b      	lsrs	r3, r3, #2
340019dc:	009b      	lsls	r3, r3, #2
340019de:	627b      	str	r3, [r7, #36]	@ 0x24

    // Identity weight matrix
    int8_t* identityWeights = getIdentityWeights_int8(insize, outsize);
340019e0:	6939      	ldr	r1, [r7, #16]
340019e2:	6978      	ldr	r0, [r7, #20]
340019e4:	f7ff f8ec 	bl	34000bc0 <getIdentityWeights_int8>
340019e8:	6238      	str	r0, [r7, #32]

    if (!identityWeights) {
340019ea:	6a3b      	ldr	r3, [r7, #32]
340019ec:	2b00      	cmp	r3, #0
340019ee:	d105      	bne.n	340019fc <ARM_MatMul_int8+0x9c>
        printf("Memory allocation failed\n");
340019f0:	4817      	ldr	r0, [pc, #92]	@ (34001a50 <ARM_MatMul_int8+0xf0>)
340019f2:	f01a fdfb 	bl	3401c5ec <puts>
        return -1;
340019f6:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
340019fa:	e023      	b.n	34001a44 <ARM_MatMul_int8+0xe4>
//    }
//    printf("\n\r");

//    while(1){
		// Start benchmarking
    	startTiming_Cyc();
340019fc:	f7ff feec 	bl	340017d8 <startTiming_Cyc>
    	simd_matrix_vector_mul_int8(identityWeights,inVec,outVec,outsize,insize);
34001a00:	697b      	ldr	r3, [r7, #20]
34001a02:	9300      	str	r3, [sp, #0]
34001a04:	693b      	ldr	r3, [r7, #16]
34001a06:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34001a08:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
34001a0a:	6a38      	ldr	r0, [r7, #32]
34001a0c:	f016 fba2 	bl	34018154 <simd_matrix_vector_mul_int8>
		uint32_t cycles = getTiming_Cyc();
34001a10:	f7ff feee 	bl	340017f0 <getTiming_Cyc>
34001a14:	61f8      	str	r0, [r7, #28]

//		printf("Output MatVec ARM\n\r");
		printf("Cycles ARM int8: %6d\n\r", cycles);
34001a16:	69f9      	ldr	r1, [r7, #28]
34001a18:	480e      	ldr	r0, [pc, #56]	@ (34001a54 <ARM_MatMul_int8+0xf4>)
34001a1a:	f01a fd7f 	bl	3401c51c <iprintf>
//		for(int i = 0; i < outsize; i++){
//			printf("Output[%d]: %4d\n\r",i,outVec[i]);
//		}
		startTiming_Cyc();
34001a1e:	f7ff fedb 	bl	340017d8 <startTiming_Cyc>
		controllOutput(inVec,identityWeights,insize,outsize);
34001a22:	693b      	ldr	r3, [r7, #16]
34001a24:	697a      	ldr	r2, [r7, #20]
34001a26:	6a39      	ldr	r1, [r7, #32]
34001a28:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
34001a2a:	f000 f817 	bl	34001a5c <controllOutput>
		cycles = getTiming_Cyc();
34001a2e:	f7ff fedf 	bl	340017f0 <getTiming_Cyc>
34001a32:	61f8      	str	r0, [r7, #28]
		printf("Cycles Controll CPU int8: %6d\n\r", cycles);
34001a34:	69f9      	ldr	r1, [r7, #28]
34001a36:	4808      	ldr	r0, [pc, #32]	@ (34001a58 <ARM_MatMul_int8+0xf8>)
34001a38:	f01a fd70 	bl	3401c51c <iprintf>
//    }
	free(identityWeights);
34001a3c:	6a38      	ldr	r0, [r7, #32]
34001a3e:	f019 feeb 	bl	3401b818 <free>
    return 0;
34001a42:	2300      	movs	r3, #0
34001a44:	46a5      	mov	sp, r4
}
34001a46:	4618      	mov	r0, r3
34001a48:	373c      	adds	r7, #60	@ 0x3c
34001a4a:	46bd      	mov	sp, r7
34001a4c:	e8bd 8f90 	ldmia.w	sp!, {r4, r7, r8, r9, sl, fp, pc}
34001a50:	3401e760 	.word	0x3401e760
34001a54:	3401e77c 	.word	0x3401e77c
34001a58:	3401e794 	.word	0x3401e794

34001a5c <controllOutput>:
//		setOutputZero(nn_out[0],nn_out_len[0]);

    }
}

void controllOutput(int8_t* in, int8_t* weights, size_t insize, size_t outsize) {
34001a5c:	b480      	push	{r7}
34001a5e:	b089      	sub	sp, #36	@ 0x24
34001a60:	af00      	add	r7, sp, #0
34001a62:	60f8      	str	r0, [r7, #12]
34001a64:	60b9      	str	r1, [r7, #8]
34001a66:	607a      	str	r2, [r7, #4]
34001a68:	603b      	str	r3, [r7, #0]
//    printf("Controll Output:\n\r ");
    for (size_t i = 0; i < outsize; i++) {  // Iterate over output size
34001a6a:	2300      	movs	r3, #0
34001a6c:	61fb      	str	r3, [r7, #28]
34001a6e:	e023      	b.n	34001ab8 <controllOutput+0x5c>
        int32_t acc = 0;
34001a70:	2300      	movs	r3, #0
34001a72:	61bb      	str	r3, [r7, #24]
        for (size_t j = 0; j < insize; j++) {  // Iterate over input size
34001a74:	2300      	movs	r3, #0
34001a76:	617b      	str	r3, [r7, #20]
34001a78:	e017      	b.n	34001aaa <controllOutput+0x4e>
//        	printf("In: %3d, Weight: %3d\n\r",(int32_t)in[j],(int32_t)weights[i * outsize + j]);
            acc += in[j] * weights[i + outsize * j];  // Correct indexing
34001a7a:	68fa      	ldr	r2, [r7, #12]
34001a7c:	697b      	ldr	r3, [r7, #20]
34001a7e:	4413      	add	r3, r2
34001a80:	f993 3000 	ldrsb.w	r3, [r3]
34001a84:	4619      	mov	r1, r3
34001a86:	683b      	ldr	r3, [r7, #0]
34001a88:	697a      	ldr	r2, [r7, #20]
34001a8a:	fb03 f202 	mul.w	r2, r3, r2
34001a8e:	69fb      	ldr	r3, [r7, #28]
34001a90:	4413      	add	r3, r2
34001a92:	68ba      	ldr	r2, [r7, #8]
34001a94:	4413      	add	r3, r2
34001a96:	f993 3000 	ldrsb.w	r3, [r3]
34001a9a:	fb01 f303 	mul.w	r3, r1, r3
34001a9e:	69ba      	ldr	r2, [r7, #24]
34001aa0:	4413      	add	r3, r2
34001aa2:	61bb      	str	r3, [r7, #24]
        for (size_t j = 0; j < insize; j++) {  // Iterate over input size
34001aa4:	697b      	ldr	r3, [r7, #20]
34001aa6:	3301      	adds	r3, #1
34001aa8:	617b      	str	r3, [r7, #20]
34001aaa:	697a      	ldr	r2, [r7, #20]
34001aac:	687b      	ldr	r3, [r7, #4]
34001aae:	429a      	cmp	r2, r3
34001ab0:	d3e3      	bcc.n	34001a7a <controllOutput+0x1e>
    for (size_t i = 0; i < outsize; i++) {  // Iterate over output size
34001ab2:	69fb      	ldr	r3, [r7, #28]
34001ab4:	3301      	adds	r3, #1
34001ab6:	61fb      	str	r3, [r7, #28]
34001ab8:	69fa      	ldr	r2, [r7, #28]
34001aba:	683b      	ldr	r3, [r7, #0]
34001abc:	429a      	cmp	r2, r3
34001abe:	d3d7      	bcc.n	34001a70 <controllOutput+0x14>
        }
//        printf("%3d ", acc);  // Print the result as a 32-bit integer
    }
//    printf("\n\r");
}
34001ac0:	bf00      	nop
34001ac2:	bf00      	nop
34001ac4:	3724      	adds	r7, #36	@ 0x24
34001ac6:	46bd      	mov	sp, r7
34001ac8:	f85d 7b04 	ldr.w	r7, [sp], #4
34001acc:	4770      	bx	lr
	...

34001ad0 <Hardware_init>:
        printf("%3d: %4d\n\r",i, vec[i]);
    }
}

static void Hardware_init(void)
{
34001ad0:	b580      	push	{r7, lr}
34001ad2:	b086      	sub	sp, #24
34001ad4:	af00      	add	r7, sp, #0
  /* Power on ICACHE */
  MEMSYSCTL->MSCR |= MEMSYSCTL_MSCR_ICACTIVE_Msk;
34001ad6:	4b31      	ldr	r3, [pc, #196]	@ (34001b9c <Hardware_init+0xcc>)
34001ad8:	681b      	ldr	r3, [r3, #0]
34001ada:	4a30      	ldr	r2, [pc, #192]	@ (34001b9c <Hardware_init+0xcc>)
34001adc:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
34001ae0:	6013      	str	r3, [r2, #0]

  /* Set back system and CPU clock source to HSI */
  __HAL_RCC_CPUCLK_CONFIG(RCC_CPUCLKSOURCE_HSI);
34001ae2:	2000      	movs	r0, #0
34001ae4:	f7ff fe38 	bl	34001758 <LL_RCC_SetCpuClkSource>
  __HAL_RCC_SYSCLK_CONFIG(RCC_SYSCLKSOURCE_HSI);
34001ae8:	2000      	movs	r0, #0
34001aea:	f7ff fe49 	bl	34001780 <LL_RCC_SetSysClkSource>
  __HAL_RCC_USART1_CLK_ENABLE();
34001aee:	2010      	movs	r0, #16
34001af0:	f7ff fe06 	bl	34001700 <LL_APB2_GRP1_EnableClock>

  HAL_Init();
34001af4:	f002 fa48 	bl	34003f88 <HAL_Init>
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
34001af8:	4b29      	ldr	r3, [pc, #164]	@ (34001ba0 <Hardware_init+0xd0>)
34001afa:	695b      	ldr	r3, [r3, #20]
34001afc:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34001b00:	2b00      	cmp	r3, #0
34001b02:	d11b      	bne.n	34001b3c <Hardware_init+0x6c>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
34001b04:	f3bf 8f4f 	dsb	sy
}
34001b08:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34001b0a:	f3bf 8f6f 	isb	sy
}
34001b0e:	bf00      	nop

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
34001b10:	4b23      	ldr	r3, [pc, #140]	@ (34001ba0 <Hardware_init+0xd0>)
34001b12:	2200      	movs	r2, #0
34001b14:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
34001b18:	f3bf 8f4f 	dsb	sy
}
34001b1c:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34001b1e:	f3bf 8f6f 	isb	sy
}
34001b22:	bf00      	nop
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
34001b24:	4b1e      	ldr	r3, [pc, #120]	@ (34001ba0 <Hardware_init+0xd0>)
34001b26:	695b      	ldr	r3, [r3, #20]
34001b28:	4a1d      	ldr	r2, [pc, #116]	@ (34001ba0 <Hardware_init+0xd0>)
34001b2a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
34001b2e:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
34001b30:	f3bf 8f4f 	dsb	sy
}
34001b34:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34001b36:	f3bf 8f6f 	isb	sy
}
34001b3a:	e000      	b.n	34001b3e <Hardware_init+0x6e>
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
34001b3c:	bf00      	nop
#if defined(USE_DCACHE)
  MEMSYSCTL->MSCR |= MEMSYSCTL_MSCR_DCACTIVE_Msk;
  SCB_EnableDCache();
#endif

  SystemClock_Config();
34001b3e:	f000 f945 	bl	34001dcc <SystemClock_Config>

  NPURam_enable();
34001b42:	f000 f845 	bl	34001bd0 <NPURam_enable>
  Fuse_Programming();
34001b46:	f7ff fcc3 	bl	340014d0 <Fuse_Programming>
  NPUCache_config();
34001b4a:	f000 f8bc 	bl	34001cc6 <NPUCache_config>

  BSP_XSPI_NOR_Init_t NOR_Init;
  NOR_Init.InterfaceMode = BSP_XSPI_NOR_OPI_MODE;
34001b4e:	2301      	movs	r3, #1
34001b50:	753b      	strb	r3, [r7, #20]
  NOR_Init.TransferRate = BSP_XSPI_NOR_DTR_TRANSFER;
34001b52:	2301      	movs	r3, #1
34001b54:	757b      	strb	r3, [r7, #21]
  BSP_XSPI_NOR_Init(0, &NOR_Init);
34001b56:	f107 0314 	add.w	r3, r7, #20
34001b5a:	4619      	mov	r1, r3
34001b5c:	2000      	movs	r0, #0
34001b5e:	f001 f9b7 	bl	34002ed0 <BSP_XSPI_NOR_Init>
  BSP_XSPI_NOR_EnableMemoryMappedMode(0);
34001b62:	2000      	movs	r0, #0
34001b64:	f001 fa9a 	bl	3400309c <BSP_XSPI_NOR_EnableMemoryMappedMode>

  Security_Config();
34001b68:	f000 f8b6 	bl	34001cd8 <Security_Config>
  IAC_Config();
34001b6c:	f000 f91a 	bl	34001da4 <IAC_Config>
  set_clk_sleep_mode();
34001b70:	f000 f876 	bl	34001c60 <set_clk_sleep_mode>

  /*** Now initialize UART ***/
  COM_InitTypeDef com_config = {
34001b74:	f44f 33e1 	mov.w	r3, #115200	@ 0x1c200
34001b78:	607b      	str	r3, [r7, #4]
34001b7a:	2300      	movs	r3, #0
34001b7c:	60bb      	str	r3, [r7, #8]
34001b7e:	2300      	movs	r3, #0
34001b80:	81bb      	strh	r3, [r7, #12]
34001b82:	2300      	movs	r3, #0
34001b84:	81fb      	strh	r3, [r7, #14]
34001b86:	2300      	movs	r3, #0
34001b88:	823b      	strh	r3, [r7, #16]
    .WordLength = UART_WORDLENGTH_8B,
    .StopBits = UART_STOPBITS_1,
    .Parity = UART_PARITY_NONE,
    .HwFlowCtl = UART_HWCONTROL_NONE
  };
  BSP_COM_Init(COM1, &com_config);
34001b8a:	1d3b      	adds	r3, r7, #4
34001b8c:	4619      	mov	r1, r3
34001b8e:	2000      	movs	r0, #0
34001b90:	f001 f860 	bl	34002c54 <BSP_COM_Init>
}
34001b94:	bf00      	nop
34001b96:	3718      	adds	r7, #24
34001b98:	46bd      	mov	sp, r7
34001b9a:	bd80      	pop	{r7, pc}
34001b9c:	e001e000 	.word	0xe001e000
34001ba0:	e000ed00 	.word	0xe000ed00

34001ba4 <_write>:

int _write(int file, char *ptr, int len)
{
34001ba4:	b580      	push	{r7, lr}
34001ba6:	b084      	sub	sp, #16
34001ba8:	af00      	add	r7, sp, #0
34001baa:	60f8      	str	r0, [r7, #12]
34001bac:	60b9      	str	r1, [r7, #8]
34001bae:	607a      	str	r2, [r7, #4]
    HAL_UART_Transmit(&hcom_uart[COM1], (uint8_t *)ptr, len, HAL_MAX_DELAY);
34001bb0:	687b      	ldr	r3, [r7, #4]
34001bb2:	b29a      	uxth	r2, r3
34001bb4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
34001bb8:	68b9      	ldr	r1, [r7, #8]
34001bba:	4804      	ldr	r0, [pc, #16]	@ (34001bcc <_write+0x28>)
34001bbc:	f014 f97c 	bl	34015eb8 <HAL_UART_Transmit>
    return len;
34001bc0:	687b      	ldr	r3, [r7, #4]
}
34001bc2:	4618      	mov	r0, r3
34001bc4:	3710      	adds	r7, #16
34001bc6:	46bd      	mov	sp, r7
34001bc8:	bd80      	pop	{r7, pc}
34001bca:	bf00      	nop
34001bcc:	34020e80 	.word	0x34020e80

34001bd0 <NPURam_enable>:

static void NPURam_enable(void)
{
34001bd0:	b580      	push	{r7, lr}
34001bd2:	b084      	sub	sp, #16
34001bd4:	af00      	add	r7, sp, #0
  __HAL_RCC_NPU_CLK_ENABLE();
34001bd6:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
34001bda:	f7ff fd41 	bl	34001660 <LL_AHB5_GRP1_EnableClock>
  __HAL_RCC_NPU_FORCE_RESET();
34001bde:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
34001be2:	f7ff fd53 	bl	3400168c <LL_AHB5_GRP1_ForceReset>
  __HAL_RCC_NPU_RELEASE_RESET();
34001be6:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
34001bea:	f7ff fd5f 	bl	340016ac <LL_AHB5_GRP1_ReleaseReset>

  /* Enable NPU RAMs (4x448KB) */
  __HAL_RCC_AXISRAM3_MEM_CLK_ENABLE();
34001bee:	2001      	movs	r0, #1
34001bf0:	f7ff fcba 	bl	34001568 <LL_MEM_EnableClock>
  __HAL_RCC_AXISRAM4_MEM_CLK_ENABLE();
34001bf4:	2002      	movs	r0, #2
34001bf6:	f7ff fcb7 	bl	34001568 <LL_MEM_EnableClock>
  __HAL_RCC_AXISRAM5_MEM_CLK_ENABLE();
34001bfa:	2004      	movs	r0, #4
34001bfc:	f7ff fcb4 	bl	34001568 <LL_MEM_EnableClock>
  __HAL_RCC_AXISRAM6_MEM_CLK_ENABLE();
34001c00:	2008      	movs	r0, #8
34001c02:	f7ff fcb1 	bl	34001568 <LL_MEM_EnableClock>
  __HAL_RCC_RAMCFG_CLK_ENABLE();
34001c06:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
34001c0a:	f7ff fcd9 	bl	340015c0 <LL_AHB2_GRP1_EnableClock>
  RAMCFG_HandleTypeDef hramcfg = {0};
34001c0e:	1d3b      	adds	r3, r7, #4
34001c10:	2200      	movs	r2, #0
34001c12:	601a      	str	r2, [r3, #0]
34001c14:	605a      	str	r2, [r3, #4]
34001c16:	609a      	str	r2, [r3, #8]
  hramcfg.Instance =  RAMCFG_SRAM3_AXI;
34001c18:	4b0d      	ldr	r3, [pc, #52]	@ (34001c50 <NPURam_enable+0x80>)
34001c1a:	607b      	str	r3, [r7, #4]
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001c1c:	1d3b      	adds	r3, r7, #4
34001c1e:	4618      	mov	r0, r3
34001c20:	f004 fcb0 	bl	34006584 <HAL_RAMCFG_EnableAXISRAM>
  hramcfg.Instance =  RAMCFG_SRAM4_AXI;
34001c24:	4b0b      	ldr	r3, [pc, #44]	@ (34001c54 <NPURam_enable+0x84>)
34001c26:	607b      	str	r3, [r7, #4]
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001c28:	1d3b      	adds	r3, r7, #4
34001c2a:	4618      	mov	r0, r3
34001c2c:	f004 fcaa 	bl	34006584 <HAL_RAMCFG_EnableAXISRAM>
  hramcfg.Instance =  RAMCFG_SRAM5_AXI;
34001c30:	4b09      	ldr	r3, [pc, #36]	@ (34001c58 <NPURam_enable+0x88>)
34001c32:	607b      	str	r3, [r7, #4]
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001c34:	1d3b      	adds	r3, r7, #4
34001c36:	4618      	mov	r0, r3
34001c38:	f004 fca4 	bl	34006584 <HAL_RAMCFG_EnableAXISRAM>
  hramcfg.Instance =  RAMCFG_SRAM6_AXI;
34001c3c:	4b07      	ldr	r3, [pc, #28]	@ (34001c5c <NPURam_enable+0x8c>)
34001c3e:	607b      	str	r3, [r7, #4]
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001c40:	1d3b      	adds	r3, r7, #4
34001c42:	4618      	mov	r0, r3
34001c44:	f004 fc9e 	bl	34006584 <HAL_RAMCFG_EnableAXISRAM>
}
34001c48:	bf00      	nop
34001c4a:	3710      	adds	r7, #16
34001c4c:	46bd      	mov	sp, r7
34001c4e:	bd80      	pop	{r7, pc}
34001c50:	52023100 	.word	0x52023100
34001c54:	52023180 	.word	0x52023180
34001c58:	52023200 	.word	0x52023200
34001c5c:	52023280 	.word	0x52023280

34001c60 <set_clk_sleep_mode>:

static void set_clk_sleep_mode(void)
{
34001c60:	b580      	push	{r7, lr}
34001c62:	af00      	add	r7, sp, #0
  /*** Enable sleep mode support during NPU inference *************************/
  /* Configure peripheral clocks to remain active during sleep mode */
  /* Keep all IP's enabled during WFE so they can wake up CPU. Fine tune
   * this if you want to save maximum power
   */
  __HAL_RCC_XSPI1_CLK_SLEEP_ENABLE();    /* For display frame buffer */
34001c64:	2020      	movs	r0, #32
34001c66:	f7ff fd35 	bl	340016d4 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_XSPI2_CLK_SLEEP_ENABLE();    /* For NN weights */
34001c6a:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
34001c6e:	f7ff fd31 	bl	340016d4 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_NPU_CLK_SLEEP_ENABLE();      /* For NN inference */
34001c72:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
34001c76:	f7ff fd2d 	bl	340016d4 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_CACHEAXI_CLK_SLEEP_ENABLE(); /* For NN inference */
34001c7a:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
34001c7e:	f7ff fd29 	bl	340016d4 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_DMA2D_CLK_SLEEP_ENABLE();    /* For display */
34001c82:	2002      	movs	r0, #2
34001c84:	f7ff fd26 	bl	340016d4 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_DCMIPP_CLK_SLEEP_ENABLE();   /* For camera configuration retention */
34001c88:	2004      	movs	r0, #4
34001c8a:	f7ff fd4f 	bl	3400172c <LL_APB5_GRP1_EnableClockLowPower>
  __HAL_RCC_CSI_CLK_SLEEP_ENABLE();      /* For camera configuration retention */
34001c8e:	2040      	movs	r0, #64	@ 0x40
34001c90:	f7ff fd4c 	bl	3400172c <LL_APB5_GRP1_EnableClockLowPower>

  __HAL_RCC_FLEXRAM_MEM_CLK_SLEEP_ENABLE();
34001c94:	f44f 7000 	mov.w	r0, #512	@ 0x200
34001c98:	f7ff fc7c 	bl	34001594 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM1_MEM_CLK_SLEEP_ENABLE();
34001c9c:	2080      	movs	r0, #128	@ 0x80
34001c9e:	f7ff fc79 	bl	34001594 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM2_MEM_CLK_SLEEP_ENABLE();
34001ca2:	f44f 7080 	mov.w	r0, #256	@ 0x100
34001ca6:	f7ff fc75 	bl	34001594 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM3_MEM_CLK_SLEEP_ENABLE();
34001caa:	2001      	movs	r0, #1
34001cac:	f7ff fc72 	bl	34001594 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM4_MEM_CLK_SLEEP_ENABLE();
34001cb0:	2002      	movs	r0, #2
34001cb2:	f7ff fc6f 	bl	34001594 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM5_MEM_CLK_SLEEP_ENABLE();
34001cb6:	2004      	movs	r0, #4
34001cb8:	f7ff fc6c 	bl	34001594 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM6_MEM_CLK_SLEEP_ENABLE();
34001cbc:	2008      	movs	r0, #8
34001cbe:	f7ff fc69 	bl	34001594 <LL_MEM_EnableClockLowPower>
}
34001cc2:	bf00      	nop
34001cc4:	bd80      	pop	{r7, pc}

34001cc6 <NPUCache_config>:

static void NPUCache_config(void)
{
34001cc6:	b580      	push	{r7, lr}
34001cc8:	af00      	add	r7, sp, #0
  npu_cache_init();
34001cca:	f000 f9eb 	bl	340020a4 <npu_cache_init>
  npu_cache_enable();
34001cce:	f000 f9f7 	bl	340020c0 <npu_cache_enable>
}
34001cd2:	bf00      	nop
34001cd4:	bd80      	pop	{r7, pc}
	...

34001cd8 <Security_Config>:

static void Security_Config(void)
{
34001cd8:	b580      	push	{r7, lr}
34001cda:	b082      	sub	sp, #8
34001cdc:	af00      	add	r7, sp, #0
  __HAL_RCC_RIFSC_CLK_ENABLE();
34001cde:	f44f 7000 	mov.w	r0, #512	@ 0x200
34001ce2:	f7ff fc83 	bl	340015ec <LL_AHB3_GRP1_EnableClock>
  RIMC_MasterConfig_t RIMC_master = {0};
34001ce6:	463b      	mov	r3, r7
34001ce8:	2200      	movs	r2, #0
34001cea:	601a      	str	r2, [r3, #0]
34001cec:	605a      	str	r2, [r3, #4]
  RIMC_master.MasterCID = RIF_CID_1;
34001cee:	2302      	movs	r3, #2
34001cf0:	603b      	str	r3, [r7, #0]
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
34001cf2:	2303      	movs	r3, #3
34001cf4:	607b      	str	r3, [r7, #4]
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_NPU, &RIMC_master);
34001cf6:	463b      	mov	r3, r7
34001cf8:	4619      	mov	r1, r3
34001cfa:	2001      	movs	r0, #1
34001cfc:	f012 fe46 	bl	3401498c <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DMA2D, &RIMC_master);
34001d00:	463b      	mov	r3, r7
34001d02:	4619      	mov	r1, r3
34001d04:	2008      	movs	r0, #8
34001d06:	f012 fe41 	bl	3401498c <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DCMIPP, &RIMC_master);
34001d0a:	463b      	mov	r3, r7
34001d0c:	4619      	mov	r1, r3
34001d0e:	2009      	movs	r0, #9
34001d10:	f012 fe3c 	bl	3401498c <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC1 , &RIMC_master);
34001d14:	463b      	mov	r3, r7
34001d16:	4619      	mov	r1, r3
34001d18:	200a      	movs	r0, #10
34001d1a:	f012 fe37 	bl	3401498c <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC2 , &RIMC_master);
34001d1e:	463b      	mov	r3, r7
34001d20:	4619      	mov	r1, r3
34001d22:	200b      	movs	r0, #11
34001d24:	f012 fe32 	bl	3401498c <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_OTG1 , &RIMC_master);
34001d28:	463b      	mov	r3, r7
34001d2a:	4619      	mov	r1, r3
34001d2c:	2004      	movs	r0, #4
34001d2e:	f012 fe2d 	bl	3401498c <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_NPU , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001d32:	2103      	movs	r1, #3
34001d34:	4813      	ldr	r0, [pc, #76]	@ (34001d84 <Security_Config+0xac>)
34001d36:	f012 fed3 	bl	34014ae0 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_DMA2D , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001d3a:	2103      	movs	r1, #3
34001d3c:	4812      	ldr	r0, [pc, #72]	@ (34001d88 <Security_Config+0xb0>)
34001d3e:	f012 fecf 	bl	34014ae0 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_CSI    , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001d42:	2103      	movs	r1, #3
34001d44:	4811      	ldr	r0, [pc, #68]	@ (34001d8c <Security_Config+0xb4>)
34001d46:	f012 fecb 	bl	34014ae0 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_DCMIPP , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001d4a:	2103      	movs	r1, #3
34001d4c:	4810      	ldr	r0, [pc, #64]	@ (34001d90 <Security_Config+0xb8>)
34001d4e:	f012 fec7 	bl	34014ae0 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDC   , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001d52:	2103      	movs	r1, #3
34001d54:	480f      	ldr	r0, [pc, #60]	@ (34001d94 <Security_Config+0xbc>)
34001d56:	f012 fec3 	bl	34014ae0 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDCL1 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001d5a:	2103      	movs	r1, #3
34001d5c:	480e      	ldr	r0, [pc, #56]	@ (34001d98 <Security_Config+0xc0>)
34001d5e:	f012 febf 	bl	34014ae0 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDCL2 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001d62:	2103      	movs	r1, #3
34001d64:	480d      	ldr	r0, [pc, #52]	@ (34001d9c <Security_Config+0xc4>)
34001d66:	f012 febb 	bl	34014ae0 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_OTG1HS , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001d6a:	2103      	movs	r1, #3
34001d6c:	480c      	ldr	r0, [pc, #48]	@ (34001da0 <Security_Config+0xc8>)
34001d6e:	f012 feb7 	bl	34014ae0 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_SPI5 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001d72:	2103      	movs	r1, #3
34001d74:	2004      	movs	r0, #4
34001d76:	f012 feb3 	bl	34014ae0 <HAL_RIF_RISC_SetSlaveSecureAttributes>
}
34001d7a:	bf00      	nop
34001d7c:	3708      	adds	r7, #8
34001d7e:	46bd      	mov	sp, r7
34001d80:	bd80      	pop	{r7, pc}
34001d82:	bf00      	nop
34001d84:	3000000a 	.word	0x3000000a
34001d88:	30000005 	.word	0x30000005
34001d8c:	2000001c 	.word	0x2000001c
34001d90:	2000001d 	.word	0x2000001d
34001d94:	30000006 	.word	0x30000006
34001d98:	30000007 	.word	0x30000007
34001d9c:	30000008 	.word	0x30000008
34001da0:	10000018 	.word	0x10000018

34001da4 <IAC_Config>:

static void IAC_Config(void)
{
34001da4:	b580      	push	{r7, lr}
34001da6:	af00      	add	r7, sp, #0
/* Configure IAC to trap illegal access events */
  __HAL_RCC_IAC_CLK_ENABLE();
34001da8:	f44f 6080 	mov.w	r0, #1024	@ 0x400
34001dac:	f7ff fc1e 	bl	340015ec <LL_AHB3_GRP1_EnableClock>
  __HAL_RCC_IAC_FORCE_RESET();
34001db0:	f44f 6080 	mov.w	r0, #1024	@ 0x400
34001db4:	f7ff fc30 	bl	34001618 <LL_AHB3_GRP1_ForceReset>
  __HAL_RCC_IAC_RELEASE_RESET();
34001db8:	f44f 6080 	mov.w	r0, #1024	@ 0x400
34001dbc:	f7ff fc3c 	bl	34001638 <LL_AHB3_GRP1_ReleaseReset>
}
34001dc0:	bf00      	nop
34001dc2:	bd80      	pop	{r7, pc}

34001dc4 <IAC_IRQHandler>:

void IAC_IRQHandler(void)
{
34001dc4:	b480      	push	{r7}
34001dc6:	af00      	add	r7, sp, #0
  while (1)
34001dc8:	bf00      	nop
34001dca:	e7fd      	b.n	34001dc8 <IAC_IRQHandler+0x4>

34001dcc <SystemClock_Config>:

  return ret;
}

static void SystemClock_Config(void)
{
34001dcc:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
34001dd0:	f5ad 7d1a 	sub.w	sp, sp, #616	@ 0x268
34001dd4:	af00      	add	r7, sp, #0
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
34001dd6:	f507 730a 	add.w	r3, r7, #552	@ 0x228
34001dda:	2240      	movs	r2, #64	@ 0x40
34001ddc:	2100      	movs	r1, #0
34001dde:	4618      	mov	r0, r3
34001de0:	f01a fce4 	bl	3401c7ac <memset>
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
34001de4:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
34001de8:	2298      	movs	r2, #152	@ 0x98
34001dea:	2100      	movs	r1, #0
34001dec:	4618      	mov	r0, r3
34001dee:	f01a fcdd 	bl	3401c7ac <memset>
  RCC_PeriphCLKInitTypeDef RCC_PeriphCLKInitStruct = {0};
34001df2:	f507 731a 	add.w	r3, r7, #616	@ 0x268
34001df6:	f5a3 731a 	sub.w	r3, r3, #616	@ 0x268
34001dfa:	4618      	mov	r0, r3
34001dfc:	f44f 73c8 	mov.w	r3, #400	@ 0x190
34001e00:	461a      	mov	r2, r3
34001e02:	2100      	movs	r1, #0
34001e04:	f01a fcd2 	bl	3401c7ac <memset>

  /* Ensure VDDCORE=0.9V before increasing the system frequency */
  BSP_SMPS_Init(SMPS_VOLTAGE_OVERDRIVE);
34001e08:	2001      	movs	r0, #1
34001e0a:	f000 fef7 	bl	34002bfc <BSP_SMPS_Init>

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_NONE;
34001e0e:	2300      	movs	r3, #0
34001e10:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190

  /* PLL1 = 64 x 25 / 2 = 800MHz */
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_ON;
34001e14:	2302      	movs	r3, #2
34001e16:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
  RCC_OscInitStruct.PLL1.PLLSource = RCC_PLLSOURCE_HSI;
34001e1a:	2300      	movs	r3, #0
34001e1c:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
  RCC_OscInitStruct.PLL1.PLLM = 2;
34001e20:	2302      	movs	r3, #2
34001e22:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
  RCC_OscInitStruct.PLL1.PLLN = 25;
34001e26:	2319      	movs	r3, #25
34001e28:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
  RCC_OscInitStruct.PLL1.PLLFractional = 0;
34001e2c:	2300      	movs	r3, #0
34001e2e:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
  RCC_OscInitStruct.PLL1.PLLP1 = 1;
34001e32:	2301      	movs	r3, #1
34001e34:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
  RCC_OscInitStruct.PLL1.PLLP2 = 1;
34001e38:	2301      	movs	r3, #1
34001e3a:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0

  /* PLL2 = 64 x 125 / 8 = 1000MHz */
  RCC_OscInitStruct.PLL2.PLLState = RCC_PLL_ON;
34001e3e:	2302      	movs	r3, #2
34001e40:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
  RCC_OscInitStruct.PLL2.PLLSource = RCC_PLLSOURCE_HSI;
34001e44:	2300      	movs	r3, #0
34001e46:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
  RCC_OscInitStruct.PLL2.PLLM = 8;
34001e4a:	2308      	movs	r3, #8
34001e4c:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
  RCC_OscInitStruct.PLL2.PLLFractional = 0;
34001e50:	2300      	movs	r3, #0
34001e52:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
  RCC_OscInitStruct.PLL2.PLLN = 125;
34001e56:	237d      	movs	r3, #125	@ 0x7d
34001e58:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
  RCC_OscInitStruct.PLL2.PLLP1 = 1;
34001e5c:	2301      	movs	r3, #1
34001e5e:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8
  RCC_OscInitStruct.PLL2.PLLP2 = 1;
34001e62:	2301      	movs	r3, #1
34001e64:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec

  /* PLL3 = (64 x 225 / 8) / (1 * 2) = 900MHz */
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_ON;
34001e68:	2302      	movs	r3, #2
34001e6a:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
  RCC_OscInitStruct.PLL3.PLLSource = RCC_PLLSOURCE_HSI;
34001e6e:	2300      	movs	r3, #0
34001e70:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
  RCC_OscInitStruct.PLL3.PLLM = 8;
34001e74:	2308      	movs	r3, #8
34001e76:	f8c7 31f8 	str.w	r3, [r7, #504]	@ 0x1f8
  RCC_OscInitStruct.PLL3.PLLN = 225;
34001e7a:	23e1      	movs	r3, #225	@ 0xe1
34001e7c:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
  RCC_OscInitStruct.PLL3.PLLFractional = 0;
34001e80:	2300      	movs	r3, #0
34001e82:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
  RCC_OscInitStruct.PLL3.PLLP1 = 1;
34001e86:	2301      	movs	r3, #1
34001e88:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
  RCC_OscInitStruct.PLL3.PLLP2 = 2;
34001e8c:	2302      	movs	r3, #2
34001e8e:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208

  /* PLL4 = (64 x 225 / 8) / (6 * 6) = 50 MHz */
  RCC_OscInitStruct.PLL4.PLLState = RCC_PLL_ON;
34001e92:	2302      	movs	r3, #2
34001e94:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
  RCC_OscInitStruct.PLL4.PLLSource = RCC_PLLSOURCE_HSI;
34001e98:	2300      	movs	r3, #0
34001e9a:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210
  RCC_OscInitStruct.PLL4.PLLM = 8;
34001e9e:	2308      	movs	r3, #8
34001ea0:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
  RCC_OscInitStruct.PLL4.PLLFractional = 0;
34001ea4:	2300      	movs	r3, #0
34001ea6:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
  RCC_OscInitStruct.PLL4.PLLN = 225;
34001eaa:	23e1      	movs	r3, #225	@ 0xe1
34001eac:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
  RCC_OscInitStruct.PLL4.PLLP1 = 6;
34001eb0:	2306      	movs	r3, #6
34001eb2:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
  RCC_OscInitStruct.PLL4.PLLP2 = 6;
34001eb6:	2306      	movs	r3, #6
34001eb8:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224

  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
34001ebc:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
34001ec0:	4618      	mov	r0, r3
34001ec2:	f004 fe37 	bl	34006b34 <HAL_RCC_OscConfig>
34001ec6:	4603      	mov	r3, r0
34001ec8:	2b00      	cmp	r3, #0
34001eca:	d001      	beq.n	34001ed0 <SystemClock_Config+0x104>
  {
    while(1);
34001ecc:	bf00      	nop
34001ece:	e7fd      	b.n	34001ecc <SystemClock_Config+0x100>
  }

  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_CPUCLK | RCC_CLOCKTYPE_SYSCLK |
34001ed0:	237f      	movs	r3, #127	@ 0x7f
34001ed2:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
                                 RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 |
                                 RCC_CLOCKTYPE_PCLK2 | RCC_CLOCKTYPE_PCLK4 |
                                 RCC_CLOCKTYPE_PCLK5);

  /* CPU CLock (sysa_ck) = ic1_ck = PLL1 output/ic1_divider = 800 MHz */
  RCC_ClkInitStruct.CPUCLKSource = RCC_CPUCLKSOURCE_IC1;
34001ed6:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
34001eda:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_IC2_IC6_IC11;
34001ede:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
34001ee2:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
  RCC_ClkInitStruct.IC1Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
34001ee6:	2300      	movs	r3, #0
34001ee8:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
  RCC_ClkInitStruct.IC1Selection.ClockDivider = 1;
34001eec:	2301      	movs	r3, #1
34001eee:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c

  /* AXI Clock (sysb_ck) = ic2_ck = PLL1 output/ic2_divider = 400 MHz */
  RCC_ClkInitStruct.IC2Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
34001ef2:	2300      	movs	r3, #0
34001ef4:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
  RCC_ClkInitStruct.IC2Selection.ClockDivider = 2;
34001ef8:	2302      	movs	r3, #2
34001efa:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254

  /* NPU Clock (sysc_ck) = ic6_ck = PLL2 output/ic6_divider = 1000 MHz */
  RCC_ClkInitStruct.IC6Selection.ClockSelection = RCC_ICCLKSOURCE_PLL2;
34001efe:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
34001f02:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
  RCC_ClkInitStruct.IC6Selection.ClockDivider = 1;
34001f06:	2301      	movs	r3, #1
34001f08:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c

  /* AXISRAM3/4/5/6 Clock (sysd_ck) = ic11_ck = PLL3 output/ic11_divider = 900 MHz */
  RCC_ClkInitStruct.IC11Selection.ClockSelection = RCC_ICCLKSOURCE_PLL3;
34001f0c:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
34001f10:	f8c7 3260 	str.w	r3, [r7, #608]	@ 0x260
  RCC_ClkInitStruct.IC11Selection.ClockDivider = 1;
34001f14:	2301      	movs	r3, #1
34001f16:	f8c7 3264 	str.w	r3, [r7, #612]	@ 0x264

  /* HCLK = sysb_ck / HCLK divider = 200 MHz */
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
34001f1a:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
34001f1e:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234

  /* PCLKx = HCLK / PCLKx divider = 200 MHz */
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;
34001f22:	2300      	movs	r3, #0
34001f24:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV1;
34001f28:	2300      	movs	r3, #0
34001f2a:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;
34001f2e:	2300      	movs	r3, #0
34001f30:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
  RCC_ClkInitStruct.APB5CLKDivider = RCC_APB5_DIV1;
34001f34:	2300      	movs	r3, #0
34001f36:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
34001f3a:	f507 730a 	add.w	r3, r7, #552	@ 0x228
34001f3e:	4618      	mov	r0, r3
34001f40:	f005 fb18 	bl	34007574 <HAL_RCC_ClockConfig>
34001f44:	4603      	mov	r3, r0
34001f46:	2b00      	cmp	r3, #0
34001f48:	d001      	beq.n	34001f4e <SystemClock_Config+0x182>
  {
    while(1);
34001f4a:	bf00      	nop
34001f4c:	e7fd      	b.n	34001f4a <SystemClock_Config+0x17e>
  }

  RCC_PeriphCLKInitStruct.PeriphClockSelection = 0;
34001f4e:	f507 731a 	add.w	r3, r7, #616	@ 0x268
34001f52:	f5a3 711a 	sub.w	r1, r3, #616	@ 0x268
34001f56:	f04f 0200 	mov.w	r2, #0
34001f5a:	f04f 0300 	mov.w	r3, #0
34001f5e:	e9c1 2300 	strd	r2, r3, [r1]

  /* XSPI1 kernel clock (ck_ker_xspi1) = HCLK = 200MHz */
  RCC_PeriphCLKInitStruct.PeriphClockSelection |= RCC_PERIPHCLK_XSPI1;
34001f62:	f507 731a 	add.w	r3, r7, #616	@ 0x268
34001f66:	f5a3 731a 	sub.w	r3, r3, #616	@ 0x268
34001f6a:	e9d3 2300 	ldrd	r2, r3, [r3]
34001f6e:	4690      	mov	r8, r2
34001f70:	f443 0980 	orr.w	r9, r3, #4194304	@ 0x400000
34001f74:	f507 731a 	add.w	r3, r7, #616	@ 0x268
34001f78:	f5a3 731a 	sub.w	r3, r3, #616	@ 0x268
34001f7c:	e9c3 8900 	strd	r8, r9, [r3]
  RCC_PeriphCLKInitStruct.Xspi1ClockSelection = RCC_XSPI1CLKSOURCE_HCLK;
34001f80:	f507 731a 	add.w	r3, r7, #616	@ 0x268
34001f84:	f5a3 731a 	sub.w	r3, r3, #616	@ 0x268
34001f88:	4a13      	ldr	r2, [pc, #76]	@ (34001fd8 <SystemClock_Config+0x20c>)
34001f8a:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac

  /* XSPI2 kernel clock (ck_ker_xspi1) = HCLK =  200MHz */
  RCC_PeriphCLKInitStruct.PeriphClockSelection |= RCC_PERIPHCLK_XSPI2;
34001f8e:	f507 731a 	add.w	r3, r7, #616	@ 0x268
34001f92:	f5a3 731a 	sub.w	r3, r3, #616	@ 0x268
34001f96:	e9d3 2300 	ldrd	r2, r3, [r3]
34001f9a:	4614      	mov	r4, r2
34001f9c:	f443 0500 	orr.w	r5, r3, #8388608	@ 0x800000
34001fa0:	f507 731a 	add.w	r3, r7, #616	@ 0x268
34001fa4:	f5a3 731a 	sub.w	r3, r3, #616	@ 0x268
34001fa8:	e9c3 4500 	strd	r4, r5, [r3]
  RCC_PeriphCLKInitStruct.Xspi2ClockSelection = RCC_XSPI2CLKSOURCE_HCLK;
34001fac:	f507 731a 	add.w	r3, r7, #616	@ 0x268
34001fb0:	f5a3 731a 	sub.w	r3, r3, #616	@ 0x268
34001fb4:	4a09      	ldr	r2, [pc, #36]	@ (34001fdc <SystemClock_Config+0x210>)
34001fb6:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

  if (HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct) != HAL_OK)
34001fba:	463b      	mov	r3, r7
34001fbc:	4618      	mov	r0, r3
34001fbe:	f007 fecf 	bl	34009d60 <HAL_RCCEx_PeriphCLKConfig>
34001fc2:	4603      	mov	r3, r0
34001fc4:	2b00      	cmp	r3, #0
34001fc6:	d001      	beq.n	34001fcc <SystemClock_Config+0x200>
  {
    while (1);
34001fc8:	bf00      	nop
34001fca:	e7fd      	b.n	34001fc8 <SystemClock_Config+0x1fc>
  }
}
34001fcc:	bf00      	nop
34001fce:	f507 771a 	add.w	r7, r7, #616	@ 0x268
34001fd2:	46bd      	mov	sp, r7
34001fd4:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
34001fd8:	03000014 	.word	0x03000014
34001fdc:	03000414 	.word	0x03000414

34001fe0 <HAL_CACHEAXI_MspInit>:

void HAL_CACHEAXI_MspInit(CACHEAXI_HandleTypeDef *hcacheaxi)
{
34001fe0:	b580      	push	{r7, lr}
34001fe2:	b082      	sub	sp, #8
34001fe4:	af00      	add	r7, sp, #0
34001fe6:	6078      	str	r0, [r7, #4]
  __HAL_RCC_CACHEAXIRAM_MEM_CLK_ENABLE();
34001fe8:	f44f 6080 	mov.w	r0, #1024	@ 0x400
34001fec:	f7ff fabc 	bl	34001568 <LL_MEM_EnableClock>
  __HAL_RCC_CACHEAXI_CLK_ENABLE();
34001ff0:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
34001ff4:	f7ff fb34 	bl	34001660 <LL_AHB5_GRP1_EnableClock>
  __HAL_RCC_CACHEAXI_FORCE_RESET();
34001ff8:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
34001ffc:	f7ff fb46 	bl	3400168c <LL_AHB5_GRP1_ForceReset>
  __HAL_RCC_CACHEAXI_RELEASE_RESET();
34002000:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
34002004:	f7ff fb52 	bl	340016ac <LL_AHB5_GRP1_ReleaseReset>
}
34002008:	bf00      	nop
3400200a:	3708      	adds	r7, #8
3400200c:	46bd      	mov	sp, r7
3400200e:	bd80      	pop	{r7, pc}

34002010 <assert_failed>:
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t* file, uint32_t line)
{
34002010:	b480      	push	{r7}
34002012:	b083      	sub	sp, #12
34002014:	af00      	add	r7, sp, #0
34002016:	6078      	str	r0, [r7, #4]
34002018:	6039      	str	r1, [r7, #0]
  UNUSED(file);
  UNUSED(line);
  __BKPT(0);
3400201a:	be00      	bkpt	0x0000
  while (1)
3400201c:	bf00      	nop
3400201e:	e7fd      	b.n	3400201c <assert_failed+0xc>

34002020 <mcu_cache_invalidate_range>:
  }  
  return 0;
}

int mcu_cache_invalidate_range(uint32_t start_addr, uint32_t end_addr) 
{
34002020:	b480      	push	{r7}
34002022:	b087      	sub	sp, #28
34002024:	af00      	add	r7, sp, #0
34002026:	6078      	str	r0, [r7, #4]
34002028:	6039      	str	r1, [r7, #0]

#include "stm32n6xx_hal.h"

__STATIC_FORCEINLINE int mcu_cache_enabled(void) {
#if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
   if (SCB->CCR & SCB_CCR_DC_Msk) return 1;  /* return `1` if DCache is enabled */
3400202a:	4b1d      	ldr	r3, [pc, #116]	@ (340020a0 <mcu_cache_invalidate_range+0x80>)
3400202c:	695b      	ldr	r3, [r3, #20]
3400202e:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34002032:	2b00      	cmp	r3, #0
34002034:	d001      	beq.n	3400203a <mcu_cache_invalidate_range+0x1a>
34002036:	2301      	movs	r3, #1
34002038:	e000      	b.n	3400203c <mcu_cache_invalidate_range+0x1c>
#endif // (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)

  return 0;
3400203a:	2300      	movs	r3, #0
  if(mcu_cache_enabled()) {
3400203c:	2b00      	cmp	r3, #0
3400203e:	d027      	beq.n	34002090 <mcu_cache_invalidate_range+0x70>
    SCB_InvalidateDCache_by_Addr((volatile void *)start_addr, (int32_t)(end_addr - start_addr));
34002040:	687b      	ldr	r3, [r7, #4]
34002042:	6839      	ldr	r1, [r7, #0]
34002044:	687a      	ldr	r2, [r7, #4]
34002046:	1a8a      	subs	r2, r1, r2
34002048:	617b      	str	r3, [r7, #20]
3400204a:	613a      	str	r2, [r7, #16]
  \param[in]   dsize   size of memory block (in number of bytes)
*/
__STATIC_FORCEINLINE void SCB_InvalidateDCache_by_Addr (volatile void *addr, int32_t dsize)
{
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    if ( dsize > 0 ) {
3400204c:	693b      	ldr	r3, [r7, #16]
3400204e:	2b00      	cmp	r3, #0
34002050:	dd1d      	ble.n	3400208e <mcu_cache_invalidate_range+0x6e>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
34002052:	697b      	ldr	r3, [r7, #20]
34002054:	f003 021f 	and.w	r2, r3, #31
34002058:	693b      	ldr	r3, [r7, #16]
3400205a:	4413      	add	r3, r2
3400205c:	60fb      	str	r3, [r7, #12]
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
3400205e:	697b      	ldr	r3, [r7, #20]
34002060:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("dsb 0xF":::"memory");
34002062:	f3bf 8f4f 	dsb	sy
}
34002066:	bf00      	nop

      __DSB();

      do {
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
34002068:	4a0d      	ldr	r2, [pc, #52]	@ (340020a0 <mcu_cache_invalidate_range+0x80>)
3400206a:	68bb      	ldr	r3, [r7, #8]
3400206c:	f8c2 325c 	str.w	r3, [r2, #604]	@ 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
34002070:	68bb      	ldr	r3, [r7, #8]
34002072:	3320      	adds	r3, #32
34002074:	60bb      	str	r3, [r7, #8]
        op_size -= __SCB_DCACHE_LINE_SIZE;
34002076:	68fb      	ldr	r3, [r7, #12]
34002078:	3b20      	subs	r3, #32
3400207a:	60fb      	str	r3, [r7, #12]
      } while ( op_size > 0 );
3400207c:	68fb      	ldr	r3, [r7, #12]
3400207e:	2b00      	cmp	r3, #0
34002080:	dcf2      	bgt.n	34002068 <mcu_cache_invalidate_range+0x48>
  __ASM volatile ("dsb 0xF":::"memory");
34002082:	f3bf 8f4f 	dsb	sy
}
34002086:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34002088:	f3bf 8f6f 	isb	sy
}
3400208c:	bf00      	nop

      __DSB();
      __ISB();
    }
  #endif
}
3400208e:	bf00      	nop
  }
  return 0;
34002090:	2300      	movs	r3, #0
}
34002092:	4618      	mov	r0, r3
34002094:	371c      	adds	r7, #28
34002096:	46bd      	mov	sp, r7
34002098:	f85d 7b04 	ldr.w	r7, [sp], #4
3400209c:	4770      	bx	lr
3400209e:	bf00      	nop
340020a0:	e000ed00 	.word	0xe000ed00

340020a4 <npu_cache_init>:
#include "stm32n6xx_hal_cacheaxi.h"

static CACHEAXI_HandleTypeDef hcacheaxi_s;

void npu_cache_init(void)
{
340020a4:	b580      	push	{r7, lr}
340020a6:	af00      	add	r7, sp, #0
  hcacheaxi_s.Instance = CACHEAXI;
340020a8:	4b03      	ldr	r3, [pc, #12]	@ (340020b8 <npu_cache_init+0x14>)
340020aa:	4a04      	ldr	r2, [pc, #16]	@ (340020bc <npu_cache_init+0x18>)
340020ac:	601a      	str	r2, [r3, #0]
  HAL_CACHEAXI_Init(&hcacheaxi_s);      // Side effect: cacheaxi should be enabled (but one should call npu_enable_cache to be sure)
340020ae:	4802      	ldr	r0, [pc, #8]	@ (340020b8 <npu_cache_init+0x14>)
340020b0:	f002 f952 	bl	34004358 <HAL_CACHEAXI_Init>
}
340020b4:	bf00      	nop
340020b6:	bd80      	pop	{r7, pc}
340020b8:	34020e74 	.word	0x34020e74
340020bc:	580dfc00 	.word	0x580dfc00

340020c0 <npu_cache_enable>:

void npu_cache_enable(void)
{
340020c0:	b580      	push	{r7, lr}
340020c2:	b082      	sub	sp, #8
340020c4:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status;
  // Enable is wrapped in a loop because most of times, the first call returns
  //    HAL_BUSY, resulting in a cache not enabled.
  do
  {
    status = HAL_CACHEAXI_Enable(&hcacheaxi_s);
340020c6:	4806      	ldr	r0, [pc, #24]	@ (340020e0 <npu_cache_enable+0x20>)
340020c8:	f002 f97c 	bl	340043c4 <HAL_CACHEAXI_Enable>
340020cc:	4603      	mov	r3, r0
340020ce:	71fb      	strb	r3, [r7, #7]
  } while (status == HAL_BUSY);
340020d0:	79fb      	ldrb	r3, [r7, #7]
340020d2:	2b02      	cmp	r3, #2
340020d4:	d0f7      	beq.n	340020c6 <npu_cache_enable+0x6>
}
340020d6:	bf00      	nop
340020d8:	bf00      	nop
340020da:	3708      	adds	r7, #8
340020dc:	46bd      	mov	sp, r7
340020de:	bd80      	pop	{r7, pc}
340020e0:	34020e74 	.word	0x34020e74

340020e4 <NMI_Handler>:
  * @brief   This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
340020e4:	b480      	push	{r7}
340020e6:	af00      	add	r7, sp, #0
}
340020e8:	bf00      	nop
340020ea:	46bd      	mov	sp, r7
340020ec:	f85d 7b04 	ldr.w	r7, [sp], #4
340020f0:	4770      	bx	lr

340020f2 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
340020f2:	b480      	push	{r7}
340020f4:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
340020f6:	bf00      	nop
340020f8:	e7fd      	b.n	340020f6 <HardFault_Handler+0x4>

340020fa <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
340020fa:	b480      	push	{r7}
340020fc:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
340020fe:	bf00      	nop
34002100:	e7fd      	b.n	340020fe <MemManage_Handler+0x4>

34002102 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
34002102:	b480      	push	{r7}
34002104:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
34002106:	bf00      	nop
34002108:	e7fd      	b.n	34002106 <BusFault_Handler+0x4>

3400210a <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
3400210a:	b480      	push	{r7}
3400210c:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
3400210e:	bf00      	nop
34002110:	e7fd      	b.n	3400210e <UsageFault_Handler+0x4>

34002112 <SecureFault_Handler>:
  * @brief  This function handles Secure Fault exception.
  * @param  None
  * @retval None
  */
void SecureFault_Handler(void)
{
34002112:	b480      	push	{r7}
34002114:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Secure Fault exception occurs */
  while (1)
34002116:	bf00      	nop
34002118:	e7fd      	b.n	34002116 <SecureFault_Handler+0x4>

3400211a <SVC_Handler>:
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
3400211a:	b480      	push	{r7}
3400211c:	af00      	add	r7, sp, #0
}
3400211e:	bf00      	nop
34002120:	46bd      	mov	sp, r7
34002122:	f85d 7b04 	ldr.w	r7, [sp], #4
34002126:	4770      	bx	lr

34002128 <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
34002128:	b480      	push	{r7}
3400212a:	af00      	add	r7, sp, #0
  while (1)
3400212c:	bf00      	nop
3400212e:	e7fd      	b.n	3400212c <DebugMon_Handler+0x4>

34002130 <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
34002130:	b480      	push	{r7}
34002132:	af00      	add	r7, sp, #0
  while (1)
34002134:	bf00      	nop
34002136:	e7fd      	b.n	34002134 <PendSV_Handler+0x4>

34002138 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
34002138:	b580      	push	{r7, lr}
3400213a:	af00      	add	r7, sp, #0
  HAL_IncTick();
3400213c:	f001 ff76 	bl	3400402c <HAL_IncTick>
}
34002140:	bf00      	nop
34002142:	bd80      	pop	{r7, pc}

34002144 <CSI_IRQHandler>:
/*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
/*  available peripheral interrupt handler's name please refer to the startup */
/*  file (startup_stm32n6xx.s).                                               */
/******************************************************************************/
void CSI_IRQHandler(void)
{
34002144:	b580      	push	{r7, lr}
34002146:	b082      	sub	sp, #8
34002148:	af00      	add	r7, sp, #0
  DCMIPP_HandleTypeDef *hcamera_dcmipp = CMW_CAMERA_GetDCMIPPHandle();
3400214a:	f015 ff15 	bl	34017f78 <CMW_CAMERA_GetDCMIPPHandle>
3400214e:	6078      	str	r0, [r7, #4]
  HAL_DCMIPP_CSI_IRQHandler(hcamera_dcmipp);
34002150:	6878      	ldr	r0, [r7, #4]
34002152:	f002 fce5 	bl	34004b20 <HAL_DCMIPP_CSI_IRQHandler>
}
34002156:	bf00      	nop
34002158:	3708      	adds	r7, #8
3400215a:	46bd      	mov	sp, r7
3400215c:	bd80      	pop	{r7, pc}

3400215e <DCMIPP_IRQHandler>:

void DCMIPP_IRQHandler(void)
{
3400215e:	b580      	push	{r7, lr}
34002160:	b082      	sub	sp, #8
34002162:	af00      	add	r7, sp, #0
  DCMIPP_HandleTypeDef *hcamera_dcmipp = CMW_CAMERA_GetDCMIPPHandle();
34002164:	f015 ff08 	bl	34017f78 <CMW_CAMERA_GetDCMIPPHandle>
34002168:	6078      	str	r0, [r7, #4]
  HAL_DCMIPP_IRQHandler(hcamera_dcmipp);
3400216a:	6878      	ldr	r0, [r7, #4]
3400216c:	f002 faf4 	bl	34004758 <HAL_DCMIPP_IRQHandler>
34002170:	bf00      	nop
34002172:	3708      	adds	r7, #8
34002174:	46bd      	mov	sp, r7
34002176:	bd80      	pop	{r7, pc}

34002178 <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
34002178:	b480      	push	{r7}
3400217a:	af00      	add	r7, sp, #0
  return 1;
3400217c:	2301      	movs	r3, #1
}
3400217e:	4618      	mov	r0, r3
34002180:	46bd      	mov	sp, r7
34002182:	f85d 7b04 	ldr.w	r7, [sp], #4
34002186:	4770      	bx	lr

34002188 <_kill>:

int _kill(int pid, int sig)
{
34002188:	b580      	push	{r7, lr}
3400218a:	b082      	sub	sp, #8
3400218c:	af00      	add	r7, sp, #0
3400218e:	6078      	str	r0, [r7, #4]
34002190:	6039      	str	r1, [r7, #0]
  (void)pid;
  (void)sig;
  errno = EINVAL;
34002192:	f01a fd5f 	bl	3401cc54 <__errno>
34002196:	4603      	mov	r3, r0
34002198:	2216      	movs	r2, #22
3400219a:	601a      	str	r2, [r3, #0]
  return -1;
3400219c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
340021a0:	4618      	mov	r0, r3
340021a2:	3708      	adds	r7, #8
340021a4:	46bd      	mov	sp, r7
340021a6:	bd80      	pop	{r7, pc}

340021a8 <_exit>:

void _exit (int status)
{
340021a8:	b580      	push	{r7, lr}
340021aa:	b082      	sub	sp, #8
340021ac:	af00      	add	r7, sp, #0
340021ae:	6078      	str	r0, [r7, #4]
  _kill(status, -1);
340021b0:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
340021b4:	6878      	ldr	r0, [r7, #4]
340021b6:	f7ff ffe7 	bl	34002188 <_kill>
  while (1) {}    /* Make sure we hang here */
340021ba:	bf00      	nop
340021bc:	e7fd      	b.n	340021ba <_exit+0x12>

340021be <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
340021be:	b580      	push	{r7, lr}
340021c0:	b086      	sub	sp, #24
340021c2:	af00      	add	r7, sp, #0
340021c4:	60f8      	str	r0, [r7, #12]
340021c6:	60b9      	str	r1, [r7, #8]
340021c8:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
340021ca:	2300      	movs	r3, #0
340021cc:	617b      	str	r3, [r7, #20]
340021ce:	e00a      	b.n	340021e6 <_read+0x28>
  {
    *ptr++ = __io_getchar();
340021d0:	f3af 8000 	nop.w
340021d4:	4601      	mov	r1, r0
340021d6:	68bb      	ldr	r3, [r7, #8]
340021d8:	1c5a      	adds	r2, r3, #1
340021da:	60ba      	str	r2, [r7, #8]
340021dc:	b2ca      	uxtb	r2, r1
340021de:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
340021e0:	697b      	ldr	r3, [r7, #20]
340021e2:	3301      	adds	r3, #1
340021e4:	617b      	str	r3, [r7, #20]
340021e6:	697a      	ldr	r2, [r7, #20]
340021e8:	687b      	ldr	r3, [r7, #4]
340021ea:	429a      	cmp	r2, r3
340021ec:	dbf0      	blt.n	340021d0 <_read+0x12>
  }

  return len;
340021ee:	687b      	ldr	r3, [r7, #4]
}
340021f0:	4618      	mov	r0, r3
340021f2:	3718      	adds	r7, #24
340021f4:	46bd      	mov	sp, r7
340021f6:	bd80      	pop	{r7, pc}

340021f8 <_close>:
  }
  return len;
}

int _close(int file)
{
340021f8:	b480      	push	{r7}
340021fa:	b083      	sub	sp, #12
340021fc:	af00      	add	r7, sp, #0
340021fe:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
34002200:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
34002204:	4618      	mov	r0, r3
34002206:	370c      	adds	r7, #12
34002208:	46bd      	mov	sp, r7
3400220a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400220e:	4770      	bx	lr

34002210 <_fstat>:


int _fstat(int file, struct stat *st)
{
34002210:	b480      	push	{r7}
34002212:	b083      	sub	sp, #12
34002214:	af00      	add	r7, sp, #0
34002216:	6078      	str	r0, [r7, #4]
34002218:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
3400221a:	683b      	ldr	r3, [r7, #0]
3400221c:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
34002220:	605a      	str	r2, [r3, #4]
  return 0;
34002222:	2300      	movs	r3, #0
}
34002224:	4618      	mov	r0, r3
34002226:	370c      	adds	r7, #12
34002228:	46bd      	mov	sp, r7
3400222a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400222e:	4770      	bx	lr

34002230 <_isatty>:

int _isatty(int file)
{
34002230:	b480      	push	{r7}
34002232:	b083      	sub	sp, #12
34002234:	af00      	add	r7, sp, #0
34002236:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
34002238:	2301      	movs	r3, #1
}
3400223a:	4618      	mov	r0, r3
3400223c:	370c      	adds	r7, #12
3400223e:	46bd      	mov	sp, r7
34002240:	f85d 7b04 	ldr.w	r7, [sp], #4
34002244:	4770      	bx	lr

34002246 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
34002246:	b480      	push	{r7}
34002248:	b085      	sub	sp, #20
3400224a:	af00      	add	r7, sp, #0
3400224c:	60f8      	str	r0, [r7, #12]
3400224e:	60b9      	str	r1, [r7, #8]
34002250:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
34002252:	2300      	movs	r3, #0
}
34002254:	4618      	mov	r0, r3
34002256:	3714      	adds	r7, #20
34002258:	46bd      	mov	sp, r7
3400225a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400225e:	4770      	bx	lr

34002260 <MX25UM51245G_GetFlashInfo>:
  * @brief  Get Flash information
  * @param  pInfo pointer to information structure
  * @retval error status
  */
int32_t MX25UM51245G_GetFlashInfo(MX25UM51245G_Info_t *pInfo)
{
34002260:	b480      	push	{r7}
34002262:	b083      	sub	sp, #12
34002264:	af00      	add	r7, sp, #0
34002266:	6078      	str	r0, [r7, #4]
  /* Configure the structure with the memory configuration */
  pInfo->FlashSize              = MX25UM51245G_FLASH_SIZE;
34002268:	687b      	ldr	r3, [r7, #4]
3400226a:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
3400226e:	601a      	str	r2, [r3, #0]
  pInfo->EraseSectorSize        = MX25UM51245G_SECTOR_64K;
34002270:	687b      	ldr	r3, [r7, #4]
34002272:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34002276:	605a      	str	r2, [r3, #4]
  pInfo->EraseSectorsNumber     = (MX25UM51245G_FLASH_SIZE / MX25UM51245G_SECTOR_64K);
34002278:	687b      	ldr	r3, [r7, #4]
3400227a:	f44f 6280 	mov.w	r2, #1024	@ 0x400
3400227e:	609a      	str	r2, [r3, #8]
  pInfo->EraseSubSectorSize     = MX25UM51245G_SUBSECTOR_4K;
34002280:	687b      	ldr	r3, [r7, #4]
34002282:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34002286:	60da      	str	r2, [r3, #12]
  pInfo->EraseSubSectorNumber   = (MX25UM51245G_FLASH_SIZE / MX25UM51245G_SUBSECTOR_4K);
34002288:	687b      	ldr	r3, [r7, #4]
3400228a:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
3400228e:	611a      	str	r2, [r3, #16]
  pInfo->EraseSubSector1Size    = MX25UM51245G_SUBSECTOR_4K;
34002290:	687b      	ldr	r3, [r7, #4]
34002292:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34002296:	615a      	str	r2, [r3, #20]
  pInfo->EraseSubSector1Number  = (MX25UM51245G_FLASH_SIZE / MX25UM51245G_SUBSECTOR_4K);
34002298:	687b      	ldr	r3, [r7, #4]
3400229a:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
3400229e:	619a      	str	r2, [r3, #24]
  pInfo->ProgPageSize           = MX25UM51245G_PAGE_SIZE;
340022a0:	687b      	ldr	r3, [r7, #4]
340022a2:	f44f 7280 	mov.w	r2, #256	@ 0x100
340022a6:	61da      	str	r2, [r3, #28]
  pInfo->ProgPagesNumber        = (MX25UM51245G_FLASH_SIZE / MX25UM51245G_PAGE_SIZE);
340022a8:	687b      	ldr	r3, [r7, #4]
340022aa:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
340022ae:	621a      	str	r2, [r3, #32]

  return MX25UM51245G_OK;
340022b0:	2300      	movs	r3, #0
};
340022b2:	4618      	mov	r0, r3
340022b4:	370c      	adds	r7, #12
340022b6:	46bd      	mov	sp, r7
340022b8:	f85d 7b04 	ldr.w	r7, [sp], #4
340022bc:	4770      	bx	lr

340022be <MX25UM51245G_AutoPollingMemReady>:
  * @param  Rate Transfer rate
  * @retval error status
  */
int32_t MX25UM51245G_AutoPollingMemReady(XSPI_HandleTypeDef *Ctx, MX25UM51245G_Interface_t Mode,
                                         MX25UM51245G_Transfer_t Rate)
{
340022be:	b580      	push	{r7, lr}
340022c0:	b09a      	sub	sp, #104	@ 0x68
340022c2:	af00      	add	r7, sp, #0
340022c4:	6078      	str	r0, [r7, #4]
340022c6:	460b      	mov	r3, r1
340022c8:	70fb      	strb	r3, [r7, #3]
340022ca:	4613      	mov	r3, r2
340022cc:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef  s_command = {0};
340022ce:	f107 031c 	add.w	r3, r7, #28
340022d2:	224c      	movs	r2, #76	@ 0x4c
340022d4:	2100      	movs	r1, #0
340022d6:	4618      	mov	r0, r3
340022d8:	f01a fa68 	bl	3401c7ac <memset>
  XSPI_AutoPollingTypeDef s_config = {0};
340022dc:	f107 0308 	add.w	r3, r7, #8
340022e0:	2200      	movs	r2, #0
340022e2:	601a      	str	r2, [r3, #0]
340022e4:	605a      	str	r2, [r3, #4]
340022e6:	609a      	str	r2, [r3, #8]
340022e8:	60da      	str	r2, [r3, #12]
340022ea:	611a      	str	r2, [r3, #16]

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25UM51245G_SPI_MODE) && (Rate == MX25UM51245G_DTR_TRANSFER))
340022ec:	78fb      	ldrb	r3, [r7, #3]
340022ee:	2b00      	cmp	r3, #0
340022f0:	d105      	bne.n	340022fe <MX25UM51245G_AutoPollingMemReady+0x40>
340022f2:	78bb      	ldrb	r3, [r7, #2]
340022f4:	2b01      	cmp	r3, #1
340022f6:	d102      	bne.n	340022fe <MX25UM51245G_AutoPollingMemReady+0x40>
  {
    return MX25UM51245G_ERROR;
340022f8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
340022fc:	e08b      	b.n	34002416 <MX25UM51245G_AutoPollingMemReady+0x158>
  }

  /* Configure automatic polling mode to wait for memory ready */
  s_command.OperationType      = HAL_XSPI_OPTYPE_COMMON_CFG;
340022fe:	2300      	movs	r3, #0
34002300:	61fb      	str	r3, [r7, #28]
  s_command.IOSelect           = HAL_XSPI_SELECT_IO_7_0;
34002302:	2300      	movs	r3, #0
34002304:	623b      	str	r3, [r7, #32]
  s_command.InstructionMode    = (Mode == MX25UM51245G_SPI_MODE)
                                 ? HAL_XSPI_INSTRUCTION_1_LINE
                                 : HAL_XSPI_INSTRUCTION_8_LINES;
34002306:	78fb      	ldrb	r3, [r7, #3]
34002308:	2b00      	cmp	r3, #0
3400230a:	d101      	bne.n	34002310 <MX25UM51245G_AutoPollingMemReady+0x52>
3400230c:	2301      	movs	r3, #1
3400230e:	e000      	b.n	34002312 <MX25UM51245G_AutoPollingMemReady+0x54>
34002310:	2304      	movs	r3, #4
  s_command.InstructionMode    = (Mode == MX25UM51245G_SPI_MODE)
34002312:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionDTRMode = (Rate == MX25UM51245G_DTR_TRANSFER)
                                 ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                 : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002314:	78bb      	ldrb	r3, [r7, #2]
34002316:	2b01      	cmp	r3, #1
34002318:	d101      	bne.n	3400231e <MX25UM51245G_AutoPollingMemReady+0x60>
3400231a:	2308      	movs	r3, #8
3400231c:	e000      	b.n	34002320 <MX25UM51245G_AutoPollingMemReady+0x62>
3400231e:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX25UM51245G_DTR_TRANSFER)
34002320:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.InstructionWidth   = (Mode == MX25UM51245G_SPI_MODE)
                                 ? HAL_XSPI_INSTRUCTION_8_BITS
                                 : HAL_XSPI_INSTRUCTION_16_BITS;
34002322:	78fb      	ldrb	r3, [r7, #3]
34002324:	2b00      	cmp	r3, #0
34002326:	d101      	bne.n	3400232c <MX25UM51245G_AutoPollingMemReady+0x6e>
34002328:	2300      	movs	r3, #0
3400232a:	e000      	b.n	3400232e <MX25UM51245G_AutoPollingMemReady+0x70>
3400232c:	2310      	movs	r3, #16
  s_command.InstructionWidth   = (Mode == MX25UM51245G_SPI_MODE)
3400232e:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.Instruction        = (Mode == MX25UM51245G_SPI_MODE)
                                 ? MX25UM51245G_READ_STATUS_REG_CMD
                                 : MX25UM51245G_OCTA_READ_STATUS_REG_CMD;
34002330:	78fb      	ldrb	r3, [r7, #3]
34002332:	2b00      	cmp	r3, #0
34002334:	d101      	bne.n	3400233a <MX25UM51245G_AutoPollingMemReady+0x7c>
34002336:	2305      	movs	r3, #5
34002338:	e001      	b.n	3400233e <MX25UM51245G_AutoPollingMemReady+0x80>
3400233a:	f240 53fa 	movw	r3, #1530	@ 0x5fa
  s_command.Instruction        = (Mode == MX25UM51245G_SPI_MODE)
3400233e:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode        = (Mode == MX25UM51245G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
34002340:	78fb      	ldrb	r3, [r7, #3]
34002342:	2b00      	cmp	r3, #0
34002344:	d101      	bne.n	3400234a <MX25UM51245G_AutoPollingMemReady+0x8c>
34002346:	2300      	movs	r3, #0
34002348:	e001      	b.n	3400234e <MX25UM51245G_AutoPollingMemReady+0x90>
3400234a:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3400234e:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressDTRMode     = (Rate == MX25UM51245G_DTR_TRANSFER)
                                 ? HAL_XSPI_ADDRESS_DTR_ENABLE
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002350:	78bb      	ldrb	r3, [r7, #2]
34002352:	2b01      	cmp	r3, #1
34002354:	d102      	bne.n	3400235c <MX25UM51245G_AutoPollingMemReady+0x9e>
34002356:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3400235a:	e000      	b.n	3400235e <MX25UM51245G_AutoPollingMemReady+0xa0>
3400235c:	2300      	movs	r3, #0
  s_command.AddressDTRMode     = (Rate == MX25UM51245G_DTR_TRANSFER)
3400235e:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.AddressWidth       = HAL_XSPI_ADDRESS_32_BITS;
34002360:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34002364:	63fb      	str	r3, [r7, #60]	@ 0x3c
  s_command.Address            = 0U;
34002366:	2300      	movs	r3, #0
34002368:	637b      	str	r3, [r7, #52]	@ 0x34
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
3400236a:	2300      	movs	r3, #0
3400236c:	64bb      	str	r3, [r7, #72]	@ 0x48
  s_command.DataMode           = (Mode == MX25UM51245G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
3400236e:	78fb      	ldrb	r3, [r7, #3]
34002370:	2b00      	cmp	r3, #0
34002372:	d102      	bne.n	3400237a <MX25UM51245G_AutoPollingMemReady+0xbc>
34002374:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34002378:	e001      	b.n	3400237e <MX25UM51245G_AutoPollingMemReady+0xc0>
3400237a:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
3400237e:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataDTRMode        = (Rate == MX25UM51245G_DTR_TRANSFER)
                                 ? HAL_XSPI_DATA_DTR_ENABLE
                                 : HAL_XSPI_DATA_DTR_DISABLE;
34002380:	78bb      	ldrb	r3, [r7, #2]
34002382:	2b01      	cmp	r3, #1
34002384:	d102      	bne.n	3400238c <MX25UM51245G_AutoPollingMemReady+0xce>
34002386:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
3400238a:	e000      	b.n	3400238e <MX25UM51245G_AutoPollingMemReady+0xd0>
3400238c:	2300      	movs	r3, #0
  s_command.DataDTRMode        = (Rate == MX25UM51245G_DTR_TRANSFER)
3400238e:	65fb      	str	r3, [r7, #92]	@ 0x5c
  s_command.DummyCycles        = (Mode == MX25UM51245G_SPI_MODE)
                                 ? 0U
                                 : ((Rate == MX25UM51245G_DTR_TRANSFER)
34002390:	78fb      	ldrb	r3, [r7, #3]
34002392:	2b00      	cmp	r3, #0
34002394:	d006      	beq.n	340023a4 <MX25UM51245G_AutoPollingMemReady+0xe6>
34002396:	78bb      	ldrb	r3, [r7, #2]
34002398:	2b01      	cmp	r3, #1
3400239a:	d101      	bne.n	340023a0 <MX25UM51245G_AutoPollingMemReady+0xe2>
3400239c:	2305      	movs	r3, #5
3400239e:	e002      	b.n	340023a6 <MX25UM51245G_AutoPollingMemReady+0xe8>
340023a0:	2304      	movs	r3, #4
340023a2:	e000      	b.n	340023a6 <MX25UM51245G_AutoPollingMemReady+0xe8>
340023a4:	2300      	movs	r3, #0
  s_command.DummyCycles        = (Mode == MX25UM51245G_SPI_MODE)
340023a6:	663b      	str	r3, [r7, #96]	@ 0x60
                                    ? DUMMY_CYCLES_REG_OCTAL_DTR
                                    : DUMMY_CYCLES_REG_OCTAL);
  s_command.DataLength         = (Rate == MX25UM51245G_DTR_TRANSFER) ? 2U : 1U;
340023a8:	78bb      	ldrb	r3, [r7, #2]
340023aa:	2b01      	cmp	r3, #1
340023ac:	d101      	bne.n	340023b2 <MX25UM51245G_AutoPollingMemReady+0xf4>
340023ae:	2302      	movs	r3, #2
340023b0:	e000      	b.n	340023b4 <MX25UM51245G_AutoPollingMemReady+0xf6>
340023b2:	2301      	movs	r3, #1
340023b4:	65bb      	str	r3, [r7, #88]	@ 0x58
  s_command.DQSMode            = (Rate == MX25UM51245G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
340023b6:	78bb      	ldrb	r3, [r7, #2]
340023b8:	2b01      	cmp	r3, #1
340023ba:	d102      	bne.n	340023c2 <MX25UM51245G_AutoPollingMemReady+0x104>
340023bc:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
340023c0:	e000      	b.n	340023c4 <MX25UM51245G_AutoPollingMemReady+0x106>
340023c2:	2300      	movs	r3, #0
340023c4:	667b      	str	r3, [r7, #100]	@ 0x64
#if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode           = HAL_XSPI_SIOO_INST_EVERY_CMD;
#endif

  s_config.MatchValue    = 0U;
340023c6:	2300      	movs	r3, #0
340023c8:	60bb      	str	r3, [r7, #8]
  s_config.MatchMask     = MX25UM51245G_SR_WIP;
340023ca:	2301      	movs	r3, #1
340023cc:	60fb      	str	r3, [r7, #12]
  s_config.MatchMode     = HAL_XSPI_MATCH_MODE_AND;
340023ce:	2300      	movs	r3, #0
340023d0:	613b      	str	r3, [r7, #16]
  s_config.IntervalTime  = MX25UM51245G_AUTOPOLLING_INTERVAL_TIME;
340023d2:	2310      	movs	r3, #16
340023d4:	61bb      	str	r3, [r7, #24]
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
340023d6:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
340023da:	617b      	str	r3, [r7, #20]

  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340023dc:	f107 031c 	add.w	r3, r7, #28
340023e0:	f241 3288 	movw	r2, #5000	@ 0x1388
340023e4:	4619      	mov	r1, r3
340023e6:	6878      	ldr	r0, [r7, #4]
340023e8:	f014 ff00 	bl	340171ec <HAL_XSPI_Command>
340023ec:	4603      	mov	r3, r0
340023ee:	2b00      	cmp	r3, #0
340023f0:	d002      	beq.n	340023f8 <MX25UM51245G_AutoPollingMemReady+0x13a>
  {
    return MX25UM51245G_ERROR;
340023f2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
340023f6:	e00e      	b.n	34002416 <MX25UM51245G_AutoPollingMemReady+0x158>
  }

  if (HAL_XSPI_AutoPolling(Ctx, &s_config, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340023f8:	f107 0308 	add.w	r3, r7, #8
340023fc:	f241 3288 	movw	r2, #5000	@ 0x1388
34002400:	4619      	mov	r1, r3
34002402:	6878      	ldr	r0, [r7, #4]
34002404:	f015 fa1a 	bl	3401783c <HAL_XSPI_AutoPolling>
34002408:	4603      	mov	r3, r0
3400240a:	2b00      	cmp	r3, #0
3400240c:	d002      	beq.n	34002414 <MX25UM51245G_AutoPollingMemReady+0x156>
  {
    return MX25UM51245G_ERROR;
3400240e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
34002412:	e000      	b.n	34002416 <MX25UM51245G_AutoPollingMemReady+0x158>
  }

  return MX25UM51245G_OK;
34002414:	2300      	movs	r3, #0
}
34002416:	4618      	mov	r0, r3
34002418:	3768      	adds	r7, #104	@ 0x68
3400241a:	46bd      	mov	sp, r7
3400241c:	bd80      	pop	{r7, pc}

3400241e <MX25UM51245G_EnableSTRMemoryMappedMode>:
  * @param  AddressSize Address size
  * @retval Memory status
  */
int32_t MX25UM51245G_EnableSTRMemoryMappedMode(XSPI_HandleTypeDef *Ctx, MX25UM51245G_Interface_t Mode,
                                               MX25UM51245G_AddressSize_t AddressSize)
{
3400241e:	b580      	push	{r7, lr}
34002420:	b09a      	sub	sp, #104	@ 0x68
34002422:	af00      	add	r7, sp, #0
34002424:	6078      	str	r0, [r7, #4]
34002426:	460b      	mov	r3, r1
34002428:	70fb      	strb	r3, [r7, #3]
3400242a:	4613      	mov	r3, r2
3400242c:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef      s_command = {0};
3400242e:	f107 031c 	add.w	r3, r7, #28
34002432:	224c      	movs	r2, #76	@ 0x4c
34002434:	2100      	movs	r1, #0
34002436:	4618      	mov	r0, r3
34002438:	f01a f9b8 	bl	3401c7ac <memset>
  XSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
3400243c:	f107 030c 	add.w	r3, r7, #12
34002440:	2200      	movs	r2, #0
34002442:	601a      	str	r2, [r3, #0]
34002444:	605a      	str	r2, [r3, #4]
34002446:	609a      	str	r2, [r3, #8]
34002448:	60da      	str	r2, [r3, #12]

  /* OPI mode and 3-bytes address size not supported by memory */
  if ((Mode == MX25UM51245G_OPI_MODE) && (AddressSize == MX25UM51245G_3BYTES_SIZE))
3400244a:	78fb      	ldrb	r3, [r7, #3]
3400244c:	2b01      	cmp	r3, #1
3400244e:	d105      	bne.n	3400245c <MX25UM51245G_EnableSTRMemoryMappedMode+0x3e>
34002450:	78bb      	ldrb	r3, [r7, #2]
34002452:	2b00      	cmp	r3, #0
34002454:	d102      	bne.n	3400245c <MX25UM51245G_EnableSTRMemoryMappedMode+0x3e>
  {
    return MX25UM51245G_ERROR;
34002456:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
3400245a:	e086      	b.n	3400256a <MX25UM51245G_EnableSTRMemoryMappedMode+0x14c>
  }

  /* Initialize the read command */
  s_command.OperationType      = HAL_XSPI_OPTYPE_READ_CFG;
3400245c:	2301      	movs	r3, #1
3400245e:	61fb      	str	r3, [r7, #28]
  s_command.IOSelect           = HAL_XSPI_SELECT_IO_7_0;
34002460:	2300      	movs	r3, #0
34002462:	623b      	str	r3, [r7, #32]
  s_command.InstructionMode    = (Mode == MX25UM51245G_SPI_MODE)
                                 ? HAL_XSPI_INSTRUCTION_1_LINE
                                 : HAL_XSPI_INSTRUCTION_8_LINES;
34002464:	78fb      	ldrb	r3, [r7, #3]
34002466:	2b00      	cmp	r3, #0
34002468:	d101      	bne.n	3400246e <MX25UM51245G_EnableSTRMemoryMappedMode+0x50>
3400246a:	2301      	movs	r3, #1
3400246c:	e000      	b.n	34002470 <MX25UM51245G_EnableSTRMemoryMappedMode+0x52>
3400246e:	2304      	movs	r3, #4
  s_command.InstructionMode    = (Mode == MX25UM51245G_SPI_MODE)
34002470:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002472:	2300      	movs	r3, #0
34002474:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.InstructionWidth   = (Mode == MX25UM51245G_SPI_MODE)
                                 ? HAL_XSPI_INSTRUCTION_8_BITS
                                 : HAL_XSPI_INSTRUCTION_16_BITS;
34002476:	78fb      	ldrb	r3, [r7, #3]
34002478:	2b00      	cmp	r3, #0
3400247a:	d101      	bne.n	34002480 <MX25UM51245G_EnableSTRMemoryMappedMode+0x62>
3400247c:	2300      	movs	r3, #0
3400247e:	e000      	b.n	34002482 <MX25UM51245G_EnableSTRMemoryMappedMode+0x64>
34002480:	2310      	movs	r3, #16
  s_command.InstructionWidth   = (Mode == MX25UM51245G_SPI_MODE)
34002482:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.Instruction        = (Mode == MX25UM51245G_SPI_MODE)
                                 ? ((AddressSize == MX25UM51245G_3BYTES_SIZE)
                                    ? MX25UM51245G_FAST_READ_CMD
                                    : MX25UM51245G_4_BYTE_ADDR_FAST_READ_CMD)
                                 : MX25UM51245G_OCTA_READ_CMD;
34002484:	78fb      	ldrb	r3, [r7, #3]
34002486:	2b00      	cmp	r3, #0
34002488:	d106      	bne.n	34002498 <MX25UM51245G_EnableSTRMemoryMappedMode+0x7a>
3400248a:	78bb      	ldrb	r3, [r7, #2]
3400248c:	2b00      	cmp	r3, #0
3400248e:	d101      	bne.n	34002494 <MX25UM51245G_EnableSTRMemoryMappedMode+0x76>
34002490:	230b      	movs	r3, #11
34002492:	e003      	b.n	3400249c <MX25UM51245G_EnableSTRMemoryMappedMode+0x7e>
34002494:	230c      	movs	r3, #12
34002496:	e001      	b.n	3400249c <MX25UM51245G_EnableSTRMemoryMappedMode+0x7e>
34002498:	f64e 4313 	movw	r3, #60435	@ 0xec13
  s_command.Instruction        = (Mode == MX25UM51245G_SPI_MODE)
3400249c:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode        = (Mode == MX25UM51245G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
3400249e:	78fb      	ldrb	r3, [r7, #3]
340024a0:	2b00      	cmp	r3, #0
340024a2:	d102      	bne.n	340024aa <MX25UM51245G_EnableSTRMemoryMappedMode+0x8c>
340024a4:	f44f 7380 	mov.w	r3, #256	@ 0x100
340024a8:	e001      	b.n	340024ae <MX25UM51245G_EnableSTRMemoryMappedMode+0x90>
340024aa:	f44f 6380 	mov.w	r3, #1024	@ 0x400
340024ae:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressDTRMode     = HAL_XSPI_ADDRESS_DTR_DISABLE;
340024b0:	2300      	movs	r3, #0
340024b2:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.AddressWidth       = (AddressSize == MX25UM51245G_3BYTES_SIZE)
                                 ? HAL_XSPI_ADDRESS_24_BITS
                                 : HAL_XSPI_ADDRESS_32_BITS;
340024b4:	78bb      	ldrb	r3, [r7, #2]
340024b6:	2b00      	cmp	r3, #0
340024b8:	d102      	bne.n	340024c0 <MX25UM51245G_EnableSTRMemoryMappedMode+0xa2>
340024ba:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
340024be:	e001      	b.n	340024c4 <MX25UM51245G_EnableSTRMemoryMappedMode+0xa6>
340024c0:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
  s_command.AddressWidth       = (AddressSize == MX25UM51245G_3BYTES_SIZE)
340024c4:	63fb      	str	r3, [r7, #60]	@ 0x3c
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
340024c6:	2300      	movs	r3, #0
340024c8:	64bb      	str	r3, [r7, #72]	@ 0x48
  s_command.DataMode           = (Mode == MX25UM51245G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
340024ca:	78fb      	ldrb	r3, [r7, #3]
340024cc:	2b00      	cmp	r3, #0
340024ce:	d102      	bne.n	340024d6 <MX25UM51245G_EnableSTRMemoryMappedMode+0xb8>
340024d0:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
340024d4:	e001      	b.n	340024da <MX25UM51245G_EnableSTRMemoryMappedMode+0xbc>
340024d6:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
340024da:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataDTRMode        = HAL_XSPI_DATA_DTR_DISABLE;
340024dc:	2300      	movs	r3, #0
340024de:	65fb      	str	r3, [r7, #92]	@ 0x5c
  s_command.DummyCycles        = (Mode == MX25UM51245G_SPI_MODE) ? DUMMY_CYCLES_READ : DUMMY_CYCLES_READ_OCTAL;
340024e0:	78fb      	ldrb	r3, [r7, #3]
340024e2:	2b00      	cmp	r3, #0
340024e4:	d101      	bne.n	340024ea <MX25UM51245G_EnableSTRMemoryMappedMode+0xcc>
340024e6:	2308      	movs	r3, #8
340024e8:	e000      	b.n	340024ec <MX25UM51245G_EnableSTRMemoryMappedMode+0xce>
340024ea:	2306      	movs	r3, #6
340024ec:	663b      	str	r3, [r7, #96]	@ 0x60
  s_command.DQSMode            = HAL_XSPI_DQS_DISABLE;
340024ee:	2300      	movs	r3, #0
340024f0:	667b      	str	r3, [r7, #100]	@ 0x64
#if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode           = HAL_XSPI_SIOO_INST_EVERY_CMD;
#endif

  /* Send the read command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340024f2:	f107 031c 	add.w	r3, r7, #28
340024f6:	f241 3288 	movw	r2, #5000	@ 0x1388
340024fa:	4619      	mov	r1, r3
340024fc:	6878      	ldr	r0, [r7, #4]
340024fe:	f014 fe75 	bl	340171ec <HAL_XSPI_Command>
34002502:	4603      	mov	r3, r0
34002504:	2b00      	cmp	r3, #0
34002506:	d002      	beq.n	3400250e <MX25UM51245G_EnableSTRMemoryMappedMode+0xf0>
  {
    return MX25UM51245G_ERROR;
34002508:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
3400250c:	e02d      	b.n	3400256a <MX25UM51245G_EnableSTRMemoryMappedMode+0x14c>
  }

  /* Initialize the program command */
  s_command.OperationType      = HAL_XSPI_OPTYPE_WRITE_CFG;
3400250e:	2302      	movs	r3, #2
34002510:	61fb      	str	r3, [r7, #28]
  s_command.Instruction        = (Mode == MX25UM51245G_SPI_MODE)
                                 ? ((AddressSize == MX25UM51245G_3BYTES_SIZE)
                                    ? MX25UM51245G_PAGE_PROG_CMD
                                    : MX25UM51245G_4_BYTE_PAGE_PROG_CMD)
                                 : MX25UM51245G_OCTA_PAGE_PROG_CMD;
34002512:	78fb      	ldrb	r3, [r7, #3]
34002514:	2b00      	cmp	r3, #0
34002516:	d106      	bne.n	34002526 <MX25UM51245G_EnableSTRMemoryMappedMode+0x108>
34002518:	78bb      	ldrb	r3, [r7, #2]
3400251a:	2b00      	cmp	r3, #0
3400251c:	d101      	bne.n	34002522 <MX25UM51245G_EnableSTRMemoryMappedMode+0x104>
3400251e:	2302      	movs	r3, #2
34002520:	e003      	b.n	3400252a <MX25UM51245G_EnableSTRMemoryMappedMode+0x10c>
34002522:	2312      	movs	r3, #18
34002524:	e001      	b.n	3400252a <MX25UM51245G_EnableSTRMemoryMappedMode+0x10c>
34002526:	f241 23ed 	movw	r3, #4845	@ 0x12ed
  s_command.Instruction        = (Mode == MX25UM51245G_SPI_MODE)
3400252a:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.DummyCycles        = 0U;
3400252c:	2300      	movs	r3, #0
3400252e:	663b      	str	r3, [r7, #96]	@ 0x60

  /* Send the write command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002530:	f107 031c 	add.w	r3, r7, #28
34002534:	f241 3288 	movw	r2, #5000	@ 0x1388
34002538:	4619      	mov	r1, r3
3400253a:	6878      	ldr	r0, [r7, #4]
3400253c:	f014 fe56 	bl	340171ec <HAL_XSPI_Command>
34002540:	4603      	mov	r3, r0
34002542:	2b00      	cmp	r3, #0
34002544:	d002      	beq.n	3400254c <MX25UM51245G_EnableSTRMemoryMappedMode+0x12e>
  {
    return MX25UM51245G_ERROR;
34002546:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
3400254a:	e00e      	b.n	3400256a <MX25UM51245G_EnableSTRMemoryMappedMode+0x14c>
  }

  /* Configure the memory mapped mode */
  s_mem_mapped_cfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
3400254c:	2300      	movs	r3, #0
3400254e:	60fb      	str	r3, [r7, #12]

  if (HAL_XSPI_MemoryMapped(Ctx, &s_mem_mapped_cfg) != HAL_OK)
34002550:	f107 030c 	add.w	r3, r7, #12
34002554:	4619      	mov	r1, r3
34002556:	6878      	ldr	r0, [r7, #4]
34002558:	f015 fa3a 	bl	340179d0 <HAL_XSPI_MemoryMapped>
3400255c:	4603      	mov	r3, r0
3400255e:	2b00      	cmp	r3, #0
34002560:	d002      	beq.n	34002568 <MX25UM51245G_EnableSTRMemoryMappedMode+0x14a>
  {
    return MX25UM51245G_ERROR;
34002562:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
34002566:	e000      	b.n	3400256a <MX25UM51245G_EnableSTRMemoryMappedMode+0x14c>
  }

  return MX25UM51245G_OK;
34002568:	2300      	movs	r3, #0
}
3400256a:	4618      	mov	r0, r3
3400256c:	3768      	adds	r7, #104	@ 0x68
3400256e:	46bd      	mov	sp, r7
34002570:	bd80      	pop	{r7, pc}

34002572 <MX25UM51245G_EnableDTRMemoryMappedMode>:
  * @param  AddressSize Address size
  * @note   Only OPI mode support DTR transfer rate
  * @retval Memory status
  */
int32_t MX25UM51245G_EnableDTRMemoryMappedMode(XSPI_HandleTypeDef *Ctx, MX25UM51245G_Interface_t Mode)
{
34002572:	b580      	push	{r7, lr}
34002574:	b09a      	sub	sp, #104	@ 0x68
34002576:	af00      	add	r7, sp, #0
34002578:	6078      	str	r0, [r7, #4]
3400257a:	460b      	mov	r3, r1
3400257c:	70fb      	strb	r3, [r7, #3]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Mode);

  XSPI_RegularCmdTypeDef      s_command = {0};
3400257e:	f107 031c 	add.w	r3, r7, #28
34002582:	224c      	movs	r2, #76	@ 0x4c
34002584:	2100      	movs	r1, #0
34002586:	4618      	mov	r0, r3
34002588:	f01a f910 	bl	3401c7ac <memset>
  XSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
3400258c:	f107 030c 	add.w	r3, r7, #12
34002590:	2200      	movs	r2, #0
34002592:	601a      	str	r2, [r3, #0]
34002594:	605a      	str	r2, [r3, #4]
34002596:	609a      	str	r2, [r3, #8]
34002598:	60da      	str	r2, [r3, #12]

  /* Initialize the read command */
  s_command.OperationType      = HAL_XSPI_OPTYPE_READ_CFG;
3400259a:	2301      	movs	r3, #1
3400259c:	61fb      	str	r3, [r7, #28]
  s_command.IOSelect           = HAL_XSPI_SELECT_IO_7_0;
3400259e:	2300      	movs	r3, #0
340025a0:	623b      	str	r3, [r7, #32]
  s_command.InstructionMode    = HAL_XSPI_INSTRUCTION_8_LINES;
340025a2:	2304      	movs	r3, #4
340025a4:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_ENABLE;
340025a6:	2308      	movs	r3, #8
340025a8:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.InstructionWidth   = HAL_XSPI_INSTRUCTION_16_BITS;
340025aa:	2310      	movs	r3, #16
340025ac:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.Instruction        = MX25UM51245G_OCTA_READ_DTR_CMD;
340025ae:	f64e 6311 	movw	r3, #60945	@ 0xee11
340025b2:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode        = HAL_XSPI_ADDRESS_8_LINES;
340025b4:	f44f 6380 	mov.w	r3, #1024	@ 0x400
340025b8:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressDTRMode     = HAL_XSPI_ADDRESS_DTR_ENABLE;
340025ba:	f44f 6300 	mov.w	r3, #2048	@ 0x800
340025be:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.AddressWidth       = HAL_XSPI_ADDRESS_32_BITS;
340025c0:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
340025c4:	63fb      	str	r3, [r7, #60]	@ 0x3c
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
340025c6:	2300      	movs	r3, #0
340025c8:	64bb      	str	r3, [r7, #72]	@ 0x48
  s_command.DataMode           = HAL_XSPI_DATA_8_LINES;
340025ca:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
340025ce:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataDTRMode        = HAL_XSPI_DATA_DTR_ENABLE;
340025d0:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
340025d4:	65fb      	str	r3, [r7, #92]	@ 0x5c
  s_command.DummyCycles        = DUMMY_CYCLES_READ_OCTAL_DTR;
340025d6:	2306      	movs	r3, #6
340025d8:	663b      	str	r3, [r7, #96]	@ 0x60
  s_command.DQSMode            = HAL_XSPI_DQS_ENABLE;
340025da:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
340025de:	667b      	str	r3, [r7, #100]	@ 0x64
#if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode           = HAL_XSPI_SIOO_INST_EVERY_CMD;
#endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340025e0:	f107 031c 	add.w	r3, r7, #28
340025e4:	f241 3288 	movw	r2, #5000	@ 0x1388
340025e8:	4619      	mov	r1, r3
340025ea:	6878      	ldr	r0, [r7, #4]
340025ec:	f014 fdfe 	bl	340171ec <HAL_XSPI_Command>
340025f0:	4603      	mov	r3, r0
340025f2:	2b00      	cmp	r3, #0
340025f4:	d002      	beq.n	340025fc <MX25UM51245G_EnableDTRMemoryMappedMode+0x8a>
  {
    return MX25UM51245G_ERROR;
340025f6:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
340025fa:	e025      	b.n	34002648 <MX25UM51245G_EnableDTRMemoryMappedMode+0xd6>
  }

  /* Initialize the program command */
  s_command.OperationType = HAL_XSPI_OPTYPE_WRITE_CFG;
340025fc:	2302      	movs	r3, #2
340025fe:	61fb      	str	r3, [r7, #28]
  s_command.Instruction   = MX25UM51245G_OCTA_PAGE_PROG_CMD;
34002600:	f241 23ed 	movw	r3, #4845	@ 0x12ed
34002604:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.DummyCycles   = 0U;
34002606:	2300      	movs	r3, #0
34002608:	663b      	str	r3, [r7, #96]	@ 0x60
  s_command.DQSMode       = HAL_XSPI_DQS_DISABLE;
3400260a:	2300      	movs	r3, #0
3400260c:	667b      	str	r3, [r7, #100]	@ 0x64

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3400260e:	f107 031c 	add.w	r3, r7, #28
34002612:	f241 3288 	movw	r2, #5000	@ 0x1388
34002616:	4619      	mov	r1, r3
34002618:	6878      	ldr	r0, [r7, #4]
3400261a:	f014 fde7 	bl	340171ec <HAL_XSPI_Command>
3400261e:	4603      	mov	r3, r0
34002620:	2b00      	cmp	r3, #0
34002622:	d002      	beq.n	3400262a <MX25UM51245G_EnableDTRMemoryMappedMode+0xb8>
  {
    return MX25UM51245G_ERROR;
34002624:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
34002628:	e00e      	b.n	34002648 <MX25UM51245G_EnableDTRMemoryMappedMode+0xd6>
  }
  /* Configure the memory mapped mode */
  s_mem_mapped_cfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
3400262a:	2300      	movs	r3, #0
3400262c:	60fb      	str	r3, [r7, #12]

  if (HAL_XSPI_MemoryMapped(Ctx, &s_mem_mapped_cfg) != HAL_OK)
3400262e:	f107 030c 	add.w	r3, r7, #12
34002632:	4619      	mov	r1, r3
34002634:	6878      	ldr	r0, [r7, #4]
34002636:	f015 f9cb 	bl	340179d0 <HAL_XSPI_MemoryMapped>
3400263a:	4603      	mov	r3, r0
3400263c:	2b00      	cmp	r3, #0
3400263e:	d002      	beq.n	34002646 <MX25UM51245G_EnableDTRMemoryMappedMode+0xd4>
  {
    return MX25UM51245G_ERROR;
34002640:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
34002644:	e000      	b.n	34002648 <MX25UM51245G_EnableDTRMemoryMappedMode+0xd6>
  }

  return MX25UM51245G_OK;
34002646:	2300      	movs	r3, #0
}
34002648:	4618      	mov	r0, r3
3400264a:	3768      	adds	r7, #104	@ 0x68
3400264c:	46bd      	mov	sp, r7
3400264e:	bd80      	pop	{r7, pc}

34002650 <MX25UM51245G_WriteEnable>:
  * @param  Mode Interface mode
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX25UM51245G_WriteEnable(XSPI_HandleTypeDef *Ctx, MX25UM51245G_Interface_t Mode, MX25UM51245G_Transfer_t Rate)
{
34002650:	b580      	push	{r7, lr}
34002652:	b09a      	sub	sp, #104	@ 0x68
34002654:	af00      	add	r7, sp, #0
34002656:	6078      	str	r0, [r7, #4]
34002658:	460b      	mov	r3, r1
3400265a:	70fb      	strb	r3, [r7, #3]
3400265c:	4613      	mov	r3, r2
3400265e:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef     s_command = {0};
34002660:	f107 031c 	add.w	r3, r7, #28
34002664:	224c      	movs	r2, #76	@ 0x4c
34002666:	2100      	movs	r1, #0
34002668:	4618      	mov	r0, r3
3400266a:	f01a f89f 	bl	3401c7ac <memset>
  XSPI_AutoPollingTypeDef s_config = {0};
3400266e:	f107 0308 	add.w	r3, r7, #8
34002672:	2200      	movs	r2, #0
34002674:	601a      	str	r2, [r3, #0]
34002676:	605a      	str	r2, [r3, #4]
34002678:	609a      	str	r2, [r3, #8]
3400267a:	60da      	str	r2, [r3, #12]
3400267c:	611a      	str	r2, [r3, #16]

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25UM51245G_SPI_MODE) && (Rate == MX25UM51245G_DTR_TRANSFER))
3400267e:	78fb      	ldrb	r3, [r7, #3]
34002680:	2b00      	cmp	r3, #0
34002682:	d105      	bne.n	34002690 <MX25UM51245G_WriteEnable+0x40>
34002684:	78bb      	ldrb	r3, [r7, #2]
34002686:	2b01      	cmp	r3, #1
34002688:	d102      	bne.n	34002690 <MX25UM51245G_WriteEnable+0x40>
  {
    return MX25UM51245G_ERROR;
3400268a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
3400268e:	e0a9      	b.n	340027e4 <MX25UM51245G_WriteEnable+0x194>
  }

  /* Initialize the write enable command */
  s_command.OperationType      = HAL_XSPI_OPTYPE_COMMON_CFG;
34002690:	2300      	movs	r3, #0
34002692:	61fb      	str	r3, [r7, #28]
  s_command.IOSelect           = HAL_XSPI_SELECT_IO_7_0;
34002694:	2300      	movs	r3, #0
34002696:	623b      	str	r3, [r7, #32]
  s_command.InstructionMode    = (Mode == MX25UM51245G_SPI_MODE)
                                 ? HAL_XSPI_INSTRUCTION_1_LINE
                                 : HAL_XSPI_INSTRUCTION_8_LINES;
34002698:	78fb      	ldrb	r3, [r7, #3]
3400269a:	2b00      	cmp	r3, #0
3400269c:	d101      	bne.n	340026a2 <MX25UM51245G_WriteEnable+0x52>
3400269e:	2301      	movs	r3, #1
340026a0:	e000      	b.n	340026a4 <MX25UM51245G_WriteEnable+0x54>
340026a2:	2304      	movs	r3, #4
  s_command.InstructionMode    = (Mode == MX25UM51245G_SPI_MODE)
340026a4:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionDTRMode = (Rate == MX25UM51245G_DTR_TRANSFER)
                                 ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                 : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
340026a6:	78bb      	ldrb	r3, [r7, #2]
340026a8:	2b01      	cmp	r3, #1
340026aa:	d101      	bne.n	340026b0 <MX25UM51245G_WriteEnable+0x60>
340026ac:	2308      	movs	r3, #8
340026ae:	e000      	b.n	340026b2 <MX25UM51245G_WriteEnable+0x62>
340026b0:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX25UM51245G_DTR_TRANSFER)
340026b2:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.InstructionWidth   = (Mode == MX25UM51245G_SPI_MODE)
                                 ? HAL_XSPI_INSTRUCTION_8_BITS
                                 : HAL_XSPI_INSTRUCTION_16_BITS;
340026b4:	78fb      	ldrb	r3, [r7, #3]
340026b6:	2b00      	cmp	r3, #0
340026b8:	d101      	bne.n	340026be <MX25UM51245G_WriteEnable+0x6e>
340026ba:	2300      	movs	r3, #0
340026bc:	e000      	b.n	340026c0 <MX25UM51245G_WriteEnable+0x70>
340026be:	2310      	movs	r3, #16
  s_command.InstructionWidth   = (Mode == MX25UM51245G_SPI_MODE)
340026c0:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.Instruction        = (Mode == MX25UM51245G_SPI_MODE)
                                 ? MX25UM51245G_WRITE_ENABLE_CMD
                                 : MX25UM51245G_OCTA_WRITE_ENABLE_CMD;
340026c2:	78fb      	ldrb	r3, [r7, #3]
340026c4:	2b00      	cmp	r3, #0
340026c6:	d101      	bne.n	340026cc <MX25UM51245G_WriteEnable+0x7c>
340026c8:	2306      	movs	r3, #6
340026ca:	e001      	b.n	340026d0 <MX25UM51245G_WriteEnable+0x80>
340026cc:	f240 63f9 	movw	r3, #1785	@ 0x6f9
  s_command.Instruction        = (Mode == MX25UM51245G_SPI_MODE)
340026d0:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode        = HAL_XSPI_ADDRESS_NONE;
340026d2:	2300      	movs	r3, #0
340026d4:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
340026d6:	2300      	movs	r3, #0
340026d8:	64bb      	str	r3, [r7, #72]	@ 0x48
  s_command.DataMode           = HAL_XSPI_DATA_NONE;
340026da:	2300      	movs	r3, #0
340026dc:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DummyCycles        = 0U;
340026de:	2300      	movs	r3, #0
340026e0:	663b      	str	r3, [r7, #96]	@ 0x60
  s_command.DQSMode            = HAL_XSPI_DQS_DISABLE;
340026e2:	2300      	movs	r3, #0
340026e4:	667b      	str	r3, [r7, #100]	@ 0x64
#if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode           = HAL_XSPI_SIOO_INST_EVERY_CMD;
#endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340026e6:	f107 031c 	add.w	r3, r7, #28
340026ea:	f241 3288 	movw	r2, #5000	@ 0x1388
340026ee:	4619      	mov	r1, r3
340026f0:	6878      	ldr	r0, [r7, #4]
340026f2:	f014 fd7b 	bl	340171ec <HAL_XSPI_Command>
340026f6:	4603      	mov	r3, r0
340026f8:	2b00      	cmp	r3, #0
340026fa:	d002      	beq.n	34002702 <MX25UM51245G_WriteEnable+0xb2>
  {
    return MX25UM51245G_ERROR;
340026fc:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
34002700:	e070      	b.n	340027e4 <MX25UM51245G_WriteEnable+0x194>
  }

  /* Configure automatic polling mode to wait for write enabling */
  s_command.Instruction    = (Mode == MX25UM51245G_SPI_MODE)
                             ? MX25UM51245G_READ_STATUS_REG_CMD
                             : MX25UM51245G_OCTA_READ_STATUS_REG_CMD;
34002702:	78fb      	ldrb	r3, [r7, #3]
34002704:	2b00      	cmp	r3, #0
34002706:	d101      	bne.n	3400270c <MX25UM51245G_WriteEnable+0xbc>
34002708:	2305      	movs	r3, #5
3400270a:	e001      	b.n	34002710 <MX25UM51245G_WriteEnable+0xc0>
3400270c:	f240 53fa 	movw	r3, #1530	@ 0x5fa
  s_command.Instruction    = (Mode == MX25UM51245G_SPI_MODE)
34002710:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode    = (Mode == MX25UM51245G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
34002712:	78fb      	ldrb	r3, [r7, #3]
34002714:	2b00      	cmp	r3, #0
34002716:	d101      	bne.n	3400271c <MX25UM51245G_WriteEnable+0xcc>
34002718:	2300      	movs	r3, #0
3400271a:	e001      	b.n	34002720 <MX25UM51245G_WriteEnable+0xd0>
3400271c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34002720:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressDTRMode = (Rate == MX25UM51245G_DTR_TRANSFER)
                             ? HAL_XSPI_ADDRESS_DTR_ENABLE
                             : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002722:	78bb      	ldrb	r3, [r7, #2]
34002724:	2b01      	cmp	r3, #1
34002726:	d102      	bne.n	3400272e <MX25UM51245G_WriteEnable+0xde>
34002728:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3400272c:	e000      	b.n	34002730 <MX25UM51245G_WriteEnable+0xe0>
3400272e:	2300      	movs	r3, #0
  s_command.AddressDTRMode = (Rate == MX25UM51245G_DTR_TRANSFER)
34002730:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.AddressWidth   = HAL_XSPI_ADDRESS_32_BITS;
34002732:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34002736:	63fb      	str	r3, [r7, #60]	@ 0x3c
  s_command.Address        = 0U;
34002738:	2300      	movs	r3, #0
3400273a:	637b      	str	r3, [r7, #52]	@ 0x34
  s_command.DataMode       = (Mode == MX25UM51245G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
3400273c:	78fb      	ldrb	r3, [r7, #3]
3400273e:	2b00      	cmp	r3, #0
34002740:	d102      	bne.n	34002748 <MX25UM51245G_WriteEnable+0xf8>
34002742:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34002746:	e001      	b.n	3400274c <MX25UM51245G_WriteEnable+0xfc>
34002748:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
3400274c:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataDTRMode    = (Rate == MX25UM51245G_DTR_TRANSFER) ? HAL_XSPI_DATA_DTR_ENABLE : HAL_XSPI_DATA_DTR_DISABLE;
3400274e:	78bb      	ldrb	r3, [r7, #2]
34002750:	2b01      	cmp	r3, #1
34002752:	d102      	bne.n	3400275a <MX25UM51245G_WriteEnable+0x10a>
34002754:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
34002758:	e000      	b.n	3400275c <MX25UM51245G_WriteEnable+0x10c>
3400275a:	2300      	movs	r3, #0
3400275c:	65fb      	str	r3, [r7, #92]	@ 0x5c
  s_command.DummyCycles    = (Mode == MX25UM51245G_SPI_MODE)
                             ? 0U
                             : ((Rate == MX25UM51245G_DTR_TRANSFER)
3400275e:	78fb      	ldrb	r3, [r7, #3]
34002760:	2b00      	cmp	r3, #0
34002762:	d006      	beq.n	34002772 <MX25UM51245G_WriteEnable+0x122>
34002764:	78bb      	ldrb	r3, [r7, #2]
34002766:	2b01      	cmp	r3, #1
34002768:	d101      	bne.n	3400276e <MX25UM51245G_WriteEnable+0x11e>
3400276a:	2305      	movs	r3, #5
3400276c:	e002      	b.n	34002774 <MX25UM51245G_WriteEnable+0x124>
3400276e:	2304      	movs	r3, #4
34002770:	e000      	b.n	34002774 <MX25UM51245G_WriteEnable+0x124>
34002772:	2300      	movs	r3, #0
  s_command.DummyCycles    = (Mode == MX25UM51245G_SPI_MODE)
34002774:	663b      	str	r3, [r7, #96]	@ 0x60
                                ? DUMMY_CYCLES_REG_OCTAL_DTR
                                : DUMMY_CYCLES_REG_OCTAL);
  s_command.DataLength         = (Rate == MX25UM51245G_DTR_TRANSFER) ? 2U : 1U;
34002776:	78bb      	ldrb	r3, [r7, #2]
34002778:	2b01      	cmp	r3, #1
3400277a:	d101      	bne.n	34002780 <MX25UM51245G_WriteEnable+0x130>
3400277c:	2302      	movs	r3, #2
3400277e:	e000      	b.n	34002782 <MX25UM51245G_WriteEnable+0x132>
34002780:	2301      	movs	r3, #1
34002782:	65bb      	str	r3, [r7, #88]	@ 0x58
  s_command.DQSMode        = (Rate == MX25UM51245G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34002784:	78bb      	ldrb	r3, [r7, #2]
34002786:	2b01      	cmp	r3, #1
34002788:	d102      	bne.n	34002790 <MX25UM51245G_WriteEnable+0x140>
3400278a:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
3400278e:	e000      	b.n	34002792 <MX25UM51245G_WriteEnable+0x142>
34002790:	2300      	movs	r3, #0
34002792:	667b      	str	r3, [r7, #100]	@ 0x64

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002794:	f107 031c 	add.w	r3, r7, #28
34002798:	f241 3288 	movw	r2, #5000	@ 0x1388
3400279c:	4619      	mov	r1, r3
3400279e:	6878      	ldr	r0, [r7, #4]
340027a0:	f014 fd24 	bl	340171ec <HAL_XSPI_Command>
340027a4:	4603      	mov	r3, r0
340027a6:	2b00      	cmp	r3, #0
340027a8:	d002      	beq.n	340027b0 <MX25UM51245G_WriteEnable+0x160>
  {
    return MX25UM51245G_ERROR;
340027aa:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
340027ae:	e019      	b.n	340027e4 <MX25UM51245G_WriteEnable+0x194>
  }

  s_config.MatchValue      = 2U;
340027b0:	2302      	movs	r3, #2
340027b2:	60bb      	str	r3, [r7, #8]
  s_config.MatchMask       = 2U;
340027b4:	2302      	movs	r3, #2
340027b6:	60fb      	str	r3, [r7, #12]
  s_config.MatchMode       = HAL_XSPI_MATCH_MODE_AND;
340027b8:	2300      	movs	r3, #0
340027ba:	613b      	str	r3, [r7, #16]
  s_config.IntervalTime    = MX25UM51245G_AUTOPOLLING_INTERVAL_TIME;
340027bc:	2310      	movs	r3, #16
340027be:	61bb      	str	r3, [r7, #24]
  s_config.AutomaticStop   = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
340027c0:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
340027c4:	617b      	str	r3, [r7, #20]

  if (HAL_XSPI_AutoPolling(Ctx, &s_config, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340027c6:	f107 0308 	add.w	r3, r7, #8
340027ca:	f241 3288 	movw	r2, #5000	@ 0x1388
340027ce:	4619      	mov	r1, r3
340027d0:	6878      	ldr	r0, [r7, #4]
340027d2:	f015 f833 	bl	3401783c <HAL_XSPI_AutoPolling>
340027d6:	4603      	mov	r3, r0
340027d8:	2b00      	cmp	r3, #0
340027da:	d002      	beq.n	340027e2 <MX25UM51245G_WriteEnable+0x192>
  {
    return MX25UM51245G_ERROR;
340027dc:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
340027e0:	e000      	b.n	340027e4 <MX25UM51245G_WriteEnable+0x194>
  }

  return MX25UM51245G_OK;
340027e2:	2300      	movs	r3, #0
}
340027e4:	4618      	mov	r0, r3
340027e6:	3768      	adds	r7, #104	@ 0x68
340027e8:	46bd      	mov	sp, r7
340027ea:	bd80      	pop	{r7, pc}

340027ec <MX25UM51245G_WriteCfg2Register>:
  * @param  Value Value to write to configuration register
  * @retval error status
  */
int32_t MX25UM51245G_WriteCfg2Register(XSPI_HandleTypeDef *Ctx, MX25UM51245G_Interface_t Mode,
                                       MX25UM51245G_Transfer_t Rate, uint32_t WriteAddr, uint8_t Value)
{
340027ec:	b580      	push	{r7, lr}
340027ee:	b098      	sub	sp, #96	@ 0x60
340027f0:	af00      	add	r7, sp, #0
340027f2:	60f8      	str	r0, [r7, #12]
340027f4:	607b      	str	r3, [r7, #4]
340027f6:	460b      	mov	r3, r1
340027f8:	72fb      	strb	r3, [r7, #11]
340027fa:	4613      	mov	r3, r2
340027fc:	72bb      	strb	r3, [r7, #10]
  XSPI_RegularCmdTypeDef s_command = {0};
340027fe:	f107 0314 	add.w	r3, r7, #20
34002802:	224c      	movs	r2, #76	@ 0x4c
34002804:	2100      	movs	r1, #0
34002806:	4618      	mov	r0, r3
34002808:	f019 ffd0 	bl	3401c7ac <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25UM51245G_SPI_MODE) && (Rate == MX25UM51245G_DTR_TRANSFER))
3400280c:	7afb      	ldrb	r3, [r7, #11]
3400280e:	2b00      	cmp	r3, #0
34002810:	d105      	bne.n	3400281e <MX25UM51245G_WriteCfg2Register+0x32>
34002812:	7abb      	ldrb	r3, [r7, #10]
34002814:	2b01      	cmp	r3, #1
34002816:	d102      	bne.n	3400281e <MX25UM51245G_WriteCfg2Register+0x32>
  {
    return MX25UM51245G_ERROR;
34002818:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
3400281c:	e075      	b.n	3400290a <MX25UM51245G_WriteCfg2Register+0x11e>
  }

  /* Initialize the writing of configuration register 2 */
  s_command.OperationType      = HAL_XSPI_OPTYPE_COMMON_CFG;
3400281e:	2300      	movs	r3, #0
34002820:	617b      	str	r3, [r7, #20]
  s_command.IOSelect           = HAL_XSPI_SELECT_IO_7_0;
34002822:	2300      	movs	r3, #0
34002824:	61bb      	str	r3, [r7, #24]
  s_command.InstructionMode    = (Mode == MX25UM51245G_SPI_MODE)
                                 ? HAL_XSPI_INSTRUCTION_1_LINE
                                 : HAL_XSPI_INSTRUCTION_8_LINES;
34002826:	7afb      	ldrb	r3, [r7, #11]
34002828:	2b00      	cmp	r3, #0
3400282a:	d101      	bne.n	34002830 <MX25UM51245G_WriteCfg2Register+0x44>
3400282c:	2301      	movs	r3, #1
3400282e:	e000      	b.n	34002832 <MX25UM51245G_WriteCfg2Register+0x46>
34002830:	2304      	movs	r3, #4
  s_command.InstructionMode    = (Mode == MX25UM51245G_SPI_MODE)
34002832:	623b      	str	r3, [r7, #32]
  s_command.InstructionDTRMode = (Rate == MX25UM51245G_DTR_TRANSFER)
                                 ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                 : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002834:	7abb      	ldrb	r3, [r7, #10]
34002836:	2b01      	cmp	r3, #1
34002838:	d101      	bne.n	3400283e <MX25UM51245G_WriteCfg2Register+0x52>
3400283a:	2308      	movs	r3, #8
3400283c:	e000      	b.n	34002840 <MX25UM51245G_WriteCfg2Register+0x54>
3400283e:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX25UM51245G_DTR_TRANSFER)
34002840:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionWidth   = (Mode == MX25UM51245G_SPI_MODE)
                                 ? HAL_XSPI_INSTRUCTION_8_BITS
                                 : HAL_XSPI_INSTRUCTION_16_BITS;
34002842:	7afb      	ldrb	r3, [r7, #11]
34002844:	2b00      	cmp	r3, #0
34002846:	d101      	bne.n	3400284c <MX25UM51245G_WriteCfg2Register+0x60>
34002848:	2300      	movs	r3, #0
3400284a:	e000      	b.n	3400284e <MX25UM51245G_WriteCfg2Register+0x62>
3400284c:	2310      	movs	r3, #16
  s_command.InstructionWidth   = (Mode == MX25UM51245G_SPI_MODE)
3400284e:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.Instruction        = (Mode == MX25UM51245G_SPI_MODE)
                                 ? MX25UM51245G_WRITE_CFG_REG2_CMD
                                 : MX25UM51245G_OCTA_WRITE_CFG_REG2_CMD;
34002850:	7afb      	ldrb	r3, [r7, #11]
34002852:	2b00      	cmp	r3, #0
34002854:	d101      	bne.n	3400285a <MX25UM51245G_WriteCfg2Register+0x6e>
34002856:	2372      	movs	r3, #114	@ 0x72
34002858:	e001      	b.n	3400285e <MX25UM51245G_WriteCfg2Register+0x72>
3400285a:	f247 238d 	movw	r3, #29325	@ 0x728d
  s_command.Instruction        = (Mode == MX25UM51245G_SPI_MODE)
3400285e:	61fb      	str	r3, [r7, #28]
  s_command.AddressMode        = (Mode == MX25UM51245G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34002860:	7afb      	ldrb	r3, [r7, #11]
34002862:	2b00      	cmp	r3, #0
34002864:	d102      	bne.n	3400286c <MX25UM51245G_WriteCfg2Register+0x80>
34002866:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400286a:	e001      	b.n	34002870 <MX25UM51245G_WriteCfg2Register+0x84>
3400286c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34002870:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.AddressDTRMode     = (Rate == MX25UM51245G_DTR_TRANSFER)
                                 ? HAL_XSPI_ADDRESS_DTR_ENABLE
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002872:	7abb      	ldrb	r3, [r7, #10]
34002874:	2b01      	cmp	r3, #1
34002876:	d102      	bne.n	3400287e <MX25UM51245G_WriteCfg2Register+0x92>
34002878:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3400287c:	e000      	b.n	34002880 <MX25UM51245G_WriteCfg2Register+0x94>
3400287e:	2300      	movs	r3, #0
  s_command.AddressDTRMode     = (Rate == MX25UM51245G_DTR_TRANSFER)
34002880:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressWidth       = HAL_XSPI_ADDRESS_32_BITS;
34002882:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34002886:	637b      	str	r3, [r7, #52]	@ 0x34
  s_command.Address            = WriteAddr;
34002888:	687b      	ldr	r3, [r7, #4]
3400288a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
3400288c:	2300      	movs	r3, #0
3400288e:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.DataMode           = (Mode == MX25UM51245G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002890:	7afb      	ldrb	r3, [r7, #11]
34002892:	2b00      	cmp	r3, #0
34002894:	d102      	bne.n	3400289c <MX25UM51245G_WriteCfg2Register+0xb0>
34002896:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3400289a:	e001      	b.n	340028a0 <MX25UM51245G_WriteCfg2Register+0xb4>
3400289c:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
340028a0:	64fb      	str	r3, [r7, #76]	@ 0x4c
  s_command.DataDTRMode        = (Rate == MX25UM51245G_DTR_TRANSFER)
                                 ? HAL_XSPI_DATA_DTR_ENABLE
                                 : HAL_XSPI_DATA_DTR_DISABLE;
340028a2:	7abb      	ldrb	r3, [r7, #10]
340028a4:	2b01      	cmp	r3, #1
340028a6:	d102      	bne.n	340028ae <MX25UM51245G_WriteCfg2Register+0xc2>
340028a8:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
340028ac:	e000      	b.n	340028b0 <MX25UM51245G_WriteCfg2Register+0xc4>
340028ae:	2300      	movs	r3, #0
  s_command.DataDTRMode        = (Rate == MX25UM51245G_DTR_TRANSFER)
340028b0:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DummyCycles        = 0U;
340028b2:	2300      	movs	r3, #0
340028b4:	65bb      	str	r3, [r7, #88]	@ 0x58
  s_command.DataLength             = (Mode == MX25UM51245G_SPI_MODE) ? 1U : ((Rate == MX25UM51245G_DTR_TRANSFER) ? 2U : 1U);
340028b6:	7afb      	ldrb	r3, [r7, #11]
340028b8:	2b00      	cmp	r3, #0
340028ba:	d006      	beq.n	340028ca <MX25UM51245G_WriteCfg2Register+0xde>
340028bc:	7abb      	ldrb	r3, [r7, #10]
340028be:	2b01      	cmp	r3, #1
340028c0:	d101      	bne.n	340028c6 <MX25UM51245G_WriteCfg2Register+0xda>
340028c2:	2302      	movs	r3, #2
340028c4:	e002      	b.n	340028cc <MX25UM51245G_WriteCfg2Register+0xe0>
340028c6:	2301      	movs	r3, #1
340028c8:	e000      	b.n	340028cc <MX25UM51245G_WriteCfg2Register+0xe0>
340028ca:	2301      	movs	r3, #1
340028cc:	653b      	str	r3, [r7, #80]	@ 0x50
  s_command.DQSMode            = HAL_XSPI_DQS_DISABLE;
340028ce:	2300      	movs	r3, #0
340028d0:	65fb      	str	r3, [r7, #92]	@ 0x5c
#if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode           = HAL_XSPI_SIOO_INST_EVERY_CMD;
#endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340028d2:	f107 0314 	add.w	r3, r7, #20
340028d6:	f241 3288 	movw	r2, #5000	@ 0x1388
340028da:	4619      	mov	r1, r3
340028dc:	68f8      	ldr	r0, [r7, #12]
340028de:	f014 fc85 	bl	340171ec <HAL_XSPI_Command>
340028e2:	4603      	mov	r3, r0
340028e4:	2b00      	cmp	r3, #0
340028e6:	d002      	beq.n	340028ee <MX25UM51245G_WriteCfg2Register+0x102>
  {
    return MX25UM51245G_ERROR;
340028e8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
340028ec:	e00d      	b.n	3400290a <MX25UM51245G_WriteCfg2Register+0x11e>
  }

  if (HAL_XSPI_Transmit(Ctx, &Value, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340028ee:	f241 3288 	movw	r2, #5000	@ 0x1388
340028f2:	f107 0168 	add.w	r1, r7, #104	@ 0x68
340028f6:	68f8      	ldr	r0, [r7, #12]
340028f8:	f014 fe8a 	bl	34017610 <HAL_XSPI_Transmit>
340028fc:	4603      	mov	r3, r0
340028fe:	2b00      	cmp	r3, #0
34002900:	d002      	beq.n	34002908 <MX25UM51245G_WriteCfg2Register+0x11c>
  {
    return MX25UM51245G_ERROR;
34002902:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
34002906:	e000      	b.n	3400290a <MX25UM51245G_WriteCfg2Register+0x11e>
  }

  return MX25UM51245G_OK;
34002908:	2300      	movs	r3, #0
}
3400290a:	4618      	mov	r0, r3
3400290c:	3760      	adds	r7, #96	@ 0x60
3400290e:	46bd      	mov	sp, r7
34002910:	bd80      	pop	{r7, pc}

34002912 <MX25UM51245G_ReadCfg2Register>:
  * @param  Value configuration register 2 value pointer
  * @retval error status
  */
int32_t MX25UM51245G_ReadCfg2Register(XSPI_HandleTypeDef *Ctx, MX25UM51245G_Interface_t Mode,
                                      MX25UM51245G_Transfer_t Rate, uint32_t ReadAddr, uint8_t *Value)
{
34002912:	b580      	push	{r7, lr}
34002914:	b098      	sub	sp, #96	@ 0x60
34002916:	af00      	add	r7, sp, #0
34002918:	60f8      	str	r0, [r7, #12]
3400291a:	607b      	str	r3, [r7, #4]
3400291c:	460b      	mov	r3, r1
3400291e:	72fb      	strb	r3, [r7, #11]
34002920:	4613      	mov	r3, r2
34002922:	72bb      	strb	r3, [r7, #10]
  XSPI_RegularCmdTypeDef s_command = {0};
34002924:	f107 0314 	add.w	r3, r7, #20
34002928:	224c      	movs	r2, #76	@ 0x4c
3400292a:	2100      	movs	r1, #0
3400292c:	4618      	mov	r0, r3
3400292e:	f019 ff3d 	bl	3401c7ac <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25UM51245G_SPI_MODE) && (Rate == MX25UM51245G_DTR_TRANSFER))
34002932:	7afb      	ldrb	r3, [r7, #11]
34002934:	2b00      	cmp	r3, #0
34002936:	d105      	bne.n	34002944 <MX25UM51245G_ReadCfg2Register+0x32>
34002938:	7abb      	ldrb	r3, [r7, #10]
3400293a:	2b01      	cmp	r3, #1
3400293c:	d102      	bne.n	34002944 <MX25UM51245G_ReadCfg2Register+0x32>
  {
    return MX25UM51245G_ERROR;
3400293e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
34002942:	e07f      	b.n	34002a44 <MX25UM51245G_ReadCfg2Register+0x132>
  }

  /* Initialize the reading of status register */
  s_command.OperationType      = HAL_XSPI_OPTYPE_COMMON_CFG;
34002944:	2300      	movs	r3, #0
34002946:	617b      	str	r3, [r7, #20]
  s_command.IOSelect           = HAL_XSPI_SELECT_IO_7_0;
34002948:	2300      	movs	r3, #0
3400294a:	61bb      	str	r3, [r7, #24]
  s_command.InstructionMode    = (Mode == MX25UM51245G_SPI_MODE)
                                 ? HAL_XSPI_INSTRUCTION_1_LINE
                                 : HAL_XSPI_INSTRUCTION_8_LINES;
3400294c:	7afb      	ldrb	r3, [r7, #11]
3400294e:	2b00      	cmp	r3, #0
34002950:	d101      	bne.n	34002956 <MX25UM51245G_ReadCfg2Register+0x44>
34002952:	2301      	movs	r3, #1
34002954:	e000      	b.n	34002958 <MX25UM51245G_ReadCfg2Register+0x46>
34002956:	2304      	movs	r3, #4
  s_command.InstructionMode    = (Mode == MX25UM51245G_SPI_MODE)
34002958:	623b      	str	r3, [r7, #32]
  s_command.InstructionDTRMode = (Rate == MX25UM51245G_DTR_TRANSFER)
                                 ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                 : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
3400295a:	7abb      	ldrb	r3, [r7, #10]
3400295c:	2b01      	cmp	r3, #1
3400295e:	d101      	bne.n	34002964 <MX25UM51245G_ReadCfg2Register+0x52>
34002960:	2308      	movs	r3, #8
34002962:	e000      	b.n	34002966 <MX25UM51245G_ReadCfg2Register+0x54>
34002964:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX25UM51245G_DTR_TRANSFER)
34002966:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionWidth   = (Mode == MX25UM51245G_SPI_MODE)
                                 ? HAL_XSPI_INSTRUCTION_8_BITS
                                 : HAL_XSPI_INSTRUCTION_16_BITS;
34002968:	7afb      	ldrb	r3, [r7, #11]
3400296a:	2b00      	cmp	r3, #0
3400296c:	d101      	bne.n	34002972 <MX25UM51245G_ReadCfg2Register+0x60>
3400296e:	2300      	movs	r3, #0
34002970:	e000      	b.n	34002974 <MX25UM51245G_ReadCfg2Register+0x62>
34002972:	2310      	movs	r3, #16
  s_command.InstructionWidth   = (Mode == MX25UM51245G_SPI_MODE)
34002974:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.Instruction        = (Mode == MX25UM51245G_SPI_MODE)
                                 ? MX25UM51245G_READ_CFG_REG2_CMD
                                 : MX25UM51245G_OCTA_READ_CFG_REG2_CMD;
34002976:	7afb      	ldrb	r3, [r7, #11]
34002978:	2b00      	cmp	r3, #0
3400297a:	d101      	bne.n	34002980 <MX25UM51245G_ReadCfg2Register+0x6e>
3400297c:	2371      	movs	r3, #113	@ 0x71
3400297e:	e001      	b.n	34002984 <MX25UM51245G_ReadCfg2Register+0x72>
34002980:	f247 138e 	movw	r3, #29070	@ 0x718e
  s_command.Instruction        = (Mode == MX25UM51245G_SPI_MODE)
34002984:	61fb      	str	r3, [r7, #28]
  s_command.AddressMode        = (Mode == MX25UM51245G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34002986:	7afb      	ldrb	r3, [r7, #11]
34002988:	2b00      	cmp	r3, #0
3400298a:	d102      	bne.n	34002992 <MX25UM51245G_ReadCfg2Register+0x80>
3400298c:	f44f 7380 	mov.w	r3, #256	@ 0x100
34002990:	e001      	b.n	34002996 <MX25UM51245G_ReadCfg2Register+0x84>
34002992:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34002996:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.AddressDTRMode     = (Rate == MX25UM51245G_DTR_TRANSFER)
                                 ? HAL_XSPI_ADDRESS_DTR_ENABLE
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002998:	7abb      	ldrb	r3, [r7, #10]
3400299a:	2b01      	cmp	r3, #1
3400299c:	d102      	bne.n	340029a4 <MX25UM51245G_ReadCfg2Register+0x92>
3400299e:	f44f 6300 	mov.w	r3, #2048	@ 0x800
340029a2:	e000      	b.n	340029a6 <MX25UM51245G_ReadCfg2Register+0x94>
340029a4:	2300      	movs	r3, #0
  s_command.AddressDTRMode     = (Rate == MX25UM51245G_DTR_TRANSFER)
340029a6:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressWidth       = HAL_XSPI_ADDRESS_32_BITS;
340029a8:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
340029ac:	637b      	str	r3, [r7, #52]	@ 0x34
  s_command.Address            = ReadAddr;
340029ae:	687b      	ldr	r3, [r7, #4]
340029b0:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
340029b2:	2300      	movs	r3, #0
340029b4:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.DataMode           = (Mode == MX25UM51245G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
340029b6:	7afb      	ldrb	r3, [r7, #11]
340029b8:	2b00      	cmp	r3, #0
340029ba:	d102      	bne.n	340029c2 <MX25UM51245G_ReadCfg2Register+0xb0>
340029bc:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
340029c0:	e001      	b.n	340029c6 <MX25UM51245G_ReadCfg2Register+0xb4>
340029c2:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
340029c6:	64fb      	str	r3, [r7, #76]	@ 0x4c
  s_command.DataDTRMode        = (Rate == MX25UM51245G_DTR_TRANSFER)
                                 ? HAL_XSPI_DATA_DTR_ENABLE
                                 : HAL_XSPI_DATA_DTR_DISABLE;
340029c8:	7abb      	ldrb	r3, [r7, #10]
340029ca:	2b01      	cmp	r3, #1
340029cc:	d102      	bne.n	340029d4 <MX25UM51245G_ReadCfg2Register+0xc2>
340029ce:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
340029d2:	e000      	b.n	340029d6 <MX25UM51245G_ReadCfg2Register+0xc4>
340029d4:	2300      	movs	r3, #0
  s_command.DataDTRMode        = (Rate == MX25UM51245G_DTR_TRANSFER)
340029d6:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DummyCycles        = (Mode == MX25UM51245G_SPI_MODE)
                                 ? 0U
                                 : ((Rate == MX25UM51245G_DTR_TRANSFER)
340029d8:	7afb      	ldrb	r3, [r7, #11]
340029da:	2b00      	cmp	r3, #0
340029dc:	d006      	beq.n	340029ec <MX25UM51245G_ReadCfg2Register+0xda>
340029de:	7abb      	ldrb	r3, [r7, #10]
340029e0:	2b01      	cmp	r3, #1
340029e2:	d101      	bne.n	340029e8 <MX25UM51245G_ReadCfg2Register+0xd6>
340029e4:	2305      	movs	r3, #5
340029e6:	e002      	b.n	340029ee <MX25UM51245G_ReadCfg2Register+0xdc>
340029e8:	2304      	movs	r3, #4
340029ea:	e000      	b.n	340029ee <MX25UM51245G_ReadCfg2Register+0xdc>
340029ec:	2300      	movs	r3, #0
  s_command.DummyCycles        = (Mode == MX25UM51245G_SPI_MODE)
340029ee:	65bb      	str	r3, [r7, #88]	@ 0x58
                                    ? DUMMY_CYCLES_REG_OCTAL_DTR
                                    : DUMMY_CYCLES_REG_OCTAL);
  s_command.DataLength             = (Rate == MX25UM51245G_DTR_TRANSFER) ? 2U : 1U;
340029f0:	7abb      	ldrb	r3, [r7, #10]
340029f2:	2b01      	cmp	r3, #1
340029f4:	d101      	bne.n	340029fa <MX25UM51245G_ReadCfg2Register+0xe8>
340029f6:	2302      	movs	r3, #2
340029f8:	e000      	b.n	340029fc <MX25UM51245G_ReadCfg2Register+0xea>
340029fa:	2301      	movs	r3, #1
340029fc:	653b      	str	r3, [r7, #80]	@ 0x50
  s_command.DQSMode            = (Rate == MX25UM51245G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
340029fe:	7abb      	ldrb	r3, [r7, #10]
34002a00:	2b01      	cmp	r3, #1
34002a02:	d102      	bne.n	34002a0a <MX25UM51245G_ReadCfg2Register+0xf8>
34002a04:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
34002a08:	e000      	b.n	34002a0c <MX25UM51245G_ReadCfg2Register+0xfa>
34002a0a:	2300      	movs	r3, #0
34002a0c:	65fb      	str	r3, [r7, #92]	@ 0x5c
#if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode           = HAL_XSPI_SIOO_INST_EVERY_CMD;
#endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002a0e:	f107 0314 	add.w	r3, r7, #20
34002a12:	f241 3288 	movw	r2, #5000	@ 0x1388
34002a16:	4619      	mov	r1, r3
34002a18:	68f8      	ldr	r0, [r7, #12]
34002a1a:	f014 fbe7 	bl	340171ec <HAL_XSPI_Command>
34002a1e:	4603      	mov	r3, r0
34002a20:	2b00      	cmp	r3, #0
34002a22:	d002      	beq.n	34002a2a <MX25UM51245G_ReadCfg2Register+0x118>
  {
    return MX25UM51245G_ERROR;
34002a24:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
34002a28:	e00c      	b.n	34002a44 <MX25UM51245G_ReadCfg2Register+0x132>
  }

  /* Reception of the data */
  if (HAL_XSPI_Receive(Ctx, Value, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002a2a:	f241 3288 	movw	r2, #5000	@ 0x1388
34002a2e:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
34002a30:	68f8      	ldr	r0, [r7, #12]
34002a32:	f014 fe60 	bl	340176f6 <HAL_XSPI_Receive>
34002a36:	4603      	mov	r3, r0
34002a38:	2b00      	cmp	r3, #0
34002a3a:	d002      	beq.n	34002a42 <MX25UM51245G_ReadCfg2Register+0x130>
  {
    return MX25UM51245G_ERROR;
34002a3c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
34002a40:	e000      	b.n	34002a44 <MX25UM51245G_ReadCfg2Register+0x132>
  }

  return MX25UM51245G_OK;
34002a42:	2300      	movs	r3, #0
}
34002a44:	4618      	mov	r0, r3
34002a46:	3760      	adds	r7, #96	@ 0x60
34002a48:	46bd      	mov	sp, r7
34002a4a:	bd80      	pop	{r7, pc}

34002a4c <MX25UM51245G_ResetEnable>:
  * @param  Mode Interface select
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX25UM51245G_ResetEnable(XSPI_HandleTypeDef *Ctx, MX25UM51245G_Interface_t Mode, MX25UM51245G_Transfer_t Rate)
{
34002a4c:	b580      	push	{r7, lr}
34002a4e:	b096      	sub	sp, #88	@ 0x58
34002a50:	af00      	add	r7, sp, #0
34002a52:	6078      	str	r0, [r7, #4]
34002a54:	460b      	mov	r3, r1
34002a56:	70fb      	strb	r3, [r7, #3]
34002a58:	4613      	mov	r3, r2
34002a5a:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef s_command = {0};
34002a5c:	f107 030c 	add.w	r3, r7, #12
34002a60:	224c      	movs	r2, #76	@ 0x4c
34002a62:	2100      	movs	r1, #0
34002a64:	4618      	mov	r0, r3
34002a66:	f019 fea1 	bl	3401c7ac <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25UM51245G_SPI_MODE) && (Rate == MX25UM51245G_DTR_TRANSFER))
34002a6a:	78fb      	ldrb	r3, [r7, #3]
34002a6c:	2b00      	cmp	r3, #0
34002a6e:	d105      	bne.n	34002a7c <MX25UM51245G_ResetEnable+0x30>
34002a70:	78bb      	ldrb	r3, [r7, #2]
34002a72:	2b01      	cmp	r3, #1
34002a74:	d102      	bne.n	34002a7c <MX25UM51245G_ResetEnable+0x30>
  {
    return MX25UM51245G_ERROR;
34002a76:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
34002a7a:	e039      	b.n	34002af0 <MX25UM51245G_ResetEnable+0xa4>
  }

  /* Initialize the reset enable command */
  s_command.OperationType      = HAL_XSPI_OPTYPE_COMMON_CFG;
34002a7c:	2300      	movs	r3, #0
34002a7e:	60fb      	str	r3, [r7, #12]
  s_command.IOSelect           = HAL_XSPI_SELECT_IO_7_0;
34002a80:	2300      	movs	r3, #0
34002a82:	613b      	str	r3, [r7, #16]
  s_command.InstructionMode    = (Mode == MX25UM51245G_SPI_MODE)
                                 ? HAL_XSPI_INSTRUCTION_1_LINE
                                 : HAL_XSPI_INSTRUCTION_8_LINES;
34002a84:	78fb      	ldrb	r3, [r7, #3]
34002a86:	2b00      	cmp	r3, #0
34002a88:	d101      	bne.n	34002a8e <MX25UM51245G_ResetEnable+0x42>
34002a8a:	2301      	movs	r3, #1
34002a8c:	e000      	b.n	34002a90 <MX25UM51245G_ResetEnable+0x44>
34002a8e:	2304      	movs	r3, #4
  s_command.InstructionMode    = (Mode == MX25UM51245G_SPI_MODE)
34002a90:	61bb      	str	r3, [r7, #24]
  s_command.InstructionDTRMode = (Rate == MX25UM51245G_DTR_TRANSFER)
                                 ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                 : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002a92:	78bb      	ldrb	r3, [r7, #2]
34002a94:	2b01      	cmp	r3, #1
34002a96:	d101      	bne.n	34002a9c <MX25UM51245G_ResetEnable+0x50>
34002a98:	2308      	movs	r3, #8
34002a9a:	e000      	b.n	34002a9e <MX25UM51245G_ResetEnable+0x52>
34002a9c:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX25UM51245G_DTR_TRANSFER)
34002a9e:	623b      	str	r3, [r7, #32]
  s_command.InstructionWidth   = (Mode == MX25UM51245G_SPI_MODE)
                                 ? HAL_XSPI_INSTRUCTION_8_BITS
                                 : HAL_XSPI_INSTRUCTION_16_BITS;
34002aa0:	78fb      	ldrb	r3, [r7, #3]
34002aa2:	2b00      	cmp	r3, #0
34002aa4:	d101      	bne.n	34002aaa <MX25UM51245G_ResetEnable+0x5e>
34002aa6:	2300      	movs	r3, #0
34002aa8:	e000      	b.n	34002aac <MX25UM51245G_ResetEnable+0x60>
34002aaa:	2310      	movs	r3, #16
  s_command.InstructionWidth   = (Mode == MX25UM51245G_SPI_MODE)
34002aac:	61fb      	str	r3, [r7, #28]
  s_command.Instruction        = (Mode == MX25UM51245G_SPI_MODE)
                                 ? MX25UM51245G_RESET_ENABLE_CMD
                                 : MX25UM51245G_OCTA_RESET_ENABLE_CMD;
34002aae:	78fb      	ldrb	r3, [r7, #3]
34002ab0:	2b00      	cmp	r3, #0
34002ab2:	d101      	bne.n	34002ab8 <MX25UM51245G_ResetEnable+0x6c>
34002ab4:	2366      	movs	r3, #102	@ 0x66
34002ab6:	e001      	b.n	34002abc <MX25UM51245G_ResetEnable+0x70>
34002ab8:	f246 6399 	movw	r3, #26265	@ 0x6699
  s_command.Instruction        = (Mode == MX25UM51245G_SPI_MODE)
34002abc:	617b      	str	r3, [r7, #20]
  s_command.AddressMode        = HAL_XSPI_ADDRESS_NONE;
34002abe:	2300      	movs	r3, #0
34002ac0:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
34002ac2:	2300      	movs	r3, #0
34002ac4:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.DataMode           = HAL_XSPI_DATA_NONE;
34002ac6:	2300      	movs	r3, #0
34002ac8:	647b      	str	r3, [r7, #68]	@ 0x44
  s_command.DummyCycles        = 0U;
34002aca:	2300      	movs	r3, #0
34002acc:	653b      	str	r3, [r7, #80]	@ 0x50
  s_command.DQSMode            = HAL_XSPI_DQS_DISABLE;
34002ace:	2300      	movs	r3, #0
34002ad0:	657b      	str	r3, [r7, #84]	@ 0x54
#if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode           = HAL_XSPI_SIOO_INST_EVERY_CMD;
#endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002ad2:	f107 030c 	add.w	r3, r7, #12
34002ad6:	f241 3288 	movw	r2, #5000	@ 0x1388
34002ada:	4619      	mov	r1, r3
34002adc:	6878      	ldr	r0, [r7, #4]
34002ade:	f014 fb85 	bl	340171ec <HAL_XSPI_Command>
34002ae2:	4603      	mov	r3, r0
34002ae4:	2b00      	cmp	r3, #0
34002ae6:	d002      	beq.n	34002aee <MX25UM51245G_ResetEnable+0xa2>
  {
    return MX25UM51245G_ERROR;
34002ae8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
34002aec:	e000      	b.n	34002af0 <MX25UM51245G_ResetEnable+0xa4>
  }

  return MX25UM51245G_OK;
34002aee:	2300      	movs	r3, #0
}
34002af0:	4618      	mov	r0, r3
34002af2:	3758      	adds	r7, #88	@ 0x58
34002af4:	46bd      	mov	sp, r7
34002af6:	bd80      	pop	{r7, pc}

34002af8 <MX25UM51245G_ResetMemory>:
  * @param  Mode Interface select
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX25UM51245G_ResetMemory(XSPI_HandleTypeDef *Ctx, MX25UM51245G_Interface_t Mode, MX25UM51245G_Transfer_t Rate)
{
34002af8:	b580      	push	{r7, lr}
34002afa:	b096      	sub	sp, #88	@ 0x58
34002afc:	af00      	add	r7, sp, #0
34002afe:	6078      	str	r0, [r7, #4]
34002b00:	460b      	mov	r3, r1
34002b02:	70fb      	strb	r3, [r7, #3]
34002b04:	4613      	mov	r3, r2
34002b06:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef s_command = {0};
34002b08:	f107 030c 	add.w	r3, r7, #12
34002b0c:	224c      	movs	r2, #76	@ 0x4c
34002b0e:	2100      	movs	r1, #0
34002b10:	4618      	mov	r0, r3
34002b12:	f019 fe4b 	bl	3401c7ac <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25UM51245G_SPI_MODE) && (Rate == MX25UM51245G_DTR_TRANSFER))
34002b16:	78fb      	ldrb	r3, [r7, #3]
34002b18:	2b00      	cmp	r3, #0
34002b1a:	d105      	bne.n	34002b28 <MX25UM51245G_ResetMemory+0x30>
34002b1c:	78bb      	ldrb	r3, [r7, #2]
34002b1e:	2b01      	cmp	r3, #1
34002b20:	d102      	bne.n	34002b28 <MX25UM51245G_ResetMemory+0x30>
  {
    return MX25UM51245G_ERROR;
34002b22:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
34002b26:	e039      	b.n	34002b9c <MX25UM51245G_ResetMemory+0xa4>
  }

  /* Initialize the reset enable command */
  s_command.OperationType      = HAL_XSPI_OPTYPE_COMMON_CFG;
34002b28:	2300      	movs	r3, #0
34002b2a:	60fb      	str	r3, [r7, #12]
  s_command.IOSelect           = HAL_XSPI_SELECT_IO_7_0;
34002b2c:	2300      	movs	r3, #0
34002b2e:	613b      	str	r3, [r7, #16]
  s_command.InstructionMode    = (Mode == MX25UM51245G_SPI_MODE)
                                 ? HAL_XSPI_INSTRUCTION_1_LINE
                                 : HAL_XSPI_INSTRUCTION_8_LINES;
34002b30:	78fb      	ldrb	r3, [r7, #3]
34002b32:	2b00      	cmp	r3, #0
34002b34:	d101      	bne.n	34002b3a <MX25UM51245G_ResetMemory+0x42>
34002b36:	2301      	movs	r3, #1
34002b38:	e000      	b.n	34002b3c <MX25UM51245G_ResetMemory+0x44>
34002b3a:	2304      	movs	r3, #4
  s_command.InstructionMode    = (Mode == MX25UM51245G_SPI_MODE)
34002b3c:	61bb      	str	r3, [r7, #24]
  s_command.InstructionDTRMode = (Rate == MX25UM51245G_DTR_TRANSFER)
                                 ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                 : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002b3e:	78bb      	ldrb	r3, [r7, #2]
34002b40:	2b01      	cmp	r3, #1
34002b42:	d101      	bne.n	34002b48 <MX25UM51245G_ResetMemory+0x50>
34002b44:	2308      	movs	r3, #8
34002b46:	e000      	b.n	34002b4a <MX25UM51245G_ResetMemory+0x52>
34002b48:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX25UM51245G_DTR_TRANSFER)
34002b4a:	623b      	str	r3, [r7, #32]
  s_command.InstructionWidth   = (Mode == MX25UM51245G_SPI_MODE)
                                 ? HAL_XSPI_INSTRUCTION_8_BITS
                                 : HAL_XSPI_INSTRUCTION_16_BITS;
34002b4c:	78fb      	ldrb	r3, [r7, #3]
34002b4e:	2b00      	cmp	r3, #0
34002b50:	d101      	bne.n	34002b56 <MX25UM51245G_ResetMemory+0x5e>
34002b52:	2300      	movs	r3, #0
34002b54:	e000      	b.n	34002b58 <MX25UM51245G_ResetMemory+0x60>
34002b56:	2310      	movs	r3, #16
  s_command.InstructionWidth   = (Mode == MX25UM51245G_SPI_MODE)
34002b58:	61fb      	str	r3, [r7, #28]
  s_command.Instruction        = (Mode == MX25UM51245G_SPI_MODE)
                                 ? MX25UM51245G_RESET_MEMORY_CMD
                                 : MX25UM51245G_OCTA_RESET_MEMORY_CMD;
34002b5a:	78fb      	ldrb	r3, [r7, #3]
34002b5c:	2b00      	cmp	r3, #0
34002b5e:	d101      	bne.n	34002b64 <MX25UM51245G_ResetMemory+0x6c>
34002b60:	2399      	movs	r3, #153	@ 0x99
34002b62:	e001      	b.n	34002b68 <MX25UM51245G_ResetMemory+0x70>
34002b64:	f649 1366 	movw	r3, #39270	@ 0x9966
  s_command.Instruction        = (Mode == MX25UM51245G_SPI_MODE)
34002b68:	617b      	str	r3, [r7, #20]
  s_command.AddressMode        = HAL_XSPI_ADDRESS_NONE;
34002b6a:	2300      	movs	r3, #0
34002b6c:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
34002b6e:	2300      	movs	r3, #0
34002b70:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.DataMode           = HAL_XSPI_DATA_NONE;
34002b72:	2300      	movs	r3, #0
34002b74:	647b      	str	r3, [r7, #68]	@ 0x44
  s_command.DummyCycles        = 0U;
34002b76:	2300      	movs	r3, #0
34002b78:	653b      	str	r3, [r7, #80]	@ 0x50
  s_command.DQSMode            = HAL_XSPI_DQS_DISABLE;
34002b7a:	2300      	movs	r3, #0
34002b7c:	657b      	str	r3, [r7, #84]	@ 0x54
#if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode           = HAL_XSPI_SIOO_INST_EVERY_CMD;
#endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002b7e:	f107 030c 	add.w	r3, r7, #12
34002b82:	f241 3288 	movw	r2, #5000	@ 0x1388
34002b86:	4619      	mov	r1, r3
34002b88:	6878      	ldr	r0, [r7, #4]
34002b8a:	f014 fb2f 	bl	340171ec <HAL_XSPI_Command>
34002b8e:	4603      	mov	r3, r0
34002b90:	2b00      	cmp	r3, #0
34002b92:	d002      	beq.n	34002b9a <MX25UM51245G_ResetMemory+0xa2>
  {
    return MX25UM51245G_ERROR;
34002b94:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
34002b98:	e000      	b.n	34002b9c <MX25UM51245G_ResetMemory+0xa4>
  }

  return MX25UM51245G_OK;
34002b9a:	2300      	movs	r3, #0
}
34002b9c:	4618      	mov	r0, r3
34002b9e:	3758      	adds	r7, #88	@ 0x58
34002ba0:	46bd      	mov	sp, r7
34002ba2:	bd80      	pop	{r7, pc}

34002ba4 <LL_AHB4_GRP1_EnableClock>:
{
34002ba4:	b480      	push	{r7}
34002ba6:	b085      	sub	sp, #20
34002ba8:	af00      	add	r7, sp, #0
34002baa:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34002bac:	4a07      	ldr	r2, [pc, #28]	@ (34002bcc <LL_AHB4_GRP1_EnableClock+0x28>)
34002bae:	687b      	ldr	r3, [r7, #4]
34002bb0:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34002bb4:	4b05      	ldr	r3, [pc, #20]	@ (34002bcc <LL_AHB4_GRP1_EnableClock+0x28>)
34002bb6:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34002bba:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34002bbc:	68fb      	ldr	r3, [r7, #12]
}
34002bbe:	bf00      	nop
34002bc0:	3714      	adds	r7, #20
34002bc2:	46bd      	mov	sp, r7
34002bc4:	f85d 7b04 	ldr.w	r7, [sp], #4
34002bc8:	4770      	bx	lr
34002bca:	bf00      	nop
34002bcc:	56028000 	.word	0x56028000

34002bd0 <LL_APB2_GRP1_EnableClock>:
{
34002bd0:	b480      	push	{r7}
34002bd2:	b085      	sub	sp, #20
34002bd4:	af00      	add	r7, sp, #0
34002bd6:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB2ENSR, Periphs);
34002bd8:	4a07      	ldr	r2, [pc, #28]	@ (34002bf8 <LL_APB2_GRP1_EnableClock+0x28>)
34002bda:	687b      	ldr	r3, [r7, #4]
34002bdc:	f8c2 3a6c 	str.w	r3, [r2, #2668]	@ 0xa6c
  tmpreg = READ_REG(RCC->APB2ENR);
34002be0:	4b05      	ldr	r3, [pc, #20]	@ (34002bf8 <LL_APB2_GRP1_EnableClock+0x28>)
34002be2:	f8d3 326c 	ldr.w	r3, [r3, #620]	@ 0x26c
34002be6:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34002be8:	68fb      	ldr	r3, [r7, #12]
}
34002bea:	bf00      	nop
34002bec:	3714      	adds	r7, #20
34002bee:	46bd      	mov	sp, r7
34002bf0:	f85d 7b04 	ldr.w	r7, [sp], #4
34002bf4:	4770      	bx	lr
34002bf6:	bf00      	nop
34002bf8:	56028000 	.word	0x56028000

34002bfc <BSP_SMPS_Init>:
  * @param Voltage configuration
  *          This parameter can be one of the following values:
  *            @arg  SMPS_VOLTAGE_NOMINAL
  *            @arg  SMPS_VOLTAGE_OVERDRIVE
  */
void BSP_SMPS_Init(SMPSVoltage_TypeDef Voltage){
34002bfc:	b580      	push	{r7, lr}
34002bfe:	b088      	sub	sp, #32
34002c00:	af00      	add	r7, sp, #0
34002c02:	4603      	mov	r3, r0
34002c04:	71fb      	strb	r3, [r7, #7]
  SMPS_GPIO_CLK_ENABLE();
34002c06:	2002      	movs	r0, #2
34002c08:	f7ff ffcc 	bl	34002ba4 <LL_AHB4_GRP1_EnableClock>
  GPIO_InitTypeDef  gpio_init_structure = {0};
34002c0c:	f107 030c 	add.w	r3, r7, #12
34002c10:	2200      	movs	r2, #0
34002c12:	601a      	str	r2, [r3, #0]
34002c14:	605a      	str	r2, [r3, #4]
34002c16:	609a      	str	r2, [r3, #8]
34002c18:	60da      	str	r2, [r3, #12]
34002c1a:	611a      	str	r2, [r3, #16]
  /* configure the external SMPS control pin */
  gpio_init_structure.Pin = SMPS_GPIO_PIN;
34002c1c:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34002c20:	60fb      	str	r3, [r7, #12]
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
34002c22:	2301      	movs	r3, #1
34002c24:	613b      	str	r3, [r7, #16]
  gpio_init_structure.Pull = GPIO_NOPULL;
34002c26:	2300      	movs	r3, #0
34002c28:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34002c2a:	2303      	movs	r3, #3
34002c2c:	61bb      	str	r3, [r7, #24]
  HAL_GPIO_Init(SMPS_GPIO_PORT, &gpio_init_structure);
34002c2e:	f107 030c 	add.w	r3, r7, #12
34002c32:	4619      	mov	r1, r3
34002c34:	4806      	ldr	r0, [pc, #24]	@ (34002c50 <BSP_SMPS_Init+0x54>)
34002c36:	f003 f899 	bl	34005d6c <HAL_GPIO_Init>

  HAL_GPIO_WritePin(SMPS_GPIO_PORT, SMPS_GPIO_PIN, (GPIO_PinState) Voltage);
34002c3a:	79fb      	ldrb	r3, [r7, #7]
34002c3c:	461a      	mov	r2, r3
34002c3e:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
34002c42:	4803      	ldr	r0, [pc, #12]	@ (34002c50 <BSP_SMPS_Init+0x54>)
34002c44:	f003 fbf2 	bl	3400642c <HAL_GPIO_WritePin>
}
34002c48:	bf00      	nop
34002c4a:	3720      	adds	r7, #32
34002c4c:	46bd      	mov	sp, r7
34002c4e:	bd80      	pop	{r7, pc}
34002c50:	56020400 	.word	0x56020400

34002c54 <BSP_COM_Init>:
  * @param  COM_Init Pointer to a COM_InitTypeDef structure that contains the
  *                  configuration information for the specified COM peripheral.
  * @retval BSP error code
  */
int32_t BSP_COM_Init(COM_TypeDef COM, COM_InitTypeDef *COM_Init)
{
34002c54:	b580      	push	{r7, lr}
34002c56:	b084      	sub	sp, #16
34002c58:	af00      	add	r7, sp, #0
34002c5a:	4603      	mov	r3, r0
34002c5c:	6039      	str	r1, [r7, #0]
34002c5e:	71fb      	strb	r3, [r7, #7]
  int32_t status = BSP_ERROR_NONE;
34002c60:	2300      	movs	r3, #0
34002c62:	60fb      	str	r3, [r7, #12]

  if (COM_Init == NULL)
34002c64:	683b      	ldr	r3, [r7, #0]
34002c66:	2b00      	cmp	r3, #0
34002c68:	d103      	bne.n	34002c72 <BSP_COM_Init+0x1e>
  {
    status = BSP_ERROR_WRONG_PARAM;
34002c6a:	f06f 0301 	mvn.w	r3, #1
34002c6e:	60fb      	str	r3, [r7, #12]
34002c70:	e029      	b.n	34002cc6 <BSP_COM_Init+0x72>
  }
  else
  {
    /* Initialize COM instance */
    hcom_uart[COM].Instance = COM_UART[COM];
34002c72:	79fa      	ldrb	r2, [r7, #7]
34002c74:	79fb      	ldrb	r3, [r7, #7]
34002c76:	4916      	ldr	r1, [pc, #88]	@ (34002cd0 <BSP_COM_Init+0x7c>)
34002c78:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
34002c7c:	4915      	ldr	r1, [pc, #84]	@ (34002cd4 <BSP_COM_Init+0x80>)
34002c7e:	2094      	movs	r0, #148	@ 0x94
34002c80:	fb00 f303 	mul.w	r3, r0, r3
34002c84:	440b      	add	r3, r1
34002c86:	601a      	str	r2, [r3, #0]

#if (USE_HAL_UART_REGISTER_CALLBACKS == 0)
    UART_MspInit(&hcom_uart[COM]);
34002c88:	79fb      	ldrb	r3, [r7, #7]
34002c8a:	2294      	movs	r2, #148	@ 0x94
34002c8c:	fb02 f303 	mul.w	r3, r2, r3
34002c90:	4a10      	ldr	r2, [pc, #64]	@ (34002cd4 <BSP_COM_Init+0x80>)
34002c92:	4413      	add	r3, r2
34002c94:	4618      	mov	r0, r3
34002c96:	f000 f853 	bl	34002d40 <UART_MspInit>
        status = BSP_ERROR_MSP_FAILURE;
      }
    }
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */

    if (status == BSP_ERROR_NONE)
34002c9a:	68fb      	ldr	r3, [r7, #12]
34002c9c:	2b00      	cmp	r3, #0
34002c9e:	d112      	bne.n	34002cc6 <BSP_COM_Init+0x72>
    {
      if (COM == COM1)
34002ca0:	79fb      	ldrb	r3, [r7, #7]
34002ca2:	2b00      	cmp	r3, #0
34002ca4:	d10f      	bne.n	34002cc6 <BSP_COM_Init+0x72>
      {
        if (MX_USART1_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
34002ca6:	79fb      	ldrb	r3, [r7, #7]
34002ca8:	2294      	movs	r2, #148	@ 0x94
34002caa:	fb02 f303 	mul.w	r3, r2, r3
34002cae:	4a09      	ldr	r2, [pc, #36]	@ (34002cd4 <BSP_COM_Init+0x80>)
34002cb0:	4413      	add	r3, r2
34002cb2:	6839      	ldr	r1, [r7, #0]
34002cb4:	4618      	mov	r0, r3
34002cb6:	f000 f80f 	bl	34002cd8 <MX_USART1_Init>
34002cba:	4603      	mov	r3, r0
34002cbc:	2b00      	cmp	r3, #0
34002cbe:	d002      	beq.n	34002cc6 <BSP_COM_Init+0x72>
        {
          status = BSP_ERROR_PERIPH_FAILURE;
34002cc0:	f06f 0303 	mvn.w	r3, #3
34002cc4:	60fb      	str	r3, [r7, #12]
//        }
      }
    }
  }

  return status;
34002cc6:	68fb      	ldr	r3, [r7, #12]
}
34002cc8:	4618      	mov	r0, r3
34002cca:	3710      	adds	r7, #16
34002ccc:	46bd      	mov	sp, r7
34002cce:	bd80      	pop	{r7, pc}
34002cd0:	34020c4c 	.word	0x34020c4c
34002cd4:	34020e80 	.word	0x34020e80

34002cd8 <MX_USART1_Init>:
  * @param  COM_Init Pointer to a UART_HandleTypeDef structure that contains the
  *                  configuration information for the specified USART peripheral.
  * @retval HAL error code
  */
__weak HAL_StatusTypeDef MX_USART1_Init(UART_HandleTypeDef *huart, MX_UART_InitTypeDef *COM_Init)
{
34002cd8:	b580      	push	{r7, lr}
34002cda:	b082      	sub	sp, #8
34002cdc:	af00      	add	r7, sp, #0
34002cde:	6078      	str	r0, [r7, #4]
34002ce0:	6039      	str	r1, [r7, #0]
  /* USART configuration */
  huart->Instance            = COM_UART[COM1];
34002ce2:	4b16      	ldr	r3, [pc, #88]	@ (34002d3c <MX_USART1_Init+0x64>)
34002ce4:	681a      	ldr	r2, [r3, #0]
34002ce6:	687b      	ldr	r3, [r7, #4]
34002ce8:	601a      	str	r2, [r3, #0]
  huart->Init.BaudRate       = COM_Init->BaudRate;
34002cea:	683b      	ldr	r3, [r7, #0]
34002cec:	681a      	ldr	r2, [r3, #0]
34002cee:	687b      	ldr	r3, [r7, #4]
34002cf0:	605a      	str	r2, [r3, #4]
  huart->Init.Mode           = UART_MODE_TX_RX;
34002cf2:	687b      	ldr	r3, [r7, #4]
34002cf4:	220c      	movs	r2, #12
34002cf6:	615a      	str	r2, [r3, #20]
  huart->Init.Parity         = (uint32_t)COM_Init->Parity;
34002cf8:	683b      	ldr	r3, [r7, #0]
34002cfa:	895b      	ldrh	r3, [r3, #10]
34002cfc:	461a      	mov	r2, r3
34002cfe:	687b      	ldr	r3, [r7, #4]
34002d00:	611a      	str	r2, [r3, #16]
  huart->Init.WordLength     = (uint32_t)COM_Init->WordLength;
34002d02:	683b      	ldr	r3, [r7, #0]
34002d04:	685a      	ldr	r2, [r3, #4]
34002d06:	687b      	ldr	r3, [r7, #4]
34002d08:	609a      	str	r2, [r3, #8]
  huart->Init.StopBits       = (uint32_t)COM_Init->StopBits;
34002d0a:	683b      	ldr	r3, [r7, #0]
34002d0c:	891b      	ldrh	r3, [r3, #8]
34002d0e:	461a      	mov	r2, r3
34002d10:	687b      	ldr	r3, [r7, #4]
34002d12:	60da      	str	r2, [r3, #12]
  huart->Init.HwFlowCtl      = (uint32_t)COM_Init->HwFlowCtl;
34002d14:	683b      	ldr	r3, [r7, #0]
34002d16:	899b      	ldrh	r3, [r3, #12]
34002d18:	461a      	mov	r2, r3
34002d1a:	687b      	ldr	r3, [r7, #4]
34002d1c:	619a      	str	r2, [r3, #24]
  huart->Init.OverSampling   = UART_OVERSAMPLING_8;
34002d1e:	687b      	ldr	r3, [r7, #4]
34002d20:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34002d24:	61da      	str	r2, [r3, #28]
  huart->Init.ClockPrescaler = UART_PRESCALER_DIV1;
34002d26:	687b      	ldr	r3, [r7, #4]
34002d28:	2200      	movs	r2, #0
34002d2a:	625a      	str	r2, [r3, #36]	@ 0x24
  return HAL_UART_Init(huart);
34002d2c:	6878      	ldr	r0, [r7, #4]
34002d2e:	f012 ff3d 	bl	34015bac <HAL_UART_Init>
34002d32:	4603      	mov	r3, r0
}
34002d34:	4618      	mov	r0, r3
34002d36:	3708      	adds	r7, #8
34002d38:	46bd      	mov	sp, r7
34002d3a:	bd80      	pop	{r7, pc}
34002d3c:	34020c4c 	.word	0x34020c4c

34002d40 <UART_MspInit>:
  * @brief  Initialize UART MSP.
  * @param  huart UART handle.
  * @retval None.
  */
static void UART_MspInit(UART_HandleTypeDef *huart)
{
34002d40:	b580      	push	{r7, lr}
34002d42:	b090      	sub	sp, #64	@ 0x40
34002d44:	af00      	add	r7, sp, #0
34002d46:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_Init;
  GPIO_TypeDef    *COM_TX_PORT[COMn] = {COM1_TX_GPIO_PORT};
34002d48:	f107 0320 	add.w	r3, r7, #32
34002d4c:	2200      	movs	r2, #0
34002d4e:	601a      	str	r2, [r3, #0]
34002d50:	605a      	str	r2, [r3, #4]
34002d52:	4b34      	ldr	r3, [pc, #208]	@ (34002e24 <UART_MspInit+0xe4>)
34002d54:	623b      	str	r3, [r7, #32]
  GPIO_TypeDef    *COM_RX_PORT[COMn] = {COM1_RX_GPIO_PORT};
34002d56:	f107 0318 	add.w	r3, r7, #24
34002d5a:	2200      	movs	r2, #0
34002d5c:	601a      	str	r2, [r3, #0]
34002d5e:	605a      	str	r2, [r3, #4]
34002d60:	4b31      	ldr	r3, [pc, #196]	@ (34002e28 <UART_MspInit+0xe8>)
34002d62:	61bb      	str	r3, [r7, #24]
  uint16_t         COM_TX_PIN[COMn]  = {COM1_TX_PIN};
34002d64:	2300      	movs	r3, #0
34002d66:	617b      	str	r3, [r7, #20]
34002d68:	2320      	movs	r3, #32
34002d6a:	82bb      	strh	r3, [r7, #20]
  uint16_t         COM_RX_PIN[COMn]  = {COM1_RX_PIN};
34002d6c:	2300      	movs	r3, #0
34002d6e:	613b      	str	r3, [r7, #16]
34002d70:	2340      	movs	r3, #64	@ 0x40
34002d72:	823b      	strh	r3, [r7, #16]
  uint8_t          COM_TX_AF[COMn]   = {COM1_TX_AF};
34002d74:	2307      	movs	r3, #7
34002d76:	81bb      	strh	r3, [r7, #12]
  uint8_t          COM_RX_AF[COMn]   = {COM1_RX_AF};
34002d78:	2307      	movs	r3, #7
34002d7a:	813b      	strh	r3, [r7, #8]
  COM_TypeDef      COM;

  /* Get COM according instance */
  if (huart->Instance == COM1_UART)
34002d7c:	687b      	ldr	r3, [r7, #4]
34002d7e:	681b      	ldr	r3, [r3, #0]
34002d80:	4a2a      	ldr	r2, [pc, #168]	@ (34002e2c <UART_MspInit+0xec>)
34002d82:	4293      	cmp	r3, r2
34002d84:	d14a      	bne.n	34002e1c <UART_MspInit+0xdc>
  {
    COM = COM1;
34002d86:	2300      	movs	r3, #0
34002d88:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    /* Enable COM and GPIO clocks */
    COM1_TX_GPIO_CLK_ENABLE();
34002d8c:	2010      	movs	r0, #16
34002d8e:	f7ff ff09 	bl	34002ba4 <LL_AHB4_GRP1_EnableClock>
    COM1_RX_GPIO_CLK_ENABLE();
34002d92:	2008      	movs	r0, #8
34002d94:	f7ff ff06 	bl	34002ba4 <LL_AHB4_GRP1_EnableClock>
    COM1_CLK_ENABLE();
34002d98:	2010      	movs	r0, #16
34002d9a:	f7ff ff19 	bl	34002bd0 <LL_APB2_GRP1_EnableClock>
  {
      return;
  }

  /* Configure COM Tx as alternate function */
  GPIO_Init.Pin       = COM_TX_PIN[COM];
34002d9e:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
34002da2:	005b      	lsls	r3, r3, #1
34002da4:	3340      	adds	r3, #64	@ 0x40
34002da6:	443b      	add	r3, r7
34002da8:	f833 3c2c 	ldrh.w	r3, [r3, #-44]
34002dac:	62bb      	str	r3, [r7, #40]	@ 0x28
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
34002dae:	2302      	movs	r3, #2
34002db0:	62fb      	str	r3, [r7, #44]	@ 0x2c
  GPIO_Init.Speed     = GPIO_SPEED_FREQ_HIGH;
34002db2:	2302      	movs	r3, #2
34002db4:	637b      	str	r3, [r7, #52]	@ 0x34
  GPIO_Init.Pull      = GPIO_PULLUP;
34002db6:	2301      	movs	r3, #1
34002db8:	633b      	str	r3, [r7, #48]	@ 0x30
  GPIO_Init.Alternate = COM_TX_AF[COM];
34002dba:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
34002dbe:	3340      	adds	r3, #64	@ 0x40
34002dc0:	443b      	add	r3, r7
34002dc2:	f813 3c34 	ldrb.w	r3, [r3, #-52]
34002dc6:	63bb      	str	r3, [r7, #56]	@ 0x38
  HAL_GPIO_Init(COM_TX_PORT[COM], &GPIO_Init);
34002dc8:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
34002dcc:	009b      	lsls	r3, r3, #2
34002dce:	3340      	adds	r3, #64	@ 0x40
34002dd0:	443b      	add	r3, r7
34002dd2:	f853 3c20 	ldr.w	r3, [r3, #-32]
34002dd6:	f107 0228 	add.w	r2, r7, #40	@ 0x28
34002dda:	4611      	mov	r1, r2
34002ddc:	4618      	mov	r0, r3
34002dde:	f002 ffc5 	bl	34005d6c <HAL_GPIO_Init>

  /* Configure COM Rx as alternate function */
  GPIO_Init.Pin       = COM_RX_PIN[COM];
34002de2:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
34002de6:	005b      	lsls	r3, r3, #1
34002de8:	3340      	adds	r3, #64	@ 0x40
34002dea:	443b      	add	r3, r7
34002dec:	f833 3c30 	ldrh.w	r3, [r3, #-48]
34002df0:	62bb      	str	r3, [r7, #40]	@ 0x28
  GPIO_Init.Alternate = COM_RX_AF[COM];
34002df2:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
34002df6:	3340      	adds	r3, #64	@ 0x40
34002df8:	443b      	add	r3, r7
34002dfa:	f813 3c38 	ldrb.w	r3, [r3, #-56]
34002dfe:	63bb      	str	r3, [r7, #56]	@ 0x38
  HAL_GPIO_Init(COM_RX_PORT[COM], &GPIO_Init);
34002e00:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
34002e04:	009b      	lsls	r3, r3, #2
34002e06:	3340      	adds	r3, #64	@ 0x40
34002e08:	443b      	add	r3, r7
34002e0a:	f853 3c28 	ldr.w	r3, [r3, #-40]
34002e0e:	f107 0228 	add.w	r2, r7, #40	@ 0x28
34002e12:	4611      	mov	r1, r2
34002e14:	4618      	mov	r0, r3
34002e16:	f002 ffa9 	bl	34005d6c <HAL_GPIO_Init>
34002e1a:	e000      	b.n	34002e1e <UART_MspInit+0xde>
      return;
34002e1c:	bf00      	nop
}
34002e1e:	3740      	adds	r7, #64	@ 0x40
34002e20:	46bd      	mov	sp, r7
34002e22:	bd80      	pop	{r7, pc}
34002e24:	56021000 	.word	0x56021000
34002e28:	56020c00 	.word	0x56020c00
34002e2c:	52001000 	.word	0x52001000

34002e30 <LL_AHB4_GRP1_EnableClock>:
{
34002e30:	b480      	push	{r7}
34002e32:	b085      	sub	sp, #20
34002e34:	af00      	add	r7, sp, #0
34002e36:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34002e38:	4a07      	ldr	r2, [pc, #28]	@ (34002e58 <LL_AHB4_GRP1_EnableClock+0x28>)
34002e3a:	687b      	ldr	r3, [r7, #4]
34002e3c:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34002e40:	4b05      	ldr	r3, [pc, #20]	@ (34002e58 <LL_AHB4_GRP1_EnableClock+0x28>)
34002e42:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34002e46:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34002e48:	68fb      	ldr	r3, [r7, #12]
}
34002e4a:	bf00      	nop
34002e4c:	3714      	adds	r7, #20
34002e4e:	46bd      	mov	sp, r7
34002e50:	f85d 7b04 	ldr.w	r7, [sp], #4
34002e54:	4770      	bx	lr
34002e56:	bf00      	nop
34002e58:	56028000 	.word	0x56028000

34002e5c <LL_AHB5_GRP1_EnableClock>:
{
34002e5c:	b480      	push	{r7}
34002e5e:	b085      	sub	sp, #20
34002e60:	af00      	add	r7, sp, #0
34002e62:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34002e64:	4a07      	ldr	r2, [pc, #28]	@ (34002e84 <LL_AHB5_GRP1_EnableClock+0x28>)
34002e66:	687b      	ldr	r3, [r7, #4]
34002e68:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34002e6c:	4b05      	ldr	r3, [pc, #20]	@ (34002e84 <LL_AHB5_GRP1_EnableClock+0x28>)
34002e6e:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
34002e72:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34002e74:	68fb      	ldr	r3, [r7, #12]
}
34002e76:	bf00      	nop
34002e78:	3714      	adds	r7, #20
34002e7a:	46bd      	mov	sp, r7
34002e7c:	f85d 7b04 	ldr.w	r7, [sp], #4
34002e80:	4770      	bx	lr
34002e82:	bf00      	nop
34002e84:	56028000 	.word	0x56028000

34002e88 <LL_AHB5_GRP1_ForceReset>:
{
34002e88:	b480      	push	{r7}
34002e8a:	b083      	sub	sp, #12
34002e8c:	af00      	add	r7, sp, #0
34002e8e:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34002e90:	4a04      	ldr	r2, [pc, #16]	@ (34002ea4 <LL_AHB5_GRP1_ForceReset+0x1c>)
34002e92:	687b      	ldr	r3, [r7, #4]
34002e94:	f8c2 3a20 	str.w	r3, [r2, #2592]	@ 0xa20
}
34002e98:	bf00      	nop
34002e9a:	370c      	adds	r7, #12
34002e9c:	46bd      	mov	sp, r7
34002e9e:	f85d 7b04 	ldr.w	r7, [sp], #4
34002ea2:	4770      	bx	lr
34002ea4:	56028000 	.word	0x56028000

34002ea8 <LL_AHB5_GRP1_ReleaseReset>:
{
34002ea8:	b480      	push	{r7}
34002eaa:	b083      	sub	sp, #12
34002eac:	af00      	add	r7, sp, #0
34002eae:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34002eb0:	4b06      	ldr	r3, [pc, #24]	@ (34002ecc <LL_AHB5_GRP1_ReleaseReset+0x24>)
34002eb2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34002eb6:	461a      	mov	r2, r3
34002eb8:	687b      	ldr	r3, [r7, #4]
34002eba:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220
}
34002ebe:	bf00      	nop
34002ec0:	370c      	adds	r7, #12
34002ec2:	46bd      	mov	sp, r7
34002ec4:	f85d 7b04 	ldr.w	r7, [sp], #4
34002ec8:	4770      	bx	lr
34002eca:	bf00      	nop
34002ecc:	56028000 	.word	0x56028000

34002ed0 <BSP_XSPI_NOR_Init>:
  * @param  Instance   XSPI Instance
  * @param  Init       XSPI Init structure
  * @retval BSP status
  */
int32_t BSP_XSPI_NOR_Init(uint32_t Instance, BSP_XSPI_NOR_Init_t *Init)
{
34002ed0:	b590      	push	{r4, r7, lr}
34002ed2:	b095      	sub	sp, #84	@ 0x54
34002ed4:	af00      	add	r7, sp, #0
34002ed6:	6078      	str	r0, [r7, #4]
34002ed8:	6039      	str	r1, [r7, #0]
  int32_t ret;
  BSP_XSPI_NOR_Info_t pInfo;
  MX_XSPI_InitTypeDef xspi_init;

  /* Check if the instance is supported */
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
34002eda:	687b      	ldr	r3, [r7, #4]
34002edc:	2b00      	cmp	r3, #0
34002ede:	d003      	beq.n	34002ee8 <BSP_XSPI_NOR_Init+0x18>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34002ee0:	f06f 0301 	mvn.w	r3, #1
34002ee4:	64fb      	str	r3, [r7, #76]	@ 0x4c
34002ee6:	e080      	b.n	34002fea <BSP_XSPI_NOR_Init+0x11a>
  }
  else
  {
    /* Check if the instance is already initialized */
    if (Xspi_Nor_Ctx[Instance].IsInitialized == XSPI_ACCESS_NONE)
34002ee8:	4947      	ldr	r1, [pc, #284]	@ (34003008 <BSP_XSPI_NOR_Init+0x138>)
34002eea:	687a      	ldr	r2, [r7, #4]
34002eec:	4613      	mov	r3, r2
34002eee:	005b      	lsls	r3, r3, #1
34002ef0:	4413      	add	r3, r2
34002ef2:	440b      	add	r3, r1
34002ef4:	781b      	ldrb	r3, [r3, #0]
34002ef6:	2b00      	cmp	r3, #0
34002ef8:	d175      	bne.n	34002fe6 <BSP_XSPI_NOR_Init+0x116>
    {
#if (USE_HAL_XSPI_REGISTER_CALLBACKS == 0)
      /* Msp XSPI initialization */
      XSPI_NOR_MspInit(&hxspi_nor[Instance]);
34002efa:	687b      	ldr	r3, [r7, #4]
34002efc:	2264      	movs	r2, #100	@ 0x64
34002efe:	fb02 f303 	mul.w	r3, r2, r3
34002f02:	4a42      	ldr	r2, [pc, #264]	@ (3400300c <BSP_XSPI_NOR_Init+0x13c>)
34002f04:	4413      	add	r3, r2
34002f06:	4618      	mov	r0, r3
34002f08:	f000 f9b6 	bl	34003278 <XSPI_NOR_MspInit>
        }
      }
#endif /* USE_HAL_XSPI_REGISTER_CALLBACKS */

      /* Get Flash information of one memory */
      (void)MX25UM51245G_GetFlashInfo(&pInfo);
34002f0c:	f107 031c 	add.w	r3, r7, #28
34002f10:	4618      	mov	r0, r3
34002f12:	f7ff f9a5 	bl	34002260 <MX25UM51245G_GetFlashInfo>

      /* Fill config structure */
      xspi_init.ClockPrescaler = 3;
34002f16:	2303      	movs	r3, #3
34002f18:	613b      	str	r3, [r7, #16]
      xspi_init.MemorySize     = (uint32_t)POSITION_VAL((uint32_t)pInfo.FlashSize);
34002f1a:	69fb      	ldr	r3, [r7, #28]
34002f1c:	647b      	str	r3, [r7, #68]	@ 0x44
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
34002f1e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34002f20:	fa93 f3a3 	rbit	r3, r3
34002f24:	643b      	str	r3, [r7, #64]	@ 0x40
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
34002f26:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34002f28:	64bb      	str	r3, [r7, #72]	@ 0x48
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
34002f2a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34002f2c:	2b00      	cmp	r3, #0
34002f2e:	d101      	bne.n	34002f34 <BSP_XSPI_NOR_Init+0x64>
  {
    return 32U;
34002f30:	2320      	movs	r3, #32
34002f32:	e003      	b.n	34002f3c <BSP_XSPI_NOR_Init+0x6c>
  }
  return __builtin_clz(value);
34002f34:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34002f36:	fab3 f383 	clz	r3, r3
34002f3a:	b2db      	uxtb	r3, r3
34002f3c:	60fb      	str	r3, [r7, #12]
      xspi_init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
34002f3e:	2300      	movs	r3, #0
34002f40:	617b      	str	r3, [r7, #20]
      xspi_init.TransferRate   = (uint32_t) Init->TransferRate;
34002f42:	683b      	ldr	r3, [r7, #0]
34002f44:	785b      	ldrb	r3, [r3, #1]
34002f46:	61bb      	str	r3, [r7, #24]

      /* STM32 XSPI interface initialization */
      if (MX_XSPI_NOR_Init(&hxspi_nor[Instance], &xspi_init) != HAL_OK)
34002f48:	687b      	ldr	r3, [r7, #4]
34002f4a:	2264      	movs	r2, #100	@ 0x64
34002f4c:	fb02 f303 	mul.w	r3, r2, r3
34002f50:	4a2e      	ldr	r2, [pc, #184]	@ (3400300c <BSP_XSPI_NOR_Init+0x13c>)
34002f52:	4413      	add	r3, r2
34002f54:	f107 020c 	add.w	r2, r7, #12
34002f58:	4611      	mov	r1, r2
34002f5a:	4618      	mov	r0, r3
34002f5c:	f000 f858 	bl	34003010 <MX_XSPI_NOR_Init>
34002f60:	4603      	mov	r3, r0
34002f62:	2b00      	cmp	r3, #0
34002f64:	d003      	beq.n	34002f6e <BSP_XSPI_NOR_Init+0x9e>
      {
        ret = BSP_ERROR_PERIPH_FAILURE;
34002f66:	f06f 0303 	mvn.w	r3, #3
34002f6a:	64fb      	str	r3, [r7, #76]	@ 0x4c
34002f6c:	e03d      	b.n	34002fea <BSP_XSPI_NOR_Init+0x11a>
      }
      /* XSPI memory reset */
      else if (XSPI_NOR_ResetMemory(Instance) != BSP_ERROR_NONE)
34002f6e:	6878      	ldr	r0, [r7, #4]
34002f70:	f000 fa50 	bl	34003414 <XSPI_NOR_ResetMemory>
34002f74:	4603      	mov	r3, r0
34002f76:	2b00      	cmp	r3, #0
34002f78:	d003      	beq.n	34002f82 <BSP_XSPI_NOR_Init+0xb2>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
34002f7a:	f06f 0304 	mvn.w	r3, #4
34002f7e:	64fb      	str	r3, [r7, #76]	@ 0x4c
34002f80:	e033      	b.n	34002fea <BSP_XSPI_NOR_Init+0x11a>
      }
      /* Check if memory is ready */
      else if (MX25UM51245G_AutoPollingMemReady(&hxspi_nor[Instance], Xspi_Nor_Ctx[Instance].InterfaceMode,
34002f82:	687b      	ldr	r3, [r7, #4]
34002f84:	2264      	movs	r2, #100	@ 0x64
34002f86:	fb02 f303 	mul.w	r3, r2, r3
34002f8a:	4a20      	ldr	r2, [pc, #128]	@ (3400300c <BSP_XSPI_NOR_Init+0x13c>)
34002f8c:	1898      	adds	r0, r3, r2
34002f8e:	491e      	ldr	r1, [pc, #120]	@ (34003008 <BSP_XSPI_NOR_Init+0x138>)
34002f90:	687a      	ldr	r2, [r7, #4]
34002f92:	4613      	mov	r3, r2
34002f94:	005b      	lsls	r3, r3, #1
34002f96:	4413      	add	r3, r2
34002f98:	440b      	add	r3, r1
34002f9a:	3301      	adds	r3, #1
34002f9c:	7819      	ldrb	r1, [r3, #0]
34002f9e:	4c1a      	ldr	r4, [pc, #104]	@ (34003008 <BSP_XSPI_NOR_Init+0x138>)
34002fa0:	687a      	ldr	r2, [r7, #4]
34002fa2:	4613      	mov	r3, r2
34002fa4:	005b      	lsls	r3, r3, #1
34002fa6:	4413      	add	r3, r2
34002fa8:	4423      	add	r3, r4
34002faa:	3302      	adds	r3, #2
34002fac:	781b      	ldrb	r3, [r3, #0]
34002fae:	461a      	mov	r2, r3
34002fb0:	f7ff f985 	bl	340022be <MX25UM51245G_AutoPollingMemReady>
34002fb4:	4603      	mov	r3, r0
34002fb6:	2b00      	cmp	r3, #0
34002fb8:	d003      	beq.n	34002fc2 <BSP_XSPI_NOR_Init+0xf2>
                                                Xspi_Nor_Ctx[Instance].TransferRate) != MX25UM51245G_OK)
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
34002fba:	f06f 0304 	mvn.w	r3, #4
34002fbe:	64fb      	str	r3, [r7, #76]	@ 0x4c
34002fc0:	e013      	b.n	34002fea <BSP_XSPI_NOR_Init+0x11a>
      }
      /* Configure the memory */
      else if (BSP_XSPI_NOR_ConfigFlash(Instance, Init->InterfaceMode, Init->TransferRate) != BSP_ERROR_NONE)
34002fc2:	683b      	ldr	r3, [r7, #0]
34002fc4:	7819      	ldrb	r1, [r3, #0]
34002fc6:	683b      	ldr	r3, [r7, #0]
34002fc8:	785b      	ldrb	r3, [r3, #1]
34002fca:	461a      	mov	r2, r3
34002fcc:	6878      	ldr	r0, [r7, #4]
34002fce:	f000 f8c7 	bl	34003160 <BSP_XSPI_NOR_ConfigFlash>
34002fd2:	4603      	mov	r3, r0
34002fd4:	2b00      	cmp	r3, #0
34002fd6:	d003      	beq.n	34002fe0 <BSP_XSPI_NOR_Init+0x110>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
34002fd8:	f06f 0304 	mvn.w	r3, #4
34002fdc:	64fb      	str	r3, [r7, #76]	@ 0x4c
34002fde:	e004      	b.n	34002fea <BSP_XSPI_NOR_Init+0x11a>
      }
      else
      {
        ret = BSP_ERROR_NONE;
34002fe0:	2300      	movs	r3, #0
34002fe2:	64fb      	str	r3, [r7, #76]	@ 0x4c
34002fe4:	e001      	b.n	34002fea <BSP_XSPI_NOR_Init+0x11a>
      }
    }
    else
    {
      ret = BSP_ERROR_NONE;
34002fe6:	2300      	movs	r3, #0
34002fe8:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
  }

  HAL_XSPI_SetClockPrescaler(&hxspi_nor[Instance], 0);
34002fea:	687b      	ldr	r3, [r7, #4]
34002fec:	2264      	movs	r2, #100	@ 0x64
34002fee:	fb02 f303 	mul.w	r3, r2, r3
34002ff2:	4a06      	ldr	r2, [pc, #24]	@ (3400300c <BSP_XSPI_NOR_Init+0x13c>)
34002ff4:	4413      	add	r3, r2
34002ff6:	2100      	movs	r1, #0
34002ff8:	4618      	mov	r0, r3
34002ffa:	f014 fd8b 	bl	34017b14 <HAL_XSPI_SetClockPrescaler>
  /* Return BSP status */
  return ret;
34002ffe:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
34003000:	4618      	mov	r0, r3
34003002:	3754      	adds	r7, #84	@ 0x54
34003004:	46bd      	mov	sp, r7
34003006:	bd90      	pop	{r4, r7, pc}
34003008:	3402100c 	.word	0x3402100c
3400300c:	34020fa8 	.word	0x34020fa8

34003010 <MX_XSPI_NOR_Init>:
  * @param  hxspi          XSPI handle
  * @param  Init           XSPI config structure
  * @retval BSP status
  */
__weak HAL_StatusTypeDef MX_XSPI_NOR_Init(XSPI_HandleTypeDef *hxspi, MX_XSPI_InitTypeDef *Init)
{
34003010:	b580      	push	{r7, lr}
34003012:	b082      	sub	sp, #8
34003014:	af00      	add	r7, sp, #0
34003016:	6078      	str	r0, [r7, #4]
34003018:	6039      	str	r1, [r7, #0]
  /* XSPI initialization */
  hxspi->Instance = XSPI2;
3400301a:	687b      	ldr	r3, [r7, #4]
3400301c:	4a1e      	ldr	r2, [pc, #120]	@ (34003098 <MX_XSPI_NOR_Init+0x88>)
3400301e:	601a      	str	r2, [r3, #0]

  hxspi->Init.FifoThresholdByte       = 4;
34003020:	687b      	ldr	r3, [r7, #4]
34003022:	2204      	movs	r2, #4
34003024:	605a      	str	r2, [r3, #4]
  hxspi->Init.MemoryMode              = HAL_XSPI_SINGLE_MEM;
34003026:	687b      	ldr	r3, [r7, #4]
34003028:	2200      	movs	r2, #0
3400302a:	609a      	str	r2, [r3, #8]
  hxspi->Init.MemorySize              = Init->MemorySize; /* 512 MBits */
3400302c:	683b      	ldr	r3, [r7, #0]
3400302e:	681a      	ldr	r2, [r3, #0]
34003030:	687b      	ldr	r3, [r7, #4]
34003032:	611a      	str	r2, [r3, #16]
  hxspi->Init.ChipSelectHighTimeCycle = 2;
34003034:	687b      	ldr	r3, [r7, #4]
34003036:	2202      	movs	r2, #2
34003038:	615a      	str	r2, [r3, #20]
  hxspi->Init.FreeRunningClock        = HAL_XSPI_FREERUNCLK_DISABLE;
3400303a:	687b      	ldr	r3, [r7, #4]
3400303c:	2200      	movs	r2, #0
3400303e:	619a      	str	r2, [r3, #24]
  hxspi->Init.ClockMode               = HAL_XSPI_CLOCK_MODE_0;
34003040:	687b      	ldr	r3, [r7, #4]
34003042:	2200      	movs	r2, #0
34003044:	61da      	str	r2, [r3, #28]
  hxspi->Init.WrapSize                = HAL_XSPI_WRAP_NOT_SUPPORTED;
34003046:	687b      	ldr	r3, [r7, #4]
34003048:	2200      	movs	r2, #0
3400304a:	621a      	str	r2, [r3, #32]
  hxspi->Init.ClockPrescaler          = Init->ClockPrescaler;
3400304c:	683b      	ldr	r3, [r7, #0]
3400304e:	685a      	ldr	r2, [r3, #4]
34003050:	687b      	ldr	r3, [r7, #4]
34003052:	625a      	str	r2, [r3, #36]	@ 0x24
  hxspi->Init.SampleShifting          = Init->SampleShifting;
34003054:	683b      	ldr	r3, [r7, #0]
34003056:	689a      	ldr	r2, [r3, #8]
34003058:	687b      	ldr	r3, [r7, #4]
3400305a:	629a      	str	r2, [r3, #40]	@ 0x28
  hxspi->Init.ChipSelectBoundary      = 0;
3400305c:	687b      	ldr	r3, [r7, #4]
3400305e:	2200      	movs	r2, #0
34003060:	631a      	str	r2, [r3, #48]	@ 0x30
#if defined (OCTOSPI_DCR1_DLYBYP)
  hxspi->Init.DelayBlockBypass           = HAL_XSPI_DELAY_BLOCK_BYPASS;
#endif /* OCTOSPI_DCR1_DLYBYP */

  if (Init->TransferRate == (uint32_t) BSP_XSPI_NOR_DTR_TRANSFER)
34003062:	683b      	ldr	r3, [r7, #0]
34003064:	68db      	ldr	r3, [r3, #12]
34003066:	2b01      	cmp	r3, #1
34003068:	d108      	bne.n	3400307c <MX_XSPI_NOR_Init+0x6c>
  {
    hxspi->Init.MemoryType            = HAL_XSPI_MEMTYPE_MACRONIX;
3400306a:	687b      	ldr	r3, [r7, #4]
3400306c:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34003070:	60da      	str	r2, [r3, #12]
    hxspi->Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
34003072:	687b      	ldr	r3, [r7, #4]
34003074:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34003078:	62da      	str	r2, [r3, #44]	@ 0x2c
3400307a:	e005      	b.n	34003088 <MX_XSPI_NOR_Init+0x78>
  }
  else
  {
    hxspi->Init.MemoryType            = HAL_XSPI_MEMTYPE_MICRON;
3400307c:	687b      	ldr	r3, [r7, #4]
3400307e:	2200      	movs	r2, #0
34003080:	60da      	str	r2, [r3, #12]
    hxspi->Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
34003082:	687b      	ldr	r3, [r7, #4]
34003084:	2200      	movs	r2, #0
34003086:	62da      	str	r2, [r3, #44]	@ 0x2c
  }

  return HAL_XSPI_Init(hxspi);
34003088:	6878      	ldr	r0, [r7, #4]
3400308a:	f013 fdb7 	bl	34016bfc <HAL_XSPI_Init>
3400308e:	4603      	mov	r3, r0
}
34003090:	4618      	mov	r0, r3
34003092:	3708      	adds	r7, #8
34003094:	46bd      	mov	sp, r7
34003096:	bd80      	pop	{r7, pc}
34003098:	5802a000 	.word	0x5802a000

3400309c <BSP_XSPI_NOR_EnableMemoryMappedMode>:
  * @brief  Configure the XSPI in memory-mapped mode
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
int32_t BSP_XSPI_NOR_EnableMemoryMappedMode(uint32_t Instance)
{
3400309c:	b580      	push	{r7, lr}
3400309e:	b084      	sub	sp, #16
340030a0:	af00      	add	r7, sp, #0
340030a2:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
340030a4:	2300      	movs	r3, #0
340030a6:	60fb      	str	r3, [r7, #12]

  /* Check if the instance is supported */
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
340030a8:	687b      	ldr	r3, [r7, #4]
340030aa:	2b00      	cmp	r3, #0
340030ac:	d003      	beq.n	340030b6 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
340030ae:	f06f 0301 	mvn.w	r3, #1
340030b2:	60fb      	str	r3, [r7, #12]
340030b4:	e04b      	b.n	3400314e <BSP_XSPI_NOR_EnableMemoryMappedMode+0xb2>
  }
  else
  {
    if (Xspi_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_STR_TRANSFER)
340030b6:	4928      	ldr	r1, [pc, #160]	@ (34003158 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xbc>)
340030b8:	687a      	ldr	r2, [r7, #4]
340030ba:	4613      	mov	r3, r2
340030bc:	005b      	lsls	r3, r3, #1
340030be:	4413      	add	r3, r2
340030c0:	440b      	add	r3, r1
340030c2:	3302      	adds	r3, #2
340030c4:	781b      	ldrb	r3, [r3, #0]
340030c6:	2b00      	cmp	r3, #0
340030c8:	d121      	bne.n	3400310e <BSP_XSPI_NOR_EnableMemoryMappedMode+0x72>
    {
      if (MX25UM51245G_EnableMemoryMappedModeSTR(&hxspi_nor[Instance], Xspi_Nor_Ctx[Instance].InterfaceMode,
340030ca:	687b      	ldr	r3, [r7, #4]
340030cc:	2264      	movs	r2, #100	@ 0x64
340030ce:	fb02 f303 	mul.w	r3, r2, r3
340030d2:	4a22      	ldr	r2, [pc, #136]	@ (3400315c <BSP_XSPI_NOR_EnableMemoryMappedMode+0xc0>)
340030d4:	1898      	adds	r0, r3, r2
340030d6:	4920      	ldr	r1, [pc, #128]	@ (34003158 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xbc>)
340030d8:	687a      	ldr	r2, [r7, #4]
340030da:	4613      	mov	r3, r2
340030dc:	005b      	lsls	r3, r3, #1
340030de:	4413      	add	r3, r2
340030e0:	440b      	add	r3, r1
340030e2:	3301      	adds	r3, #1
340030e4:	781b      	ldrb	r3, [r3, #0]
340030e6:	2201      	movs	r2, #1
340030e8:	4619      	mov	r1, r3
340030ea:	f7ff f998 	bl	3400241e <MX25UM51245G_EnableSTRMemoryMappedMode>
340030ee:	4603      	mov	r3, r0
340030f0:	2b00      	cmp	r3, #0
340030f2:	d003      	beq.n	340030fc <BSP_XSPI_NOR_EnableMemoryMappedMode+0x60>
                                                 MX25UM51245G_4BYTES_SIZE) != MX25UM51245G_OK)
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
340030f4:	f06f 0304 	mvn.w	r3, #4
340030f8:	60fb      	str	r3, [r7, #12]
340030fa:	e028      	b.n	3400314e <BSP_XSPI_NOR_EnableMemoryMappedMode+0xb2>
      }
      else /* Update XSPI context if all operations are well done */
      {
        Xspi_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_MMP;
340030fc:	4916      	ldr	r1, [pc, #88]	@ (34003158 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xbc>)
340030fe:	687a      	ldr	r2, [r7, #4]
34003100:	4613      	mov	r3, r2
34003102:	005b      	lsls	r3, r3, #1
34003104:	4413      	add	r3, r2
34003106:	440b      	add	r3, r1
34003108:	2202      	movs	r2, #2
3400310a:	701a      	strb	r2, [r3, #0]
3400310c:	e01f      	b.n	3400314e <BSP_XSPI_NOR_EnableMemoryMappedMode+0xb2>
      }
    }
    else
    {
      if (MX25UM51245G_EnableMemoryMappedModeDTR(&hxspi_nor[Instance],
3400310e:	687b      	ldr	r3, [r7, #4]
34003110:	2264      	movs	r2, #100	@ 0x64
34003112:	fb02 f303 	mul.w	r3, r2, r3
34003116:	4a11      	ldr	r2, [pc, #68]	@ (3400315c <BSP_XSPI_NOR_EnableMemoryMappedMode+0xc0>)
34003118:	1898      	adds	r0, r3, r2
3400311a:	490f      	ldr	r1, [pc, #60]	@ (34003158 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xbc>)
3400311c:	687a      	ldr	r2, [r7, #4]
3400311e:	4613      	mov	r3, r2
34003120:	005b      	lsls	r3, r3, #1
34003122:	4413      	add	r3, r2
34003124:	440b      	add	r3, r1
34003126:	3301      	adds	r3, #1
34003128:	781b      	ldrb	r3, [r3, #0]
3400312a:	4619      	mov	r1, r3
3400312c:	f7ff fa21 	bl	34002572 <MX25UM51245G_EnableDTRMemoryMappedMode>
34003130:	4603      	mov	r3, r0
34003132:	2b00      	cmp	r3, #0
34003134:	d003      	beq.n	3400313e <BSP_XSPI_NOR_EnableMemoryMappedMode+0xa2>
                                                 Xspi_Nor_Ctx[Instance].InterfaceMode) != MX25UM51245G_OK)
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
34003136:	f06f 0304 	mvn.w	r3, #4
3400313a:	60fb      	str	r3, [r7, #12]
3400313c:	e007      	b.n	3400314e <BSP_XSPI_NOR_EnableMemoryMappedMode+0xb2>
      }
      else /* Update XSPI context if all operations are well done */
      {
        Xspi_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_MMP;
3400313e:	4906      	ldr	r1, [pc, #24]	@ (34003158 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xbc>)
34003140:	687a      	ldr	r2, [r7, #4]
34003142:	4613      	mov	r3, r2
34003144:	005b      	lsls	r3, r3, #1
34003146:	4413      	add	r3, r2
34003148:	440b      	add	r3, r1
3400314a:	2202      	movs	r2, #2
3400314c:	701a      	strb	r2, [r3, #0]
      }
    }
  }

  /* Return BSP status */
  return ret;
3400314e:	68fb      	ldr	r3, [r7, #12]
}
34003150:	4618      	mov	r0, r3
34003152:	3710      	adds	r7, #16
34003154:	46bd      	mov	sp, r7
34003156:	bd80      	pop	{r7, pc}
34003158:	3402100c 	.word	0x3402100c
3400315c:	34020fa8 	.word	0x34020fa8

34003160 <BSP_XSPI_NOR_ConfigFlash>:
  * @param  Mode      XSPI mode
  * @param  Rate      XSPI transfer rate
  * @retval BSP status
  */
int32_t BSP_XSPI_NOR_ConfigFlash(uint32_t Instance, BSP_XSPI_NOR_Interface_t Mode, BSP_XSPI_NOR_Transfer_t Rate)
{
34003160:	b580      	push	{r7, lr}
34003162:	b084      	sub	sp, #16
34003164:	af00      	add	r7, sp, #0
34003166:	6078      	str	r0, [r7, #4]
34003168:	460b      	mov	r3, r1
3400316a:	70fb      	strb	r3, [r7, #3]
3400316c:	4613      	mov	r3, r2
3400316e:	70bb      	strb	r3, [r7, #2]
  int32_t ret = BSP_ERROR_NONE;
34003170:	2300      	movs	r3, #0
34003172:	60fb      	str	r3, [r7, #12]

  /* Check if the instance is supported */
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
34003174:	687b      	ldr	r3, [r7, #4]
34003176:	2b00      	cmp	r3, #0
34003178:	d003      	beq.n	34003182 <BSP_XSPI_NOR_ConfigFlash+0x22>
  {
    ret = BSP_ERROR_WRONG_PARAM;
3400317a:	f06f 0301 	mvn.w	r3, #1
3400317e:	60fb      	str	r3, [r7, #12]
34003180:	e072      	b.n	34003268 <BSP_XSPI_NOR_ConfigFlash+0x108>
  }
  else
  {
    /* Check if MMP mode locked ************************************************/
    if (Xspi_Nor_Ctx[Instance].IsInitialized == XSPI_ACCESS_MMP)
34003182:	493c      	ldr	r1, [pc, #240]	@ (34003274 <BSP_XSPI_NOR_ConfigFlash+0x114>)
34003184:	687a      	ldr	r2, [r7, #4]
34003186:	4613      	mov	r3, r2
34003188:	005b      	lsls	r3, r3, #1
3400318a:	4413      	add	r3, r2
3400318c:	440b      	add	r3, r1
3400318e:	781b      	ldrb	r3, [r3, #0]
34003190:	2b02      	cmp	r3, #2
34003192:	d103      	bne.n	3400319c <BSP_XSPI_NOR_ConfigFlash+0x3c>
    {
      ret = BSP_ERROR_XSPI_MMP_LOCK_FAILURE;
34003194:	f06f 0319 	mvn.w	r3, #25
34003198:	60fb      	str	r3, [r7, #12]
3400319a:	e065      	b.n	34003268 <BSP_XSPI_NOR_ConfigFlash+0x108>
    }
    else
    {
      /* Setup Flash interface ***************************************************/
      switch (Xspi_Nor_Ctx[Instance].InterfaceMode)
3400319c:	4935      	ldr	r1, [pc, #212]	@ (34003274 <BSP_XSPI_NOR_ConfigFlash+0x114>)
3400319e:	687a      	ldr	r2, [r7, #4]
340031a0:	4613      	mov	r3, r2
340031a2:	005b      	lsls	r3, r3, #1
340031a4:	4413      	add	r3, r2
340031a6:	440b      	add	r3, r1
340031a8:	3301      	adds	r3, #1
340031aa:	781b      	ldrb	r3, [r3, #0]
340031ac:	2b01      	cmp	r3, #1
340031ae:	d12b      	bne.n	34003208 <BSP_XSPI_NOR_ConfigFlash+0xa8>
      {
        case BSP_XSPI_NOR_OPI_MODE :  /* 8-8-8 commands */
          if ((Mode != BSP_XSPI_NOR_OPI_MODE) || (Rate != Xspi_Nor_Ctx[Instance].TransferRate))
340031b0:	78fb      	ldrb	r3, [r7, #3]
340031b2:	2b01      	cmp	r3, #1
340031b4:	d10a      	bne.n	340031cc <BSP_XSPI_NOR_ConfigFlash+0x6c>
340031b6:	492f      	ldr	r1, [pc, #188]	@ (34003274 <BSP_XSPI_NOR_ConfigFlash+0x114>)
340031b8:	687a      	ldr	r2, [r7, #4]
340031ba:	4613      	mov	r3, r2
340031bc:	005b      	lsls	r3, r3, #1
340031be:	4413      	add	r3, r2
340031c0:	440b      	add	r3, r1
340031c2:	3302      	adds	r3, #2
340031c4:	781b      	ldrb	r3, [r3, #0]
340031c6:	78ba      	ldrb	r2, [r7, #2]
340031c8:	429a      	cmp	r2, r3
340031ca:	d02d      	beq.n	34003228 <BSP_XSPI_NOR_ConfigFlash+0xc8>
          {
            /* Exit OPI mode */
            ret = XSPI_NOR_ExitOPIMode(Instance);
340031cc:	6878      	ldr	r0, [r7, #4]
340031ce:	f000 fb7d 	bl	340038cc <XSPI_NOR_ExitOPIMode>
340031d2:	60f8      	str	r0, [r7, #12]

            if ((ret == BSP_ERROR_NONE) && (Mode == BSP_XSPI_NOR_OPI_MODE))
340031d4:	68fb      	ldr	r3, [r7, #12]
340031d6:	2b00      	cmp	r3, #0
340031d8:	d126      	bne.n	34003228 <BSP_XSPI_NOR_ConfigFlash+0xc8>
340031da:	78fb      	ldrb	r3, [r7, #3]
340031dc:	2b01      	cmp	r3, #1
340031de:	d123      	bne.n	34003228 <BSP_XSPI_NOR_ConfigFlash+0xc8>
            {

              if (Xspi_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_STR_TRANSFER)
340031e0:	4924      	ldr	r1, [pc, #144]	@ (34003274 <BSP_XSPI_NOR_ConfigFlash+0x114>)
340031e2:	687a      	ldr	r2, [r7, #4]
340031e4:	4613      	mov	r3, r2
340031e6:	005b      	lsls	r3, r3, #1
340031e8:	4413      	add	r3, r2
340031ea:	440b      	add	r3, r1
340031ec:	3302      	adds	r3, #2
340031ee:	781b      	ldrb	r3, [r3, #0]
340031f0:	2b00      	cmp	r3, #0
340031f2:	d104      	bne.n	340031fe <BSP_XSPI_NOR_ConfigFlash+0x9e>
              {
                /* Enter DTR OPI mode */
                ret = XSPI_NOR_EnterDOPIMode(Instance);
340031f4:	6878      	ldr	r0, [r7, #4]
340031f6:	f000 f9ad 	bl	34003554 <XSPI_NOR_EnterDOPIMode>
340031fa:	60f8      	str	r0, [r7, #12]
                /* Enter STR OPI mode */
                ret = XSPI_NOR_EnterSOPIMode(Instance);
              }
            }
          }
          break;
340031fc:	e014      	b.n	34003228 <BSP_XSPI_NOR_ConfigFlash+0xc8>
                ret = XSPI_NOR_EnterSOPIMode(Instance);
340031fe:	6878      	ldr	r0, [r7, #4]
34003200:	f000 fa98 	bl	34003734 <XSPI_NOR_EnterSOPIMode>
34003204:	60f8      	str	r0, [r7, #12]
          break;
34003206:	e00f      	b.n	34003228 <BSP_XSPI_NOR_ConfigFlash+0xc8>

        case BSP_XSPI_NOR_SPI_MODE :  /* 1-1-1 commands, Power on H/W default setting */
        default :
          if (Mode == BSP_XSPI_NOR_OPI_MODE)
34003208:	78fb      	ldrb	r3, [r7, #3]
3400320a:	2b01      	cmp	r3, #1
3400320c:	d10e      	bne.n	3400322c <BSP_XSPI_NOR_ConfigFlash+0xcc>
          {
            if (Rate == BSP_XSPI_NOR_STR_TRANSFER)
3400320e:	78bb      	ldrb	r3, [r7, #2]
34003210:	2b00      	cmp	r3, #0
34003212:	d104      	bne.n	3400321e <BSP_XSPI_NOR_ConfigFlash+0xbe>
            {
              /* Enter STR OPI mode */
              ret = XSPI_NOR_EnterSOPIMode(Instance);
34003214:	6878      	ldr	r0, [r7, #4]
34003216:	f000 fa8d 	bl	34003734 <XSPI_NOR_EnterSOPIMode>
3400321a:	60f8      	str	r0, [r7, #12]
            {
              /* Enter DTR OPI mode */
              ret = XSPI_NOR_EnterDOPIMode(Instance);
            }
          }
          break;
3400321c:	e006      	b.n	3400322c <BSP_XSPI_NOR_ConfigFlash+0xcc>
              ret = XSPI_NOR_EnterDOPIMode(Instance);
3400321e:	6878      	ldr	r0, [r7, #4]
34003220:	f000 f998 	bl	34003554 <XSPI_NOR_EnterDOPIMode>
34003224:	60f8      	str	r0, [r7, #12]
          break;
34003226:	e001      	b.n	3400322c <BSP_XSPI_NOR_ConfigFlash+0xcc>
          break;
34003228:	bf00      	nop
3400322a:	e000      	b.n	3400322e <BSP_XSPI_NOR_ConfigFlash+0xce>
          break;
3400322c:	bf00      	nop
      }

      /* Update XSPI context if all operations are well done */
      if (ret == BSP_ERROR_NONE)
3400322e:	68fb      	ldr	r3, [r7, #12]
34003230:	2b00      	cmp	r3, #0
34003232:	d119      	bne.n	34003268 <BSP_XSPI_NOR_ConfigFlash+0x108>
      {
        /* Update current status parameter *****************************************/
        Xspi_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;
34003234:	490f      	ldr	r1, [pc, #60]	@ (34003274 <BSP_XSPI_NOR_ConfigFlash+0x114>)
34003236:	687a      	ldr	r2, [r7, #4]
34003238:	4613      	mov	r3, r2
3400323a:	005b      	lsls	r3, r3, #1
3400323c:	4413      	add	r3, r2
3400323e:	440b      	add	r3, r1
34003240:	2201      	movs	r2, #1
34003242:	701a      	strb	r2, [r3, #0]
        Xspi_Nor_Ctx[Instance].InterfaceMode = Mode;
34003244:	490b      	ldr	r1, [pc, #44]	@ (34003274 <BSP_XSPI_NOR_ConfigFlash+0x114>)
34003246:	687a      	ldr	r2, [r7, #4]
34003248:	4613      	mov	r3, r2
3400324a:	005b      	lsls	r3, r3, #1
3400324c:	4413      	add	r3, r2
3400324e:	440b      	add	r3, r1
34003250:	3301      	adds	r3, #1
34003252:	78fa      	ldrb	r2, [r7, #3]
34003254:	701a      	strb	r2, [r3, #0]
        Xspi_Nor_Ctx[Instance].TransferRate  = Rate;
34003256:	4907      	ldr	r1, [pc, #28]	@ (34003274 <BSP_XSPI_NOR_ConfigFlash+0x114>)
34003258:	687a      	ldr	r2, [r7, #4]
3400325a:	4613      	mov	r3, r2
3400325c:	005b      	lsls	r3, r3, #1
3400325e:	4413      	add	r3, r2
34003260:	440b      	add	r3, r1
34003262:	3302      	adds	r3, #2
34003264:	78ba      	ldrb	r2, [r7, #2]
34003266:	701a      	strb	r2, [r3, #0]
      }
    }
  }

  /* Return BSP status */
  return ret;
34003268:	68fb      	ldr	r3, [r7, #12]
}
3400326a:	4618      	mov	r0, r3
3400326c:	3710      	adds	r7, #16
3400326e:	46bd      	mov	sp, r7
34003270:	bd80      	pop	{r7, pc}
34003272:	bf00      	nop
34003274:	3402100c 	.word	0x3402100c

34003278 <XSPI_NOR_MspInit>:
  * @brief  Initializes the XSPI MSP.
  * @param  hxspi XSPI handle
  * @retval None
  */
static void XSPI_NOR_MspInit(XSPI_HandleTypeDef *hxspi)
{
34003278:	b580      	push	{r7, lr}
3400327a:	b088      	sub	sp, #32
3400327c:	af00      	add	r7, sp, #0
3400327e:	6078      	str	r0, [r7, #4]

  /* hxspi unused argument(s) compilation warning */
  UNUSED(hxspi);

  /* Enable the XSPI memory interface clock */
  XSPI_CLK_ENABLE();
34003280:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
34003284:	f7ff fdea 	bl	34002e5c <LL_AHB5_GRP1_EnableClock>

  /* XSPI power enable */
  __HAL_RCC_PWR_CLK_ENABLE();
34003288:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
3400328c:	f7ff fdd0 	bl	34002e30 <LL_AHB4_GRP1_EnableClock>
  HAL_PWREx_EnableVddIO3();
34003290:	f003 f968 	bl	34006564 <HAL_PWREx_EnableVddIO3>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO3, PWR_VDDIO_RANGE_1V8);
34003294:	2101      	movs	r1, #1
34003296:	2002      	movs	r0, #2
34003298:	f003 f8f4 	bl	34006484 <HAL_PWREx_ConfigVddIORange>

  /* Reset the XSPI memory interface */
  XSPI_FORCE_RESET();
3400329c:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
340032a0:	f7ff fdf2 	bl	34002e88 <LL_AHB5_GRP1_ForceReset>
  XSPI_RELEASE_RESET();
340032a4:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
340032a8:	f7ff fdfe 	bl	34002ea8 <LL_AHB5_GRP1_ReleaseReset>

  /* Enable GPIO clocks */
  XSPI_CLK_GPIO_CLK_ENABLE();
340032ac:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
340032b0:	f7ff fdbe 	bl	34002e30 <LL_AHB4_GRP1_EnableClock>
  XSPI_DQS_GPIO_CLK_ENABLE();
340032b4:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
340032b8:	f7ff fdba 	bl	34002e30 <LL_AHB4_GRP1_EnableClock>
  XSPI_CS_GPIO_CLK_ENABLE();
340032bc:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
340032c0:	f7ff fdb6 	bl	34002e30 <LL_AHB4_GRP1_EnableClock>
  XSPI_D0_GPIO_CLK_ENABLE();
340032c4:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
340032c8:	f7ff fdb2 	bl	34002e30 <LL_AHB4_GRP1_EnableClock>
  XSPI_D1_GPIO_CLK_ENABLE();
340032cc:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
340032d0:	f7ff fdae 	bl	34002e30 <LL_AHB4_GRP1_EnableClock>
  XSPI_D2_GPIO_CLK_ENABLE();
340032d4:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
340032d8:	f7ff fdaa 	bl	34002e30 <LL_AHB4_GRP1_EnableClock>
  XSPI_D3_GPIO_CLK_ENABLE();
340032dc:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
340032e0:	f7ff fda6 	bl	34002e30 <LL_AHB4_GRP1_EnableClock>
  XSPI_D4_GPIO_CLK_ENABLE();
340032e4:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
340032e8:	f7ff fda2 	bl	34002e30 <LL_AHB4_GRP1_EnableClock>
  XSPI_D5_GPIO_CLK_ENABLE();
340032ec:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
340032f0:	f7ff fd9e 	bl	34002e30 <LL_AHB4_GRP1_EnableClock>
  XSPI_D6_GPIO_CLK_ENABLE();
340032f4:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
340032f8:	f7ff fd9a 	bl	34002e30 <LL_AHB4_GRP1_EnableClock>
  XSPI_D7_GPIO_CLK_ENABLE();
340032fc:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34003300:	f7ff fd96 	bl	34002e30 <LL_AHB4_GRP1_EnableClock>

  /* XSPI CS GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_CS_PIN;
34003304:	2302      	movs	r3, #2
34003306:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
34003308:	2302      	movs	r3, #2
3400330a:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
3400330c:	2301      	movs	r3, #1
3400330e:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
34003310:	2303      	movs	r3, #3
34003312:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Alternate = XSPI_CS_PIN_AF;
34003314:	2309      	movs	r3, #9
34003316:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_CS_GPIO_PORT, &GPIO_InitStruct);
34003318:	f107 030c 	add.w	r3, r7, #12
3400331c:	4619      	mov	r1, r3
3400331e:	483c      	ldr	r0, [pc, #240]	@ (34003410 <XSPI_NOR_MspInit+0x198>)
34003320:	f002 fd24 	bl	34005d6c <HAL_GPIO_Init>

  /* XSPI CLK GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_CLK_PIN;
34003324:	2340      	movs	r3, #64	@ 0x40
34003326:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
34003328:	2300      	movs	r3, #0
3400332a:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = XSPI_CLK_PIN_AF;
3400332c:	2309      	movs	r3, #9
3400332e:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_CLK_GPIO_PORT, &GPIO_InitStruct);
34003330:	f107 030c 	add.w	r3, r7, #12
34003334:	4619      	mov	r1, r3
34003336:	4836      	ldr	r0, [pc, #216]	@ (34003410 <XSPI_NOR_MspInit+0x198>)
34003338:	f002 fd18 	bl	34005d6c <HAL_GPIO_Init>

  /* XSPI D0 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_D0_PIN;
3400333c:	2304      	movs	r3, #4
3400333e:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_D0_PIN_AF;
34003340:	2309      	movs	r3, #9
34003342:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_D0_GPIO_PORT, &GPIO_InitStruct);
34003344:	f107 030c 	add.w	r3, r7, #12
34003348:	4619      	mov	r1, r3
3400334a:	4831      	ldr	r0, [pc, #196]	@ (34003410 <XSPI_NOR_MspInit+0x198>)
3400334c:	f002 fd0e 	bl	34005d6c <HAL_GPIO_Init>

  /* XSPI D1 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_D1_PIN;
34003350:	2308      	movs	r3, #8
34003352:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_D1_PIN_AF;
34003354:	2309      	movs	r3, #9
34003356:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_D1_GPIO_PORT, &GPIO_InitStruct);
34003358:	f107 030c 	add.w	r3, r7, #12
3400335c:	4619      	mov	r1, r3
3400335e:	482c      	ldr	r0, [pc, #176]	@ (34003410 <XSPI_NOR_MspInit+0x198>)
34003360:	f002 fd04 	bl	34005d6c <HAL_GPIO_Init>

  /* XSPI D2 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_D2_PIN;
34003364:	2310      	movs	r3, #16
34003366:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_D2_PIN_AF;
34003368:	2309      	movs	r3, #9
3400336a:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_D2_GPIO_PORT, &GPIO_InitStruct);
3400336c:	f107 030c 	add.w	r3, r7, #12
34003370:	4619      	mov	r1, r3
34003372:	4827      	ldr	r0, [pc, #156]	@ (34003410 <XSPI_NOR_MspInit+0x198>)
34003374:	f002 fcfa 	bl	34005d6c <HAL_GPIO_Init>

  /* XSPI D3 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_D3_PIN;
34003378:	2320      	movs	r3, #32
3400337a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_D3_PIN_AF;
3400337c:	2309      	movs	r3, #9
3400337e:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_D3_GPIO_PORT, &GPIO_InitStruct);
34003380:	f107 030c 	add.w	r3, r7, #12
34003384:	4619      	mov	r1, r3
34003386:	4822      	ldr	r0, [pc, #136]	@ (34003410 <XSPI_NOR_MspInit+0x198>)
34003388:	f002 fcf0 	bl	34005d6c <HAL_GPIO_Init>

  /* XSPI D4 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_D4_PIN;
3400338c:	f44f 7380 	mov.w	r3, #256	@ 0x100
34003390:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_D4_PIN_AF;
34003392:	2309      	movs	r3, #9
34003394:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_D4_GPIO_PORT, &GPIO_InitStruct);
34003396:	f107 030c 	add.w	r3, r7, #12
3400339a:	4619      	mov	r1, r3
3400339c:	481c      	ldr	r0, [pc, #112]	@ (34003410 <XSPI_NOR_MspInit+0x198>)
3400339e:	f002 fce5 	bl	34005d6c <HAL_GPIO_Init>

  /* XSPI D5 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_D5_PIN;
340033a2:	f44f 7300 	mov.w	r3, #512	@ 0x200
340033a6:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_D5_PIN_AF;
340033a8:	2309      	movs	r3, #9
340033aa:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_D5_GPIO_PORT, &GPIO_InitStruct);
340033ac:	f107 030c 	add.w	r3, r7, #12
340033b0:	4619      	mov	r1, r3
340033b2:	4817      	ldr	r0, [pc, #92]	@ (34003410 <XSPI_NOR_MspInit+0x198>)
340033b4:	f002 fcda 	bl	34005d6c <HAL_GPIO_Init>

  /* XSPI D6 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_D6_PIN;
340033b8:	f44f 6380 	mov.w	r3, #1024	@ 0x400
340033bc:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_D6_PIN_AF;
340033be:	2309      	movs	r3, #9
340033c0:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_D6_GPIO_PORT, &GPIO_InitStruct);
340033c2:	f107 030c 	add.w	r3, r7, #12
340033c6:	4619      	mov	r1, r3
340033c8:	4811      	ldr	r0, [pc, #68]	@ (34003410 <XSPI_NOR_MspInit+0x198>)
340033ca:	f002 fccf 	bl	34005d6c <HAL_GPIO_Init>

  /* XSPI D7 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_D7_PIN;
340033ce:	f44f 6300 	mov.w	r3, #2048	@ 0x800
340033d2:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_D7_PIN_AF;
340033d4:	2309      	movs	r3, #9
340033d6:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_D7_GPIO_PORT, &GPIO_InitStruct);
340033d8:	f107 030c 	add.w	r3, r7, #12
340033dc:	4619      	mov	r1, r3
340033de:	480c      	ldr	r0, [pc, #48]	@ (34003410 <XSPI_NOR_MspInit+0x198>)
340033e0:	f002 fcc4 	bl	34005d6c <HAL_GPIO_Init>

  /* XSPI DQS GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_DQS_PIN;
340033e4:	2301      	movs	r3, #1
340033e6:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_DQS_PIN_AF;
340033e8:	2309      	movs	r3, #9
340033ea:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_DQS_GPIO_PORT, &GPIO_InitStruct);
340033ec:	f107 030c 	add.w	r3, r7, #12
340033f0:	4619      	mov	r1, r3
340033f2:	4807      	ldr	r0, [pc, #28]	@ (34003410 <XSPI_NOR_MspInit+0x198>)
340033f4:	f002 fcba 	bl	34005d6c <HAL_GPIO_Init>

  /* Configure the NVIC for XSPI */
  /* NVIC configuration for XSPI interrupt */
  HAL_NVIC_SetPriority(XSPI1_IRQn, 0x0F, 0);
340033f8:	2200      	movs	r2, #0
340033fa:	210f      	movs	r1, #15
340033fc:	20aa      	movs	r0, #170	@ 0xaa
340033fe:	f001 f92b 	bl	34004658 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(XSPI1_IRQn);
34003402:	20aa      	movs	r0, #170	@ 0xaa
34003404:	f001 f982 	bl	3400470c <HAL_NVIC_EnableIRQ>
}
34003408:	bf00      	nop
3400340a:	3720      	adds	r7, #32
3400340c:	46bd      	mov	sp, r7
3400340e:	bd80      	pop	{r7, pc}
34003410:	56023400 	.word	0x56023400

34003414 <XSPI_NOR_ResetMemory>:
  * @brief  This function reset the XSPI memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_ResetMemory(uint32_t Instance)
{
34003414:	b580      	push	{r7, lr}
34003416:	b084      	sub	sp, #16
34003418:	af00      	add	r7, sp, #0
3400341a:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
3400341c:	2300      	movs	r3, #0
3400341e:	60fb      	str	r3, [r7, #12]

  /* Check if the instance is supported */
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
34003420:	687b      	ldr	r3, [r7, #4]
34003422:	2b00      	cmp	r3, #0
34003424:	d003      	beq.n	3400342e <XSPI_NOR_ResetMemory+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34003426:	f06f 0301 	mvn.w	r3, #1
3400342a:	60fb      	str	r3, [r7, #12]
3400342c:	e088      	b.n	34003540 <XSPI_NOR_ResetMemory+0x12c>
  }
  else if (MX25UM51245G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
3400342e:	687b      	ldr	r3, [r7, #4]
34003430:	2264      	movs	r2, #100	@ 0x64
34003432:	fb02 f303 	mul.w	r3, r2, r3
34003436:	4a45      	ldr	r2, [pc, #276]	@ (3400354c <XSPI_NOR_ResetMemory+0x138>)
34003438:	4413      	add	r3, r2
3400343a:	2200      	movs	r2, #0
3400343c:	2100      	movs	r1, #0
3400343e:	4618      	mov	r0, r3
34003440:	f7ff fb04 	bl	34002a4c <MX25UM51245G_ResetEnable>
34003444:	4603      	mov	r3, r0
34003446:	2b00      	cmp	r3, #0
34003448:	d003      	beq.n	34003452 <XSPI_NOR_ResetMemory+0x3e>
                                    BSP_XSPI_NOR_STR_TRANSFER) != MX25UM51245G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
3400344a:	f06f 0304 	mvn.w	r3, #4
3400344e:	60fb      	str	r3, [r7, #12]
34003450:	e076      	b.n	34003540 <XSPI_NOR_ResetMemory+0x12c>
  }
  else if (MX25UM51245G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
34003452:	687b      	ldr	r3, [r7, #4]
34003454:	2264      	movs	r2, #100	@ 0x64
34003456:	fb02 f303 	mul.w	r3, r2, r3
3400345a:	4a3c      	ldr	r2, [pc, #240]	@ (3400354c <XSPI_NOR_ResetMemory+0x138>)
3400345c:	4413      	add	r3, r2
3400345e:	2200      	movs	r2, #0
34003460:	2100      	movs	r1, #0
34003462:	4618      	mov	r0, r3
34003464:	f7ff fb48 	bl	34002af8 <MX25UM51245G_ResetMemory>
34003468:	4603      	mov	r3, r0
3400346a:	2b00      	cmp	r3, #0
3400346c:	d003      	beq.n	34003476 <XSPI_NOR_ResetMemory+0x62>
                                    BSP_XSPI_NOR_STR_TRANSFER) != MX25UM51245G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
3400346e:	f06f 0304 	mvn.w	r3, #4
34003472:	60fb      	str	r3, [r7, #12]
34003474:	e064      	b.n	34003540 <XSPI_NOR_ResetMemory+0x12c>
  }
  else if (MX25UM51245G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34003476:	687b      	ldr	r3, [r7, #4]
34003478:	2264      	movs	r2, #100	@ 0x64
3400347a:	fb02 f303 	mul.w	r3, r2, r3
3400347e:	4a33      	ldr	r2, [pc, #204]	@ (3400354c <XSPI_NOR_ResetMemory+0x138>)
34003480:	4413      	add	r3, r2
34003482:	2200      	movs	r2, #0
34003484:	2101      	movs	r1, #1
34003486:	4618      	mov	r0, r3
34003488:	f7ff fae0 	bl	34002a4c <MX25UM51245G_ResetEnable>
3400348c:	4603      	mov	r3, r0
3400348e:	2b00      	cmp	r3, #0
34003490:	d003      	beq.n	3400349a <XSPI_NOR_ResetMemory+0x86>
                                    BSP_XSPI_NOR_STR_TRANSFER) != MX25UM51245G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34003492:	f06f 0304 	mvn.w	r3, #4
34003496:	60fb      	str	r3, [r7, #12]
34003498:	e052      	b.n	34003540 <XSPI_NOR_ResetMemory+0x12c>
  }
  else if (MX25UM51245G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
3400349a:	687b      	ldr	r3, [r7, #4]
3400349c:	2264      	movs	r2, #100	@ 0x64
3400349e:	fb02 f303 	mul.w	r3, r2, r3
340034a2:	4a2a      	ldr	r2, [pc, #168]	@ (3400354c <XSPI_NOR_ResetMemory+0x138>)
340034a4:	4413      	add	r3, r2
340034a6:	2200      	movs	r2, #0
340034a8:	2101      	movs	r1, #1
340034aa:	4618      	mov	r0, r3
340034ac:	f7ff fb24 	bl	34002af8 <MX25UM51245G_ResetMemory>
340034b0:	4603      	mov	r3, r0
340034b2:	2b00      	cmp	r3, #0
340034b4:	d003      	beq.n	340034be <XSPI_NOR_ResetMemory+0xaa>
                                    BSP_XSPI_NOR_STR_TRANSFER) != MX25UM51245G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
340034b6:	f06f 0304 	mvn.w	r3, #4
340034ba:	60fb      	str	r3, [r7, #12]
340034bc:	e040      	b.n	34003540 <XSPI_NOR_ResetMemory+0x12c>
  }
  else if (MX25UM51245G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
340034be:	687b      	ldr	r3, [r7, #4]
340034c0:	2264      	movs	r2, #100	@ 0x64
340034c2:	fb02 f303 	mul.w	r3, r2, r3
340034c6:	4a21      	ldr	r2, [pc, #132]	@ (3400354c <XSPI_NOR_ResetMemory+0x138>)
340034c8:	4413      	add	r3, r2
340034ca:	2201      	movs	r2, #1
340034cc:	2101      	movs	r1, #1
340034ce:	4618      	mov	r0, r3
340034d0:	f7ff fabc 	bl	34002a4c <MX25UM51245G_ResetEnable>
340034d4:	4603      	mov	r3, r0
340034d6:	2b00      	cmp	r3, #0
340034d8:	d003      	beq.n	340034e2 <XSPI_NOR_ResetMemory+0xce>
                                    BSP_XSPI_NOR_DTR_TRANSFER) != MX25UM51245G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
340034da:	f06f 0304 	mvn.w	r3, #4
340034de:	60fb      	str	r3, [r7, #12]
340034e0:	e02e      	b.n	34003540 <XSPI_NOR_ResetMemory+0x12c>
  }
  else if (MX25UM51245G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
340034e2:	687b      	ldr	r3, [r7, #4]
340034e4:	2264      	movs	r2, #100	@ 0x64
340034e6:	fb02 f303 	mul.w	r3, r2, r3
340034ea:	4a18      	ldr	r2, [pc, #96]	@ (3400354c <XSPI_NOR_ResetMemory+0x138>)
340034ec:	4413      	add	r3, r2
340034ee:	2201      	movs	r2, #1
340034f0:	2101      	movs	r1, #1
340034f2:	4618      	mov	r0, r3
340034f4:	f7ff fb00 	bl	34002af8 <MX25UM51245G_ResetMemory>
340034f8:	4603      	mov	r3, r0
340034fa:	2b00      	cmp	r3, #0
340034fc:	d003      	beq.n	34003506 <XSPI_NOR_ResetMemory+0xf2>
                                    BSP_XSPI_NOR_DTR_TRANSFER) != MX25UM51245G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
340034fe:	f06f 0304 	mvn.w	r3, #4
34003502:	60fb      	str	r3, [r7, #12]
34003504:	e01c      	b.n	34003540 <XSPI_NOR_ResetMemory+0x12c>
  }
  else
  {
    Xspi_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;      /* After reset S/W setting to indirect access  */
34003506:	4912      	ldr	r1, [pc, #72]	@ (34003550 <XSPI_NOR_ResetMemory+0x13c>)
34003508:	687a      	ldr	r2, [r7, #4]
3400350a:	4613      	mov	r3, r2
3400350c:	005b      	lsls	r3, r3, #1
3400350e:	4413      	add	r3, r2
34003510:	440b      	add	r3, r1
34003512:	2201      	movs	r2, #1
34003514:	701a      	strb	r2, [r3, #0]
    Xspi_Nor_Ctx[Instance].InterfaceMode = BSP_XSPI_NOR_SPI_MODE;     /* After reset H/W back to SPI mode by default */
34003516:	490e      	ldr	r1, [pc, #56]	@ (34003550 <XSPI_NOR_ResetMemory+0x13c>)
34003518:	687a      	ldr	r2, [r7, #4]
3400351a:	4613      	mov	r3, r2
3400351c:	005b      	lsls	r3, r3, #1
3400351e:	4413      	add	r3, r2
34003520:	440b      	add	r3, r1
34003522:	3301      	adds	r3, #1
34003524:	2200      	movs	r2, #0
34003526:	701a      	strb	r2, [r3, #0]
    Xspi_Nor_Ctx[Instance].TransferRate  = BSP_XSPI_NOR_STR_TRANSFER; /* After reset S/W setting to STR mode         */
34003528:	4909      	ldr	r1, [pc, #36]	@ (34003550 <XSPI_NOR_ResetMemory+0x13c>)
3400352a:	687a      	ldr	r2, [r7, #4]
3400352c:	4613      	mov	r3, r2
3400352e:	005b      	lsls	r3, r3, #1
34003530:	4413      	add	r3, r2
34003532:	440b      	add	r3, r1
34003534:	3302      	adds	r3, #2
34003536:	2200      	movs	r2, #0
34003538:	701a      	strb	r2, [r3, #0]

    /* After SWreset CMD, wait in case SWReset occurred during erase operation */
    HAL_Delay(MX25UM51245G_RESET_MAX_TIME);
3400353a:	2064      	movs	r0, #100	@ 0x64
3400353c:	f000 fd96 	bl	3400406c <HAL_Delay>
  }

  /* Return BSP status */
  return ret;
34003540:	68fb      	ldr	r3, [r7, #12]
}
34003542:	4618      	mov	r0, r3
34003544:	3710      	adds	r7, #16
34003546:	46bd      	mov	sp, r7
34003548:	bd80      	pop	{r7, pc}
3400354a:	bf00      	nop
3400354c:	34020fa8 	.word	0x34020fa8
34003550:	3402100c 	.word	0x3402100c

34003554 <XSPI_NOR_EnterDOPIMode>:
  * @brief  This function enables the octal DTR mode of the memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_EnterDOPIMode(uint32_t Instance)
{
34003554:	b590      	push	{r4, r7, lr}
34003556:	b087      	sub	sp, #28
34003558:	af02      	add	r7, sp, #8
3400355a:	6078      	str	r0, [r7, #4]
  int32_t ret;
  uint8_t reg[2];

  /* Check if the instance is supported */
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
3400355c:	687b      	ldr	r3, [r7, #4]
3400355e:	2b00      	cmp	r3, #0
34003560:	d003      	beq.n	3400356a <XSPI_NOR_EnterDOPIMode+0x16>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34003562:	f06f 0301 	mvn.w	r3, #1
34003566:	60fb      	str	r3, [r7, #12]
34003568:	e0db      	b.n	34003722 <XSPI_NOR_EnterDOPIMode+0x1ce>
  }
  /* Enable write operations */
  else if (MX25UM51245G_WriteEnable(&hxspi_nor[Instance], Xspi_Nor_Ctx[Instance].InterfaceMode,
3400356a:	687b      	ldr	r3, [r7, #4]
3400356c:	2264      	movs	r2, #100	@ 0x64
3400356e:	fb02 f303 	mul.w	r3, r2, r3
34003572:	4a6e      	ldr	r2, [pc, #440]	@ (3400372c <XSPI_NOR_EnterDOPIMode+0x1d8>)
34003574:	1898      	adds	r0, r3, r2
34003576:	496e      	ldr	r1, [pc, #440]	@ (34003730 <XSPI_NOR_EnterDOPIMode+0x1dc>)
34003578:	687a      	ldr	r2, [r7, #4]
3400357a:	4613      	mov	r3, r2
3400357c:	005b      	lsls	r3, r3, #1
3400357e:	4413      	add	r3, r2
34003580:	440b      	add	r3, r1
34003582:	3301      	adds	r3, #1
34003584:	7819      	ldrb	r1, [r3, #0]
34003586:	4c6a      	ldr	r4, [pc, #424]	@ (34003730 <XSPI_NOR_EnterDOPIMode+0x1dc>)
34003588:	687a      	ldr	r2, [r7, #4]
3400358a:	4613      	mov	r3, r2
3400358c:	005b      	lsls	r3, r3, #1
3400358e:	4413      	add	r3, r2
34003590:	4423      	add	r3, r4
34003592:	3302      	adds	r3, #2
34003594:	781b      	ldrb	r3, [r3, #0]
34003596:	461a      	mov	r2, r3
34003598:	f7ff f85a 	bl	34002650 <MX25UM51245G_WriteEnable>
3400359c:	4603      	mov	r3, r0
3400359e:	2b00      	cmp	r3, #0
340035a0:	d003      	beq.n	340035aa <XSPI_NOR_EnterDOPIMode+0x56>
                                    Xspi_Nor_Ctx[Instance].TransferRate) != MX25UM51245G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
340035a2:	f06f 0304 	mvn.w	r3, #4
340035a6:	60fb      	str	r3, [r7, #12]
340035a8:	e0bb      	b.n	34003722 <XSPI_NOR_EnterDOPIMode+0x1ce>
  }
  /* Write Configuration register 2 (with new dummy cycles) */
  else if (MX25UM51245G_WriteCfg2Register(&hxspi_nor[Instance], Xspi_Nor_Ctx[Instance].InterfaceMode,
340035aa:	687b      	ldr	r3, [r7, #4]
340035ac:	2264      	movs	r2, #100	@ 0x64
340035ae:	fb02 f303 	mul.w	r3, r2, r3
340035b2:	4a5e      	ldr	r2, [pc, #376]	@ (3400372c <XSPI_NOR_EnterDOPIMode+0x1d8>)
340035b4:	1898      	adds	r0, r3, r2
340035b6:	495e      	ldr	r1, [pc, #376]	@ (34003730 <XSPI_NOR_EnterDOPIMode+0x1dc>)
340035b8:	687a      	ldr	r2, [r7, #4]
340035ba:	4613      	mov	r3, r2
340035bc:	005b      	lsls	r3, r3, #1
340035be:	4413      	add	r3, r2
340035c0:	440b      	add	r3, r1
340035c2:	3301      	adds	r3, #1
340035c4:	7819      	ldrb	r1, [r3, #0]
340035c6:	4c5a      	ldr	r4, [pc, #360]	@ (34003730 <XSPI_NOR_EnterDOPIMode+0x1dc>)
340035c8:	687a      	ldr	r2, [r7, #4]
340035ca:	4613      	mov	r3, r2
340035cc:	005b      	lsls	r3, r3, #1
340035ce:	4413      	add	r3, r2
340035d0:	4423      	add	r3, r4
340035d2:	3302      	adds	r3, #2
340035d4:	781a      	ldrb	r2, [r3, #0]
340035d6:	2300      	movs	r3, #0
340035d8:	9300      	str	r3, [sp, #0]
340035da:	f44f 7340 	mov.w	r3, #768	@ 0x300
340035de:	f7ff f905 	bl	340027ec <MX25UM51245G_WriteCfg2Register>
340035e2:	4603      	mov	r3, r0
340035e4:	2b00      	cmp	r3, #0
340035e6:	d003      	beq.n	340035f0 <XSPI_NOR_EnterDOPIMode+0x9c>
                                          Xspi_Nor_Ctx[Instance].TransferRate, MX25UM51245G_CR2_REG3_ADDR,
                                          MX25UM51245G_CR2_DC_20_CYCLES) != MX25UM51245G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
340035e8:	f06f 0304 	mvn.w	r3, #4
340035ec:	60fb      	str	r3, [r7, #12]
340035ee:	e098      	b.n	34003722 <XSPI_NOR_EnterDOPIMode+0x1ce>
  }
  /* Enable write operations */
  else if (MX25UM51245G_WriteEnable(&hxspi_nor[Instance], Xspi_Nor_Ctx[Instance].InterfaceMode,
340035f0:	687b      	ldr	r3, [r7, #4]
340035f2:	2264      	movs	r2, #100	@ 0x64
340035f4:	fb02 f303 	mul.w	r3, r2, r3
340035f8:	4a4c      	ldr	r2, [pc, #304]	@ (3400372c <XSPI_NOR_EnterDOPIMode+0x1d8>)
340035fa:	1898      	adds	r0, r3, r2
340035fc:	494c      	ldr	r1, [pc, #304]	@ (34003730 <XSPI_NOR_EnterDOPIMode+0x1dc>)
340035fe:	687a      	ldr	r2, [r7, #4]
34003600:	4613      	mov	r3, r2
34003602:	005b      	lsls	r3, r3, #1
34003604:	4413      	add	r3, r2
34003606:	440b      	add	r3, r1
34003608:	3301      	adds	r3, #1
3400360a:	7819      	ldrb	r1, [r3, #0]
3400360c:	4c48      	ldr	r4, [pc, #288]	@ (34003730 <XSPI_NOR_EnterDOPIMode+0x1dc>)
3400360e:	687a      	ldr	r2, [r7, #4]
34003610:	4613      	mov	r3, r2
34003612:	005b      	lsls	r3, r3, #1
34003614:	4413      	add	r3, r2
34003616:	4423      	add	r3, r4
34003618:	3302      	adds	r3, #2
3400361a:	781b      	ldrb	r3, [r3, #0]
3400361c:	461a      	mov	r2, r3
3400361e:	f7ff f817 	bl	34002650 <MX25UM51245G_WriteEnable>
34003622:	4603      	mov	r3, r0
34003624:	2b00      	cmp	r3, #0
34003626:	d003      	beq.n	34003630 <XSPI_NOR_EnterDOPIMode+0xdc>
                                    Xspi_Nor_Ctx[Instance].TransferRate) != MX25UM51245G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34003628:	f06f 0304 	mvn.w	r3, #4
3400362c:	60fb      	str	r3, [r7, #12]
3400362e:	e078      	b.n	34003722 <XSPI_NOR_EnterDOPIMode+0x1ce>
  }
  /* Write Configuration register 2 (with Octal I/O SPI protocol) */
  else if (MX25UM51245G_WriteCfg2Register(&hxspi_nor[Instance], Xspi_Nor_Ctx[Instance].InterfaceMode,
34003630:	687b      	ldr	r3, [r7, #4]
34003632:	2264      	movs	r2, #100	@ 0x64
34003634:	fb02 f303 	mul.w	r3, r2, r3
34003638:	4a3c      	ldr	r2, [pc, #240]	@ (3400372c <XSPI_NOR_EnterDOPIMode+0x1d8>)
3400363a:	1898      	adds	r0, r3, r2
3400363c:	493c      	ldr	r1, [pc, #240]	@ (34003730 <XSPI_NOR_EnterDOPIMode+0x1dc>)
3400363e:	687a      	ldr	r2, [r7, #4]
34003640:	4613      	mov	r3, r2
34003642:	005b      	lsls	r3, r3, #1
34003644:	4413      	add	r3, r2
34003646:	440b      	add	r3, r1
34003648:	3301      	adds	r3, #1
3400364a:	7819      	ldrb	r1, [r3, #0]
3400364c:	4c38      	ldr	r4, [pc, #224]	@ (34003730 <XSPI_NOR_EnterDOPIMode+0x1dc>)
3400364e:	687a      	ldr	r2, [r7, #4]
34003650:	4613      	mov	r3, r2
34003652:	005b      	lsls	r3, r3, #1
34003654:	4413      	add	r3, r2
34003656:	4423      	add	r3, r4
34003658:	3302      	adds	r3, #2
3400365a:	781a      	ldrb	r2, [r3, #0]
3400365c:	2302      	movs	r3, #2
3400365e:	9300      	str	r3, [sp, #0]
34003660:	2300      	movs	r3, #0
34003662:	f7ff f8c3 	bl	340027ec <MX25UM51245G_WriteCfg2Register>
34003666:	4603      	mov	r3, r0
34003668:	2b00      	cmp	r3, #0
3400366a:	d003      	beq.n	34003674 <XSPI_NOR_EnterDOPIMode+0x120>
                                          Xspi_Nor_Ctx[Instance].TransferRate, MX25UM51245G_CR2_REG1_ADDR,
                                          MX25UM51245G_CR2_DOPI) != MX25UM51245G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
3400366c:	f06f 0304 	mvn.w	r3, #4
34003670:	60fb      	str	r3, [r7, #12]
34003672:	e056      	b.n	34003722 <XSPI_NOR_EnterDOPIMode+0x1ce>
  }
  else
  {
    /* Wait that the configuration is effective and check that memory is ready */
    HAL_Delay(MX25UM51245G_WRITE_REG_MAX_TIME);
34003674:	2028      	movs	r0, #40	@ 0x28
34003676:	f000 fcf9 	bl	3400406c <HAL_Delay>

    /* Reconfigure the memory type of the peripheral */
    hxspi_nor[Instance].Init.MemoryType            = HAL_XSPI_MEMTYPE_MACRONIX;
3400367a:	4a2c      	ldr	r2, [pc, #176]	@ (3400372c <XSPI_NOR_EnterDOPIMode+0x1d8>)
3400367c:	687b      	ldr	r3, [r7, #4]
3400367e:	2164      	movs	r1, #100	@ 0x64
34003680:	fb01 f303 	mul.w	r3, r1, r3
34003684:	4413      	add	r3, r2
34003686:	330c      	adds	r3, #12
34003688:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
3400368c:	601a      	str	r2, [r3, #0]
    hxspi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
3400368e:	4a27      	ldr	r2, [pc, #156]	@ (3400372c <XSPI_NOR_EnterDOPIMode+0x1d8>)
34003690:	687b      	ldr	r3, [r7, #4]
34003692:	2164      	movs	r1, #100	@ 0x64
34003694:	fb01 f303 	mul.w	r3, r1, r3
34003698:	4413      	add	r3, r2
3400369a:	332c      	adds	r3, #44	@ 0x2c
3400369c:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
340036a0:	601a      	str	r2, [r3, #0]
    if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
340036a2:	687b      	ldr	r3, [r7, #4]
340036a4:	2264      	movs	r2, #100	@ 0x64
340036a6:	fb02 f303 	mul.w	r3, r2, r3
340036aa:	4a20      	ldr	r2, [pc, #128]	@ (3400372c <XSPI_NOR_EnterDOPIMode+0x1d8>)
340036ac:	4413      	add	r3, r2
340036ae:	4618      	mov	r0, r3
340036b0:	f013 faa4 	bl	34016bfc <HAL_XSPI_Init>
340036b4:	4603      	mov	r3, r0
340036b6:	2b00      	cmp	r3, #0
340036b8:	d003      	beq.n	340036c2 <XSPI_NOR_EnterDOPIMode+0x16e>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
340036ba:	f06f 0303 	mvn.w	r3, #3
340036be:	60fb      	str	r3, [r7, #12]
340036c0:	e02f      	b.n	34003722 <XSPI_NOR_EnterDOPIMode+0x1ce>
    }
    /* Check Flash busy ? */
    else if (MX25UM51245G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
340036c2:	687b      	ldr	r3, [r7, #4]
340036c4:	2264      	movs	r2, #100	@ 0x64
340036c6:	fb02 f303 	mul.w	r3, r2, r3
340036ca:	4a18      	ldr	r2, [pc, #96]	@ (3400372c <XSPI_NOR_EnterDOPIMode+0x1d8>)
340036cc:	4413      	add	r3, r2
340036ce:	2201      	movs	r2, #1
340036d0:	2101      	movs	r1, #1
340036d2:	4618      	mov	r0, r3
340036d4:	f7fe fdf3 	bl	340022be <MX25UM51245G_AutoPollingMemReady>
340036d8:	4603      	mov	r3, r0
340036da:	2b00      	cmp	r3, #0
340036dc:	d003      	beq.n	340036e6 <XSPI_NOR_EnterDOPIMode+0x192>
                                              BSP_XSPI_NOR_DTR_TRANSFER) != MX25UM51245G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
340036de:	f06f 0304 	mvn.w	r3, #4
340036e2:	60fb      	str	r3, [r7, #12]
340036e4:	e01d      	b.n	34003722 <XSPI_NOR_EnterDOPIMode+0x1ce>
    }
    /* Check the configuration has been correctly done */
    else if (MX25UM51245G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE, BSP_XSPI_NOR_DTR_TRANSFER,
340036e6:	687b      	ldr	r3, [r7, #4]
340036e8:	2264      	movs	r2, #100	@ 0x64
340036ea:	fb02 f303 	mul.w	r3, r2, r3
340036ee:	4a0f      	ldr	r2, [pc, #60]	@ (3400372c <XSPI_NOR_EnterDOPIMode+0x1d8>)
340036f0:	1898      	adds	r0, r3, r2
340036f2:	f107 0308 	add.w	r3, r7, #8
340036f6:	9300      	str	r3, [sp, #0]
340036f8:	2300      	movs	r3, #0
340036fa:	2201      	movs	r2, #1
340036fc:	2101      	movs	r1, #1
340036fe:	f7ff f908 	bl	34002912 <MX25UM51245G_ReadCfg2Register>
34003702:	4603      	mov	r3, r0
34003704:	2b00      	cmp	r3, #0
34003706:	d003      	beq.n	34003710 <XSPI_NOR_EnterDOPIMode+0x1bc>
                                           MX25UM51245G_CR2_REG1_ADDR, reg) != MX25UM51245G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34003708:	f06f 0304 	mvn.w	r3, #4
3400370c:	60fb      	str	r3, [r7, #12]
3400370e:	e008      	b.n	34003722 <XSPI_NOR_EnterDOPIMode+0x1ce>
    }
    else if (reg[0] != MX25UM51245G_CR2_DOPI)
34003710:	7a3b      	ldrb	r3, [r7, #8]
34003712:	2b02      	cmp	r3, #2
34003714:	d003      	beq.n	3400371e <XSPI_NOR_EnterDOPIMode+0x1ca>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34003716:	f06f 0304 	mvn.w	r3, #4
3400371a:	60fb      	str	r3, [r7, #12]
3400371c:	e001      	b.n	34003722 <XSPI_NOR_EnterDOPIMode+0x1ce>
    }
    else
    {
      ret = BSP_ERROR_NONE;
3400371e:	2300      	movs	r3, #0
34003720:	60fb      	str	r3, [r7, #12]
    }
  }

  /* Return BSP status */
  return ret;
34003722:	68fb      	ldr	r3, [r7, #12]
}
34003724:	4618      	mov	r0, r3
34003726:	3714      	adds	r7, #20
34003728:	46bd      	mov	sp, r7
3400372a:	bd90      	pop	{r4, r7, pc}
3400372c:	34020fa8 	.word	0x34020fa8
34003730:	3402100c 	.word	0x3402100c

34003734 <XSPI_NOR_EnterSOPIMode>:
  * @brief  This function enables the octal STR mode of the memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_EnterSOPIMode(uint32_t Instance)
{
34003734:	b590      	push	{r4, r7, lr}
34003736:	b087      	sub	sp, #28
34003738:	af02      	add	r7, sp, #8
3400373a:	6078      	str	r0, [r7, #4]
  int32_t ret;
  uint8_t reg[2];

  /* Check if the instance is supported */
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
3400373c:	687b      	ldr	r3, [r7, #4]
3400373e:	2b00      	cmp	r3, #0
34003740:	d003      	beq.n	3400374a <XSPI_NOR_EnterSOPIMode+0x16>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34003742:	f06f 0301 	mvn.w	r3, #1
34003746:	60fb      	str	r3, [r7, #12]
34003748:	e0b7      	b.n	340038ba <XSPI_NOR_EnterSOPIMode+0x186>
  }
  /* Enable write operations */
  else if (MX25UM51245G_WriteEnable(&hxspi_nor[Instance], Xspi_Nor_Ctx[Instance].InterfaceMode,
3400374a:	687b      	ldr	r3, [r7, #4]
3400374c:	2264      	movs	r2, #100	@ 0x64
3400374e:	fb02 f303 	mul.w	r3, r2, r3
34003752:	4a5c      	ldr	r2, [pc, #368]	@ (340038c4 <XSPI_NOR_EnterSOPIMode+0x190>)
34003754:	1898      	adds	r0, r3, r2
34003756:	495c      	ldr	r1, [pc, #368]	@ (340038c8 <XSPI_NOR_EnterSOPIMode+0x194>)
34003758:	687a      	ldr	r2, [r7, #4]
3400375a:	4613      	mov	r3, r2
3400375c:	005b      	lsls	r3, r3, #1
3400375e:	4413      	add	r3, r2
34003760:	440b      	add	r3, r1
34003762:	3301      	adds	r3, #1
34003764:	7819      	ldrb	r1, [r3, #0]
34003766:	4c58      	ldr	r4, [pc, #352]	@ (340038c8 <XSPI_NOR_EnterSOPIMode+0x194>)
34003768:	687a      	ldr	r2, [r7, #4]
3400376a:	4613      	mov	r3, r2
3400376c:	005b      	lsls	r3, r3, #1
3400376e:	4413      	add	r3, r2
34003770:	4423      	add	r3, r4
34003772:	3302      	adds	r3, #2
34003774:	781b      	ldrb	r3, [r3, #0]
34003776:	461a      	mov	r2, r3
34003778:	f7fe ff6a 	bl	34002650 <MX25UM51245G_WriteEnable>
3400377c:	4603      	mov	r3, r0
3400377e:	2b00      	cmp	r3, #0
34003780:	d003      	beq.n	3400378a <XSPI_NOR_EnterSOPIMode+0x56>
                                    Xspi_Nor_Ctx[Instance].TransferRate) != MX25UM51245G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34003782:	f06f 0304 	mvn.w	r3, #4
34003786:	60fb      	str	r3, [r7, #12]
34003788:	e097      	b.n	340038ba <XSPI_NOR_EnterSOPIMode+0x186>
  }
  /* Write Configuration register 2 (with new dummy cycles) */
  else if (MX25UM51245G_WriteCfg2Register(&hxspi_nor[Instance], Xspi_Nor_Ctx[Instance].InterfaceMode,
3400378a:	687b      	ldr	r3, [r7, #4]
3400378c:	2264      	movs	r2, #100	@ 0x64
3400378e:	fb02 f303 	mul.w	r3, r2, r3
34003792:	4a4c      	ldr	r2, [pc, #304]	@ (340038c4 <XSPI_NOR_EnterSOPIMode+0x190>)
34003794:	1898      	adds	r0, r3, r2
34003796:	494c      	ldr	r1, [pc, #304]	@ (340038c8 <XSPI_NOR_EnterSOPIMode+0x194>)
34003798:	687a      	ldr	r2, [r7, #4]
3400379a:	4613      	mov	r3, r2
3400379c:	005b      	lsls	r3, r3, #1
3400379e:	4413      	add	r3, r2
340037a0:	440b      	add	r3, r1
340037a2:	3301      	adds	r3, #1
340037a4:	7819      	ldrb	r1, [r3, #0]
340037a6:	4c48      	ldr	r4, [pc, #288]	@ (340038c8 <XSPI_NOR_EnterSOPIMode+0x194>)
340037a8:	687a      	ldr	r2, [r7, #4]
340037aa:	4613      	mov	r3, r2
340037ac:	005b      	lsls	r3, r3, #1
340037ae:	4413      	add	r3, r2
340037b0:	4423      	add	r3, r4
340037b2:	3302      	adds	r3, #2
340037b4:	781a      	ldrb	r2, [r3, #0]
340037b6:	2300      	movs	r3, #0
340037b8:	9300      	str	r3, [sp, #0]
340037ba:	f44f 7340 	mov.w	r3, #768	@ 0x300
340037be:	f7ff f815 	bl	340027ec <MX25UM51245G_WriteCfg2Register>
340037c2:	4603      	mov	r3, r0
340037c4:	2b00      	cmp	r3, #0
340037c6:	d003      	beq.n	340037d0 <XSPI_NOR_EnterSOPIMode+0x9c>
                                          Xspi_Nor_Ctx[Instance].TransferRate, MX25UM51245G_CR2_REG3_ADDR,
                                          MX25UM51245G_CR2_DC_20_CYCLES) != MX25UM51245G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
340037c8:	f06f 0304 	mvn.w	r3, #4
340037cc:	60fb      	str	r3, [r7, #12]
340037ce:	e074      	b.n	340038ba <XSPI_NOR_EnterSOPIMode+0x186>
  }
  /* Enable write operations */
  else if (MX25UM51245G_WriteEnable(&hxspi_nor[Instance], Xspi_Nor_Ctx[Instance].InterfaceMode,
340037d0:	687b      	ldr	r3, [r7, #4]
340037d2:	2264      	movs	r2, #100	@ 0x64
340037d4:	fb02 f303 	mul.w	r3, r2, r3
340037d8:	4a3a      	ldr	r2, [pc, #232]	@ (340038c4 <XSPI_NOR_EnterSOPIMode+0x190>)
340037da:	1898      	adds	r0, r3, r2
340037dc:	493a      	ldr	r1, [pc, #232]	@ (340038c8 <XSPI_NOR_EnterSOPIMode+0x194>)
340037de:	687a      	ldr	r2, [r7, #4]
340037e0:	4613      	mov	r3, r2
340037e2:	005b      	lsls	r3, r3, #1
340037e4:	4413      	add	r3, r2
340037e6:	440b      	add	r3, r1
340037e8:	3301      	adds	r3, #1
340037ea:	7819      	ldrb	r1, [r3, #0]
340037ec:	4c36      	ldr	r4, [pc, #216]	@ (340038c8 <XSPI_NOR_EnterSOPIMode+0x194>)
340037ee:	687a      	ldr	r2, [r7, #4]
340037f0:	4613      	mov	r3, r2
340037f2:	005b      	lsls	r3, r3, #1
340037f4:	4413      	add	r3, r2
340037f6:	4423      	add	r3, r4
340037f8:	3302      	adds	r3, #2
340037fa:	781b      	ldrb	r3, [r3, #0]
340037fc:	461a      	mov	r2, r3
340037fe:	f7fe ff27 	bl	34002650 <MX25UM51245G_WriteEnable>
34003802:	4603      	mov	r3, r0
34003804:	2b00      	cmp	r3, #0
34003806:	d003      	beq.n	34003810 <XSPI_NOR_EnterSOPIMode+0xdc>
                                    Xspi_Nor_Ctx[Instance].TransferRate) != MX25UM51245G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34003808:	f06f 0304 	mvn.w	r3, #4
3400380c:	60fb      	str	r3, [r7, #12]
3400380e:	e054      	b.n	340038ba <XSPI_NOR_EnterSOPIMode+0x186>
  }
  /* Write Configuration register 2 (with Octal I/O SPI protocol) */
  else if (MX25UM51245G_WriteCfg2Register(&hxspi_nor[Instance], Xspi_Nor_Ctx[Instance].InterfaceMode,
34003810:	687b      	ldr	r3, [r7, #4]
34003812:	2264      	movs	r2, #100	@ 0x64
34003814:	fb02 f303 	mul.w	r3, r2, r3
34003818:	4a2a      	ldr	r2, [pc, #168]	@ (340038c4 <XSPI_NOR_EnterSOPIMode+0x190>)
3400381a:	1898      	adds	r0, r3, r2
3400381c:	492a      	ldr	r1, [pc, #168]	@ (340038c8 <XSPI_NOR_EnterSOPIMode+0x194>)
3400381e:	687a      	ldr	r2, [r7, #4]
34003820:	4613      	mov	r3, r2
34003822:	005b      	lsls	r3, r3, #1
34003824:	4413      	add	r3, r2
34003826:	440b      	add	r3, r1
34003828:	3301      	adds	r3, #1
3400382a:	7819      	ldrb	r1, [r3, #0]
3400382c:	4c26      	ldr	r4, [pc, #152]	@ (340038c8 <XSPI_NOR_EnterSOPIMode+0x194>)
3400382e:	687a      	ldr	r2, [r7, #4]
34003830:	4613      	mov	r3, r2
34003832:	005b      	lsls	r3, r3, #1
34003834:	4413      	add	r3, r2
34003836:	4423      	add	r3, r4
34003838:	3302      	adds	r3, #2
3400383a:	781a      	ldrb	r2, [r3, #0]
3400383c:	2301      	movs	r3, #1
3400383e:	9300      	str	r3, [sp, #0]
34003840:	2300      	movs	r3, #0
34003842:	f7fe ffd3 	bl	340027ec <MX25UM51245G_WriteCfg2Register>
34003846:	4603      	mov	r3, r0
34003848:	2b00      	cmp	r3, #0
3400384a:	d003      	beq.n	34003854 <XSPI_NOR_EnterSOPIMode+0x120>
                                          Xspi_Nor_Ctx[Instance].TransferRate, MX25UM51245G_CR2_REG1_ADDR,
                                          MX25UM51245G_CR2_SOPI) != MX25UM51245G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
3400384c:	f06f 0304 	mvn.w	r3, #4
34003850:	60fb      	str	r3, [r7, #12]
34003852:	e032      	b.n	340038ba <XSPI_NOR_EnterSOPIMode+0x186>
  }
  else
  {
    /* Wait that the configuration is effective and check that memory is ready */
    HAL_Delay(MX25UM51245G_WRITE_REG_MAX_TIME);
34003854:	2028      	movs	r0, #40	@ 0x28
34003856:	f000 fc09 	bl	3400406c <HAL_Delay>

    /* Check Flash busy ? */
    if (MX25UM51245G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
3400385a:	687b      	ldr	r3, [r7, #4]
3400385c:	2264      	movs	r2, #100	@ 0x64
3400385e:	fb02 f303 	mul.w	r3, r2, r3
34003862:	4a18      	ldr	r2, [pc, #96]	@ (340038c4 <XSPI_NOR_EnterSOPIMode+0x190>)
34003864:	4413      	add	r3, r2
34003866:	2200      	movs	r2, #0
34003868:	2101      	movs	r1, #1
3400386a:	4618      	mov	r0, r3
3400386c:	f7fe fd27 	bl	340022be <MX25UM51245G_AutoPollingMemReady>
34003870:	4603      	mov	r3, r0
34003872:	2b00      	cmp	r3, #0
34003874:	d003      	beq.n	3400387e <XSPI_NOR_EnterSOPIMode+0x14a>
                                         BSP_XSPI_NOR_STR_TRANSFER) != MX25UM51245G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34003876:	f06f 0304 	mvn.w	r3, #4
3400387a:	60fb      	str	r3, [r7, #12]
3400387c:	e01d      	b.n	340038ba <XSPI_NOR_EnterSOPIMode+0x186>
    }
    /* Check the configuration has been correctly done */
    else if (MX25UM51245G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE, BSP_XSPI_NOR_STR_TRANSFER,
3400387e:	687b      	ldr	r3, [r7, #4]
34003880:	2264      	movs	r2, #100	@ 0x64
34003882:	fb02 f303 	mul.w	r3, r2, r3
34003886:	4a0f      	ldr	r2, [pc, #60]	@ (340038c4 <XSPI_NOR_EnterSOPIMode+0x190>)
34003888:	1898      	adds	r0, r3, r2
3400388a:	f107 0308 	add.w	r3, r7, #8
3400388e:	9300      	str	r3, [sp, #0]
34003890:	2300      	movs	r3, #0
34003892:	2200      	movs	r2, #0
34003894:	2101      	movs	r1, #1
34003896:	f7ff f83c 	bl	34002912 <MX25UM51245G_ReadCfg2Register>
3400389a:	4603      	mov	r3, r0
3400389c:	2b00      	cmp	r3, #0
3400389e:	d003      	beq.n	340038a8 <XSPI_NOR_EnterSOPIMode+0x174>
                                           MX25UM51245G_CR2_REG1_ADDR, reg) != MX25UM51245G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
340038a0:	f06f 0304 	mvn.w	r3, #4
340038a4:	60fb      	str	r3, [r7, #12]
340038a6:	e008      	b.n	340038ba <XSPI_NOR_EnterSOPIMode+0x186>
    }
    else if (reg[0] != MX25UM51245G_CR2_SOPI)
340038a8:	7a3b      	ldrb	r3, [r7, #8]
340038aa:	2b01      	cmp	r3, #1
340038ac:	d003      	beq.n	340038b6 <XSPI_NOR_EnterSOPIMode+0x182>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
340038ae:	f06f 0304 	mvn.w	r3, #4
340038b2:	60fb      	str	r3, [r7, #12]
340038b4:	e001      	b.n	340038ba <XSPI_NOR_EnterSOPIMode+0x186>
    }
    else
    {
      ret = BSP_ERROR_NONE;
340038b6:	2300      	movs	r3, #0
340038b8:	60fb      	str	r3, [r7, #12]
    }
  }

  /* Return BSP status */
  return ret;
340038ba:	68fb      	ldr	r3, [r7, #12]
}
340038bc:	4618      	mov	r0, r3
340038be:	3714      	adds	r7, #20
340038c0:	46bd      	mov	sp, r7
340038c2:	bd90      	pop	{r4, r7, pc}
340038c4:	34020fa8 	.word	0x34020fa8
340038c8:	3402100c 	.word	0x3402100c

340038cc <XSPI_NOR_ExitOPIMode>:
  * @brief  This function disables the octal DTR or STR mode of the memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_ExitOPIMode(uint32_t Instance)
{
340038cc:	b590      	push	{r4, r7, lr}
340038ce:	b087      	sub	sp, #28
340038d0:	af02      	add	r7, sp, #8
340038d2:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
340038d4:	2300      	movs	r3, #0
340038d6:	60fb      	str	r3, [r7, #12]
  uint8_t reg[2];

  /* Check if the instance is supported */
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
340038d8:	687b      	ldr	r3, [r7, #4]
340038da:	2b00      	cmp	r3, #0
340038dc:	d003      	beq.n	340038e6 <XSPI_NOR_ExitOPIMode+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
340038de:	f06f 0301 	mvn.w	r3, #1
340038e2:	60fb      	str	r3, [r7, #12]
340038e4:	e0a3      	b.n	34003a2e <XSPI_NOR_ExitOPIMode+0x162>
  }
  /* Enable write operations */
  else if (MX25UM51245G_WriteEnable(&hxspi_nor[Instance], Xspi_Nor_Ctx[Instance].InterfaceMode,
340038e6:	687b      	ldr	r3, [r7, #4]
340038e8:	2264      	movs	r2, #100	@ 0x64
340038ea:	fb02 f303 	mul.w	r3, r2, r3
340038ee:	4a52      	ldr	r2, [pc, #328]	@ (34003a38 <XSPI_NOR_ExitOPIMode+0x16c>)
340038f0:	1898      	adds	r0, r3, r2
340038f2:	4952      	ldr	r1, [pc, #328]	@ (34003a3c <XSPI_NOR_ExitOPIMode+0x170>)
340038f4:	687a      	ldr	r2, [r7, #4]
340038f6:	4613      	mov	r3, r2
340038f8:	005b      	lsls	r3, r3, #1
340038fa:	4413      	add	r3, r2
340038fc:	440b      	add	r3, r1
340038fe:	3301      	adds	r3, #1
34003900:	7819      	ldrb	r1, [r3, #0]
34003902:	4c4e      	ldr	r4, [pc, #312]	@ (34003a3c <XSPI_NOR_ExitOPIMode+0x170>)
34003904:	687a      	ldr	r2, [r7, #4]
34003906:	4613      	mov	r3, r2
34003908:	005b      	lsls	r3, r3, #1
3400390a:	4413      	add	r3, r2
3400390c:	4423      	add	r3, r4
3400390e:	3302      	adds	r3, #2
34003910:	781b      	ldrb	r3, [r3, #0]
34003912:	461a      	mov	r2, r3
34003914:	f7fe fe9c 	bl	34002650 <MX25UM51245G_WriteEnable>
34003918:	4603      	mov	r3, r0
3400391a:	2b00      	cmp	r3, #0
3400391c:	d003      	beq.n	34003926 <XSPI_NOR_ExitOPIMode+0x5a>
                                    Xspi_Nor_Ctx[Instance].TransferRate) != MX25UM51245G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
3400391e:	f06f 0304 	mvn.w	r3, #4
34003922:	60fb      	str	r3, [r7, #12]
34003924:	e083      	b.n	34003a2e <XSPI_NOR_ExitOPIMode+0x162>
  }
  else
  {
    /* Write Configuration register 2 (with SPI protocol) */
    reg[0] = 0;
34003926:	2300      	movs	r3, #0
34003928:	723b      	strb	r3, [r7, #8]
    reg[1] = 0;
3400392a:	2300      	movs	r3, #0
3400392c:	727b      	strb	r3, [r7, #9]
    if (MX25UM51245G_WriteCfg2Register(&hxspi_nor[Instance], Xspi_Nor_Ctx[Instance].InterfaceMode,
3400392e:	687b      	ldr	r3, [r7, #4]
34003930:	2264      	movs	r2, #100	@ 0x64
34003932:	fb02 f303 	mul.w	r3, r2, r3
34003936:	4a40      	ldr	r2, [pc, #256]	@ (34003a38 <XSPI_NOR_ExitOPIMode+0x16c>)
34003938:	1898      	adds	r0, r3, r2
3400393a:	4940      	ldr	r1, [pc, #256]	@ (34003a3c <XSPI_NOR_ExitOPIMode+0x170>)
3400393c:	687a      	ldr	r2, [r7, #4]
3400393e:	4613      	mov	r3, r2
34003940:	005b      	lsls	r3, r3, #1
34003942:	4413      	add	r3, r2
34003944:	440b      	add	r3, r1
34003946:	3301      	adds	r3, #1
34003948:	7819      	ldrb	r1, [r3, #0]
3400394a:	4c3c      	ldr	r4, [pc, #240]	@ (34003a3c <XSPI_NOR_ExitOPIMode+0x170>)
3400394c:	687a      	ldr	r2, [r7, #4]
3400394e:	4613      	mov	r3, r2
34003950:	005b      	lsls	r3, r3, #1
34003952:	4413      	add	r3, r2
34003954:	4423      	add	r3, r4
34003956:	3302      	adds	r3, #2
34003958:	781a      	ldrb	r2, [r3, #0]
3400395a:	7a3b      	ldrb	r3, [r7, #8]
3400395c:	9300      	str	r3, [sp, #0]
3400395e:	2300      	movs	r3, #0
34003960:	f7fe ff44 	bl	340027ec <MX25UM51245G_WriteCfg2Register>
34003964:	4603      	mov	r3, r0
34003966:	2b00      	cmp	r3, #0
34003968:	d003      	beq.n	34003972 <XSPI_NOR_ExitOPIMode+0xa6>
                                       Xspi_Nor_Ctx[Instance].TransferRate, MX25UM51245G_CR2_REG1_ADDR,
                                       reg[0]) != MX25UM51245G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
3400396a:	f06f 0304 	mvn.w	r3, #4
3400396e:	60fb      	str	r3, [r7, #12]
34003970:	e05d      	b.n	34003a2e <XSPI_NOR_ExitOPIMode+0x162>
    }
    else
    {
      /* Wait that the configuration is effective and check that memory is ready */
      HAL_Delay(MX25UM51245G_WRITE_REG_MAX_TIME);
34003972:	2028      	movs	r0, #40	@ 0x28
34003974:	f000 fb7a 	bl	3400406c <HAL_Delay>

      if (Xspi_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_DTR_TRANSFER)
34003978:	4930      	ldr	r1, [pc, #192]	@ (34003a3c <XSPI_NOR_ExitOPIMode+0x170>)
3400397a:	687a      	ldr	r2, [r7, #4]
3400397c:	4613      	mov	r3, r2
3400397e:	005b      	lsls	r3, r3, #1
34003980:	4413      	add	r3, r2
34003982:	440b      	add	r3, r1
34003984:	3302      	adds	r3, #2
34003986:	781b      	ldrb	r3, [r3, #0]
34003988:	2b01      	cmp	r3, #1
3400398a:	d120      	bne.n	340039ce <XSPI_NOR_ExitOPIMode+0x102>
      {
        /* Reconfigure the memory type of the peripheral */
        hxspi_nor[Instance].Init.MemoryType            = HAL_XSPI_MEMTYPE_MICRON;
3400398c:	4a2a      	ldr	r2, [pc, #168]	@ (34003a38 <XSPI_NOR_ExitOPIMode+0x16c>)
3400398e:	687b      	ldr	r3, [r7, #4]
34003990:	2164      	movs	r1, #100	@ 0x64
34003992:	fb01 f303 	mul.w	r3, r1, r3
34003996:	4413      	add	r3, r2
34003998:	330c      	adds	r3, #12
3400399a:	2200      	movs	r2, #0
3400399c:	601a      	str	r2, [r3, #0]
        hxspi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
3400399e:	4a26      	ldr	r2, [pc, #152]	@ (34003a38 <XSPI_NOR_ExitOPIMode+0x16c>)
340039a0:	687b      	ldr	r3, [r7, #4]
340039a2:	2164      	movs	r1, #100	@ 0x64
340039a4:	fb01 f303 	mul.w	r3, r1, r3
340039a8:	4413      	add	r3, r2
340039aa:	332c      	adds	r3, #44	@ 0x2c
340039ac:	2200      	movs	r2, #0
340039ae:	601a      	str	r2, [r3, #0]
        if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
340039b0:	687b      	ldr	r3, [r7, #4]
340039b2:	2264      	movs	r2, #100	@ 0x64
340039b4:	fb02 f303 	mul.w	r3, r2, r3
340039b8:	4a1f      	ldr	r2, [pc, #124]	@ (34003a38 <XSPI_NOR_ExitOPIMode+0x16c>)
340039ba:	4413      	add	r3, r2
340039bc:	4618      	mov	r0, r3
340039be:	f013 f91d 	bl	34016bfc <HAL_XSPI_Init>
340039c2:	4603      	mov	r3, r0
340039c4:	2b00      	cmp	r3, #0
340039c6:	d002      	beq.n	340039ce <XSPI_NOR_ExitOPIMode+0x102>
        {
          ret = BSP_ERROR_PERIPH_FAILURE;
340039c8:	f06f 0303 	mvn.w	r3, #3
340039cc:	60fb      	str	r3, [r7, #12]
        }
      }

      if (ret == BSP_ERROR_NONE)
340039ce:	68fb      	ldr	r3, [r7, #12]
340039d0:	2b00      	cmp	r3, #0
340039d2:	d12c      	bne.n	34003a2e <XSPI_NOR_ExitOPIMode+0x162>
      {
        /* Check Flash busy ? */
        if (MX25UM51245G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
340039d4:	687b      	ldr	r3, [r7, #4]
340039d6:	2264      	movs	r2, #100	@ 0x64
340039d8:	fb02 f303 	mul.w	r3, r2, r3
340039dc:	4a16      	ldr	r2, [pc, #88]	@ (34003a38 <XSPI_NOR_ExitOPIMode+0x16c>)
340039de:	4413      	add	r3, r2
340039e0:	2200      	movs	r2, #0
340039e2:	2100      	movs	r1, #0
340039e4:	4618      	mov	r0, r3
340039e6:	f7fe fc6a 	bl	340022be <MX25UM51245G_AutoPollingMemReady>
340039ea:	4603      	mov	r3, r0
340039ec:	2b00      	cmp	r3, #0
340039ee:	d003      	beq.n	340039f8 <XSPI_NOR_ExitOPIMode+0x12c>
                                             BSP_XSPI_NOR_STR_TRANSFER) != MX25UM51245G_OK)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
340039f0:	f06f 0304 	mvn.w	r3, #4
340039f4:	60fb      	str	r3, [r7, #12]
340039f6:	e01a      	b.n	34003a2e <XSPI_NOR_ExitOPIMode+0x162>
        }
        /* Check the configuration has been correctly done */
        else if (MX25UM51245G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE, BSP_XSPI_NOR_STR_TRANSFER,
340039f8:	687b      	ldr	r3, [r7, #4]
340039fa:	2264      	movs	r2, #100	@ 0x64
340039fc:	fb02 f303 	mul.w	r3, r2, r3
34003a00:	4a0d      	ldr	r2, [pc, #52]	@ (34003a38 <XSPI_NOR_ExitOPIMode+0x16c>)
34003a02:	1898      	adds	r0, r3, r2
34003a04:	f107 0308 	add.w	r3, r7, #8
34003a08:	9300      	str	r3, [sp, #0]
34003a0a:	2300      	movs	r3, #0
34003a0c:	2200      	movs	r2, #0
34003a0e:	2100      	movs	r1, #0
34003a10:	f7fe ff7f 	bl	34002912 <MX25UM51245G_ReadCfg2Register>
34003a14:	4603      	mov	r3, r0
34003a16:	2b00      	cmp	r3, #0
34003a18:	d003      	beq.n	34003a22 <XSPI_NOR_ExitOPIMode+0x156>
                                               MX25UM51245G_CR2_REG1_ADDR, reg) != MX25UM51245G_OK)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
34003a1a:	f06f 0304 	mvn.w	r3, #4
34003a1e:	60fb      	str	r3, [r7, #12]
34003a20:	e005      	b.n	34003a2e <XSPI_NOR_ExitOPIMode+0x162>
        }
        else if (reg[0] != 0U)
34003a22:	7a3b      	ldrb	r3, [r7, #8]
34003a24:	2b00      	cmp	r3, #0
34003a26:	d002      	beq.n	34003a2e <XSPI_NOR_ExitOPIMode+0x162>
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
34003a28:	f06f 0304 	mvn.w	r3, #4
34003a2c:	60fb      	str	r3, [r7, #12]
      }
    }
  }

  /* Return BSP status */
  return ret;
34003a2e:	68fb      	ldr	r3, [r7, #12]
}
34003a30:	4618      	mov	r0, r3
34003a32:	3714      	adds	r7, #20
34003a34:	46bd      	mov	sp, r7
34003a36:	bd90      	pop	{r4, r7, pc}
34003a38:	34020fa8 	.word	0x34020fa8
34003a3c:	3402100c 	.word	0x3402100c

34003a40 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
34003a40:	b480      	push	{r7}
34003a42:	af00      	add	r7, sp, #0

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#else
  SCB->VTOR = INTVECT_START;
34003a44:	4b6a      	ldr	r3, [pc, #424]	@ (34003bf0 <SystemInit+0x1b0>)
34003a46:	4a6b      	ldr	r2, [pc, #428]	@ (34003bf4 <SystemInit+0x1b4>)
34003a48:	609a      	str	r2, [r3, #8]
#endif  /* USER_VECT_TAB_ADDRESS */

  /* RNG reset */
  RCC->AHB3RSTSR = RCC_AHB3RSTSR_RNGRSTS;
34003a4a:	4b6b      	ldr	r3, [pc, #428]	@ (34003bf8 <SystemInit+0x1b8>)
34003a4c:	2201      	movs	r2, #1
34003a4e:	f8c3 2a18 	str.w	r2, [r3, #2584]	@ 0xa18
  RCC->AHB3RSTCR = RCC_AHB3RSTCR_RNGRSTC;
34003a52:	4b69      	ldr	r3, [pc, #420]	@ (34003bf8 <SystemInit+0x1b8>)
34003a54:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34003a58:	461a      	mov	r2, r3
34003a5a:	2301      	movs	r3, #1
34003a5c:	f8c2 3218 	str.w	r3, [r2, #536]	@ 0x218
  /* Deactivate RNG clock */
  RCC->AHB3ENCR = RCC_AHB3ENCR_RNGENC;
34003a60:	4b65      	ldr	r3, [pc, #404]	@ (34003bf8 <SystemInit+0x1b8>)
34003a62:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34003a66:	461a      	mov	r2, r3
34003a68:	2301      	movs	r3, #1
34003a6a:	f8c2 3258 	str.w	r3, [r2, #600]	@ 0x258

  /* Clear SAU regions */
  SAU->RNR = 0;
34003a6e:	4b63      	ldr	r3, [pc, #396]	@ (34003bfc <SystemInit+0x1bc>)
34003a70:	2200      	movs	r2, #0
34003a72:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34003a74:	4b61      	ldr	r3, [pc, #388]	@ (34003bfc <SystemInit+0x1bc>)
34003a76:	2200      	movs	r2, #0
34003a78:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34003a7a:	4b60      	ldr	r3, [pc, #384]	@ (34003bfc <SystemInit+0x1bc>)
34003a7c:	2200      	movs	r2, #0
34003a7e:	611a      	str	r2, [r3, #16]
  SAU->RNR = 1;
34003a80:	4b5e      	ldr	r3, [pc, #376]	@ (34003bfc <SystemInit+0x1bc>)
34003a82:	2201      	movs	r2, #1
34003a84:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34003a86:	4b5d      	ldr	r3, [pc, #372]	@ (34003bfc <SystemInit+0x1bc>)
34003a88:	2200      	movs	r2, #0
34003a8a:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34003a8c:	4b5b      	ldr	r3, [pc, #364]	@ (34003bfc <SystemInit+0x1bc>)
34003a8e:	2200      	movs	r2, #0
34003a90:	611a      	str	r2, [r3, #16]
  SAU->RNR = 2;
34003a92:	4b5a      	ldr	r3, [pc, #360]	@ (34003bfc <SystemInit+0x1bc>)
34003a94:	2202      	movs	r2, #2
34003a96:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34003a98:	4b58      	ldr	r3, [pc, #352]	@ (34003bfc <SystemInit+0x1bc>)
34003a9a:	2200      	movs	r2, #0
34003a9c:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34003a9e:	4b57      	ldr	r3, [pc, #348]	@ (34003bfc <SystemInit+0x1bc>)
34003aa0:	2200      	movs	r2, #0
34003aa2:	611a      	str	r2, [r3, #16]
  SAU->RNR = 3;
34003aa4:	4b55      	ldr	r3, [pc, #340]	@ (34003bfc <SystemInit+0x1bc>)
34003aa6:	2203      	movs	r2, #3
34003aa8:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34003aaa:	4b54      	ldr	r3, [pc, #336]	@ (34003bfc <SystemInit+0x1bc>)
34003aac:	2200      	movs	r2, #0
34003aae:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34003ab0:	4b52      	ldr	r3, [pc, #328]	@ (34003bfc <SystemInit+0x1bc>)
34003ab2:	2200      	movs	r2, #0
34003ab4:	611a      	str	r2, [r3, #16]
  SAU->RNR = 4;
34003ab6:	4b51      	ldr	r3, [pc, #324]	@ (34003bfc <SystemInit+0x1bc>)
34003ab8:	2204      	movs	r2, #4
34003aba:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34003abc:	4b4f      	ldr	r3, [pc, #316]	@ (34003bfc <SystemInit+0x1bc>)
34003abe:	2200      	movs	r2, #0
34003ac0:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34003ac2:	4b4e      	ldr	r3, [pc, #312]	@ (34003bfc <SystemInit+0x1bc>)
34003ac4:	2200      	movs	r2, #0
34003ac6:	611a      	str	r2, [r3, #16]
  SAU->RNR = 5;
34003ac8:	4b4c      	ldr	r3, [pc, #304]	@ (34003bfc <SystemInit+0x1bc>)
34003aca:	2205      	movs	r2, #5
34003acc:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34003ace:	4b4b      	ldr	r3, [pc, #300]	@ (34003bfc <SystemInit+0x1bc>)
34003ad0:	2200      	movs	r2, #0
34003ad2:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34003ad4:	4b49      	ldr	r3, [pc, #292]	@ (34003bfc <SystemInit+0x1bc>)
34003ad6:	2200      	movs	r2, #0
34003ad8:	611a      	str	r2, [r3, #16]
  SAU->RNR = 6;
34003ada:	4b48      	ldr	r3, [pc, #288]	@ (34003bfc <SystemInit+0x1bc>)
34003adc:	2206      	movs	r2, #6
34003ade:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34003ae0:	4b46      	ldr	r3, [pc, #280]	@ (34003bfc <SystemInit+0x1bc>)
34003ae2:	2200      	movs	r2, #0
34003ae4:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34003ae6:	4b45      	ldr	r3, [pc, #276]	@ (34003bfc <SystemInit+0x1bc>)
34003ae8:	2200      	movs	r2, #0
34003aea:	611a      	str	r2, [r3, #16]
  SAU->RNR = 7;
34003aec:	4b43      	ldr	r3, [pc, #268]	@ (34003bfc <SystemInit+0x1bc>)
34003aee:	2207      	movs	r2, #7
34003af0:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34003af2:	4b42      	ldr	r3, [pc, #264]	@ (34003bfc <SystemInit+0x1bc>)
34003af4:	2200      	movs	r2, #0
34003af6:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34003af8:	4b40      	ldr	r3, [pc, #256]	@ (34003bfc <SystemInit+0x1bc>)
34003afa:	2200      	movs	r2, #0
34003afc:	611a      	str	r2, [r3, #16]

  /* System configuration setup */
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
34003afe:	4b3e      	ldr	r3, [pc, #248]	@ (34003bf8 <SystemInit+0x1b8>)
34003b00:	2201      	movs	r2, #1
34003b02:	f8c3 2a78 	str.w	r2, [r3, #2680]	@ 0xa78
  /* Delay after an RCC peripheral clock enabling */
  (void)RCC->APB4ENR2;
34003b06:	4b3c      	ldr	r3, [pc, #240]	@ (34003bf8 <SystemInit+0x1b8>)
34003b08:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278

  /* Set default Vector Table location after system reset or return from Standby */
  SYSCFG->INITSVTORCR = SCB->VTOR;
34003b0c:	4b38      	ldr	r3, [pc, #224]	@ (34003bf0 <SystemInit+0x1b0>)
34003b0e:	4a3c      	ldr	r2, [pc, #240]	@ (34003c00 <SystemInit+0x1c0>)
34003b10:	689b      	ldr	r3, [r3, #8]
34003b12:	6113      	str	r3, [r2, #16]

  /* Enable VDDADC CLAMP */
  PWR->SVMCR3 |= PWR_SVMCR3_ASV;
34003b14:	4b3b      	ldr	r3, [pc, #236]	@ (34003c04 <SystemInit+0x1c4>)
34003b16:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34003b18:	4a3a      	ldr	r2, [pc, #232]	@ (34003c04 <SystemInit+0x1c4>)
34003b1a:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
34003b1e:	63d3      	str	r3, [r2, #60]	@ 0x3c
  PWR->SVMCR3 |= PWR_SVMCR3_AVMEN;
34003b20:	4b38      	ldr	r3, [pc, #224]	@ (34003c04 <SystemInit+0x1c4>)
34003b22:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34003b24:	4a37      	ldr	r2, [pc, #220]	@ (34003c04 <SystemInit+0x1c4>)
34003b26:	f043 0310 	orr.w	r3, r3, #16
34003b2a:	63d3      	str	r3, [r2, #60]	@ 0x3c
  /* read back the register to make sure that the transaction has taken place */
  (void) PWR->SVMCR3;
34003b2c:	4b35      	ldr	r3, [pc, #212]	@ (34003c04 <SystemInit+0x1c4>)
34003b2e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
  /* enable VREF */
  RCC->APB4ENR1 |= RCC_APB4ENR1_VREFBUFEN;
34003b30:	4b31      	ldr	r3, [pc, #196]	@ (34003bf8 <SystemInit+0x1b8>)
34003b32:	f8d3 3274 	ldr.w	r3, [r3, #628]	@ 0x274
34003b36:	4a30      	ldr	r2, [pc, #192]	@ (34003bf8 <SystemInit+0x1b8>)
34003b38:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34003b3c:	f8c2 3274 	str.w	r3, [r2, #628]	@ 0x274

  /* RCC Fix to lower power consumption */
  RCC->APB4ENR2 |= 0x00000010UL;
34003b40:	4b2d      	ldr	r3, [pc, #180]	@ (34003bf8 <SystemInit+0x1b8>)
34003b42:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
34003b46:	4a2c      	ldr	r2, [pc, #176]	@ (34003bf8 <SystemInit+0x1b8>)
34003b48:	f043 0310 	orr.w	r3, r3, #16
34003b4c:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  (void) RCC->APB4ENR2;
34003b50:	4b29      	ldr	r3, [pc, #164]	@ (34003bf8 <SystemInit+0x1b8>)
34003b52:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
  RCC->APB4ENR2 &= ~(0x00000010UL);
34003b56:	4b28      	ldr	r3, [pc, #160]	@ (34003bf8 <SystemInit+0x1b8>)
34003b58:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
34003b5c:	4a26      	ldr	r2, [pc, #152]	@ (34003bf8 <SystemInit+0x1b8>)
34003b5e:	f023 0310 	bic.w	r3, r3, #16
34003b62:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278

  /* XSPI2 & XSPIM reset                                  */
  RCC->AHB5RSTSR = RCC_AHB5RSTSR_XSPIMRSTS | RCC_AHB5RSTSR_XSPI2RSTS;
34003b66:	4b24      	ldr	r3, [pc, #144]	@ (34003bf8 <SystemInit+0x1b8>)
34003b68:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
34003b6c:	f8c3 2a20 	str.w	r2, [r3, #2592]	@ 0xa20
  RCC->AHB5RSTCR = RCC_AHB5RSTCR_XSPIMRSTC | RCC_AHB5RSTCR_XSPI2RSTC;
34003b70:	4b21      	ldr	r3, [pc, #132]	@ (34003bf8 <SystemInit+0x1b8>)
34003b72:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34003b76:	461a      	mov	r2, r3
34003b78:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34003b7c:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220

  /* TIM2 reset */
  RCC->APB1RSTSR1 = RCC_APB1RSTSR1_TIM2RSTS;
34003b80:	4b1d      	ldr	r3, [pc, #116]	@ (34003bf8 <SystemInit+0x1b8>)
34003b82:	2201      	movs	r2, #1
34003b84:	f8c3 2a24 	str.w	r2, [r3, #2596]	@ 0xa24
  RCC->APB1RSTCR1 = RCC_APB1RSTCR1_TIM2RSTC;
34003b88:	4b1b      	ldr	r3, [pc, #108]	@ (34003bf8 <SystemInit+0x1b8>)
34003b8a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34003b8e:	461a      	mov	r2, r3
34003b90:	2301      	movs	r3, #1
34003b92:	f8c2 3224 	str.w	r3, [r2, #548]	@ 0x224
  /* Deactivate TIM2 clock */
  RCC->APB1ENCR1 = RCC_APB1ENCR1_TIM2ENC;
34003b96:	4b18      	ldr	r3, [pc, #96]	@ (34003bf8 <SystemInit+0x1b8>)
34003b98:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34003b9c:	461a      	mov	r2, r3
34003b9e:	2301      	movs	r3, #1
34003ba0:	f8c2 3264 	str.w	r3, [r2, #612]	@ 0x264

  /* Deactivate GPIOG clock */
  RCC->AHB4ENCR = RCC_AHB4ENCR_GPIOGENC;
34003ba4:	4b14      	ldr	r3, [pc, #80]	@ (34003bf8 <SystemInit+0x1b8>)
34003ba6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34003baa:	461a      	mov	r2, r3
34003bac:	2340      	movs	r3, #64	@ 0x40
34003bae:	f8c2 325c 	str.w	r3, [r2, #604]	@ 0x25c

  /* Read back the value to make sure it is written before deactivating SYSCFG */
  (void) SYSCFG->INITSVTORCR;
34003bb2:	4b13      	ldr	r3, [pc, #76]	@ (34003c00 <SystemInit+0x1c0>)
34003bb4:	691b      	ldr	r3, [r3, #16]
  /* Deactivate SYSCFG clock */
  RCC->APB4ENCR2 = RCC_APB4ENCR2_SYSCFGENC;
34003bb6:	4b10      	ldr	r3, [pc, #64]	@ (34003bf8 <SystemInit+0x1b8>)
34003bb8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34003bbc:	461a      	mov	r2, r3
34003bbe:	2301      	movs	r3, #1
34003bc0:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  TZ_SAU_Setup();
#endif /* USER_TZ_SAU_SETUP */

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34003bc4:	4b0a      	ldr	r3, [pc, #40]	@ (34003bf0 <SystemInit+0x1b0>)
34003bc6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34003bca:	4a09      	ldr	r2, [pc, #36]	@ (34003bf0 <SystemInit+0x1b0>)
34003bcc:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34003bd0:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34003bd4:	4b0c      	ldr	r3, [pc, #48]	@ (34003c08 <SystemInit+0x1c8>)
34003bd6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34003bda:	4a0b      	ldr	r2, [pc, #44]	@ (34003c08 <SystemInit+0x1c8>)
34003bdc:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34003be0:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif /* __FPU_PRESENT && __FPU_USED */

}
34003be4:	bf00      	nop
34003be6:	46bd      	mov	sp, r7
34003be8:	f85d 7b04 	ldr.w	r7, [sp], #4
34003bec:	4770      	bx	lr
34003bee:	bf00      	nop
34003bf0:	e000ed00 	.word	0xe000ed00
34003bf4:	34000400 	.word	0x34000400
34003bf8:	56028000 	.word	0x56028000
34003bfc:	e000edd0 	.word	0xe000edd0
34003c00:	56008000 	.word	0x56008000
34003c04:	56024800 	.word	0x56024800
34003c08:	e002ed00 	.word	0xe002ed00

34003c0c <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
34003c0c:	b480      	push	{r7}
34003c0e:	b08d      	sub	sp, #52	@ 0x34
34003c10:	af00      	add	r7, sp, #0
  uint32_t sysclk = 0;
34003c12:	2300      	movs	r3, #0
34003c14:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t pllm = 0;
34003c16:	2300      	movs	r3, #0
34003c18:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t plln = 0;
34003c1a:	2300      	movs	r3, #0
34003c1c:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pllfracn = 0;
34003c1e:	2300      	movs	r3, #0
34003c20:	623b      	str	r3, [r7, #32]
  uint32_t pllp1 = 0;
34003c22:	2300      	movs	r3, #0
34003c24:	61fb      	str	r3, [r7, #28]
  uint32_t pllp2 = 0;
34003c26:	2300      	movs	r3, #0
34003c28:	61bb      	str	r3, [r7, #24]
  uint32_t pllcfgr, pllsource, pllbypass, ic_divider;
  float_t pllvco;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34003c2a:	4b9b      	ldr	r3, [pc, #620]	@ (34003e98 <SystemCoreClockUpdate+0x28c>)
34003c2c:	6a1b      	ldr	r3, [r3, #32]
34003c2e:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
34003c32:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34003c36:	d029      	beq.n	34003c8c <SystemCoreClockUpdate+0x80>
34003c38:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34003c3c:	f200 8180 	bhi.w	34003f40 <SystemCoreClockUpdate+0x334>
34003c40:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34003c44:	d01f      	beq.n	34003c86 <SystemCoreClockUpdate+0x7a>
34003c46:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34003c4a:	f200 8179 	bhi.w	34003f40 <SystemCoreClockUpdate+0x334>
34003c4e:	2b00      	cmp	r3, #0
34003c50:	d003      	beq.n	34003c5a <SystemCoreClockUpdate+0x4e>
34003c52:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34003c56:	d00a      	beq.n	34003c6e <SystemCoreClockUpdate+0x62>
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
    sysclk = sysclk / ic_divider;
    break;
  default:
    /* Nothing to do, should not occur */
    break;
34003c58:	e172      	b.n	34003f40 <SystemCoreClockUpdate+0x334>
    sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34003c5a:	4b8f      	ldr	r3, [pc, #572]	@ (34003e98 <SystemCoreClockUpdate+0x28c>)
34003c5c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34003c5e:	09db      	lsrs	r3, r3, #7
34003c60:	f003 0303 	and.w	r3, r3, #3
34003c64:	4a8d      	ldr	r2, [pc, #564]	@ (34003e9c <SystemCoreClockUpdate+0x290>)
34003c66:	fa22 f303 	lsr.w	r3, r2, r3
34003c6a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34003c6c:	e169      	b.n	34003f42 <SystemCoreClockUpdate+0x336>
    if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34003c6e:	4b8a      	ldr	r3, [pc, #552]	@ (34003e98 <SystemCoreClockUpdate+0x28c>)
34003c70:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34003c72:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34003c76:	2b00      	cmp	r3, #0
34003c78:	d102      	bne.n	34003c80 <SystemCoreClockUpdate+0x74>
      sysclk = MSI_VALUE;
34003c7a:	4b89      	ldr	r3, [pc, #548]	@ (34003ea0 <SystemCoreClockUpdate+0x294>)
34003c7c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34003c7e:	e160      	b.n	34003f42 <SystemCoreClockUpdate+0x336>
      sysclk = 16000000UL;
34003c80:	4b88      	ldr	r3, [pc, #544]	@ (34003ea4 <SystemCoreClockUpdate+0x298>)
34003c82:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34003c84:	e15d      	b.n	34003f42 <SystemCoreClockUpdate+0x336>
    sysclk = HSE_VALUE;
34003c86:	4b88      	ldr	r3, [pc, #544]	@ (34003ea8 <SystemCoreClockUpdate+0x29c>)
34003c88:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34003c8a:	e15a      	b.n	34003f42 <SystemCoreClockUpdate+0x336>
    switch (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL))
34003c8c:	4b82      	ldr	r3, [pc, #520]	@ (34003e98 <SystemCoreClockUpdate+0x28c>)
34003c8e:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34003c92:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
34003c96:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34003c9a:	d066      	beq.n	34003d6a <SystemCoreClockUpdate+0x15e>
34003c9c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34003ca0:	f200 8091 	bhi.w	34003dc6 <SystemCoreClockUpdate+0x1ba>
34003ca4:	2b00      	cmp	r3, #0
34003ca6:	d003      	beq.n	34003cb0 <SystemCoreClockUpdate+0xa4>
34003ca8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34003cac:	d02f      	beq.n	34003d0e <SystemCoreClockUpdate+0x102>
34003cae:	e08a      	b.n	34003dc6 <SystemCoreClockUpdate+0x1ba>
      pllcfgr = READ_REG(RCC->PLL1CFGR1);
34003cb0:	4b79      	ldr	r3, [pc, #484]	@ (34003e98 <SystemCoreClockUpdate+0x28c>)
34003cb2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34003cb6:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL1CFGR1_PLL1SEL;
34003cb8:	68fb      	ldr	r3, [r7, #12]
34003cba:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34003cbe:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL1CFGR1_PLL1BYP;
34003cc0:	68fb      	ldr	r3, [r7, #12]
34003cc2:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34003cc6:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34003cc8:	693b      	ldr	r3, [r7, #16]
34003cca:	2b00      	cmp	r3, #0
34003ccc:	f040 80a9 	bne.w	34003e22 <SystemCoreClockUpdate+0x216>
        pllm = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVM) >>  RCC_PLL1CFGR1_PLL1DIVM_Pos;
34003cd0:	68fb      	ldr	r3, [r7, #12]
34003cd2:	0d1b      	lsrs	r3, r3, #20
34003cd4:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34003cd8:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVN) >>  RCC_PLL1CFGR1_PLL1DIVN_Pos;
34003cda:	68fb      	ldr	r3, [r7, #12]
34003cdc:	0a1b      	lsrs	r3, r3, #8
34003cde:	f3c3 030b 	ubfx	r3, r3, #0, #12
34003ce2:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
34003ce4:	4b6c      	ldr	r3, [pc, #432]	@ (34003e98 <SystemCoreClockUpdate+0x28c>)
34003ce6:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34003cea:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34003cee:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL1CFGR3);
34003cf0:	4b69      	ldr	r3, [pc, #420]	@ (34003e98 <SystemCoreClockUpdate+0x28c>)
34003cf2:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34003cf6:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV1) >>  RCC_PLL1CFGR3_PLL1PDIV1_Pos;
34003cf8:	68fb      	ldr	r3, [r7, #12]
34003cfa:	0edb      	lsrs	r3, r3, #27
34003cfc:	f003 0307 	and.w	r3, r3, #7
34003d00:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV2) >>  RCC_PLL1CFGR3_PLL1PDIV2_Pos;
34003d02:	68fb      	ldr	r3, [r7, #12]
34003d04:	0e1b      	lsrs	r3, r3, #24
34003d06:	f003 0307 	and.w	r3, r3, #7
34003d0a:	61bb      	str	r3, [r7, #24]
      break;
34003d0c:	e089      	b.n	34003e22 <SystemCoreClockUpdate+0x216>
      pllcfgr = READ_REG(RCC->PLL2CFGR1);
34003d0e:	4b62      	ldr	r3, [pc, #392]	@ (34003e98 <SystemCoreClockUpdate+0x28c>)
34003d10:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34003d14:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL2CFGR1_PLL2SEL;
34003d16:	68fb      	ldr	r3, [r7, #12]
34003d18:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34003d1c:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL2CFGR1_PLL2BYP;
34003d1e:	68fb      	ldr	r3, [r7, #12]
34003d20:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34003d24:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34003d26:	693b      	ldr	r3, [r7, #16]
34003d28:	2b00      	cmp	r3, #0
34003d2a:	d17c      	bne.n	34003e26 <SystemCoreClockUpdate+0x21a>
        pllm = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVM) >>  RCC_PLL2CFGR1_PLL2DIVM_Pos;
34003d2c:	68fb      	ldr	r3, [r7, #12]
34003d2e:	0d1b      	lsrs	r3, r3, #20
34003d30:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34003d34:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVN) >>  RCC_PLL2CFGR1_PLL2DIVN_Pos;
34003d36:	68fb      	ldr	r3, [r7, #12]
34003d38:	0a1b      	lsrs	r3, r3, #8
34003d3a:	f3c3 030b 	ubfx	r3, r3, #0, #12
34003d3e:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
34003d40:	4b55      	ldr	r3, [pc, #340]	@ (34003e98 <SystemCoreClockUpdate+0x28c>)
34003d42:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34003d46:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34003d4a:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL2CFGR3);
34003d4c:	4b52      	ldr	r3, [pc, #328]	@ (34003e98 <SystemCoreClockUpdate+0x28c>)
34003d4e:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34003d52:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV1) >>  RCC_PLL2CFGR3_PLL2PDIV1_Pos;
34003d54:	68fb      	ldr	r3, [r7, #12]
34003d56:	0edb      	lsrs	r3, r3, #27
34003d58:	f003 0307 	and.w	r3, r3, #7
34003d5c:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV2) >>  RCC_PLL2CFGR3_PLL2PDIV2_Pos;
34003d5e:	68fb      	ldr	r3, [r7, #12]
34003d60:	0e1b      	lsrs	r3, r3, #24
34003d62:	f003 0307 	and.w	r3, r3, #7
34003d66:	61bb      	str	r3, [r7, #24]
      break;
34003d68:	e05d      	b.n	34003e26 <SystemCoreClockUpdate+0x21a>
      pllcfgr = READ_REG(RCC->PLL3CFGR1);
34003d6a:	4b4b      	ldr	r3, [pc, #300]	@ (34003e98 <SystemCoreClockUpdate+0x28c>)
34003d6c:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34003d70:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL3CFGR1_PLL3SEL;
34003d72:	68fb      	ldr	r3, [r7, #12]
34003d74:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34003d78:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL3CFGR1_PLL3BYP;
34003d7a:	68fb      	ldr	r3, [r7, #12]
34003d7c:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34003d80:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34003d82:	693b      	ldr	r3, [r7, #16]
34003d84:	2b00      	cmp	r3, #0
34003d86:	d150      	bne.n	34003e2a <SystemCoreClockUpdate+0x21e>
        pllm = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVM) >>  RCC_PLL3CFGR1_PLL3DIVM_Pos;
34003d88:	68fb      	ldr	r3, [r7, #12]
34003d8a:	0d1b      	lsrs	r3, r3, #20
34003d8c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34003d90:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVN) >>  RCC_PLL3CFGR1_PLL3DIVN_Pos;
34003d92:	68fb      	ldr	r3, [r7, #12]
34003d94:	0a1b      	lsrs	r3, r3, #8
34003d96:	f3c3 030b 	ubfx	r3, r3, #0, #12
34003d9a:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
34003d9c:	4b3e      	ldr	r3, [pc, #248]	@ (34003e98 <SystemCoreClockUpdate+0x28c>)
34003d9e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34003da2:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34003da6:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL3CFGR3);
34003da8:	4b3b      	ldr	r3, [pc, #236]	@ (34003e98 <SystemCoreClockUpdate+0x28c>)
34003daa:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34003dae:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV1) >>  RCC_PLL3CFGR3_PLL3PDIV1_Pos;
34003db0:	68fb      	ldr	r3, [r7, #12]
34003db2:	0edb      	lsrs	r3, r3, #27
34003db4:	f003 0307 	and.w	r3, r3, #7
34003db8:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV2) >>  RCC_PLL3CFGR3_PLL3PDIV2_Pos;
34003dba:	68fb      	ldr	r3, [r7, #12]
34003dbc:	0e1b      	lsrs	r3, r3, #24
34003dbe:	f003 0307 	and.w	r3, r3, #7
34003dc2:	61bb      	str	r3, [r7, #24]
      break;
34003dc4:	e031      	b.n	34003e2a <SystemCoreClockUpdate+0x21e>
      pllcfgr = READ_REG(RCC->PLL4CFGR1);
34003dc6:	4b34      	ldr	r3, [pc, #208]	@ (34003e98 <SystemCoreClockUpdate+0x28c>)
34003dc8:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34003dcc:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
34003dce:	68fb      	ldr	r3, [r7, #12]
34003dd0:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34003dd4:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL4CFGR1_PLL4BYP;
34003dd6:	68fb      	ldr	r3, [r7, #12]
34003dd8:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34003ddc:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34003dde:	693b      	ldr	r3, [r7, #16]
34003de0:	2b00      	cmp	r3, #0
34003de2:	d124      	bne.n	34003e2e <SystemCoreClockUpdate+0x222>
        pllm = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVM) >>  RCC_PLL4CFGR1_PLL4DIVM_Pos;
34003de4:	68fb      	ldr	r3, [r7, #12]
34003de6:	0d1b      	lsrs	r3, r3, #20
34003de8:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34003dec:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVN) >>  RCC_PLL4CFGR1_PLL4DIVN_Pos;
34003dee:	68fb      	ldr	r3, [r7, #12]
34003df0:	0a1b      	lsrs	r3, r3, #8
34003df2:	f3c3 030b 	ubfx	r3, r3, #0, #12
34003df6:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
34003df8:	4b27      	ldr	r3, [pc, #156]	@ (34003e98 <SystemCoreClockUpdate+0x28c>)
34003dfa:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
34003dfe:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34003e02:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
34003e04:	4b24      	ldr	r3, [pc, #144]	@ (34003e98 <SystemCoreClockUpdate+0x28c>)
34003e06:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34003e0a:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV1) >>  RCC_PLL4CFGR3_PLL4PDIV1_Pos;
34003e0c:	68fb      	ldr	r3, [r7, #12]
34003e0e:	0edb      	lsrs	r3, r3, #27
34003e10:	f003 0307 	and.w	r3, r3, #7
34003e14:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV2) >>  RCC_PLL4CFGR3_PLL4PDIV2_Pos;
34003e16:	68fb      	ldr	r3, [r7, #12]
34003e18:	0e1b      	lsrs	r3, r3, #24
34003e1a:	f003 0307 	and.w	r3, r3, #7
34003e1e:	61bb      	str	r3, [r7, #24]
      break;
34003e20:	e005      	b.n	34003e2e <SystemCoreClockUpdate+0x222>
      break;
34003e22:	bf00      	nop
34003e24:	e004      	b.n	34003e30 <SystemCoreClockUpdate+0x224>
      break;
34003e26:	bf00      	nop
34003e28:	e002      	b.n	34003e30 <SystemCoreClockUpdate+0x224>
      break;
34003e2a:	bf00      	nop
34003e2c:	e000      	b.n	34003e30 <SystemCoreClockUpdate+0x224>
      break;
34003e2e:	bf00      	nop
    switch (pllsource)
34003e30:	697b      	ldr	r3, [r7, #20]
34003e32:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34003e36:	d02c      	beq.n	34003e92 <SystemCoreClockUpdate+0x286>
34003e38:	697b      	ldr	r3, [r7, #20]
34003e3a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34003e3e:	d839      	bhi.n	34003eb4 <SystemCoreClockUpdate+0x2a8>
34003e40:	697b      	ldr	r3, [r7, #20]
34003e42:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34003e46:	d021      	beq.n	34003e8c <SystemCoreClockUpdate+0x280>
34003e48:	697b      	ldr	r3, [r7, #20]
34003e4a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34003e4e:	d831      	bhi.n	34003eb4 <SystemCoreClockUpdate+0x2a8>
34003e50:	697b      	ldr	r3, [r7, #20]
34003e52:	2b00      	cmp	r3, #0
34003e54:	d004      	beq.n	34003e60 <SystemCoreClockUpdate+0x254>
34003e56:	697b      	ldr	r3, [r7, #20]
34003e58:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34003e5c:	d00a      	beq.n	34003e74 <SystemCoreClockUpdate+0x268>
      break;
34003e5e:	e029      	b.n	34003eb4 <SystemCoreClockUpdate+0x2a8>
      sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34003e60:	4b0d      	ldr	r3, [pc, #52]	@ (34003e98 <SystemCoreClockUpdate+0x28c>)
34003e62:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34003e64:	09db      	lsrs	r3, r3, #7
34003e66:	f003 0303 	and.w	r3, r3, #3
34003e6a:	4a0c      	ldr	r2, [pc, #48]	@ (34003e9c <SystemCoreClockUpdate+0x290>)
34003e6c:	fa22 f303 	lsr.w	r3, r2, r3
34003e70:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34003e72:	e020      	b.n	34003eb6 <SystemCoreClockUpdate+0x2aa>
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34003e74:	4b08      	ldr	r3, [pc, #32]	@ (34003e98 <SystemCoreClockUpdate+0x28c>)
34003e76:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34003e78:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34003e7c:	2b00      	cmp	r3, #0
34003e7e:	d102      	bne.n	34003e86 <SystemCoreClockUpdate+0x27a>
        sysclk = MSI_VALUE;
34003e80:	4b07      	ldr	r3, [pc, #28]	@ (34003ea0 <SystemCoreClockUpdate+0x294>)
34003e82:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34003e84:	e017      	b.n	34003eb6 <SystemCoreClockUpdate+0x2aa>
        sysclk = 16000000UL;
34003e86:	4b07      	ldr	r3, [pc, #28]	@ (34003ea4 <SystemCoreClockUpdate+0x298>)
34003e88:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34003e8a:	e014      	b.n	34003eb6 <SystemCoreClockUpdate+0x2aa>
      sysclk = HSE_VALUE;
34003e8c:	4b06      	ldr	r3, [pc, #24]	@ (34003ea8 <SystemCoreClockUpdate+0x29c>)
34003e8e:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34003e90:	e011      	b.n	34003eb6 <SystemCoreClockUpdate+0x2aa>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
34003e92:	4b06      	ldr	r3, [pc, #24]	@ (34003eac <SystemCoreClockUpdate+0x2a0>)
34003e94:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34003e96:	e00e      	b.n	34003eb6 <SystemCoreClockUpdate+0x2aa>
34003e98:	56028000 	.word	0x56028000
34003e9c:	03d09000 	.word	0x03d09000
34003ea0:	003d0900 	.word	0x003d0900
34003ea4:	00f42400 	.word	0x00f42400
34003ea8:	02dc6c00 	.word	0x02dc6c00
34003eac:	00bb8000 	.word	0x00bb8000
34003eb0:	4b800000 	.word	0x4b800000
      break;
34003eb4:	bf00      	nop
    if (pllbypass == 0U)
34003eb6:	693b      	ldr	r3, [r7, #16]
34003eb8:	2b00      	cmp	r3, #0
34003eba:	d134      	bne.n	34003f26 <SystemCoreClockUpdate+0x31a>
      pllvco = ((float_t)sysclk * ((float_t)plln + ((float_t)pllfracn/(float_t)0x1000000UL))) / (float_t)pllm;
34003ebc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34003ebe:	ee07 3a90 	vmov	s15, r3
34003ec2:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34003ec6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34003ec8:	ee07 3a90 	vmov	s15, r3
34003ecc:	eef8 6a67 	vcvt.f32.u32	s13, s15
34003ed0:	6a3b      	ldr	r3, [r7, #32]
34003ed2:	ee07 3a90 	vmov	s15, r3
34003ed6:	eeb8 6a67 	vcvt.f32.u32	s12, s15
34003eda:	ed5f 5a0b 	vldr	s11, [pc, #-44]	@ 34003eb0 <SystemCoreClockUpdate+0x2a4>
34003ede:	eec6 7a25 	vdiv.f32	s15, s12, s11
34003ee2:	ee76 7aa7 	vadd.f32	s15, s13, s15
34003ee6:	ee67 6a27 	vmul.f32	s13, s14, s15
34003eea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34003eec:	ee07 3a90 	vmov	s15, r3
34003ef0:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34003ef4:	eec6 7a87 	vdiv.f32	s15, s13, s14
34003ef8:	edc7 7a02 	vstr	s15, [r7, #8]
      sysclk = (uint32_t)((float_t)(pllvco/(((float_t)pllp1) * ((float_t)pllp2))));
34003efc:	69fb      	ldr	r3, [r7, #28]
34003efe:	ee07 3a90 	vmov	s15, r3
34003f02:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34003f06:	69bb      	ldr	r3, [r7, #24]
34003f08:	ee07 3a90 	vmov	s15, r3
34003f0c:	eef8 7a67 	vcvt.f32.u32	s15, s15
34003f10:	ee27 7a27 	vmul.f32	s14, s14, s15
34003f14:	edd7 6a02 	vldr	s13, [r7, #8]
34003f18:	eec6 7a87 	vdiv.f32	s15, s13, s14
34003f1c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34003f20:	ee17 3a90 	vmov	r3, s15
34003f24:	62fb      	str	r3, [r7, #44]	@ 0x2c
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
34003f26:	4b0b      	ldr	r3, [pc, #44]	@ (34003f54 <SystemCoreClockUpdate+0x348>)
34003f28:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34003f2c:	0c1b      	lsrs	r3, r3, #16
34003f2e:	b2db      	uxtb	r3, r3
34003f30:	3301      	adds	r3, #1
34003f32:	607b      	str	r3, [r7, #4]
    sysclk = sysclk / ic_divider;
34003f34:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34003f36:	687b      	ldr	r3, [r7, #4]
34003f38:	fbb2 f3f3 	udiv	r3, r2, r3
34003f3c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34003f3e:	e000      	b.n	34003f42 <SystemCoreClockUpdate+0x336>
    break;
34003f40:	bf00      	nop
  }

  /* Return system clock frequency (CPU frequency) */
  SystemCoreClock = sysclk;
34003f42:	4a05      	ldr	r2, [pc, #20]	@ (34003f58 <SystemCoreClockUpdate+0x34c>)
34003f44:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34003f46:	6013      	str	r3, [r2, #0]
}
34003f48:	bf00      	nop
34003f4a:	3734      	adds	r7, #52	@ 0x34
34003f4c:	46bd      	mov	sp, r7
34003f4e:	f85d 7b04 	ldr.w	r7, [sp], #4
34003f52:	4770      	bx	lr
34003f54:	56028000 	.word	0x56028000
34003f58:	34020c54 	.word	0x34020c54

34003f5c <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
34003f5c:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
34003f60:	b588      	push	{r3, r7, lr}
34003f62:	af00      	add	r7, sp, #0
  SystemCoreClockUpdate();
34003f64:	f7ff fe52 	bl	34003c0c <SystemCoreClockUpdate>

  return SystemCoreClock;
34003f68:	4b06      	ldr	r3, [pc, #24]	@ (34003f84 <__acle_se_SECURE_SystemCoreClockUpdate+0x28>)
34003f6a:	681b      	ldr	r3, [r3, #0]
}
34003f6c:	4618      	mov	r0, r3
34003f6e:	46bd      	mov	sp, r7
34003f70:	e8bd 4088 	ldmia.w	sp!, {r3, r7, lr}
34003f74:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
34003f78:	e89f 900e 	clrm	{r1, r2, r3, ip, APSR}
34003f7c:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
34003f80:	4774      	bxns	lr
34003f82:	bf00      	nop
34003f84:	34020c54 	.word	0x34020c54

34003f88 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
34003f88:	b580      	push	{r7, lr}
34003f8a:	af00      	add	r7, sp, #0
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
34003f8c:	2003      	movs	r0, #3
34003f8e:	f000 fb43 	bl	34004618 <HAL_NVIC_SetPriorityGrouping>

  /* Ensure time base clock coherency in SystemCoreClock global variable */
  SystemCoreClockUpdate();
34003f92:	f7ff fe3b 	bl	34003c0c <SystemCoreClockUpdate>

  /* Initialize 1ms tick time base (default SysTick based on HSI clock after Reset) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
34003f96:	200f      	movs	r0, #15
34003f98:	f000 f812 	bl	34003fc0 <HAL_InitTick>
34003f9c:	4603      	mov	r3, r0
34003f9e:	2b00      	cmp	r3, #0
34003fa0:	d001      	beq.n	34003fa6 <HAL_Init+0x1e>
  {
    return HAL_ERROR;
34003fa2:	2301      	movs	r3, #1
34003fa4:	e002      	b.n	34003fac <HAL_Init+0x24>
  }

  /* Init the low level hardware */
  HAL_MspInit();
34003fa6:	f000 f803 	bl	34003fb0 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
34003faa:	2300      	movs	r3, #0
}
34003fac:	4618      	mov	r0, r3
34003fae:	bd80      	pop	{r7, pc}

34003fb0 <HAL_MspInit>:
/**
  * @brief  Initializes the MSP.
  * @retval None
  */
__weak void HAL_MspInit(void)
{
34003fb0:	b480      	push	{r7}
34003fb2:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
34003fb4:	bf00      	nop
34003fb6:	46bd      	mov	sp, r7
34003fb8:	f85d 7b04 	ldr.w	r7, [sp], #4
34003fbc:	4770      	bx	lr
	...

34003fc0 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
34003fc0:	b580      	push	{r7, lr}
34003fc2:	b082      	sub	sp, #8
34003fc4:	af00      	add	r7, sp, #0
34003fc6:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
34003fc8:	4b15      	ldr	r3, [pc, #84]	@ (34004020 <HAL_InitTick+0x60>)
34003fca:	781b      	ldrb	r3, [r3, #0]
34003fcc:	2b00      	cmp	r3, #0
34003fce:	d101      	bne.n	34003fd4 <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
34003fd0:	2301      	movs	r3, #1
34003fd2:	e021      	b.n	34004018 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
34003fd4:	4b13      	ldr	r3, [pc, #76]	@ (34004024 <HAL_InitTick+0x64>)
34003fd6:	681a      	ldr	r2, [r3, #0]
34003fd8:	4b11      	ldr	r3, [pc, #68]	@ (34004020 <HAL_InitTick+0x60>)
34003fda:	781b      	ldrb	r3, [r3, #0]
34003fdc:	4619      	mov	r1, r3
34003fde:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
34003fe2:	fbb3 f3f1 	udiv	r3, r3, r1
34003fe6:	fbb2 f3f3 	udiv	r3, r2, r3
34003fea:	4618      	mov	r0, r3
34003fec:	f000 fba8 	bl	34004740 <HAL_SYSTICK_Config>
34003ff0:	4603      	mov	r3, r0
34003ff2:	2b00      	cmp	r3, #0
34003ff4:	d001      	beq.n	34003ffa <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
34003ff6:	2301      	movs	r3, #1
34003ff8:	e00e      	b.n	34004018 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
34003ffa:	687b      	ldr	r3, [r7, #4]
34003ffc:	2b0f      	cmp	r3, #15
34003ffe:	d80a      	bhi.n	34004016 <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
34004000:	2200      	movs	r2, #0
34004002:	6879      	ldr	r1, [r7, #4]
34004004:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
34004008:	f000 fb26 	bl	34004658 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
3400400c:	4a06      	ldr	r2, [pc, #24]	@ (34004028 <HAL_InitTick+0x68>)
3400400e:	687b      	ldr	r3, [r7, #4]
34004010:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
34004012:	2300      	movs	r3, #0
34004014:	e000      	b.n	34004018 <HAL_InitTick+0x58>
    return HAL_ERROR;
34004016:	2301      	movs	r3, #1
}
34004018:	4618      	mov	r0, r3
3400401a:	3708      	adds	r7, #8
3400401c:	46bd      	mov	sp, r7
3400401e:	bd80      	pop	{r7, pc}
34004020:	34020c5c 	.word	0x34020c5c
34004024:	34020c54 	.word	0x34020c54
34004028:	34020c58 	.word	0x34020c58

3400402c <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
3400402c:	b480      	push	{r7}
3400402e:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
34004030:	4b06      	ldr	r3, [pc, #24]	@ (3400404c <HAL_IncTick+0x20>)
34004032:	781b      	ldrb	r3, [r3, #0]
34004034:	461a      	mov	r2, r3
34004036:	4b06      	ldr	r3, [pc, #24]	@ (34004050 <HAL_IncTick+0x24>)
34004038:	681b      	ldr	r3, [r3, #0]
3400403a:	4413      	add	r3, r2
3400403c:	4a04      	ldr	r2, [pc, #16]	@ (34004050 <HAL_IncTick+0x24>)
3400403e:	6013      	str	r3, [r2, #0]
}
34004040:	bf00      	nop
34004042:	46bd      	mov	sp, r7
34004044:	f85d 7b04 	ldr.w	r7, [sp], #4
34004048:	4770      	bx	lr
3400404a:	bf00      	nop
3400404c:	34020c5c 	.word	0x34020c5c
34004050:	34021010 	.word	0x34021010

34004054 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
34004054:	b480      	push	{r7}
34004056:	af00      	add	r7, sp, #0
  return uwTick;
34004058:	4b03      	ldr	r3, [pc, #12]	@ (34004068 <HAL_GetTick+0x14>)
3400405a:	681b      	ldr	r3, [r3, #0]
}
3400405c:	4618      	mov	r0, r3
3400405e:	46bd      	mov	sp, r7
34004060:	f85d 7b04 	ldr.w	r7, [sp], #4
34004064:	4770      	bx	lr
34004066:	bf00      	nop
34004068:	34021010 	.word	0x34021010

3400406c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay Specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
3400406c:	b580      	push	{r7, lr}
3400406e:	b084      	sub	sp, #16
34004070:	af00      	add	r7, sp, #0
34004072:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
34004074:	f7ff ffee 	bl	34004054 <HAL_GetTick>
34004078:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
3400407a:	687b      	ldr	r3, [r7, #4]
3400407c:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
3400407e:	68fb      	ldr	r3, [r7, #12]
34004080:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
34004084:	d005      	beq.n	34004092 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
34004086:	4b0a      	ldr	r3, [pc, #40]	@ (340040b0 <HAL_Delay+0x44>)
34004088:	781b      	ldrb	r3, [r3, #0]
3400408a:	461a      	mov	r2, r3
3400408c:	68fb      	ldr	r3, [r7, #12]
3400408e:	4413      	add	r3, r2
34004090:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
34004092:	bf00      	nop
34004094:	f7ff ffde 	bl	34004054 <HAL_GetTick>
34004098:	4602      	mov	r2, r0
3400409a:	68bb      	ldr	r3, [r7, #8]
3400409c:	1ad3      	subs	r3, r2, r3
3400409e:	68fa      	ldr	r2, [r7, #12]
340040a0:	429a      	cmp	r2, r3
340040a2:	d8f7      	bhi.n	34004094 <HAL_Delay+0x28>
  {
  }
}
340040a4:	bf00      	nop
340040a6:	bf00      	nop
340040a8:	3710      	adds	r7, #16
340040aa:	46bd      	mov	sp, r7
340040ac:	bd80      	pop	{r7, pc}
340040ae:	bf00      	nop
340040b0:	34020c5c 	.word	0x34020c5c

340040b4 <HAL_BSEC_OTP_Read>:
  * @param  pFuseData  Returned value of fuse. The returned value is between 0 and 0xFFFFFFFFU
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_BSEC_OTP_Read(BSEC_HandleTypeDef * hbsec, uint32_t FuseId, uint32_t *pFuseData)
{
340040b4:	b580      	push	{r7, lr}
340040b6:	b084      	sub	sp, #16
340040b8:	af00      	add	r7, sp, #0
340040ba:	60f8      	str	r0, [r7, #12]
340040bc:	60b9      	str	r1, [r7, #8]
340040be:	607a      	str	r2, [r7, #4]
  /* Check the handle pointer */
  if (hbsec == NULL)
340040c0:	68fb      	ldr	r3, [r7, #12]
340040c2:	2b00      	cmp	r3, #0
340040c4:	d101      	bne.n	340040ca <HAL_BSEC_OTP_Read+0x16>
  {
    return HAL_ERROR;
340040c6:	2301      	movs	r3, #1
340040c8:	e026      	b.n	34004118 <HAL_BSEC_OTP_Read+0x64>
  }

  /* Check the address of returned value and instance */
 if ((pFuseData == NULL) || (hbsec->Instance != BSEC))
340040ca:	687b      	ldr	r3, [r7, #4]
340040cc:	2b00      	cmp	r3, #0
340040ce:	d004      	beq.n	340040da <HAL_BSEC_OTP_Read+0x26>
340040d0:	68fb      	ldr	r3, [r7, #12]
340040d2:	681b      	ldr	r3, [r3, #0]
340040d4:	4a12      	ldr	r2, [pc, #72]	@ (34004120 <HAL_BSEC_OTP_Read+0x6c>)
340040d6:	4293      	cmp	r3, r2
340040d8:	d004      	beq.n	340040e4 <HAL_BSEC_OTP_Read+0x30>
  {
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
340040da:	68fb      	ldr	r3, [r7, #12]
340040dc:	2201      	movs	r2, #1
340040de:	605a      	str	r2, [r3, #4]
    return HAL_ERROR;
340040e0:	2301      	movs	r3, #1
340040e2:	e019      	b.n	34004118 <HAL_BSEC_OTP_Read+0x64>
  }

  if (FuseId < BSEC_NB_FUSES)
340040e4:	68bb      	ldr	r3, [r7, #8]
340040e6:	f5b3 7fbc 	cmp.w	r3, #376	@ 0x178
340040ea:	d211      	bcs.n	34004110 <HAL_BSEC_OTP_Read+0x5c>
  {
    /* Reload the data :
       - Unshadowed fuse are not automatically reload and data no more available after register read
       - Shadowed fuse contains by default the shadow value in the register */
    if (HAL_BSEC_OTP_Reload(hbsec, FuseId) == HAL_OK)
340040ec:	68b9      	ldr	r1, [r7, #8]
340040ee:	68f8      	ldr	r0, [r7, #12]
340040f0:	f000 f8ba 	bl	34004268 <HAL_BSEC_OTP_Reload>
340040f4:	4603      	mov	r3, r0
340040f6:	2b00      	cmp	r3, #0
340040f8:	d108      	bne.n	3400410c <HAL_BSEC_OTP_Read+0x58>
    {
      /* Read data from shadow register */
      *pFuseData = hbsec->Instance->FVRw[FuseId];
340040fa:	68fb      	ldr	r3, [r7, #12]
340040fc:	681b      	ldr	r3, [r3, #0]
340040fe:	68ba      	ldr	r2, [r7, #8]
34004100:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
34004104:	687b      	ldr	r3, [r7, #4]
34004106:	601a      	str	r2, [r3, #0]
  {
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
    return HAL_ERROR;
  }

  return HAL_OK;
34004108:	2300      	movs	r3, #0
3400410a:	e005      	b.n	34004118 <HAL_BSEC_OTP_Read+0x64>
      return HAL_ERROR;
3400410c:	2301      	movs	r3, #1
3400410e:	e003      	b.n	34004118 <HAL_BSEC_OTP_Read+0x64>
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
34004110:	68fb      	ldr	r3, [r7, #12]
34004112:	2201      	movs	r2, #1
34004114:	605a      	str	r2, [r3, #4]
    return HAL_ERROR;
34004116:	2301      	movs	r3, #1
}
34004118:	4618      	mov	r0, r3
3400411a:	3710      	adds	r7, #16
3400411c:	46bd      	mov	sp, r7
3400411e:	bd80      	pop	{r7, pc}
34004120:	56009000 	.word	0x56009000

34004124 <HAL_BSEC_OTP_Program>:
  * @param  Lock      Permanent lock value, this parameter is @ref BSEC_Permanent_Lock
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_BSEC_OTP_Program(BSEC_HandleTypeDef *hbsec, uint32_t FuseId, uint32_t FuseData, uint32_t Lock)
{
34004124:	b580      	push	{r7, lr}
34004126:	b088      	sub	sp, #32
34004128:	af00      	add	r7, sp, #0
3400412a:	60f8      	str	r0, [r7, #12]
3400412c:	60b9      	str	r1, [r7, #8]
3400412e:	607a      	str	r2, [r7, #4]
34004130:	603b      	str	r3, [r7, #0]
  uint32_t status_reg;
  uint32_t status_bit;
  uint32_t read_data;
  uint32_t tick_start = HAL_GetTick();
34004132:	f7ff ff8f 	bl	34004054 <HAL_GetTick>
34004136:	61f8      	str	r0, [r7, #28]

  /* Check the handle pointer */
  if (hbsec == NULL)
34004138:	68fb      	ldr	r3, [r7, #12]
3400413a:	2b00      	cmp	r3, #0
3400413c:	d101      	bne.n	34004142 <HAL_BSEC_OTP_Program+0x1e>
  {
    return HAL_ERROR;
3400413e:	2301      	movs	r3, #1
34004140:	e08a      	b.n	34004258 <HAL_BSEC_OTP_Program+0x134>
  }

  /* Check the instance */
 if (hbsec->Instance != BSEC)
34004142:	68fb      	ldr	r3, [r7, #12]
34004144:	681b      	ldr	r3, [r3, #0]
34004146:	4a46      	ldr	r2, [pc, #280]	@ (34004260 <HAL_BSEC_OTP_Program+0x13c>)
34004148:	4293      	cmp	r3, r2
3400414a:	d004      	beq.n	34004156 <HAL_BSEC_OTP_Program+0x32>
  {
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
3400414c:	68fb      	ldr	r3, [r7, #12]
3400414e:	2201      	movs	r2, #1
34004150:	605a      	str	r2, [r3, #4]
    return HAL_ERROR;
34004152:	2301      	movs	r3, #1
34004154:	e080      	b.n	34004258 <HAL_BSEC_OTP_Program+0x134>
  }

  /* Check the permanent lock */
  assert_param(IS_BSEC_PERMANENT_LOCK(Lock));
34004156:	683b      	ldr	r3, [r7, #0]
34004158:	2b00      	cmp	r3, #0
3400415a:	d008      	beq.n	3400416e <HAL_BSEC_OTP_Program+0x4a>
3400415c:	683b      	ldr	r3, [r7, #0]
3400415e:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34004162:	d004      	beq.n	3400416e <HAL_BSEC_OTP_Program+0x4a>
34004164:	f44f 71dd 	mov.w	r1, #442	@ 0x1ba
34004168:	483e      	ldr	r0, [pc, #248]	@ (34004264 <HAL_BSEC_OTP_Program+0x140>)
3400416a:	f7fd ff51 	bl	34002010 <assert_failed>

  /* Get the correct register value */
  if (FuseId < BSEC_NB_FUSES)
3400416e:	68bb      	ldr	r3, [r7, #8]
34004170:	f5b3 7fbc 	cmp.w	r3, #376	@ 0x178
34004174:	d26a      	bcs.n	3400424c <HAL_BSEC_OTP_Program+0x128>
  {
    status_reg = FuseId / 32U;
34004176:	68bb      	ldr	r3, [r7, #8]
34004178:	095b      	lsrs	r3, r3, #5
3400417a:	61bb      	str	r3, [r7, #24]
    status_bit = (uint32_t)(1UL << (FuseId % 32U));
3400417c:	68bb      	ldr	r3, [r7, #8]
3400417e:	f003 031f 	and.w	r3, r3, #31
34004182:	2201      	movs	r2, #1
34004184:	fa02 f303 	lsl.w	r3, r2, r3
34004188:	617b      	str	r3, [r7, #20]

    if ((hbsec->Instance->SPLOCKx[status_reg] & status_bit) == 0U)
3400418a:	68fb      	ldr	r3, [r7, #12]
3400418c:	681b      	ldr	r3, [r3, #0]
3400418e:	69ba      	ldr	r2, [r7, #24]
34004190:	f502 7200 	add.w	r2, r2, #512	@ 0x200
34004194:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
34004198:	697b      	ldr	r3, [r7, #20]
3400419a:	4013      	ands	r3, r2
3400419c:	2b00      	cmp	r3, #0
3400419e:	d150      	bne.n	34004242 <HAL_BSEC_OTP_Program+0x11e>
    {
      /* Write data in register */
      hbsec->Instance->WDR = FuseData;
340041a0:	68fb      	ldr	r3, [r7, #12]
340041a2:	681b      	ldr	r3, [r3, #0]
340041a4:	687a      	ldr	r2, [r7, #4]
340041a6:	f8c3 2c08 	str.w	r2, [r3, #3080]	@ 0xc08

      /* Perform a program of the fuse register */
      MODIFY_REG(hbsec->Instance->OTPCR, (BSEC_OTPCR_PPLOCK | BSEC_OTPCR_PROG | BSEC_OTPCR_ADDR),
340041aa:	68fb      	ldr	r3, [r7, #12]
340041ac:	681b      	ldr	r3, [r3, #0]
340041ae:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	@ 0xc04
340041b2:	f423 43c3 	bic.w	r3, r3, #24960	@ 0x6180
340041b6:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
340041ba:	68b9      	ldr	r1, [r7, #8]
340041bc:	683a      	ldr	r2, [r7, #0]
340041be:	430a      	orrs	r2, r1
340041c0:	431a      	orrs	r2, r3
340041c2:	68fb      	ldr	r3, [r7, #12]
340041c4:	681b      	ldr	r3, [r3, #0]
340041c6:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
340041ca:	f8c3 2c04 	str.w	r2, [r3, #3076]	@ 0xc04
                                         (FuseId | BSEC_OTPCR_PROG | Lock));

      /* Wait the operation is finished */
      while ((hbsec->Instance->OTPSR & BSEC_OTPSR_BUSY) != 0U)
340041ce:	e00c      	b.n	340041ea <HAL_BSEC_OTP_Program+0xc6>
      {
        if ((HAL_GetTick() - tick_start) > BSEC_TIMEOUT)
340041d0:	f7ff ff40 	bl	34004054 <HAL_GetTick>
340041d4:	4602      	mov	r2, r0
340041d6:	69fb      	ldr	r3, [r7, #28]
340041d8:	1ad3      	subs	r3, r2, r3
340041da:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
340041de:	d904      	bls.n	340041ea <HAL_BSEC_OTP_Program+0xc6>
        {
          hbsec->ErrorCode = HAL_BSEC_ERROR_TIMEOUT;
340041e0:	68fb      	ldr	r3, [r7, #12]
340041e2:	220a      	movs	r2, #10
340041e4:	605a      	str	r2, [r3, #4]
          return HAL_ERROR;
340041e6:	2301      	movs	r3, #1
340041e8:	e036      	b.n	34004258 <HAL_BSEC_OTP_Program+0x134>
      while ((hbsec->Instance->OTPSR & BSEC_OTPSR_BUSY) != 0U)
340041ea:	68fb      	ldr	r3, [r7, #12]
340041ec:	681b      	ldr	r3, [r3, #0]
340041ee:	f8d3 3e44 	ldr.w	r3, [r3, #3652]	@ 0xe44
340041f2:	f003 0301 	and.w	r3, r3, #1
340041f6:	2b00      	cmp	r3, #0
340041f8:	d1ea      	bne.n	340041d0 <HAL_BSEC_OTP_Program+0xac>
        }
      }

      /* Check programming errors */
      if ((hbsec->Instance->OTPSR & BSEC_OTPSR_PROGFAIL) != 0U)
340041fa:	68fb      	ldr	r3, [r7, #12]
340041fc:	681b      	ldr	r3, [r3, #0]
340041fe:	f8d3 3e44 	ldr.w	r3, [r3, #3652]	@ 0xe44
34004202:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34004206:	2b00      	cmp	r3, #0
34004208:	d005      	beq.n	34004216 <HAL_BSEC_OTP_Program+0xf2>
      {
        hbsec->ErrorCode = HAL_BSEC_ERROR_PROGFAIL;
3400420a:	68fb      	ldr	r3, [r7, #12]
3400420c:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34004210:	605a      	str	r2, [r3, #4]
        return HAL_ERROR;
34004212:	2301      	movs	r3, #1
34004214:	e020      	b.n	34004258 <HAL_BSEC_OTP_Program+0x134>
      }

      /* Read back programmed data */
      if (HAL_BSEC_OTP_Read(hbsec, FuseId, &read_data) == HAL_OK)
34004216:	f107 0310 	add.w	r3, r7, #16
3400421a:	461a      	mov	r2, r3
3400421c:	68b9      	ldr	r1, [r7, #8]
3400421e:	68f8      	ldr	r0, [r7, #12]
34004220:	f7ff ff48 	bl	340040b4 <HAL_BSEC_OTP_Read>
34004224:	4603      	mov	r3, r0
34004226:	2b00      	cmp	r3, #0
34004228:	d109      	bne.n	3400423e <HAL_BSEC_OTP_Program+0x11a>
      {
        /* Verify programmed data */
        if (read_data != FuseData)
3400422a:	693b      	ldr	r3, [r7, #16]
3400422c:	687a      	ldr	r2, [r7, #4]
3400422e:	429a      	cmp	r2, r3
34004230:	d011      	beq.n	34004256 <HAL_BSEC_OTP_Program+0x132>
        {
          hbsec->ErrorCode = HAL_BSEC_ERROR_PROGFAIL;
34004232:	68fb      	ldr	r3, [r7, #12]
34004234:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34004238:	605a      	str	r2, [r3, #4]
          return HAL_ERROR;
3400423a:	2301      	movs	r3, #1
3400423c:	e00c      	b.n	34004258 <HAL_BSEC_OTP_Program+0x134>
        }
      }
      else
      {
        return HAL_ERROR;
3400423e:	2301      	movs	r3, #1
34004240:	e00a      	b.n	34004258 <HAL_BSEC_OTP_Program+0x134>
      }
    }
    else
    {
      /* Fuse is sticky programming locked */
      hbsec->ErrorCode = HAL_BSEC_ERROR_LOCK;
34004242:	68fb      	ldr	r3, [r7, #12]
34004244:	2204      	movs	r2, #4
34004246:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
34004248:	2301      	movs	r3, #1
3400424a:	e005      	b.n	34004258 <HAL_BSEC_OTP_Program+0x134>
    }
  }
  else
  {
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
3400424c:	68fb      	ldr	r3, [r7, #12]
3400424e:	2201      	movs	r2, #1
34004250:	605a      	str	r2, [r3, #4]
    return HAL_ERROR;
34004252:	2301      	movs	r3, #1
34004254:	e000      	b.n	34004258 <HAL_BSEC_OTP_Program+0x134>
  }

  return HAL_OK;
34004256:	2300      	movs	r3, #0
}
34004258:	4618      	mov	r0, r3
3400425a:	3720      	adds	r7, #32
3400425c:	46bd      	mov	sp, r7
3400425e:	bd80      	pop	{r7, pc}
34004260:	56009000 	.word	0x56009000
34004264:	3401e904 	.word	0x3401e904

34004268 <HAL_BSEC_OTP_Reload>:
  * @param  FuseId  Fuse to be reload, this parameter value is between 0 and BSEC_NB_FUSES-1
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_BSEC_OTP_Reload(BSEC_HandleTypeDef *hbsec, uint32_t FuseId)
{
34004268:	b580      	push	{r7, lr}
3400426a:	b086      	sub	sp, #24
3400426c:	af00      	add	r7, sp, #0
3400426e:	6078      	str	r0, [r7, #4]
34004270:	6039      	str	r1, [r7, #0]
  uint32_t status_reg;
  uint32_t status_bit;
  uint32_t tick_start = HAL_GetTick();
34004272:	f7ff feef 	bl	34004054 <HAL_GetTick>
34004276:	6178      	str	r0, [r7, #20]

  /* Check the handle pointer */
  if (hbsec == NULL)
34004278:	687b      	ldr	r3, [r7, #4]
3400427a:	2b00      	cmp	r3, #0
3400427c:	d101      	bne.n	34004282 <HAL_BSEC_OTP_Reload+0x1a>
  {
    return HAL_ERROR;
3400427e:	2301      	movs	r3, #1
34004280:	e063      	b.n	3400434a <HAL_BSEC_OTP_Reload+0xe2>
  }

  /* Check the instance */
 if (hbsec->Instance != BSEC)
34004282:	687b      	ldr	r3, [r7, #4]
34004284:	681b      	ldr	r3, [r3, #0]
34004286:	4a33      	ldr	r2, [pc, #204]	@ (34004354 <HAL_BSEC_OTP_Reload+0xec>)
34004288:	4293      	cmp	r3, r2
3400428a:	d004      	beq.n	34004296 <HAL_BSEC_OTP_Reload+0x2e>
  {
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
3400428c:	687b      	ldr	r3, [r7, #4]
3400428e:	2201      	movs	r2, #1
34004290:	605a      	str	r2, [r3, #4]
    return HAL_ERROR;
34004292:	2301      	movs	r3, #1
34004294:	e059      	b.n	3400434a <HAL_BSEC_OTP_Reload+0xe2>
  }

  if (FuseId < BSEC_NB_FUSES)
34004296:	683b      	ldr	r3, [r7, #0]
34004298:	f5b3 7fbc 	cmp.w	r3, #376	@ 0x178
3400429c:	d24f      	bcs.n	3400433e <HAL_BSEC_OTP_Reload+0xd6>
  {
    status_reg = FuseId / 32U;
3400429e:	683b      	ldr	r3, [r7, #0]
340042a0:	095b      	lsrs	r3, r3, #5
340042a2:	613b      	str	r3, [r7, #16]
    status_bit = (uint32_t)(1UL << (FuseId % 32U));
340042a4:	683b      	ldr	r3, [r7, #0]
340042a6:	f003 031f 	and.w	r3, r3, #31
340042aa:	2201      	movs	r2, #1
340042ac:	fa02 f303 	lsl.w	r3, r2, r3
340042b0:	60fb      	str	r3, [r7, #12]

    if ((hbsec->Instance->SRLOCKx[status_reg] & status_bit) == 0U)
340042b2:	687b      	ldr	r3, [r7, #4]
340042b4:	681b      	ldr	r3, [r3, #0]
340042b6:	693a      	ldr	r2, [r7, #16]
340042b8:	f502 7208 	add.w	r2, r2, #544	@ 0x220
340042bc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
340042c0:	68fb      	ldr	r3, [r7, #12]
340042c2:	4013      	ands	r3, r2
340042c4:	2b00      	cmp	r3, #0
340042c6:	d135      	bne.n	34004334 <HAL_BSEC_OTP_Reload+0xcc>
    {
      /* Perform a reload of the fuse register */
      MODIFY_REG(hbsec->Instance->OTPCR, (BSEC_OTPCR_PPLOCK | BSEC_OTPCR_PROG | BSEC_OTPCR_ADDR), FuseId);
340042c8:	687b      	ldr	r3, [r7, #4]
340042ca:	681b      	ldr	r3, [r3, #0]
340042cc:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	@ 0xc04
340042d0:	f423 43c3 	bic.w	r3, r3, #24960	@ 0x6180
340042d4:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
340042d8:	687a      	ldr	r2, [r7, #4]
340042da:	6812      	ldr	r2, [r2, #0]
340042dc:	6839      	ldr	r1, [r7, #0]
340042de:	430b      	orrs	r3, r1
340042e0:	f8c2 3c04 	str.w	r3, [r2, #3076]	@ 0xc04

      /* Wait the operation is finished */
      while ((hbsec->Instance->OTPSR & BSEC_OTPSR_BUSY) != 0U)
340042e4:	e00c      	b.n	34004300 <HAL_BSEC_OTP_Reload+0x98>
      {
        if ((HAL_GetTick() - tick_start) > BSEC_TIMEOUT)
340042e6:	f7ff feb5 	bl	34004054 <HAL_GetTick>
340042ea:	4602      	mov	r2, r0
340042ec:	697b      	ldr	r3, [r7, #20]
340042ee:	1ad3      	subs	r3, r2, r3
340042f0:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
340042f4:	d904      	bls.n	34004300 <HAL_BSEC_OTP_Reload+0x98>
        {
          hbsec->ErrorCode = HAL_BSEC_ERROR_TIMEOUT;
340042f6:	687b      	ldr	r3, [r7, #4]
340042f8:	220a      	movs	r2, #10
340042fa:	605a      	str	r2, [r3, #4]
          return HAL_ERROR;
340042fc:	2301      	movs	r3, #1
340042fe:	e024      	b.n	3400434a <HAL_BSEC_OTP_Reload+0xe2>
      while ((hbsec->Instance->OTPSR & BSEC_OTPSR_BUSY) != 0U)
34004300:	687b      	ldr	r3, [r7, #4]
34004302:	681b      	ldr	r3, [r3, #0]
34004304:	f8d3 3e44 	ldr.w	r3, [r3, #3652]	@ 0xe44
34004308:	f003 0301 	and.w	r3, r3, #1
3400430c:	2b00      	cmp	r3, #0
3400430e:	d1ea      	bne.n	340042e6 <HAL_BSEC_OTP_Reload+0x7e>
        }
      }

      if ((hbsec->Instance->OTPSR & BSEC_OTPSR_RELOAD_ERRORS) != 0U)
34004310:	687b      	ldr	r3, [r7, #4]
34004312:	681b      	ldr	r3, [r3, #0]
34004314:	f8d3 3e44 	ldr.w	r3, [r3, #3652]	@ 0xe44
34004318:	f403 038c 	and.w	r3, r3, #4587520	@ 0x460000
3400431c:	2b00      	cmp	r3, #0
3400431e:	d013      	beq.n	34004348 <HAL_BSEC_OTP_Reload+0xe0>
      {
        /* An error occurred during reloading, value can't be relied on */
        hbsec->ErrorCode = (hbsec->Instance->OTPSR & BSEC_OTPSR_RELOAD_ERRORS);
34004320:	687b      	ldr	r3, [r7, #4]
34004322:	681b      	ldr	r3, [r3, #0]
34004324:	f8d3 3e44 	ldr.w	r3, [r3, #3652]	@ 0xe44
34004328:	f403 028c 	and.w	r2, r3, #4587520	@ 0x460000
3400432c:	687b      	ldr	r3, [r7, #4]
3400432e:	605a      	str	r2, [r3, #4]
        return HAL_ERROR;
34004330:	2301      	movs	r3, #1
34004332:	e00a      	b.n	3400434a <HAL_BSEC_OTP_Reload+0xe2>
      }
    }
    else
    {
      /* Shadow register is sticky reload locked */
      hbsec->ErrorCode = HAL_BSEC_ERROR_LOCK;
34004334:	687b      	ldr	r3, [r7, #4]
34004336:	2204      	movs	r2, #4
34004338:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
3400433a:	2301      	movs	r3, #1
3400433c:	e005      	b.n	3400434a <HAL_BSEC_OTP_Reload+0xe2>
    }
  }
  else
  {
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
3400433e:	687b      	ldr	r3, [r7, #4]
34004340:	2201      	movs	r2, #1
34004342:	605a      	str	r2, [r3, #4]
    return HAL_ERROR;
34004344:	2301      	movs	r3, #1
34004346:	e000      	b.n	3400434a <HAL_BSEC_OTP_Reload+0xe2>
  }

  return HAL_OK;
34004348:	2300      	movs	r3, #0
}
3400434a:	4618      	mov	r0, r3
3400434c:	3718      	adds	r7, #24
3400434e:	46bd      	mov	sp, r7
34004350:	bd80      	pop	{r7, pc}
34004352:	bf00      	nop
34004354:	56009000 	.word	0x56009000

34004358 <HAL_CACHEAXI_Init>:
  * @note   In case HAL_CACHEAXI_Init() returns HAL_BUSY because an invalidation
  *         procedure is ongoing, the application should call again HAL_CACHEAXI_Init()
  *         until it returns HAL_OK to have the CACHEAXI enabled
  */
HAL_StatusTypeDef  HAL_CACHEAXI_Init(CACHEAXI_HandleTypeDef *hcacheaxi)
{
34004358:	b580      	push	{r7, lr}
3400435a:	b084      	sub	sp, #16
3400435c:	af00      	add	r7, sp, #0
3400435e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status;

  /* Check the CACHEAXI handle allocation */
  if (hcacheaxi == NULL)
34004360:	687b      	ldr	r3, [r7, #4]
34004362:	2b00      	cmp	r3, #0
34004364:	d101      	bne.n	3400436a <HAL_CACHEAXI_Init+0x12>
  {
    return HAL_ERROR;
34004366:	2301      	movs	r3, #1
34004368:	e021      	b.n	340043ae <HAL_CACHEAXI_Init+0x56>
  }

  /* Check the parameters */
  assert_param(IS_CACHEAXI_ALL_INSTANCE(hcacheaxi->Instance));
3400436a:	687b      	ldr	r3, [r7, #4]
3400436c:	681b      	ldr	r3, [r3, #0]
3400436e:	4a12      	ldr	r2, [pc, #72]	@ (340043b8 <HAL_CACHEAXI_Init+0x60>)
34004370:	4293      	cmp	r3, r2
34004372:	d008      	beq.n	34004386 <HAL_CACHEAXI_Init+0x2e>
34004374:	687b      	ldr	r3, [r7, #4]
34004376:	681b      	ldr	r3, [r3, #0]
34004378:	4a10      	ldr	r2, [pc, #64]	@ (340043bc <HAL_CACHEAXI_Init+0x64>)
3400437a:	4293      	cmp	r3, r2
3400437c:	d003      	beq.n	34004386 <HAL_CACHEAXI_Init+0x2e>
3400437e:	21bc      	movs	r1, #188	@ 0xbc
34004380:	480f      	ldr	r0, [pc, #60]	@ (340043c0 <HAL_CACHEAXI_Init+0x68>)
34004382:	f7fd fe45 	bl	34002010 <assert_failed>

  if (hcacheaxi->State == HAL_CACHEAXI_STATE_RESET)
34004386:	687b      	ldr	r3, [r7, #4]
34004388:	791b      	ldrb	r3, [r3, #4]
3400438a:	b2db      	uxtb	r3, r3
3400438c:	2b00      	cmp	r3, #0
3400438e:	d102      	bne.n	34004396 <HAL_CACHEAXI_Init+0x3e>

    /* Init the low level hardware */
    hcacheaxi->MspInitCallback(hcacheaxi);
#else
    /* Init the low level hardware */
    HAL_CACHEAXI_MspInit(hcacheaxi);
34004390:	6878      	ldr	r0, [r7, #4]
34004392:	f7fd fe25 	bl	34001fe0 <HAL_CACHEAXI_MspInit>
#endif /* USE_HAL_CACHEAXI_REGISTER_CALLBACKS */
  }

  /* Init the error code */
  hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
34004396:	687b      	ldr	r3, [r7, #4]
34004398:	2200      	movs	r2, #0
3400439a:	609a      	str	r2, [r3, #8]

  /* Init the CACHEAXI handle state */
  hcacheaxi->State = HAL_CACHEAXI_STATE_READY;
3400439c:	687b      	ldr	r3, [r7, #4]
3400439e:	2201      	movs	r2, #1
340043a0:	711a      	strb	r2, [r3, #4]

  /* Enable the selected CACHEAXI peripheral */
  status = HAL_CACHEAXI_Enable(hcacheaxi);
340043a2:	6878      	ldr	r0, [r7, #4]
340043a4:	f000 f80e 	bl	340043c4 <HAL_CACHEAXI_Enable>
340043a8:	4603      	mov	r3, r0
340043aa:	73fb      	strb	r3, [r7, #15]

  return status;
340043ac:	7bfb      	ldrb	r3, [r7, #15]
}
340043ae:	4618      	mov	r0, r3
340043b0:	3710      	adds	r7, #16
340043b2:	46bd      	mov	sp, r7
340043b4:	bd80      	pop	{r7, pc}
340043b6:	bf00      	nop
340043b8:	580dfc00 	.word	0x580dfc00
340043bc:	480dfc00 	.word	0x480dfc00
340043c0:	3401e9b0 	.word	0x3401e9b0

340043c4 <HAL_CACHEAXI_Enable>:
  * @param  hcacheaxi Pointer to a CACHEAXI_HandleTypeDef structure that contains
  *                   the configuration information for the specified CACHEAXIx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CACHEAXI_Enable(CACHEAXI_HandleTypeDef *hcacheaxi)
{
340043c4:	b580      	push	{r7, lr}
340043c6:	b084      	sub	sp, #16
340043c8:	af00      	add	r7, sp, #0
340043ca:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
340043cc:	2300      	movs	r3, #0
340043ce:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart;

  /* Check the cacheaxi handle allocation */
  if (hcacheaxi == NULL)
340043d0:	687b      	ldr	r3, [r7, #4]
340043d2:	2b00      	cmp	r3, #0
340043d4:	d101      	bne.n	340043da <HAL_CACHEAXI_Enable+0x16>
  {
    return HAL_ERROR;
340043d6:	2301      	movs	r3, #1
340043d8:	e043      	b.n	34004462 <HAL_CACHEAXI_Enable+0x9e>
  }

  /* Check the parameters */
  assert_param(IS_CACHEAXI_ALL_INSTANCE(hcacheaxi->Instance));
340043da:	687b      	ldr	r3, [r7, #4]
340043dc:	681b      	ldr	r3, [r3, #0]
340043de:	4a23      	ldr	r2, [pc, #140]	@ (3400446c <HAL_CACHEAXI_Enable+0xa8>)
340043e0:	4293      	cmp	r3, r2
340043e2:	d009      	beq.n	340043f8 <HAL_CACHEAXI_Enable+0x34>
340043e4:	687b      	ldr	r3, [r7, #4]
340043e6:	681b      	ldr	r3, [r3, #0]
340043e8:	4a21      	ldr	r2, [pc, #132]	@ (34004470 <HAL_CACHEAXI_Enable+0xac>)
340043ea:	4293      	cmp	r3, r2
340043ec:	d004      	beq.n	340043f8 <HAL_CACHEAXI_Enable+0x34>
340043ee:	f44f 71b5 	mov.w	r1, #362	@ 0x16a
340043f2:	4820      	ldr	r0, [pc, #128]	@ (34004474 <HAL_CACHEAXI_Enable+0xb0>)
340043f4:	f7fd fe0c 	bl	34002010 <assert_failed>

  /* Check if ongoing full invalidation operation */
  if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
340043f8:	687b      	ldr	r3, [r7, #4]
340043fa:	681b      	ldr	r3, [r3, #0]
340043fc:	685b      	ldr	r3, [r3, #4]
340043fe:	f003 0301 	and.w	r3, r3, #1
34004402:	2b00      	cmp	r3, #0
34004404:	d01e      	beq.n	34004444 <HAL_CACHEAXI_Enable+0x80>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
34004406:	f7ff fe25 	bl	34004054 <HAL_GetTick>
3400440a:	60b8      	str	r0, [r7, #8]

    while (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
3400440c:	e013      	b.n	34004436 <HAL_CACHEAXI_Enable+0x72>
    {
      if ((HAL_GetTick() - tickstart) > CACHEAXI_ENABLE_TIMEOUT_VALUE)
3400440e:	f7ff fe21 	bl	34004054 <HAL_GetTick>
34004412:	4602      	mov	r2, r0
34004414:	68bb      	ldr	r3, [r7, #8]
34004416:	1ad3      	subs	r3, r2, r3
34004418:	2b01      	cmp	r3, #1
3400441a:	d90c      	bls.n	34004436 <HAL_CACHEAXI_Enable+0x72>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) == 0U)
3400441c:	687b      	ldr	r3, [r7, #4]
3400441e:	681b      	ldr	r3, [r3, #0]
34004420:	685b      	ldr	r3, [r3, #4]
34004422:	f003 0301 	and.w	r3, r3, #1
34004426:	2b00      	cmp	r3, #0
34004428:	d105      	bne.n	34004436 <HAL_CACHEAXI_Enable+0x72>
        {
          /* Update error code */
          hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_TIMEOUT;
3400442a:	687b      	ldr	r3, [r7, #4]
3400442c:	2210      	movs	r2, #16
3400442e:	609a      	str	r2, [r3, #8]
          /* Return error status */
          status =  HAL_ERROR;
34004430:	2301      	movs	r3, #1
34004432:	73fb      	strb	r3, [r7, #15]
          break;
34004434:	e006      	b.n	34004444 <HAL_CACHEAXI_Enable+0x80>
    while (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
34004436:	687b      	ldr	r3, [r7, #4]
34004438:	681b      	ldr	r3, [r3, #0]
3400443a:	685b      	ldr	r3, [r3, #4]
3400443c:	f003 0301 	and.w	r3, r3, #1
34004440:	2b00      	cmp	r3, #0
34004442:	d1e4      	bne.n	3400440e <HAL_CACHEAXI_Enable+0x4a>
        }
      }
    }
  }

  if (status == HAL_OK)
34004444:	7bfb      	ldrb	r3, [r7, #15]
34004446:	2b00      	cmp	r3, #0
34004448:	d10a      	bne.n	34004460 <HAL_CACHEAXI_Enable+0x9c>
  {
    /* Update the error code */
    hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
3400444a:	687b      	ldr	r3, [r7, #4]
3400444c:	2200      	movs	r2, #0
3400444e:	609a      	str	r2, [r3, #8]
    /* Enable the selected CACHEAXI peripheral */
    SET_BIT(hcacheaxi->Instance->CR1, CACHEAXI_CR1_EN);
34004450:	687b      	ldr	r3, [r7, #4]
34004452:	681b      	ldr	r3, [r3, #0]
34004454:	681a      	ldr	r2, [r3, #0]
34004456:	687b      	ldr	r3, [r7, #4]
34004458:	681b      	ldr	r3, [r3, #0]
3400445a:	f042 0201 	orr.w	r2, r2, #1
3400445e:	601a      	str	r2, [r3, #0]
  }

  return status;
34004460:	7bfb      	ldrb	r3, [r7, #15]
}
34004462:	4618      	mov	r0, r3
34004464:	3710      	adds	r7, #16
34004466:	46bd      	mov	sp, r7
34004468:	bd80      	pop	{r7, pc}
3400446a:	bf00      	nop
3400446c:	580dfc00 	.word	0x580dfc00
34004470:	480dfc00 	.word	0x480dfc00
34004474:	3401e9b0 	.word	0x3401e9b0

34004478 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
34004478:	b480      	push	{r7}
3400447a:	b085      	sub	sp, #20
3400447c:	af00      	add	r7, sp, #0
3400447e:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
34004480:	687b      	ldr	r3, [r7, #4]
34004482:	f003 0307 	and.w	r3, r3, #7
34004486:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
34004488:	4b0c      	ldr	r3, [pc, #48]	@ (340044bc <__NVIC_SetPriorityGrouping+0x44>)
3400448a:	68db      	ldr	r3, [r3, #12]
3400448c:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
3400448e:	68ba      	ldr	r2, [r7, #8]
34004490:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
34004494:	4013      	ands	r3, r2
34004496:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
34004498:	68fb      	ldr	r3, [r7, #12]
3400449a:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
3400449c:	68bb      	ldr	r3, [r7, #8]
3400449e:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
340044a0:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
340044a4:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
340044a8:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
340044aa:	4a04      	ldr	r2, [pc, #16]	@ (340044bc <__NVIC_SetPriorityGrouping+0x44>)
340044ac:	68bb      	ldr	r3, [r7, #8]
340044ae:	60d3      	str	r3, [r2, #12]
}
340044b0:	bf00      	nop
340044b2:	3714      	adds	r7, #20
340044b4:	46bd      	mov	sp, r7
340044b6:	f85d 7b04 	ldr.w	r7, [sp], #4
340044ba:	4770      	bx	lr
340044bc:	e000ed00 	.word	0xe000ed00

340044c0 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
340044c0:	b480      	push	{r7}
340044c2:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
340044c4:	4b04      	ldr	r3, [pc, #16]	@ (340044d8 <__NVIC_GetPriorityGrouping+0x18>)
340044c6:	68db      	ldr	r3, [r3, #12]
340044c8:	0a1b      	lsrs	r3, r3, #8
340044ca:	f003 0307 	and.w	r3, r3, #7
}
340044ce:	4618      	mov	r0, r3
340044d0:	46bd      	mov	sp, r7
340044d2:	f85d 7b04 	ldr.w	r7, [sp], #4
340044d6:	4770      	bx	lr
340044d8:	e000ed00 	.word	0xe000ed00

340044dc <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
340044dc:	b480      	push	{r7}
340044de:	b083      	sub	sp, #12
340044e0:	af00      	add	r7, sp, #0
340044e2:	4603      	mov	r3, r0
340044e4:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
340044e6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
340044ea:	2b00      	cmp	r3, #0
340044ec:	db0b      	blt.n	34004506 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
340044ee:	88fb      	ldrh	r3, [r7, #6]
340044f0:	f003 021f 	and.w	r2, r3, #31
340044f4:	4907      	ldr	r1, [pc, #28]	@ (34004514 <__NVIC_EnableIRQ+0x38>)
340044f6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
340044fa:	095b      	lsrs	r3, r3, #5
340044fc:	2001      	movs	r0, #1
340044fe:	fa00 f202 	lsl.w	r2, r0, r2
34004502:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
34004506:	bf00      	nop
34004508:	370c      	adds	r7, #12
3400450a:	46bd      	mov	sp, r7
3400450c:	f85d 7b04 	ldr.w	r7, [sp], #4
34004510:	4770      	bx	lr
34004512:	bf00      	nop
34004514:	e000e100 	.word	0xe000e100

34004518 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
34004518:	b480      	push	{r7}
3400451a:	b083      	sub	sp, #12
3400451c:	af00      	add	r7, sp, #0
3400451e:	4603      	mov	r3, r0
34004520:	6039      	str	r1, [r7, #0]
34004522:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
34004524:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34004528:	2b00      	cmp	r3, #0
3400452a:	db0a      	blt.n	34004542 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
3400452c:	683b      	ldr	r3, [r7, #0]
3400452e:	b2da      	uxtb	r2, r3
34004530:	490c      	ldr	r1, [pc, #48]	@ (34004564 <__NVIC_SetPriority+0x4c>)
34004532:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34004536:	0112      	lsls	r2, r2, #4
34004538:	b2d2      	uxtb	r2, r2
3400453a:	440b      	add	r3, r1
3400453c:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
34004540:	e00a      	b.n	34004558 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34004542:	683b      	ldr	r3, [r7, #0]
34004544:	b2da      	uxtb	r2, r3
34004546:	4908      	ldr	r1, [pc, #32]	@ (34004568 <__NVIC_SetPriority+0x50>)
34004548:	88fb      	ldrh	r3, [r7, #6]
3400454a:	f003 030f 	and.w	r3, r3, #15
3400454e:	3b04      	subs	r3, #4
34004550:	0112      	lsls	r2, r2, #4
34004552:	b2d2      	uxtb	r2, r2
34004554:	440b      	add	r3, r1
34004556:	761a      	strb	r2, [r3, #24]
}
34004558:	bf00      	nop
3400455a:	370c      	adds	r7, #12
3400455c:	46bd      	mov	sp, r7
3400455e:	f85d 7b04 	ldr.w	r7, [sp], #4
34004562:	4770      	bx	lr
34004564:	e000e100 	.word	0xe000e100
34004568:	e000ed00 	.word	0xe000ed00

3400456c <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
3400456c:	b480      	push	{r7}
3400456e:	b089      	sub	sp, #36	@ 0x24
34004570:	af00      	add	r7, sp, #0
34004572:	60f8      	str	r0, [r7, #12]
34004574:	60b9      	str	r1, [r7, #8]
34004576:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
34004578:	68fb      	ldr	r3, [r7, #12]
3400457a:	f003 0307 	and.w	r3, r3, #7
3400457e:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34004580:	69fb      	ldr	r3, [r7, #28]
34004582:	f1c3 0307 	rsb	r3, r3, #7
34004586:	2b04      	cmp	r3, #4
34004588:	bf28      	it	cs
3400458a:	2304      	movcs	r3, #4
3400458c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
3400458e:	69fb      	ldr	r3, [r7, #28]
34004590:	3304      	adds	r3, #4
34004592:	2b06      	cmp	r3, #6
34004594:	d902      	bls.n	3400459c <NVIC_EncodePriority+0x30>
34004596:	69fb      	ldr	r3, [r7, #28]
34004598:	3b03      	subs	r3, #3
3400459a:	e000      	b.n	3400459e <NVIC_EncodePriority+0x32>
3400459c:	2300      	movs	r3, #0
3400459e:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
340045a0:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
340045a4:	69bb      	ldr	r3, [r7, #24]
340045a6:	fa02 f303 	lsl.w	r3, r2, r3
340045aa:	43da      	mvns	r2, r3
340045ac:	68bb      	ldr	r3, [r7, #8]
340045ae:	401a      	ands	r2, r3
340045b0:	697b      	ldr	r3, [r7, #20]
340045b2:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
340045b4:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
340045b8:	697b      	ldr	r3, [r7, #20]
340045ba:	fa01 f303 	lsl.w	r3, r1, r3
340045be:	43d9      	mvns	r1, r3
340045c0:	687b      	ldr	r3, [r7, #4]
340045c2:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
340045c4:	4313      	orrs	r3, r2
         );
}
340045c6:	4618      	mov	r0, r3
340045c8:	3724      	adds	r7, #36	@ 0x24
340045ca:	46bd      	mov	sp, r7
340045cc:	f85d 7b04 	ldr.w	r7, [sp], #4
340045d0:	4770      	bx	lr
	...

340045d4 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
340045d4:	b580      	push	{r7, lr}
340045d6:	b082      	sub	sp, #8
340045d8:	af00      	add	r7, sp, #0
340045da:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
340045dc:	687b      	ldr	r3, [r7, #4]
340045de:	3b01      	subs	r3, #1
340045e0:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
340045e4:	d301      	bcc.n	340045ea <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
340045e6:	2301      	movs	r3, #1
340045e8:	e00f      	b.n	3400460a <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
340045ea:	4a0a      	ldr	r2, [pc, #40]	@ (34004614 <SysTick_Config+0x40>)
340045ec:	687b      	ldr	r3, [r7, #4]
340045ee:	3b01      	subs	r3, #1
340045f0:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
340045f2:	210f      	movs	r1, #15
340045f4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
340045f8:	f7ff ff8e 	bl	34004518 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
340045fc:	4b05      	ldr	r3, [pc, #20]	@ (34004614 <SysTick_Config+0x40>)
340045fe:	2200      	movs	r2, #0
34004600:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
34004602:	4b04      	ldr	r3, [pc, #16]	@ (34004614 <SysTick_Config+0x40>)
34004604:	2207      	movs	r2, #7
34004606:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
34004608:	2300      	movs	r3, #0
}
3400460a:	4618      	mov	r0, r3
3400460c:	3708      	adds	r7, #8
3400460e:	46bd      	mov	sp, r7
34004610:	bd80      	pop	{r7, pc}
34004612:	bf00      	nop
34004614:	e000e010 	.word	0xe000e010

34004618 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
34004618:	b580      	push	{r7, lr}
3400461a:	b082      	sub	sp, #8
3400461c:	af00      	add	r7, sp, #0
3400461e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
34004620:	687b      	ldr	r3, [r7, #4]
34004622:	2b07      	cmp	r3, #7
34004624:	d00f      	beq.n	34004646 <HAL_NVIC_SetPriorityGrouping+0x2e>
34004626:	687b      	ldr	r3, [r7, #4]
34004628:	2b06      	cmp	r3, #6
3400462a:	d00c      	beq.n	34004646 <HAL_NVIC_SetPriorityGrouping+0x2e>
3400462c:	687b      	ldr	r3, [r7, #4]
3400462e:	2b05      	cmp	r3, #5
34004630:	d009      	beq.n	34004646 <HAL_NVIC_SetPriorityGrouping+0x2e>
34004632:	687b      	ldr	r3, [r7, #4]
34004634:	2b04      	cmp	r3, #4
34004636:	d006      	beq.n	34004646 <HAL_NVIC_SetPriorityGrouping+0x2e>
34004638:	687b      	ldr	r3, [r7, #4]
3400463a:	2b03      	cmp	r3, #3
3400463c:	d003      	beq.n	34004646 <HAL_NVIC_SetPriorityGrouping+0x2e>
3400463e:	21e6      	movs	r1, #230	@ 0xe6
34004640:	4804      	ldr	r0, [pc, #16]	@ (34004654 <HAL_NVIC_SetPriorityGrouping+0x3c>)
34004642:	f7fd fce5 	bl	34002010 <assert_failed>

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
34004646:	6878      	ldr	r0, [r7, #4]
34004648:	f7ff ff16 	bl	34004478 <__NVIC_SetPriorityGrouping>
}
3400464c:	bf00      	nop
3400464e:	3708      	adds	r7, #8
34004650:	46bd      	mov	sp, r7
34004652:	bd80      	pop	{r7, pc}
34004654:	3401ea60 	.word	0x3401ea60

34004658 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
34004658:	b580      	push	{r7, lr}
3400465a:	b086      	sub	sp, #24
3400465c:	af00      	add	r7, sp, #0
3400465e:	4603      	mov	r3, r0
34004660:	60b9      	str	r1, [r7, #8]
34004662:	607a      	str	r2, [r7, #4]
34004664:	81fb      	strh	r3, [r7, #14]
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));
34004666:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
3400466a:	f113 0f0c 	cmn.w	r3, #12
3400466e:	db04      	blt.n	3400467a <HAL_NVIC_SetPriority+0x22>
34004670:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
34004674:	f113 0f04 	cmn.w	r3, #4
34004678:	d103      	bne.n	34004682 <HAL_NVIC_SetPriority+0x2a>
3400467a:	21ff      	movs	r1, #255	@ 0xff
3400467c:	4822      	ldr	r0, [pc, #136]	@ (34004708 <HAL_NVIC_SetPriority+0xb0>)
3400467e:	f7fd fcc7 	bl	34002010 <assert_failed>

  prioritygroup = (NVIC_GetPriorityGrouping() & 0x7U);
34004682:	f7ff ff1d 	bl	340044c0 <__NVIC_GetPriorityGrouping>
34004686:	4603      	mov	r3, r0
34004688:	f003 0307 	and.w	r3, r3, #7
3400468c:	617b      	str	r3, [r7, #20]
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
3400468e:	697b      	ldr	r3, [r7, #20]
34004690:	2b02      	cmp	r3, #2
34004692:	d806      	bhi.n	340046a2 <HAL_NVIC_SetPriority+0x4a>
34004694:	687b      	ldr	r3, [r7, #4]
34004696:	2b00      	cmp	r3, #0
34004698:	bf0c      	ite	eq
3400469a:	2301      	moveq	r3, #1
3400469c:	2300      	movne	r3, #0
3400469e:	b2db      	uxtb	r3, r3
340046a0:	e00a      	b.n	340046b8 <HAL_NVIC_SetPriority+0x60>
340046a2:	697b      	ldr	r3, [r7, #20]
340046a4:	3b03      	subs	r3, #3
340046a6:	2201      	movs	r2, #1
340046a8:	fa02 f303 	lsl.w	r3, r2, r3
340046ac:	687a      	ldr	r2, [r7, #4]
340046ae:	429a      	cmp	r2, r3
340046b0:	bf34      	ite	cc
340046b2:	2301      	movcc	r3, #1
340046b4:	2300      	movcs	r3, #0
340046b6:	b2db      	uxtb	r3, r3
340046b8:	2b00      	cmp	r3, #0
340046ba:	d104      	bne.n	340046c6 <HAL_NVIC_SetPriority+0x6e>
340046bc:	f44f 7181 	mov.w	r1, #258	@ 0x102
340046c0:	4811      	ldr	r0, [pc, #68]	@ (34004708 <HAL_NVIC_SetPriority+0xb0>)
340046c2:	f7fd fca5 	bl	34002010 <assert_failed>
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));
340046c6:	68bb      	ldr	r3, [r7, #8]
340046c8:	2b0f      	cmp	r3, #15
340046ca:	d808      	bhi.n	340046de <HAL_NVIC_SetPriority+0x86>
340046cc:	697b      	ldr	r3, [r7, #20]
340046ce:	f1c3 0307 	rsb	r3, r3, #7
340046d2:	2201      	movs	r2, #1
340046d4:	fa02 f303 	lsl.w	r3, r2, r3
340046d8:	68ba      	ldr	r2, [r7, #8]
340046da:	429a      	cmp	r2, r3
340046dc:	d304      	bcc.n	340046e8 <HAL_NVIC_SetPriority+0x90>
340046de:	f240 1103 	movw	r1, #259	@ 0x103
340046e2:	4809      	ldr	r0, [pc, #36]	@ (34004708 <HAL_NVIC_SetPriority+0xb0>)
340046e4:	f7fd fc94 	bl	34002010 <assert_failed>

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
340046e8:	687a      	ldr	r2, [r7, #4]
340046ea:	68b9      	ldr	r1, [r7, #8]
340046ec:	6978      	ldr	r0, [r7, #20]
340046ee:	f7ff ff3d 	bl	3400456c <NVIC_EncodePriority>
340046f2:	4602      	mov	r2, r0
340046f4:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
340046f8:	4611      	mov	r1, r2
340046fa:	4618      	mov	r0, r3
340046fc:	f7ff ff0c 	bl	34004518 <__NVIC_SetPriority>
}
34004700:	bf00      	nop
34004702:	3718      	adds	r7, #24
34004704:	46bd      	mov	sp, r7
34004706:	bd80      	pop	{r7, pc}
34004708:	3401ea60 	.word	0x3401ea60

3400470c <HAL_NVIC_EnableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer
  *         to the appropriate CMSIS device file (stm32n6xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
3400470c:	b580      	push	{r7, lr}
3400470e:	b082      	sub	sp, #8
34004710:	af00      	add	r7, sp, #0
34004712:	4603      	mov	r3, r0
34004714:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
34004716:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3400471a:	2b00      	cmp	r3, #0
3400471c:	da04      	bge.n	34004728 <HAL_NVIC_EnableIRQ+0x1c>
3400471e:	f240 1115 	movw	r1, #277	@ 0x115
34004722:	4806      	ldr	r0, [pc, #24]	@ (3400473c <HAL_NVIC_EnableIRQ+0x30>)
34004724:	f7fd fc74 	bl	34002010 <assert_failed>

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
34004728:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3400472c:	4618      	mov	r0, r3
3400472e:	f7ff fed5 	bl	340044dc <__NVIC_EnableIRQ>
}
34004732:	bf00      	nop
34004734:	3708      	adds	r7, #8
34004736:	46bd      	mov	sp, r7
34004738:	bd80      	pop	{r7, pc}
3400473a:	bf00      	nop
3400473c:	3401ea60 	.word	0x3401ea60

34004740 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
34004740:	b580      	push	{r7, lr}
34004742:	b082      	sub	sp, #8
34004744:	af00      	add	r7, sp, #0
34004746:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
34004748:	6878      	ldr	r0, [r7, #4]
3400474a:	f7ff ff43 	bl	340045d4 <SysTick_Config>
3400474e:	4603      	mov	r3, r0
}
34004750:	4618      	mov	r0, r3
34004752:	3708      	adds	r7, #8
34004754:	46bd      	mov	sp, r7
34004756:	bd80      	pop	{r7, pc}

34004758 <HAL_DCMIPP_IRQHandler>:
  * @brief  Handles DCMIPP interrupt request.
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
void HAL_DCMIPP_IRQHandler(DCMIPP_HandleTypeDef *hdcmipp)
{
34004758:	b580      	push	{r7, lr}
3400475a:	b084      	sub	sp, #16
3400475c:	af00      	add	r7, sp, #0
3400475e:	6078      	str	r0, [r7, #4]
  uint32_t cmsr2flags = READ_REG(hdcmipp->Instance->CMSR2);
34004760:	687b      	ldr	r3, [r7, #4]
34004762:	681b      	ldr	r3, [r3, #0]
34004764:	f8d3 33f8 	ldr.w	r3, [r3, #1016]	@ 0x3f8
34004768:	60fb      	str	r3, [r7, #12]
  uint32_t cmierflags = READ_REG(hdcmipp->Instance->CMIER);
3400476a:	687b      	ldr	r3, [r7, #4]
3400476c:	681b      	ldr	r3, [r3, #0]
3400476e:	f8d3 33f0 	ldr.w	r3, [r3, #1008]	@ 0x3f0
34004772:	60bb      	str	r3, [r7, #8]

  /* ========================= PIPE0 INTERRUPTS ==================== */
  /* Limit error on the PIPE0 ********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LIMIT) != 0U)
34004774:	68fb      	ldr	r3, [r7, #12]
34004776:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3400477a:	2b00      	cmp	r3, #0
3400477c:	d01e      	beq.n	340047bc <HAL_DCMIPP_IRQHandler+0x64>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_LIMIT) != 0U)
3400477e:	68bb      	ldr	r3, [r7, #8]
34004780:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34004784:	2b00      	cmp	r3, #0
34004786:	d019      	beq.n	340047bc <HAL_DCMIPP_IRQHandler+0x64>
    {
      /* Disable Limit error Interrupt for pipe0 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_LIMIT);
34004788:	687b      	ldr	r3, [r7, #4]
3400478a:	681b      	ldr	r3, [r3, #0]
3400478c:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34004790:	687b      	ldr	r3, [r7, #4]
34004792:	681b      	ldr	r3, [r3, #0]
34004794:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
34004798:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_LIMIT;
3400479c:	687b      	ldr	r3, [r7, #4]
3400479e:	689b      	ldr	r3, [r3, #8]
340047a0:	f043 0204 	orr.w	r2, r3, #4
340047a4:	687b      	ldr	r3, [r7, #4]
340047a6:	609a      	str	r2, [r3, #8]

      /* Clear the Limit error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LIMIT);
340047a8:	687b      	ldr	r3, [r7, #4]
340047aa:	681b      	ldr	r3, [r3, #0]
340047ac:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
340047b0:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* LIMIT Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
340047b4:	2100      	movs	r1, #0
340047b6:	6878      	ldr	r0, [r7, #4]
340047b8:	f000 fe67 	bl	3400548a <HAL_DCMIPP_PIPE_LimitEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* VSYNC interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_VSYNC) != 0U)
340047bc:	68fb      	ldr	r3, [r7, #12]
340047be:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
340047c2:	2b00      	cmp	r3, #0
340047c4:	d00e      	beq.n	340047e4 <HAL_DCMIPP_IRQHandler+0x8c>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_VSYNC) != 0U)
340047c6:	68bb      	ldr	r3, [r7, #8]
340047c8:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
340047cc:	2b00      	cmp	r3, #0
340047ce:	d009      	beq.n	340047e4 <HAL_DCMIPP_IRQHandler+0x8c>
    {
      /* Clear the VSYNC flag for pipe0 */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_VSYNC);
340047d0:	687b      	ldr	r3, [r7, #4]
340047d2:	681b      	ldr	r3, [r3, #0]
340047d4:	f44f 6280 	mov.w	r2, #1024	@ 0x400
340047d8:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* VSYNC Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
340047dc:	2100      	movs	r1, #0
340047de:	6878      	ldr	r0, [r7, #4]
340047e0:	f013 fbea 	bl	34017fb8 <HAL_DCMIPP_PIPE_VsyncEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* FRAME interrupt management ****************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_FRAME) != 0U)
340047e4:	68fb      	ldr	r3, [r7, #12]
340047e6:	f403 7300 	and.w	r3, r3, #512	@ 0x200
340047ea:	2b00      	cmp	r3, #0
340047ec:	d023      	beq.n	34004836 <HAL_DCMIPP_IRQHandler+0xde>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_FRAME) != 0U)
340047ee:	68bb      	ldr	r3, [r7, #8]
340047f0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
340047f4:	2b00      	cmp	r3, #0
340047f6:	d01e      	beq.n	34004836 <HAL_DCMIPP_IRQHandler+0xde>
    {
      /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340047f8:	687b      	ldr	r3, [r7, #4]
340047fa:	681b      	ldr	r3, [r3, #0]
340047fc:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34004800:	f003 0304 	and.w	r3, r3, #4
34004804:	2b04      	cmp	r3, #4
34004806:	d10c      	bne.n	34004822 <HAL_DCMIPP_IRQHandler+0xca>
      {
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR);
34004808:	687b      	ldr	r3, [r7, #4]
3400480a:	681b      	ldr	r3, [r3, #0]
3400480c:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34004810:	687b      	ldr	r3, [r7, #4]
34004812:	681b      	ldr	r3, [r3, #0]
34004814:	f422 4206 	bic.w	r2, r2, #34304	@ 0x8600
34004818:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

        /* Update Pipe State */
        hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_READY;
3400481c:	687b      	ldr	r3, [r7, #4]
3400481e:	2201      	movs	r2, #1
34004820:	715a      	strb	r2, [r3, #5]
      }

      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_FRAME);
34004822:	687b      	ldr	r3, [r7, #4]
34004824:	681b      	ldr	r3, [r3, #0]
34004826:	f44f 7200 	mov.w	r2, #512	@ 0x200
3400482a:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
3400482e:	2100      	movs	r1, #0
34004830:	6878      	ldr	r0, [r7, #4]
34004832:	f013 fbdb 	bl	34017fec <HAL_DCMIPP_PIPE_FrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* LINE interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LINE) != 0U)
34004836:	68fb      	ldr	r3, [r7, #12]
34004838:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400483c:	2b00      	cmp	r3, #0
3400483e:	d00e      	beq.n	3400485e <HAL_DCMIPP_IRQHandler+0x106>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_LINE) != 0U)
34004840:	68bb      	ldr	r3, [r7, #8]
34004842:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34004846:	2b00      	cmp	r3, #0
34004848:	d009      	beq.n	3400485e <HAL_DCMIPP_IRQHandler+0x106>
    {
      /* Clear the LINE flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LINE);
3400484a:	687b      	ldr	r3, [r7, #4]
3400484c:	681b      	ldr	r3, [r3, #0]
3400484e:	f44f 7280 	mov.w	r2, #256	@ 0x100
34004852:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* LINE Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
34004856:	2100      	movs	r1, #0
34004858:	6878      	ldr	r0, [r7, #4]
3400485a:	f000 fe0b 	bl	34005474 <HAL_DCMIPP_PIPE_LineEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Overrun error interrupt for Pipe0 ***************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_OVR) != 0U)
3400485e:	68fb      	ldr	r3, [r7, #12]
34004860:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34004864:	2b00      	cmp	r3, #0
34004866:	d021      	beq.n	340048ac <HAL_DCMIPP_IRQHandler+0x154>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_OVR) != 0U)
34004868:	68bb      	ldr	r3, [r7, #8]
3400486a:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
3400486e:	2b00      	cmp	r3, #0
34004870:	d01c      	beq.n	340048ac <HAL_DCMIPP_IRQHandler+0x154>
    {
      /* Disable Overrun Error Interrupt for pipe0 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_OVR);
34004872:	687b      	ldr	r3, [r7, #4]
34004874:	681b      	ldr	r3, [r3, #0]
34004876:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
3400487a:	687b      	ldr	r3, [r7, #4]
3400487c:	681b      	ldr	r3, [r3, #0]
3400487e:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34004882:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_OVR;
34004886:	687b      	ldr	r3, [r7, #4]
34004888:	689b      	ldr	r3, [r3, #8]
3400488a:	f043 0208 	orr.w	r2, r3, #8
3400488e:	687b      	ldr	r3, [r7, #4]
34004890:	609a      	str	r2, [r3, #8]

      /* Clear the overrun error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_OVR);
34004892:	687b      	ldr	r3, [r7, #4]
34004894:	681b      	ldr	r3, [r3, #0]
34004896:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
3400489a:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP Pipe state */
      hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_ERROR;
3400489e:	687b      	ldr	r3, [r7, #4]
340048a0:	2204      	movs	r2, #4
340048a2:	715a      	strb	r2, [r3, #5]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
340048a4:	2100      	movs	r1, #0
340048a6:	6878      	ldr	r0, [r7, #4]
340048a8:	f000 fdfa 	bl	340054a0 <HAL_DCMIPP_PIPE_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* ========================= PIPE1 INTERRUPTS ==================== */
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
340048ac:	68fb      	ldr	r3, [r7, #12]
340048ae:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
340048b2:	2b00      	cmp	r3, #0
340048b4:	d00e      	beq.n	340048d4 <HAL_DCMIPP_IRQHandler+0x17c>
  {
    if ((cmierflags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
340048b6:	68bb      	ldr	r3, [r7, #8]
340048b8:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
340048bc:	2b00      	cmp	r3, #0
340048be:	d009      	beq.n	340048d4 <HAL_DCMIPP_IRQHandler+0x17c>
    {
      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_LINE);
340048c0:	687b      	ldr	r3, [r7, #4]
340048c2:	681b      	ldr	r3, [r3, #0]
340048c4:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
340048c8:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
340048cc:	2101      	movs	r1, #1
340048ce:	6878      	ldr	r0, [r7, #4]
340048d0:	f000 fdd0 	bl	34005474 <HAL_DCMIPP_PIPE_LineEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* VSYNC interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_VSYNC) != 0U)
340048d4:	68fb      	ldr	r3, [r7, #12]
340048d6:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
340048da:	2b00      	cmp	r3, #0
340048dc:	d00e      	beq.n	340048fc <HAL_DCMIPP_IRQHandler+0x1a4>
  {
    if ((cmierflags & DCMIPP_IT_PIPE1_VSYNC) != 0U)
340048de:	68bb      	ldr	r3, [r7, #8]
340048e0:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
340048e4:	2b00      	cmp	r3, #0
340048e6:	d009      	beq.n	340048fc <HAL_DCMIPP_IRQHandler+0x1a4>
    {
      /* Clear the VSYNC flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_VSYNC);
340048e8:	687b      	ldr	r3, [r7, #4]
340048ea:	681b      	ldr	r3, [r3, #0]
340048ec:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
340048f0:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* VSYNC Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
340048f4:	2101      	movs	r1, #1
340048f6:	6878      	ldr	r0, [r7, #4]
340048f8:	f013 fb5e 	bl	34017fb8 <HAL_DCMIPP_PIPE_VsyncEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_FRAME) != 0U)
340048fc:	68fb      	ldr	r3, [r7, #12]
340048fe:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34004902:	2b00      	cmp	r3, #0
34004904:	d023      	beq.n	3400494e <HAL_DCMIPP_IRQHandler+0x1f6>
  {
    if ((cmierflags & DCMIPP_IT_PIPE1_FRAME) != 0U)
34004906:	68bb      	ldr	r3, [r7, #8]
34004908:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
3400490c:	2b00      	cmp	r3, #0
3400490e:	d01e      	beq.n	3400494e <HAL_DCMIPP_IRQHandler+0x1f6>
    {
      /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
      if ((hdcmipp->Instance->P1FCTCR & DCMIPP_P1FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34004910:	687b      	ldr	r3, [r7, #4]
34004912:	681b      	ldr	r3, [r3, #0]
34004914:	f8d3 3900 	ldr.w	r3, [r3, #2304]	@ 0x900
34004918:	f003 0304 	and.w	r3, r3, #4
3400491c:	2b04      	cmp	r3, #4
3400491e:	d10c      	bne.n	3400493a <HAL_DCMIPP_IRQHandler+0x1e2>
      {
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_FRAME | DCMIPP_IT_PIPE1_VSYNC | DCMIPP_IT_PIPE1_OVR);
34004920:	687b      	ldr	r3, [r7, #4]
34004922:	681b      	ldr	r3, [r3, #0]
34004924:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34004928:	687b      	ldr	r3, [r7, #4]
3400492a:	681b      	ldr	r3, [r3, #0]
3400492c:	f422 0206 	bic.w	r2, r2, #8781824	@ 0x860000
34004930:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

        /* Update Pipe State */
        hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_READY;
34004934:	687b      	ldr	r3, [r7, #4]
34004936:	2201      	movs	r2, #1
34004938:	719a      	strb	r2, [r3, #6]
      }

      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_FRAME);
3400493a:	687b      	ldr	r3, [r7, #4]
3400493c:	681b      	ldr	r3, [r3, #0]
3400493e:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
34004942:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
34004946:	2101      	movs	r1, #1
34004948:	6878      	ldr	r0, [r7, #4]
3400494a:	f013 fb4f 	bl	34017fec <HAL_DCMIPP_PIPE_FrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Overrun error on the PIPE1 **************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_OVR) != 0U)
3400494e:	68fb      	ldr	r3, [r7, #12]
34004950:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
34004954:	2b00      	cmp	r3, #0
34004956:	d021      	beq.n	3400499c <HAL_DCMIPP_IRQHandler+0x244>
  {
    if ((cmierflags & DCMIPP_IT_PIPE1_OVR) != 0U)
34004958:	68bb      	ldr	r3, [r7, #8]
3400495a:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
3400495e:	2b00      	cmp	r3, #0
34004960:	d01c      	beq.n	3400499c <HAL_DCMIPP_IRQHandler+0x244>
    {
      /* Disable Overrun Error Interrupt for pipe1 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_OVR);
34004962:	687b      	ldr	r3, [r7, #4]
34004964:	681b      	ldr	r3, [r3, #0]
34004966:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
3400496a:	687b      	ldr	r3, [r7, #4]
3400496c:	681b      	ldr	r3, [r3, #0]
3400496e:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
34004972:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE1_OVR;
34004976:	687b      	ldr	r3, [r7, #4]
34004978:	689b      	ldr	r3, [r3, #8]
3400497a:	f043 0210 	orr.w	r2, r3, #16
3400497e:	687b      	ldr	r3, [r7, #4]
34004980:	609a      	str	r2, [r3, #8]

      /* Clear the overrun error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_OVR);
34004982:	687b      	ldr	r3, [r7, #4]
34004984:	681b      	ldr	r3, [r3, #0]
34004986:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
3400498a:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_ERROR;
3400498e:	687b      	ldr	r3, [r7, #4]
34004990:	2204      	movs	r2, #4
34004992:	719a      	strb	r2, [r3, #6]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
34004994:	2101      	movs	r1, #1
34004996:	6878      	ldr	r0, [r7, #4]
34004998:	f000 fd82 	bl	340054a0 <HAL_DCMIPP_PIPE_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* ========================= PIPE2 INTERRUPTS ==================== */
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_LINE) != 0U)
3400499c:	68fb      	ldr	r3, [r7, #12]
3400499e:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
340049a2:	2b00      	cmp	r3, #0
340049a4:	d00e      	beq.n	340049c4 <HAL_DCMIPP_IRQHandler+0x26c>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_LINE) != 0U)
340049a6:	68bb      	ldr	r3, [r7, #8]
340049a8:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
340049ac:	2b00      	cmp	r3, #0
340049ae:	d009      	beq.n	340049c4 <HAL_DCMIPP_IRQHandler+0x26c>
    {
      /* Clear the End of Line flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_LINE);
340049b0:	687b      	ldr	r3, [r7, #4]
340049b2:	681b      	ldr	r3, [r3, #0]
340049b4:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
340049b8:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
340049bc:	2102      	movs	r1, #2
340049be:	6878      	ldr	r0, [r7, #4]
340049c0:	f000 fd58 	bl	34005474 <HAL_DCMIPP_PIPE_LineEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* VSYNC interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_VSYNC) != 0U)
340049c4:	68fb      	ldr	r3, [r7, #12]
340049c6:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
340049ca:	2b00      	cmp	r3, #0
340049cc:	d00e      	beq.n	340049ec <HAL_DCMIPP_IRQHandler+0x294>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_VSYNC) != 0U)
340049ce:	68bb      	ldr	r3, [r7, #8]
340049d0:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
340049d4:	2b00      	cmp	r3, #0
340049d6:	d009      	beq.n	340049ec <HAL_DCMIPP_IRQHandler+0x294>
    {
      /* Clear the VSYNC flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_VSYNC);
340049d8:	687b      	ldr	r3, [r7, #4]
340049da:	681b      	ldr	r3, [r3, #0]
340049dc:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
340049e0:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* VSYNC Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
340049e4:	2102      	movs	r1, #2
340049e6:	6878      	ldr	r0, [r7, #4]
340049e8:	f013 fae6 	bl	34017fb8 <HAL_DCMIPP_PIPE_VsyncEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_FRAME) != 0U)
340049ec:	68fb      	ldr	r3, [r7, #12]
340049ee:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
340049f2:	2b00      	cmp	r3, #0
340049f4:	d023      	beq.n	34004a3e <HAL_DCMIPP_IRQHandler+0x2e6>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_FRAME) != 0U)
340049f6:	68bb      	ldr	r3, [r7, #8]
340049f8:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
340049fc:	2b00      	cmp	r3, #0
340049fe:	d01e      	beq.n	34004a3e <HAL_DCMIPP_IRQHandler+0x2e6>
    {
      /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
      if ((hdcmipp->Instance->P2FCTCR & DCMIPP_P2FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34004a00:	687b      	ldr	r3, [r7, #4]
34004a02:	681b      	ldr	r3, [r3, #0]
34004a04:	f8d3 3d00 	ldr.w	r3, [r3, #3328]	@ 0xd00
34004a08:	f003 0304 	and.w	r3, r3, #4
34004a0c:	2b04      	cmp	r3, #4
34004a0e:	d10c      	bne.n	34004a2a <HAL_DCMIPP_IRQHandler+0x2d2>
      {
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_VSYNC | DCMIPP_IT_PIPE2_OVR);
34004a10:	687b      	ldr	r3, [r7, #4]
34004a12:	681b      	ldr	r3, [r3, #0]
34004a14:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34004a18:	687b      	ldr	r3, [r7, #4]
34004a1a:	681b      	ldr	r3, [r3, #0]
34004a1c:	f022 4206 	bic.w	r2, r2, #2248146944	@ 0x86000000
34004a20:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

        /* Update Pipe State */
        hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_READY;
34004a24:	687b      	ldr	r3, [r7, #4]
34004a26:	2201      	movs	r2, #1
34004a28:	71da      	strb	r2, [r3, #7]
      }

      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_FRAME);
34004a2a:	687b      	ldr	r3, [r7, #4]
34004a2c:	681b      	ldr	r3, [r3, #0]
34004a2e:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
34004a32:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
34004a36:	2102      	movs	r1, #2
34004a38:	6878      	ldr	r0, [r7, #4]
34004a3a:	f013 fad7 	bl	34017fec <HAL_DCMIPP_PIPE_FrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }
  /* Overrun error on the PIPE2 **************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_OVR) != 0U)
34004a3e:	68fb      	ldr	r3, [r7, #12]
34004a40:	2b00      	cmp	r3, #0
34004a42:	da1f      	bge.n	34004a84 <HAL_DCMIPP_IRQHandler+0x32c>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_OVR) != 0U)
34004a44:	68bb      	ldr	r3, [r7, #8]
34004a46:	2b00      	cmp	r3, #0
34004a48:	da1c      	bge.n	34004a84 <HAL_DCMIPP_IRQHandler+0x32c>
    {
      /* Disable Overrun Error Interrupt for pipe1 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_OVR);
34004a4a:	687b      	ldr	r3, [r7, #4]
34004a4c:	681b      	ldr	r3, [r3, #0]
34004a4e:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34004a52:	687b      	ldr	r3, [r7, #4]
34004a54:	681b      	ldr	r3, [r3, #0]
34004a56:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
34004a5a:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE2_OVR;
34004a5e:	687b      	ldr	r3, [r7, #4]
34004a60:	689b      	ldr	r3, [r3, #8]
34004a62:	f043 0220 	orr.w	r2, r3, #32
34004a66:	687b      	ldr	r3, [r7, #4]
34004a68:	609a      	str	r2, [r3, #8]

      /* Clear the overrun error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_OVR);
34004a6a:	687b      	ldr	r3, [r7, #4]
34004a6c:	681b      	ldr	r3, [r3, #0]
34004a6e:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
34004a72:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_ERROR;
34004a76:	687b      	ldr	r3, [r7, #4]
34004a78:	2204      	movs	r2, #4
34004a7a:	71da      	strb	r2, [r3, #7]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
34004a7c:	2102      	movs	r1, #2
34004a7e:	6878      	ldr	r0, [r7, #4]
34004a80:	f000 fd0e 	bl	340054a0 <HAL_DCMIPP_PIPE_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Synchronization Error Interrupt on the parallel interface  **************/
  if ((cmsr2flags & DCMIPP_FLAG_PARALLEL_SYNC_ERROR) != 0U)
34004a84:	68fb      	ldr	r3, [r7, #12]
34004a86:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34004a8a:	2b00      	cmp	r3, #0
34004a8c:	d01f      	beq.n	34004ace <HAL_DCMIPP_IRQHandler+0x376>
  {
    if ((cmierflags & DCMIPP_IT_PARALLEL_SYNC_ERROR) != 0U)
34004a8e:	68bb      	ldr	r3, [r7, #8]
34004a90:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34004a94:	2b00      	cmp	r3, #0
34004a96:	d01a      	beq.n	34004ace <HAL_DCMIPP_IRQHandler+0x376>
    {
      /* Disable Synchronization error interrupt on parallel interface */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PARALLEL_SYNC_ERROR);
34004a98:	687b      	ldr	r3, [r7, #4]
34004a9a:	681b      	ldr	r3, [r3, #0]
34004a9c:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34004aa0:	687b      	ldr	r3, [r7, #4]
34004aa2:	681b      	ldr	r3, [r3, #0]
34004aa4:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
34004aa8:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PARALLEL_SYNC;
34004aac:	687b      	ldr	r3, [r7, #4]
34004aae:	689b      	ldr	r3, [r3, #8]
34004ab0:	f043 0202 	orr.w	r2, r3, #2
34004ab4:	687b      	ldr	r3, [r7, #4]
34004ab6:	609a      	str	r2, [r3, #8]

      /* Clear the synchronization error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PARALLEL_SYNC_ERROR);
34004ab8:	687b      	ldr	r3, [r7, #4]
34004aba:	681b      	ldr	r3, [r3, #0]
34004abc:	2240      	movs	r2, #64	@ 0x40
34004abe:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34004ac2:	687b      	ldr	r3, [r7, #4]
34004ac4:	2204      	movs	r2, #4
34004ac6:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34004ac8:	6878      	ldr	r0, [r7, #4]
34004aca:	f000 fcf4 	bl	340054b6 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* IPPLUG AXI transfer Error Interrupt     *********************************/
  if ((cmsr2flags & DCMIPP_FLAG_AXI_TRANSFER_ERROR) != 0U)
34004ace:	68fb      	ldr	r3, [r7, #12]
34004ad0:	f003 0320 	and.w	r3, r3, #32
34004ad4:	2b00      	cmp	r3, #0
34004ad6:	d01f      	beq.n	34004b18 <HAL_DCMIPP_IRQHandler+0x3c0>
  {
    if ((cmierflags & DCMIPP_IT_AXI_TRANSFER_ERROR) != 0U)
34004ad8:	68bb      	ldr	r3, [r7, #8]
34004ada:	f003 0320 	and.w	r3, r3, #32
34004ade:	2b00      	cmp	r3, #0
34004ae0:	d01a      	beq.n	34004b18 <HAL_DCMIPP_IRQHandler+0x3c0>
    {
      /* Disable IPPLUG AXI transfer Error Interrupt */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_AXI_TRANSFER_ERROR);
34004ae2:	687b      	ldr	r3, [r7, #4]
34004ae4:	681b      	ldr	r3, [r3, #0]
34004ae6:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34004aea:	687b      	ldr	r3, [r7, #4]
34004aec:	681b      	ldr	r3, [r3, #0]
34004aee:	f022 0220 	bic.w	r2, r2, #32
34004af2:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_AXI_TRANSFER;
34004af6:	687b      	ldr	r3, [r7, #4]
34004af8:	689b      	ldr	r3, [r3, #8]
34004afa:	f043 0201 	orr.w	r2, r3, #1
34004afe:	687b      	ldr	r3, [r7, #4]
34004b00:	609a      	str	r2, [r3, #8]

      /* Clear the AXI transfer error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_AXI_TRANSFER_ERROR);
34004b02:	687b      	ldr	r3, [r7, #4]
34004b04:	681b      	ldr	r3, [r3, #0]
34004b06:	2220      	movs	r2, #32
34004b08:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34004b0c:	687b      	ldr	r3, [r7, #4]
34004b0e:	2204      	movs	r2, #4
34004b10:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34004b12:	6878      	ldr	r0, [r7, #4]
34004b14:	f000 fccf 	bl	340054b6 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }
}
34004b18:	bf00      	nop
34004b1a:	3710      	adds	r7, #16
34004b1c:	46bd      	mov	sp, r7
34004b1e:	bd80      	pop	{r7, pc}

34004b20 <HAL_DCMIPP_CSI_IRQHandler>:
  * @brief  Handles DCMIPP CSI interrupt request.
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
void HAL_DCMIPP_CSI_IRQHandler(DCMIPP_HandleTypeDef *hdcmipp)
{
34004b20:	b580      	push	{r7, lr}
34004b22:	b088      	sub	sp, #32
34004b24:	af00      	add	r7, sp, #0
34004b26:	6078      	str	r0, [r7, #4]
  CSI_TypeDef *csi_instance;
  csi_instance = CSI;
34004b28:	4bb1      	ldr	r3, [pc, #708]	@ (34004df0 <HAL_DCMIPP_CSI_IRQHandler+0x2d0>)
34004b2a:	61fb      	str	r3, [r7, #28]

  /* Read the SR0 register once */
  uint32_t sr0flags = READ_REG(csi_instance->SR0);
34004b2c:	69fb      	ldr	r3, [r7, #28]
34004b2e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34004b32:	61bb      	str	r3, [r7, #24]
  uint32_t sr1flags = READ_REG(csi_instance->SR1);
34004b34:	69fb      	ldr	r3, [r7, #28]
34004b36:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34004b3a:	617b      	str	r3, [r7, #20]

  uint32_t ier0_flags = READ_REG(csi_instance->IER0);
34004b3c:	69fb      	ldr	r3, [r7, #28]
34004b3e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004b42:	613b      	str	r3, [r7, #16]
  uint32_t ier1_flags = READ_REG(csi_instance->IER1);
34004b44:	69fb      	ldr	r3, [r7, #28]
34004b46:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34004b4a:	60fb      	str	r3, [r7, #12]

  /* Clock changer FIFO full event */
  if ((sr0flags & DCMIPP_CSI_FLAG_CCFIFO) != 0U)
34004b4c:	69bb      	ldr	r3, [r7, #24]
34004b4e:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34004b52:	2b00      	cmp	r3, #0
34004b54:	d014      	beq.n	34004b80 <HAL_DCMIPP_CSI_IRQHandler+0x60>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_CCFIFO) != 0U)
34004b56:	693b      	ldr	r3, [r7, #16]
34004b58:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34004b5c:	2b00      	cmp	r3, #0
34004b5e:	d00f      	beq.n	34004b80 <HAL_DCMIPP_CSI_IRQHandler+0x60>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CCFIFO);
34004b60:	69fb      	ldr	r3, [r7, #28]
34004b62:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004b66:	f423 1200 	bic.w	r2, r3, #2097152	@ 0x200000
34004b6a:	69fb      	ldr	r3, [r7, #28]
34004b6c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CCFIFO);
34004b70:	69fb      	ldr	r3, [r7, #28]
34004b72:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
34004b76:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ClockChangerFifoFullEventCallback(hdcmipp);
#else
      HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback(hdcmipp);
34004b7a:	6878      	ldr	r0, [r7, #4]
34004b7c:	f000 fcb0 	bl	340054e0 <HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback>
  }

  /*###############################
     Byte/Line Counter Interrupt
  ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_LB3) != 0U)
34004b80:	69bb      	ldr	r3, [r7, #24]
34004b82:	f003 0308 	and.w	r3, r3, #8
34004b86:	2b00      	cmp	r3, #0
34004b88:	d01c      	beq.n	34004bc4 <HAL_DCMIPP_CSI_IRQHandler+0xa4>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB3) != 0U)
34004b8a:	693b      	ldr	r3, [r7, #16]
34004b8c:	f003 0308 	and.w	r3, r3, #8
34004b90:	2b00      	cmp	r3, #0
34004b92:	d017      	beq.n	34004bc4 <HAL_DCMIPP_CSI_IRQHandler+0xa4>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34004b94:	687b      	ldr	r3, [r7, #4]
34004b96:	681b      	ldr	r3, [r3, #0]
34004b98:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34004b9c:	f003 0304 	and.w	r3, r3, #4
34004ba0:	2b04      	cmp	r3, #4
34004ba2:	d107      	bne.n	34004bb4 <HAL_DCMIPP_CSI_IRQHandler+0x94>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB3);
34004ba4:	69fb      	ldr	r3, [r7, #28]
34004ba6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004baa:	f023 0208 	bic.w	r2, r3, #8
34004bae:	69fb      	ldr	r3, [r7, #28]
34004bb0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB3);
34004bb4:	69fb      	ldr	r3, [r7, #28]
34004bb6:	2208      	movs	r2, #8
34004bb8:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
34004bbc:	2103      	movs	r1, #3
34004bbe:	6878      	ldr	r0, [r7, #4]
34004bc0:	f000 fcc3 	bl	3400554a <HAL_DCMIPP_CSI_LineByteEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_LB2) != 0U)
34004bc4:	69bb      	ldr	r3, [r7, #24]
34004bc6:	f003 0304 	and.w	r3, r3, #4
34004bca:	2b00      	cmp	r3, #0
34004bcc:	d01c      	beq.n	34004c08 <HAL_DCMIPP_CSI_IRQHandler+0xe8>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB2) != 0U)
34004bce:	693b      	ldr	r3, [r7, #16]
34004bd0:	f003 0304 	and.w	r3, r3, #4
34004bd4:	2b00      	cmp	r3, #0
34004bd6:	d017      	beq.n	34004c08 <HAL_DCMIPP_CSI_IRQHandler+0xe8>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34004bd8:	687b      	ldr	r3, [r7, #4]
34004bda:	681b      	ldr	r3, [r3, #0]
34004bdc:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34004be0:	f003 0304 	and.w	r3, r3, #4
34004be4:	2b04      	cmp	r3, #4
34004be6:	d107      	bne.n	34004bf8 <HAL_DCMIPP_CSI_IRQHandler+0xd8>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB2);
34004be8:	69fb      	ldr	r3, [r7, #28]
34004bea:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004bee:	f023 0204 	bic.w	r2, r3, #4
34004bf2:	69fb      	ldr	r3, [r7, #28]
34004bf4:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB2);
34004bf8:	69fb      	ldr	r3, [r7, #28]
34004bfa:	2204      	movs	r2, #4
34004bfc:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
34004c00:	2102      	movs	r1, #2
34004c02:	6878      	ldr	r0, [r7, #4]
34004c04:	f000 fca1 	bl	3400554a <HAL_DCMIPP_CSI_LineByteEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_LB1) != 0U)
34004c08:	69bb      	ldr	r3, [r7, #24]
34004c0a:	f003 0302 	and.w	r3, r3, #2
34004c0e:	2b00      	cmp	r3, #0
34004c10:	d01c      	beq.n	34004c4c <HAL_DCMIPP_CSI_IRQHandler+0x12c>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB1) != 0U)
34004c12:	693b      	ldr	r3, [r7, #16]
34004c14:	f003 0302 	and.w	r3, r3, #2
34004c18:	2b00      	cmp	r3, #0
34004c1a:	d017      	beq.n	34004c4c <HAL_DCMIPP_CSI_IRQHandler+0x12c>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34004c1c:	687b      	ldr	r3, [r7, #4]
34004c1e:	681b      	ldr	r3, [r3, #0]
34004c20:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34004c24:	f003 0304 	and.w	r3, r3, #4
34004c28:	2b04      	cmp	r3, #4
34004c2a:	d107      	bne.n	34004c3c <HAL_DCMIPP_CSI_IRQHandler+0x11c>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB1);
34004c2c:	69fb      	ldr	r3, [r7, #28]
34004c2e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004c32:	f023 0202 	bic.w	r2, r3, #2
34004c36:	69fb      	ldr	r3, [r7, #28]
34004c38:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB1);
34004c3c:	69fb      	ldr	r3, [r7, #28]
34004c3e:	2202      	movs	r2, #2
34004c40:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
34004c44:	2101      	movs	r1, #1
34004c46:	6878      	ldr	r0, [r7, #4]
34004c48:	f000 fc7f 	bl	3400554a <HAL_DCMIPP_CSI_LineByteEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_LB0) != 0U)
34004c4c:	69bb      	ldr	r3, [r7, #24]
34004c4e:	f003 0301 	and.w	r3, r3, #1
34004c52:	2b00      	cmp	r3, #0
34004c54:	d01c      	beq.n	34004c90 <HAL_DCMIPP_CSI_IRQHandler+0x170>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB0) != 0U)
34004c56:	693b      	ldr	r3, [r7, #16]
34004c58:	f003 0301 	and.w	r3, r3, #1
34004c5c:	2b00      	cmp	r3, #0
34004c5e:	d017      	beq.n	34004c90 <HAL_DCMIPP_CSI_IRQHandler+0x170>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34004c60:	687b      	ldr	r3, [r7, #4]
34004c62:	681b      	ldr	r3, [r3, #0]
34004c64:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34004c68:	f003 0304 	and.w	r3, r3, #4
34004c6c:	2b04      	cmp	r3, #4
34004c6e:	d107      	bne.n	34004c80 <HAL_DCMIPP_CSI_IRQHandler+0x160>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB0);
34004c70:	69fb      	ldr	r3, [r7, #28]
34004c72:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004c76:	f023 0201 	bic.w	r2, r3, #1
34004c7a:	69fb      	ldr	r3, [r7, #28]
34004c7c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB0);
34004c80:	69fb      	ldr	r3, [r7, #28]
34004c82:	2201      	movs	r2, #1
34004c84:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
34004c88:	2100      	movs	r1, #0
34004c8a:	6878      	ldr	r0, [r7, #4]
34004c8c:	f000 fc5d 	bl	3400554a <HAL_DCMIPP_CSI_LineByteEventCallback>
  }

  /*###############################
            End Of Frame
    ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_EOF3) != 0U)
34004c90:	69bb      	ldr	r3, [r7, #24]
34004c92:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34004c96:	2b00      	cmp	r3, #0
34004c98:	d01d      	beq.n	34004cd6 <HAL_DCMIPP_CSI_IRQHandler+0x1b6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF3) != 0U)
34004c9a:	693b      	ldr	r3, [r7, #16]
34004c9c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34004ca0:	2b00      	cmp	r3, #0
34004ca2:	d018      	beq.n	34004cd6 <HAL_DCMIPP_CSI_IRQHandler+0x1b6>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34004ca4:	687b      	ldr	r3, [r7, #4]
34004ca6:	681b      	ldr	r3, [r3, #0]
34004ca8:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34004cac:	f003 0304 	and.w	r3, r3, #4
34004cb0:	2b04      	cmp	r3, #4
34004cb2:	d107      	bne.n	34004cc4 <HAL_DCMIPP_CSI_IRQHandler+0x1a4>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF3);
34004cb4:	69fb      	ldr	r3, [r7, #28]
34004cb6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004cba:	f423 4200 	bic.w	r2, r3, #32768	@ 0x8000
34004cbe:	69fb      	ldr	r3, [r7, #28]
34004cc0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF3);
34004cc4:	69fb      	ldr	r3, [r7, #28]
34004cc6:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34004cca:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
34004cce:	2103      	movs	r1, #3
34004cd0:	6878      	ldr	r0, [r7, #4]
34004cd2:	f000 fc19 	bl	34005508 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_EOF2) != 0U)
34004cd6:	69bb      	ldr	r3, [r7, #24]
34004cd8:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34004cdc:	2b00      	cmp	r3, #0
34004cde:	d01d      	beq.n	34004d1c <HAL_DCMIPP_CSI_IRQHandler+0x1fc>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF2) != 0U)
34004ce0:	693b      	ldr	r3, [r7, #16]
34004ce2:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34004ce6:	2b00      	cmp	r3, #0
34004ce8:	d018      	beq.n	34004d1c <HAL_DCMIPP_CSI_IRQHandler+0x1fc>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34004cea:	687b      	ldr	r3, [r7, #4]
34004cec:	681b      	ldr	r3, [r3, #0]
34004cee:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34004cf2:	f003 0304 	and.w	r3, r3, #4
34004cf6:	2b04      	cmp	r3, #4
34004cf8:	d107      	bne.n	34004d0a <HAL_DCMIPP_CSI_IRQHandler+0x1ea>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF2);
34004cfa:	69fb      	ldr	r3, [r7, #28]
34004cfc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004d00:	f423 4280 	bic.w	r2, r3, #16384	@ 0x4000
34004d04:	69fb      	ldr	r3, [r7, #28]
34004d06:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF2);
34004d0a:	69fb      	ldr	r3, [r7, #28]
34004d0c:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34004d10:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34004d14:	2102      	movs	r1, #2
34004d16:	6878      	ldr	r0, [r7, #4]
34004d18:	f000 fbf6 	bl	34005508 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_EOF1) != 0U)
34004d1c:	69bb      	ldr	r3, [r7, #24]
34004d1e:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
34004d22:	2b00      	cmp	r3, #0
34004d24:	d01d      	beq.n	34004d62 <HAL_DCMIPP_CSI_IRQHandler+0x242>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF1) != 0U)
34004d26:	693b      	ldr	r3, [r7, #16]
34004d28:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
34004d2c:	2b00      	cmp	r3, #0
34004d2e:	d018      	beq.n	34004d62 <HAL_DCMIPP_CSI_IRQHandler+0x242>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34004d30:	687b      	ldr	r3, [r7, #4]
34004d32:	681b      	ldr	r3, [r3, #0]
34004d34:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34004d38:	f003 0304 	and.w	r3, r3, #4
34004d3c:	2b04      	cmp	r3, #4
34004d3e:	d107      	bne.n	34004d50 <HAL_DCMIPP_CSI_IRQHandler+0x230>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF1);
34004d40:	69fb      	ldr	r3, [r7, #28]
34004d42:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004d46:	f423 5200 	bic.w	r2, r3, #8192	@ 0x2000
34004d4a:	69fb      	ldr	r3, [r7, #28]
34004d4c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF1);
34004d50:	69fb      	ldr	r3, [r7, #28]
34004d52:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
34004d56:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
34004d5a:	2101      	movs	r1, #1
34004d5c:	6878      	ldr	r0, [r7, #4]
34004d5e:	f000 fbd3 	bl	34005508 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_EOF0) != 0U)
34004d62:	69bb      	ldr	r3, [r7, #24]
34004d64:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34004d68:	2b00      	cmp	r3, #0
34004d6a:	d01d      	beq.n	34004da8 <HAL_DCMIPP_CSI_IRQHandler+0x288>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF0) != 0U)
34004d6c:	693b      	ldr	r3, [r7, #16]
34004d6e:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34004d72:	2b00      	cmp	r3, #0
34004d74:	d018      	beq.n	34004da8 <HAL_DCMIPP_CSI_IRQHandler+0x288>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34004d76:	687b      	ldr	r3, [r7, #4]
34004d78:	681b      	ldr	r3, [r3, #0]
34004d7a:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34004d7e:	f003 0304 	and.w	r3, r3, #4
34004d82:	2b04      	cmp	r3, #4
34004d84:	d107      	bne.n	34004d96 <HAL_DCMIPP_CSI_IRQHandler+0x276>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF0);
34004d86:	69fb      	ldr	r3, [r7, #28]
34004d88:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004d8c:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
34004d90:	69fb      	ldr	r3, [r7, #28]
34004d92:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF0);
34004d96:	69fb      	ldr	r3, [r7, #28]
34004d98:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34004d9c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_CSIREGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
34004da0:	2100      	movs	r1, #0
34004da2:	6878      	ldr	r0, [r7, #4]
34004da4:	f000 fbb0 	bl	34005508 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
  }

  /*###############################
           Start Of Frame
  ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_SOF3) != 0U)
34004da8:	69bb      	ldr	r3, [r7, #24]
34004daa:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34004dae:	2b00      	cmp	r3, #0
34004db0:	d020      	beq.n	34004df4 <HAL_DCMIPP_CSI_IRQHandler+0x2d4>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF3) != 0U)
34004db2:	693b      	ldr	r3, [r7, #16]
34004db4:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34004db8:	2b00      	cmp	r3, #0
34004dba:	d01b      	beq.n	34004df4 <HAL_DCMIPP_CSI_IRQHandler+0x2d4>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34004dbc:	687b      	ldr	r3, [r7, #4]
34004dbe:	681b      	ldr	r3, [r3, #0]
34004dc0:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34004dc4:	f003 0304 	and.w	r3, r3, #4
34004dc8:	2b04      	cmp	r3, #4
34004dca:	d107      	bne.n	34004ddc <HAL_DCMIPP_CSI_IRQHandler+0x2bc>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF3);
34004dcc:	69fb      	ldr	r3, [r7, #28]
34004dce:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004dd2:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
34004dd6:	69fb      	ldr	r3, [r7, #28]
34004dd8:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF3);
34004ddc:	69fb      	ldr	r3, [r7, #28]
34004dde:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34004de2:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
34004de6:	2103      	movs	r1, #3
34004de8:	6878      	ldr	r0, [r7, #4]
34004dea:	f000 fb98 	bl	3400551e <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
34004dee:	e001      	b.n	34004df4 <HAL_DCMIPP_CSI_IRQHandler+0x2d4>
34004df0:	58006000 	.word	0x58006000
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SOF2) != 0U)
34004df4:	69bb      	ldr	r3, [r7, #24]
34004df6:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34004dfa:	2b00      	cmp	r3, #0
34004dfc:	d01d      	beq.n	34004e3a <HAL_DCMIPP_CSI_IRQHandler+0x31a>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF2) != 0U)
34004dfe:	693b      	ldr	r3, [r7, #16]
34004e00:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34004e04:	2b00      	cmp	r3, #0
34004e06:	d018      	beq.n	34004e3a <HAL_DCMIPP_CSI_IRQHandler+0x31a>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34004e08:	687b      	ldr	r3, [r7, #4]
34004e0a:	681b      	ldr	r3, [r3, #0]
34004e0c:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34004e10:	f003 0304 	and.w	r3, r3, #4
34004e14:	2b04      	cmp	r3, #4
34004e16:	d107      	bne.n	34004e28 <HAL_DCMIPP_CSI_IRQHandler+0x308>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF2);
34004e18:	69fb      	ldr	r3, [r7, #28]
34004e1a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004e1e:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
34004e22:	69fb      	ldr	r3, [r7, #28]
34004e24:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF2);
34004e28:	69fb      	ldr	r3, [r7, #28]
34004e2a:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34004e2e:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34004e32:	2102      	movs	r1, #2
34004e34:	6878      	ldr	r0, [r7, #4]
34004e36:	f000 fb72 	bl	3400551e <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SOF1) != 0U)
34004e3a:	69bb      	ldr	r3, [r7, #24]
34004e3c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34004e40:	2b00      	cmp	r3, #0
34004e42:	d01d      	beq.n	34004e80 <HAL_DCMIPP_CSI_IRQHandler+0x360>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF1) != 0U)
34004e44:	693b      	ldr	r3, [r7, #16]
34004e46:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34004e4a:	2b00      	cmp	r3, #0
34004e4c:	d018      	beq.n	34004e80 <HAL_DCMIPP_CSI_IRQHandler+0x360>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34004e4e:	687b      	ldr	r3, [r7, #4]
34004e50:	681b      	ldr	r3, [r3, #0]
34004e52:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34004e56:	f003 0304 	and.w	r3, r3, #4
34004e5a:	2b04      	cmp	r3, #4
34004e5c:	d107      	bne.n	34004e6e <HAL_DCMIPP_CSI_IRQHandler+0x34e>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF1);
34004e5e:	69fb      	ldr	r3, [r7, #28]
34004e60:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004e64:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
34004e68:	69fb      	ldr	r3, [r7, #28]
34004e6a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF1);
34004e6e:	69fb      	ldr	r3, [r7, #28]
34004e70:	f44f 7200 	mov.w	r2, #512	@ 0x200
34004e74:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
34004e78:	2101      	movs	r1, #1
34004e7a:	6878      	ldr	r0, [r7, #4]
34004e7c:	f000 fb4f 	bl	3400551e <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SOF0) != 0U)
34004e80:	69bb      	ldr	r3, [r7, #24]
34004e82:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34004e86:	2b00      	cmp	r3, #0
34004e88:	d01d      	beq.n	34004ec6 <HAL_DCMIPP_CSI_IRQHandler+0x3a6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF0) != 0U)
34004e8a:	693b      	ldr	r3, [r7, #16]
34004e8c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34004e90:	2b00      	cmp	r3, #0
34004e92:	d018      	beq.n	34004ec6 <HAL_DCMIPP_CSI_IRQHandler+0x3a6>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34004e94:	687b      	ldr	r3, [r7, #4]
34004e96:	681b      	ldr	r3, [r3, #0]
34004e98:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34004e9c:	f003 0304 	and.w	r3, r3, #4
34004ea0:	2b04      	cmp	r3, #4
34004ea2:	d107      	bne.n	34004eb4 <HAL_DCMIPP_CSI_IRQHandler+0x394>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF0);
34004ea4:	69fb      	ldr	r3, [r7, #28]
34004ea6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004eaa:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
34004eae:	69fb      	ldr	r3, [r7, #28]
34004eb0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF0);
34004eb4:	69fb      	ldr	r3, [r7, #28]
34004eb6:	f44f 7280 	mov.w	r2, #256	@ 0x100
34004eba:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
34004ebe:	2100      	movs	r1, #0
34004ec0:	6878      	ldr	r0, [r7, #4]
34004ec2:	f000 fb2c 	bl	3400551e <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
  }

  /*###############################
           Timer Interrupt
  ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_TIM3) != 0U)
34004ec6:	69bb      	ldr	r3, [r7, #24]
34004ec8:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34004ecc:	2b00      	cmp	r3, #0
34004ece:	d01c      	beq.n	34004f0a <HAL_DCMIPP_CSI_IRQHandler+0x3ea>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM3) != 0U)
34004ed0:	693b      	ldr	r3, [r7, #16]
34004ed2:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34004ed6:	2b00      	cmp	r3, #0
34004ed8:	d017      	beq.n	34004f0a <HAL_DCMIPP_CSI_IRQHandler+0x3ea>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34004eda:	687b      	ldr	r3, [r7, #4]
34004edc:	681b      	ldr	r3, [r3, #0]
34004ede:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34004ee2:	f003 0304 	and.w	r3, r3, #4
34004ee6:	2b04      	cmp	r3, #4
34004ee8:	d107      	bne.n	34004efa <HAL_DCMIPP_CSI_IRQHandler+0x3da>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM3);
34004eea:	69fb      	ldr	r3, [r7, #28]
34004eec:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004ef0:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
34004ef4:	69fb      	ldr	r3, [r7, #28]
34004ef6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM3);
34004efa:	69fb      	ldr	r3, [r7, #28]
34004efc:	2280      	movs	r2, #128	@ 0x80
34004efe:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
34004f02:	2103      	movs	r1, #3
34004f04:	6878      	ldr	r0, [r7, #4]
34004f06:	f000 fb15 	bl	34005534 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_TIM2) != 0U)
34004f0a:	69bb      	ldr	r3, [r7, #24]
34004f0c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34004f10:	2b00      	cmp	r3, #0
34004f12:	d01c      	beq.n	34004f4e <HAL_DCMIPP_CSI_IRQHandler+0x42e>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM2) != 0U)
34004f14:	693b      	ldr	r3, [r7, #16]
34004f16:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34004f1a:	2b00      	cmp	r3, #0
34004f1c:	d017      	beq.n	34004f4e <HAL_DCMIPP_CSI_IRQHandler+0x42e>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34004f1e:	687b      	ldr	r3, [r7, #4]
34004f20:	681b      	ldr	r3, [r3, #0]
34004f22:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34004f26:	f003 0304 	and.w	r3, r3, #4
34004f2a:	2b04      	cmp	r3, #4
34004f2c:	d107      	bne.n	34004f3e <HAL_DCMIPP_CSI_IRQHandler+0x41e>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM2);
34004f2e:	69fb      	ldr	r3, [r7, #28]
34004f30:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004f34:	f023 0240 	bic.w	r2, r3, #64	@ 0x40
34004f38:	69fb      	ldr	r3, [r7, #28]
34004f3a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM2);
34004f3e:	69fb      	ldr	r3, [r7, #28]
34004f40:	2240      	movs	r2, #64	@ 0x40
34004f42:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
34004f46:	2102      	movs	r1, #2
34004f48:	6878      	ldr	r0, [r7, #4]
34004f4a:	f000 faf3 	bl	34005534 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_TIM1) != 0U)
34004f4e:	69bb      	ldr	r3, [r7, #24]
34004f50:	f003 0320 	and.w	r3, r3, #32
34004f54:	2b00      	cmp	r3, #0
34004f56:	d01c      	beq.n	34004f92 <HAL_DCMIPP_CSI_IRQHandler+0x472>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM1) != 0U)
34004f58:	693b      	ldr	r3, [r7, #16]
34004f5a:	f003 0320 	and.w	r3, r3, #32
34004f5e:	2b00      	cmp	r3, #0
34004f60:	d017      	beq.n	34004f92 <HAL_DCMIPP_CSI_IRQHandler+0x472>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34004f62:	687b      	ldr	r3, [r7, #4]
34004f64:	681b      	ldr	r3, [r3, #0]
34004f66:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34004f6a:	f003 0304 	and.w	r3, r3, #4
34004f6e:	2b04      	cmp	r3, #4
34004f70:	d107      	bne.n	34004f82 <HAL_DCMIPP_CSI_IRQHandler+0x462>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM1);
34004f72:	69fb      	ldr	r3, [r7, #28]
34004f74:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004f78:	f023 0220 	bic.w	r2, r3, #32
34004f7c:	69fb      	ldr	r3, [r7, #28]
34004f7e:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM1);
34004f82:	69fb      	ldr	r3, [r7, #28]
34004f84:	2220      	movs	r2, #32
34004f86:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
34004f8a:	2101      	movs	r1, #1
34004f8c:	6878      	ldr	r0, [r7, #4]
34004f8e:	f000 fad1 	bl	34005534 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_TIM0) != 0U)
34004f92:	69bb      	ldr	r3, [r7, #24]
34004f94:	f003 0310 	and.w	r3, r3, #16
34004f98:	2b00      	cmp	r3, #0
34004f9a:	d01c      	beq.n	34004fd6 <HAL_DCMIPP_CSI_IRQHandler+0x4b6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM0) != 0U)
34004f9c:	693b      	ldr	r3, [r7, #16]
34004f9e:	f003 0310 	and.w	r3, r3, #16
34004fa2:	2b00      	cmp	r3, #0
34004fa4:	d017      	beq.n	34004fd6 <HAL_DCMIPP_CSI_IRQHandler+0x4b6>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34004fa6:	687b      	ldr	r3, [r7, #4]
34004fa8:	681b      	ldr	r3, [r3, #0]
34004faa:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34004fae:	f003 0304 	and.w	r3, r3, #4
34004fb2:	2b04      	cmp	r3, #4
34004fb4:	d107      	bne.n	34004fc6 <HAL_DCMIPP_CSI_IRQHandler+0x4a6>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM0);
34004fb6:	69fb      	ldr	r3, [r7, #28]
34004fb8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004fbc:	f023 0210 	bic.w	r2, r3, #16
34004fc0:	69fb      	ldr	r3, [r7, #28]
34004fc2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM0);
34004fc6:	69fb      	ldr	r3, [r7, #28]
34004fc8:	2210      	movs	r2, #16
34004fca:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
34004fce:	2100      	movs	r1, #0
34004fd0:	6878      	ldr	r0, [r7, #4]
34004fd2:	f000 faaf 	bl	34005534 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Synchronization error  */
  if ((sr0flags & DCMIPP_CSI_FLAG_SYNCERR) != 0U)
34004fd6:	69bb      	ldr	r3, [r7, #24]
34004fd8:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34004fdc:	2b00      	cmp	r3, #0
34004fde:	d01a      	beq.n	34005016 <HAL_DCMIPP_CSI_IRQHandler+0x4f6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SYNCERR) != 0U)
34004fe0:	693b      	ldr	r3, [r7, #16]
34004fe2:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34004fe6:	2b00      	cmp	r3, #0
34004fe8:	d015      	beq.n	34005016 <HAL_DCMIPP_CSI_IRQHandler+0x4f6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SYNCERR);
34004fea:	69fb      	ldr	r3, [r7, #28]
34004fec:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004ff0:	f023 4280 	bic.w	r2, r3, #1073741824	@ 0x40000000
34004ff4:	69fb      	ldr	r3, [r7, #28]
34004ff6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SYNCERR);
34004ffa:	69fb      	ldr	r3, [r7, #28]
34004ffc:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
34005000:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SYNC;
34005004:	687b      	ldr	r3, [r7, #4]
34005006:	689b      	ldr	r3, [r3, #8]
34005008:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
3400500c:	687b      	ldr	r3, [r7, #4]
3400500e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005010:	6878      	ldr	r0, [r7, #4]
34005012:	f000 fa50 	bl	340054b6 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_WDERR) != 0U)
34005016:	69bb      	ldr	r3, [r7, #24]
34005018:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
3400501c:	2b00      	cmp	r3, #0
3400501e:	d01a      	beq.n	34005056 <HAL_DCMIPP_CSI_IRQHandler+0x536>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_WDERR) != 0U)
34005020:	693b      	ldr	r3, [r7, #16]
34005022:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
34005026:	2b00      	cmp	r3, #0
34005028:	d015      	beq.n	34005056 <HAL_DCMIPP_CSI_IRQHandler+0x536>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_WDERR);
3400502a:	69fb      	ldr	r3, [r7, #28]
3400502c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34005030:	f023 5200 	bic.w	r2, r3, #536870912	@ 0x20000000
34005034:	69fb      	ldr	r3, [r7, #28]
34005036:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_WDERR);
3400503a:	69fb      	ldr	r3, [r7, #28]
3400503c:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
34005040:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_WDG;
34005044:	687b      	ldr	r3, [r7, #4]
34005046:	689b      	ldr	r3, [r3, #8]
34005048:	f443 7200 	orr.w	r2, r3, #512	@ 0x200
3400504c:	687b      	ldr	r3, [r7, #4]
3400504e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005050:	6878      	ldr	r0, [r7, #4]
34005052:	f000 fa30 	bl	340054b6 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SPKTERR) != 0U)
34005056:	69bb      	ldr	r3, [r7, #24]
34005058:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
3400505c:	2b00      	cmp	r3, #0
3400505e:	d01a      	beq.n	34005096 <HAL_DCMIPP_CSI_IRQHandler+0x576>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SPKTERR) != 0U)
34005060:	693b      	ldr	r3, [r7, #16]
34005062:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
34005066:	2b00      	cmp	r3, #0
34005068:	d015      	beq.n	34005096 <HAL_DCMIPP_CSI_IRQHandler+0x576>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKTERR);
3400506a:	69fb      	ldr	r3, [r7, #28]
3400506c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34005070:	f023 5280 	bic.w	r2, r3, #268435456	@ 0x10000000
34005074:	69fb      	ldr	r3, [r7, #28]
34005076:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SPKTERR);
3400507a:	69fb      	ldr	r3, [r7, #28]
3400507c:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34005080:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SPKT;
34005084:	687b      	ldr	r3, [r7, #4]
34005086:	689b      	ldr	r3, [r3, #8]
34005088:	f443 6280 	orr.w	r2, r3, #1024	@ 0x400
3400508c:	687b      	ldr	r3, [r7, #4]
3400508e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005090:	6878      	ldr	r0, [r7, #4]
34005092:	f000 fa10 	bl	340054b6 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_IDERR) != 0U)
34005096:	69bb      	ldr	r3, [r7, #24]
34005098:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400509c:	2b00      	cmp	r3, #0
3400509e:	d01a      	beq.n	340050d6 <HAL_DCMIPP_CSI_IRQHandler+0x5b6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_IDERR) != 0U)
340050a0:	693b      	ldr	r3, [r7, #16]
340050a2:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
340050a6:	2b00      	cmp	r3, #0
340050a8:	d015      	beq.n	340050d6 <HAL_DCMIPP_CSI_IRQHandler+0x5b6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_IDERR);
340050aa:	69fb      	ldr	r3, [r7, #28]
340050ac:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340050b0:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
340050b4:	69fb      	ldr	r3, [r7, #28]
340050b6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_IDERR);
340050ba:	69fb      	ldr	r3, [r7, #28]
340050bc:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
340050c0:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DATA_ID;
340050c4:	687b      	ldr	r3, [r7, #4]
340050c6:	689b      	ldr	r3, [r3, #8]
340050c8:	f443 6200 	orr.w	r2, r3, #2048	@ 0x800
340050cc:	687b      	ldr	r3, [r7, #4]
340050ce:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
340050d0:	6878      	ldr	r0, [r7, #4]
340050d2:	f000 f9f0 	bl	340054b6 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_CECCERR) != 0U)
340050d6:	69bb      	ldr	r3, [r7, #24]
340050d8:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
340050dc:	2b00      	cmp	r3, #0
340050de:	d01a      	beq.n	34005116 <HAL_DCMIPP_CSI_IRQHandler+0x5f6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_CECCERR) != 0U)
340050e0:	693b      	ldr	r3, [r7, #16]
340050e2:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
340050e6:	2b00      	cmp	r3, #0
340050e8:	d015      	beq.n	34005116 <HAL_DCMIPP_CSI_IRQHandler+0x5f6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CECCERR);
340050ea:	69fb      	ldr	r3, [r7, #28]
340050ec:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340050f0:	f023 6280 	bic.w	r2, r3, #67108864	@ 0x4000000
340050f4:	69fb      	ldr	r3, [r7, #28]
340050f6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CECCERR);
340050fa:	69fb      	ldr	r3, [r7, #28]
340050fc:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
34005100:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_CECC;
34005104:	687b      	ldr	r3, [r7, #4]
34005106:	689b      	ldr	r3, [r3, #8]
34005108:	f443 5280 	orr.w	r2, r3, #4096	@ 0x1000
3400510c:	687b      	ldr	r3, [r7, #4]
3400510e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005110:	6878      	ldr	r0, [r7, #4]
34005112:	f000 f9d0 	bl	340054b6 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_ECCERR) != 0U)
34005116:	69bb      	ldr	r3, [r7, #24]
34005118:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
3400511c:	2b00      	cmp	r3, #0
3400511e:	d01a      	beq.n	34005156 <HAL_DCMIPP_CSI_IRQHandler+0x636>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_ECCERR) != 0U)
34005120:	693b      	ldr	r3, [r7, #16]
34005122:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34005126:	2b00      	cmp	r3, #0
34005128:	d015      	beq.n	34005156 <HAL_DCMIPP_CSI_IRQHandler+0x636>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECCERR);
3400512a:	69fb      	ldr	r3, [r7, #28]
3400512c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34005130:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
34005134:	69fb      	ldr	r3, [r7, #28]
34005136:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_ECCERR);
3400513a:	69fb      	ldr	r3, [r7, #28]
3400513c:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
34005140:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_ECC;
34005144:	687b      	ldr	r3, [r7, #4]
34005146:	689b      	ldr	r3, [r3, #8]
34005148:	f443 5200 	orr.w	r2, r3, #8192	@ 0x2000
3400514c:	687b      	ldr	r3, [r7, #4]
3400514e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005150:	6878      	ldr	r0, [r7, #4]
34005152:	f000 f9b0 	bl	340054b6 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_CRCERR) != 0U)
34005156:	69bb      	ldr	r3, [r7, #24]
34005158:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
3400515c:	2b00      	cmp	r3, #0
3400515e:	d01a      	beq.n	34005196 <HAL_DCMIPP_CSI_IRQHandler+0x676>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_CRCERR) != 0U)
34005160:	693b      	ldr	r3, [r7, #16]
34005162:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34005166:	2b00      	cmp	r3, #0
34005168:	d015      	beq.n	34005196 <HAL_DCMIPP_CSI_IRQHandler+0x676>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CRCERR);
3400516a:	69fb      	ldr	r3, [r7, #28]
3400516c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34005170:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34005174:	69fb      	ldr	r3, [r7, #28]
34005176:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CRCERR);
3400517a:	69fb      	ldr	r3, [r7, #28]
3400517c:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34005180:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_CRC;
34005184:	687b      	ldr	r3, [r7, #4]
34005186:	689b      	ldr	r3, [r3, #8]
34005188:	f443 4280 	orr.w	r2, r3, #16384	@ 0x4000
3400518c:	687b      	ldr	r3, [r7, #4]
3400518e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005190:	6878      	ldr	r0, [r7, #4]
34005192:	f000 f990 	bl	340054b6 <HAL_DCMIPP_ErrorCallback>
    }
  }

  /* Lane 0 Errors */
  /* Start Of Transmission error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTDL0) != 0U)
34005196:	697b      	ldr	r3, [r7, #20]
34005198:	f003 0301 	and.w	r3, r3, #1
3400519c:	2b00      	cmp	r3, #0
3400519e:	d01d      	beq.n	340051dc <HAL_DCMIPP_CSI_IRQHandler+0x6bc>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTDL0) != 0U)
340051a0:	68fb      	ldr	r3, [r7, #12]
340051a2:	f003 0301 	and.w	r3, r3, #1
340051a6:	2b00      	cmp	r3, #0
340051a8:	d018      	beq.n	340051dc <HAL_DCMIPP_CSI_IRQHandler+0x6bc>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0);
340051aa:	69fb      	ldr	r3, [r7, #28]
340051ac:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340051b0:	f023 0201 	bic.w	r2, r3, #1
340051b4:	69fb      	ldr	r3, [r7, #28]
340051b6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL0);
340051ba:	69fb      	ldr	r3, [r7, #28]
340051bc:	2201      	movs	r2, #1
340051be:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT;
340051c2:	687b      	ldr	r3, [r7, #4]
340051c4:	689b      	ldr	r3, [r3, #8]
340051c6:	f443 2200 	orr.w	r2, r3, #524288	@ 0x80000
340051ca:	687b      	ldr	r3, [r7, #4]
340051cc:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
340051ce:	687b      	ldr	r3, [r7, #4]
340051d0:	2204      	movs	r2, #4
340051d2:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
340051d4:	2101      	movs	r1, #1
340051d6:	6878      	ldr	r0, [r7, #4]
340051d8:	f000 f977 	bl	340054ca <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Start Of Transmission Synchronisation error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTSYNCDL0) != 0U)
340051dc:	697b      	ldr	r3, [r7, #20]
340051de:	f003 0302 	and.w	r3, r3, #2
340051e2:	2b00      	cmp	r3, #0
340051e4:	d01d      	beq.n	34005222 <HAL_DCMIPP_CSI_IRQHandler+0x702>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTSYNCDL0) != 0U)
340051e6:	68fb      	ldr	r3, [r7, #12]
340051e8:	f003 0302 	and.w	r3, r3, #2
340051ec:	2b00      	cmp	r3, #0
340051ee:	d018      	beq.n	34005222 <HAL_DCMIPP_CSI_IRQHandler+0x702>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL0);
340051f0:	69fb      	ldr	r3, [r7, #28]
340051f2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340051f6:	f023 0202 	bic.w	r2, r3, #2
340051fa:	69fb      	ldr	r3, [r7, #28]
340051fc:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTSYNCDL0);
34005200:	69fb      	ldr	r3, [r7, #28]
34005202:	2202      	movs	r2, #2
34005204:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT_SYNC;
34005208:	687b      	ldr	r3, [r7, #4]
3400520a:	689b      	ldr	r3, [r3, #8]
3400520c:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
34005210:	687b      	ldr	r3, [r7, #4]
34005212:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34005214:	687b      	ldr	r3, [r7, #4]
34005216:	2204      	movs	r2, #4
34005218:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
3400521a:	2101      	movs	r1, #1
3400521c:	6878      	ldr	r0, [r7, #4]
3400521e:	f000 f954 	bl	340054ca <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Escape entry error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_EESCDL0) != 0U)
34005222:	697b      	ldr	r3, [r7, #20]
34005224:	f003 0304 	and.w	r3, r3, #4
34005228:	2b00      	cmp	r3, #0
3400522a:	d01a      	beq.n	34005262 <HAL_DCMIPP_CSI_IRQHandler+0x742>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_EESCDL0) != 0U)
3400522c:	68fb      	ldr	r3, [r7, #12]
3400522e:	f003 0304 	and.w	r3, r3, #4
34005232:	2b00      	cmp	r3, #0
34005234:	d015      	beq.n	34005262 <HAL_DCMIPP_CSI_IRQHandler+0x742>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL0);
34005236:	69fb      	ldr	r3, [r7, #28]
34005238:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400523c:	f023 0204 	bic.w	r2, r3, #4
34005240:	69fb      	ldr	r3, [r7, #28]
34005242:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_EESCDL0);
34005246:	69fb      	ldr	r3, [r7, #28]
34005248:	2204      	movs	r2, #4
3400524a:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_ESCAPE;
3400524e:	687b      	ldr	r3, [r7, #4]
34005250:	689b      	ldr	r3, [r3, #8]
34005252:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
34005256:	687b      	ldr	r3, [r7, #4]
34005258:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
3400525a:	2101      	movs	r1, #1
3400525c:	6878      	ldr	r0, [r7, #4]
3400525e:	f000 f934 	bl	340054ca <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Low power data transmission synchronization error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESYNCESCDL0) != 0U)
34005262:	697b      	ldr	r3, [r7, #20]
34005264:	f003 0308 	and.w	r3, r3, #8
34005268:	2b00      	cmp	r3, #0
3400526a:	d01a      	beq.n	340052a2 <HAL_DCMIPP_CSI_IRQHandler+0x782>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESYNCESCDL0) != 0U)
3400526c:	68fb      	ldr	r3, [r7, #12]
3400526e:	f003 0308 	and.w	r3, r3, #8
34005272:	2b00      	cmp	r3, #0
34005274:	d015      	beq.n	340052a2 <HAL_DCMIPP_CSI_IRQHandler+0x782>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL0);
34005276:	69fb      	ldr	r3, [r7, #28]
34005278:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400527c:	f023 0208 	bic.w	r2, r3, #8
34005280:	69fb      	ldr	r3, [r7, #28]
34005282:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESYNCESCDL0);
34005286:	69fb      	ldr	r3, [r7, #28]
34005288:	2208      	movs	r2, #8
3400528a:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_LP_SYNC;
3400528e:	687b      	ldr	r3, [r7, #4]
34005290:	689b      	ldr	r3, [r3, #8]
34005292:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
34005296:	687b      	ldr	r3, [r7, #4]
34005298:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
3400529a:	2101      	movs	r1, #1
3400529c:	6878      	ldr	r0, [r7, #4]
3400529e:	f000 f914 	bl	340054ca <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Error control on data line */
  if ((sr1flags & DCMIPP_CSI_FLAG_ECTRLDL0) != 0U)
340052a2:	697b      	ldr	r3, [r7, #20]
340052a4:	f003 0310 	and.w	r3, r3, #16
340052a8:	2b00      	cmp	r3, #0
340052aa:	d01a      	beq.n	340052e2 <HAL_DCMIPP_CSI_IRQHandler+0x7c2>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ECTRLDL0) != 0U)
340052ac:	68fb      	ldr	r3, [r7, #12]
340052ae:	f003 0310 	and.w	r3, r3, #16
340052b2:	2b00      	cmp	r3, #0
340052b4:	d015      	beq.n	340052e2 <HAL_DCMIPP_CSI_IRQHandler+0x7c2>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL0);
340052b6:	69fb      	ldr	r3, [r7, #28]
340052b8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340052bc:	f023 0210 	bic.w	r2, r3, #16
340052c0:	69fb      	ldr	r3, [r7, #28]
340052c2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ECTRLDL0);
340052c6:	69fb      	ldr	r3, [r7, #28]
340052c8:	2210      	movs	r2, #16
340052ca:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_CTRL;
340052ce:	687b      	ldr	r3, [r7, #4]
340052d0:	689b      	ldr	r3, [r3, #8]
340052d2:	f443 4200 	orr.w	r2, r3, #32768	@ 0x8000
340052d6:	687b      	ldr	r3, [r7, #4]
340052d8:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
340052da:	2101      	movs	r1, #1
340052dc:	6878      	ldr	r0, [r7, #4]
340052de:	f000 f8f4 	bl	340054ca <HAL_DCMIPP_CSI_LineErrorCallback>
    }
  }

  /* Lane 1 Errors */
  /* Start Of Transmission error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTDL1) != 0U)
340052e2:	697b      	ldr	r3, [r7, #20]
340052e4:	f403 7380 	and.w	r3, r3, #256	@ 0x100
340052e8:	2b00      	cmp	r3, #0
340052ea:	d01e      	beq.n	3400532a <HAL_DCMIPP_CSI_IRQHandler+0x80a>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTDL1) != 0U)
340052ec:	68fb      	ldr	r3, [r7, #12]
340052ee:	f403 7380 	and.w	r3, r3, #256	@ 0x100
340052f2:	2b00      	cmp	r3, #0
340052f4:	d019      	beq.n	3400532a <HAL_DCMIPP_CSI_IRQHandler+0x80a>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1);
340052f6:	69fb      	ldr	r3, [r7, #28]
340052f8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340052fc:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
34005300:	69fb      	ldr	r3, [r7, #28]
34005302:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL1);
34005306:	69fb      	ldr	r3, [r7, #28]
34005308:	f44f 7280 	mov.w	r2, #256	@ 0x100
3400530c:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT;
34005310:	687b      	ldr	r3, [r7, #4]
34005312:	689b      	ldr	r3, [r3, #8]
34005314:	f443 2200 	orr.w	r2, r3, #524288	@ 0x80000
34005318:	687b      	ldr	r3, [r7, #4]
3400531a:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
3400531c:	687b      	ldr	r3, [r7, #4]
3400531e:	2204      	movs	r2, #4
34005320:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005322:	2102      	movs	r1, #2
34005324:	6878      	ldr	r0, [r7, #4]
34005326:	f000 f8d0 	bl	340054ca <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Start Of Transmission Synchronisation error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTSYNCDL1) != 0U)
3400532a:	697b      	ldr	r3, [r7, #20]
3400532c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34005330:	2b00      	cmp	r3, #0
34005332:	d01e      	beq.n	34005372 <HAL_DCMIPP_CSI_IRQHandler+0x852>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTSYNCDL1) != 0U)
34005334:	68fb      	ldr	r3, [r7, #12]
34005336:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400533a:	2b00      	cmp	r3, #0
3400533c:	d019      	beq.n	34005372 <HAL_DCMIPP_CSI_IRQHandler+0x852>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL1);
3400533e:	69fb      	ldr	r3, [r7, #28]
34005340:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34005344:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
34005348:	69fb      	ldr	r3, [r7, #28]
3400534a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTSYNCDL1);
3400534e:	69fb      	ldr	r3, [r7, #28]
34005350:	f44f 7200 	mov.w	r2, #512	@ 0x200
34005354:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT_SYNC;
34005358:	687b      	ldr	r3, [r7, #4]
3400535a:	689b      	ldr	r3, [r3, #8]
3400535c:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
34005360:	687b      	ldr	r3, [r7, #4]
34005362:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34005364:	687b      	ldr	r3, [r7, #4]
34005366:	2204      	movs	r2, #4
34005368:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
3400536a:	2102      	movs	r1, #2
3400536c:	6878      	ldr	r0, [r7, #4]
3400536e:	f000 f8ac 	bl	340054ca <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Escape entry error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_EESCDL1) != 0U)
34005372:	697b      	ldr	r3, [r7, #20]
34005374:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34005378:	2b00      	cmp	r3, #0
3400537a:	d01b      	beq.n	340053b4 <HAL_DCMIPP_CSI_IRQHandler+0x894>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_EESCDL1) != 0U)
3400537c:	68fb      	ldr	r3, [r7, #12]
3400537e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34005382:	2b00      	cmp	r3, #0
34005384:	d016      	beq.n	340053b4 <HAL_DCMIPP_CSI_IRQHandler+0x894>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL1);
34005386:	69fb      	ldr	r3, [r7, #28]
34005388:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400538c:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
34005390:	69fb      	ldr	r3, [r7, #28]
34005392:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_EESCDL1);
34005396:	69fb      	ldr	r3, [r7, #28]
34005398:	f44f 6280 	mov.w	r2, #1024	@ 0x400
3400539c:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_ESCAPE;
340053a0:	687b      	ldr	r3, [r7, #4]
340053a2:	689b      	ldr	r3, [r3, #8]
340053a4:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
340053a8:	687b      	ldr	r3, [r7, #4]
340053aa:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
340053ac:	2102      	movs	r1, #2
340053ae:	6878      	ldr	r0, [r7, #4]
340053b0:	f000 f88b 	bl	340054ca <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Low power data transmission synchronization error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESYNCESCDL1) != 0U)
340053b4:	697b      	ldr	r3, [r7, #20]
340053b6:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
340053ba:	2b00      	cmp	r3, #0
340053bc:	d01b      	beq.n	340053f6 <HAL_DCMIPP_CSI_IRQHandler+0x8d6>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESYNCESCDL1) != 0U)
340053be:	68fb      	ldr	r3, [r7, #12]
340053c0:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
340053c4:	2b00      	cmp	r3, #0
340053c6:	d016      	beq.n	340053f6 <HAL_DCMIPP_CSI_IRQHandler+0x8d6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL1);
340053c8:	69fb      	ldr	r3, [r7, #28]
340053ca:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340053ce:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
340053d2:	69fb      	ldr	r3, [r7, #28]
340053d4:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESYNCESCDL1);
340053d8:	69fb      	ldr	r3, [r7, #28]
340053da:	f44f 6200 	mov.w	r2, #2048	@ 0x800
340053de:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_LP_SYNC;
340053e2:	687b      	ldr	r3, [r7, #4]
340053e4:	689b      	ldr	r3, [r3, #8]
340053e6:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
340053ea:	687b      	ldr	r3, [r7, #4]
340053ec:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
340053ee:	2102      	movs	r1, #2
340053f0:	6878      	ldr	r0, [r7, #4]
340053f2:	f000 f86a 	bl	340054ca <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Error control on data line */
  if ((sr1flags & DCMIPP_CSI_IT_ECTRLDL1) != 0U)
340053f6:	697b      	ldr	r3, [r7, #20]
340053f8:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
340053fc:	2b00      	cmp	r3, #0
340053fe:	d01b      	beq.n	34005438 <HAL_DCMIPP_CSI_IRQHandler+0x918>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ECTRLDL1) != 0U)
34005400:	68fb      	ldr	r3, [r7, #12]
34005402:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34005406:	2b00      	cmp	r3, #0
34005408:	d016      	beq.n	34005438 <HAL_DCMIPP_CSI_IRQHandler+0x918>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
3400540a:	69fb      	ldr	r3, [r7, #28]
3400540c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34005410:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
34005414:	69fb      	ldr	r3, [r7, #28]
34005416:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
3400541a:	69fb      	ldr	r3, [r7, #28]
3400541c:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34005420:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_CTRL;
34005424:	687b      	ldr	r3, [r7, #4]
34005426:	689b      	ldr	r3, [r3, #8]
34005428:	f443 4200 	orr.w	r2, r3, #32768	@ 0x8000
3400542c:	687b      	ldr	r3, [r7, #4]
3400542e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005430:	2102      	movs	r1, #2
34005432:	6878      	ldr	r0, [r7, #4]
34005434:	f000 f849 	bl	340054ca <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SPKT) != 0U)
34005438:	69bb      	ldr	r3, [r7, #24]
3400543a:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3400543e:	2b00      	cmp	r3, #0
34005440:	d014      	beq.n	3400546c <HAL_DCMIPP_CSI_IRQHandler+0x94c>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SPKT) != 0U)
34005442:	693b      	ldr	r3, [r7, #16]
34005444:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34005448:	2b00      	cmp	r3, #0
3400544a:	d00f      	beq.n	3400546c <HAL_DCMIPP_CSI_IRQHandler+0x94c>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKT);
3400544c:	69fb      	ldr	r3, [r7, #28]
3400544e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34005452:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
34005456:	69fb      	ldr	r3, [r7, #28]
34005458:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SPKT);
3400545c:	69fb      	ldr	r3, [r7, #28]
3400545e:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34005462:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ShortPacketDetectionEventCallback(hdcmipp);
#else
      HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(hdcmipp);
34005466:	6878      	ldr	r0, [r7, #4]
34005468:	f000 f844 	bl	340054f4 <HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }
}
3400546c:	bf00      	nop
3400546e:	3720      	adds	r7, #32
34005470:	46bd      	mov	sp, r7
34005472:	bd80      	pop	{r7, pc}

34005474 <HAL_DCMIPP_PIPE_LineEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_LineEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34005474:	b480      	push	{r7}
34005476:	b083      	sub	sp, #12
34005478:	af00      	add	r7, sp, #0
3400547a:	6078      	str	r0, [r7, #4]
3400547c:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_LineEventMainPipeCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
3400547e:	bf00      	nop
34005480:	370c      	adds	r7, #12
34005482:	46bd      	mov	sp, r7
34005484:	f85d 7b04 	ldr.w	r7, [sp], #4
34005488:	4770      	bx	lr

3400548a <HAL_DCMIPP_PIPE_LimitEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_LimitEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3400548a:	b480      	push	{r7}
3400548c:	b083      	sub	sp, #12
3400548e:	af00      	add	r7, sp, #0
34005490:	6078      	str	r0, [r7, #4]
34005492:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_LimitEventDumpPipeCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
34005494:	bf00      	nop
34005496:	370c      	adds	r7, #12
34005498:	46bd      	mov	sp, r7
3400549a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400549e:	4770      	bx	lr

340054a0 <HAL_DCMIPP_PIPE_ErrorCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
340054a0:	b480      	push	{r7}
340054a2:	b083      	sub	sp, #12
340054a4:	af00      	add	r7, sp, #0
340054a6:	6078      	str	r0, [r7, #4]
340054a8:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_SyncErrorEventCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
340054aa:	bf00      	nop
340054ac:	370c      	adds	r7, #12
340054ae:	46bd      	mov	sp, r7
340054b0:	f85d 7b04 	ldr.w	r7, [sp], #4
340054b4:	4770      	bx	lr

340054b6 <HAL_DCMIPP_ErrorCallback>:
  * @brief  Error callback on DCMIPP
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
__weak void HAL_DCMIPP_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp)
{
340054b6:	b480      	push	{r7}
340054b8:	b083      	sub	sp, #12
340054ba:	af00      	add	r7, sp, #0
340054bc:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_ErrorCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hdcmipp);
}
340054be:	bf00      	nop
340054c0:	370c      	adds	r7, #12
340054c2:	46bd      	mov	sp, r7
340054c4:	f85d 7b04 	ldr.w	r7, [sp], #4
340054c8:	4770      	bx	lr

340054ca <HAL_DCMIPP_CSI_LineErrorCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  DataLane
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_LineErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t DataLane)
{
340054ca:	b480      	push	{r7}
340054cc:	b083      	sub	sp, #12
340054ce:	af00      	add	r7, sp, #0
340054d0:	6078      	str	r0, [r7, #4]
340054d2:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_LineErrorCallback could be implemented in the user file
   */
  UNUSED(DataLane);
  UNUSED(hdcmipp);
}
340054d4:	bf00      	nop
340054d6:	370c      	adds	r7, #12
340054d8:	46bd      	mov	sp, r7
340054da:	f85d 7b04 	ldr.w	r7, [sp], #4
340054de:	4770      	bx	lr

340054e0 <HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback>:
  * @brief  Clock Changer Fifo Full Event Callback
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback(DCMIPP_HandleTypeDef *hdcmipp)
{
340054e0:	b480      	push	{r7}
340054e2:	b083      	sub	sp, #12
340054e4:	af00      	add	r7, sp, #0
340054e6:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
}
340054e8:	bf00      	nop
340054ea:	370c      	adds	r7, #12
340054ec:	46bd      	mov	sp, r7
340054ee:	f85d 7b04 	ldr.w	r7, [sp], #4
340054f2:	4770      	bx	lr

340054f4 <HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback>:
  * @brief  Short Packet Detection Event Callback
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(DCMIPP_HandleTypeDef *hdcmipp)
{
340054f4:	b480      	push	{r7}
340054f6:	b083      	sub	sp, #12
340054f8:	af00      	add	r7, sp, #0
340054fa:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
}
340054fc:	bf00      	nop
340054fe:	370c      	adds	r7, #12
34005500:	46bd      	mov	sp, r7
34005502:	f85d 7b04 	ldr.w	r7, [sp], #4
34005506:	4770      	bx	lr

34005508 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  VirtualChannel
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_EndOfFrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel)
{
34005508:	b480      	push	{r7}
3400550a:	b083      	sub	sp, #12
3400550c:	af00      	add	r7, sp, #0
3400550e:	6078      	str	r0, [r7, #4]
34005510:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_EndOfFrameEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
  UNUSED(VirtualChannel);
}
34005512:	bf00      	nop
34005514:	370c      	adds	r7, #12
34005516:	46bd      	mov	sp, r7
34005518:	f85d 7b04 	ldr.w	r7, [sp], #4
3400551c:	4770      	bx	lr

3400551e <HAL_DCMIPP_CSI_StartOfFrameEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  VirtualChannel
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_StartOfFrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel)
{
3400551e:	b480      	push	{r7}
34005520:	b083      	sub	sp, #12
34005522:	af00      	add	r7, sp, #0
34005524:	6078      	str	r0, [r7, #4]
34005526:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_StartOfFrameEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
  UNUSED(VirtualChannel);
}
34005528:	bf00      	nop
3400552a:	370c      	adds	r7, #12
3400552c:	46bd      	mov	sp, r7
3400552e:	f85d 7b04 	ldr.w	r7, [sp], #4
34005532:	4770      	bx	lr

34005534 <HAL_DCMIPP_CSI_TimerCounterEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Timer
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_TimerCounterEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Timer)
{
34005534:	b480      	push	{r7}
34005536:	b083      	sub	sp, #12
34005538:	af00      	add	r7, sp, #0
3400553a:	6078      	str	r0, [r7, #4]
3400553c:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_TimerCounterEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
  UNUSED(Timer);
}
3400553e:	bf00      	nop
34005540:	370c      	adds	r7, #12
34005542:	46bd      	mov	sp, r7
34005544:	f85d 7b04 	ldr.w	r7, [sp], #4
34005548:	4770      	bx	lr

3400554a <HAL_DCMIPP_CSI_LineByteEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Counter
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_LineByteEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Counter)
{
3400554a:	b480      	push	{r7}
3400554c:	b083      	sub	sp, #12
3400554e:	af00      	add	r7, sp, #0
34005550:	6078      	str	r0, [r7, #4]
34005552:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
          the HAL_DCMIPP_CSI_LineByteEventCallback could be implemented in the user file
  */
  UNUSED(hdcmipp);
  UNUSED(Counter);
}
34005554:	bf00      	nop
34005556:	370c      	adds	r7, #12
34005558:	46bd      	mov	sp, r7
3400555a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400555e:	4770      	bx	lr

34005560 <HAL_DMA_Start_IT>:
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *const hdma,
                                   uint32_t SrcAddress,
                                   uint32_t DstAddress,
                                   uint32_t SrcDataSize)
{
34005560:	b580      	push	{r7, lr}
34005562:	b084      	sub	sp, #16
34005564:	af00      	add	r7, sp, #0
34005566:	60f8      	str	r0, [r7, #12]
34005568:	60b9      	str	r1, [r7, #8]
3400556a:	607a      	str	r2, [r7, #4]
3400556c:	603b      	str	r3, [r7, #0]
  /* Check the DMA peripheral handle parameter */
  if (hdma == NULL)
3400556e:	68fb      	ldr	r3, [r7, #12]
34005570:	2b00      	cmp	r3, #0
34005572:	d101      	bne.n	34005578 <HAL_DMA_Start_IT+0x18>
  {
    return HAL_ERROR;
34005574:	2301      	movs	r3, #1
34005576:	e05b      	b.n	34005630 <HAL_DMA_Start_IT+0xd0>
  }

  /* Check the parameters */
  assert_param(IS_DMA_BLOCK_SIZE(SrcDataSize));
34005578:	683b      	ldr	r3, [r7, #0]
3400557a:	2b00      	cmp	r3, #0
3400557c:	d003      	beq.n	34005586 <HAL_DMA_Start_IT+0x26>
3400557e:	683b      	ldr	r3, [r7, #0]
34005580:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34005584:	d304      	bcc.n	34005590 <HAL_DMA_Start_IT+0x30>
34005586:	f240 2143 	movw	r1, #579	@ 0x243
3400558a:	482b      	ldr	r0, [pc, #172]	@ (34005638 <HAL_DMA_Start_IT+0xd8>)
3400558c:	f7fc fd40 	bl	34002010 <assert_failed>

  /* Process locked */
  __HAL_LOCK(hdma);
34005590:	68fb      	ldr	r3, [r7, #12]
34005592:	f893 304c 	ldrb.w	r3, [r3, #76]	@ 0x4c
34005596:	2b01      	cmp	r3, #1
34005598:	d101      	bne.n	3400559e <HAL_DMA_Start_IT+0x3e>
3400559a:	2302      	movs	r3, #2
3400559c:	e048      	b.n	34005630 <HAL_DMA_Start_IT+0xd0>
3400559e:	68fb      	ldr	r3, [r7, #12]
340055a0:	2201      	movs	r2, #1
340055a2:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

  /* Check DMA channel state */
  if (hdma->State == HAL_DMA_STATE_READY)
340055a6:	68fb      	ldr	r3, [r7, #12]
340055a8:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
340055ac:	b2db      	uxtb	r3, r3
340055ae:	2b01      	cmp	r3, #1
340055b0:	d136      	bne.n	34005620 <HAL_DMA_Start_IT+0xc0>
  {
    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_BUSY;
340055b2:	68fb      	ldr	r3, [r7, #12]
340055b4:	2202      	movs	r2, #2
340055b6:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Update the DMA channel error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
340055ba:	68fb      	ldr	r3, [r7, #12]
340055bc:	2200      	movs	r2, #0
340055be:	659a      	str	r2, [r3, #88]	@ 0x58

    /* Configure the source address, destination address, the data size and clear flags */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, SrcDataSize);
340055c0:	683b      	ldr	r3, [r7, #0]
340055c2:	687a      	ldr	r2, [r7, #4]
340055c4:	68b9      	ldr	r1, [r7, #8]
340055c6:	68f8      	ldr	r0, [r7, #12]
340055c8:	f000 f9d6 	bl	34005978 <DMA_SetConfig>

    /* Enable common interrupts: Transfer Complete and Transfer Errors ITs */
    __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_DTE | DMA_IT_ULE | DMA_IT_USE | DMA_IT_TO));
340055cc:	68fb      	ldr	r3, [r7, #12]
340055ce:	681b      	ldr	r3, [r3, #0]
340055d0:	695a      	ldr	r2, [r3, #20]
340055d2:	68fb      	ldr	r3, [r7, #12]
340055d4:	681b      	ldr	r3, [r3, #0]
340055d6:	f442 42ba 	orr.w	r2, r2, #23808	@ 0x5d00
340055da:	615a      	str	r2, [r3, #20]

    /* Check half transfer complete callback */
    if (hdma->XferHalfCpltCallback != NULL)
340055dc:	68fb      	ldr	r3, [r7, #12]
340055de:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
340055e0:	2b00      	cmp	r3, #0
340055e2:	d007      	beq.n	340055f4 <HAL_DMA_Start_IT+0x94>
    {
      /* If Half Transfer complete callback is set, enable the corresponding IT */
      __HAL_DMA_ENABLE_IT(hdma, DMA_IT_HT);
340055e4:	68fb      	ldr	r3, [r7, #12]
340055e6:	681b      	ldr	r3, [r3, #0]
340055e8:	695a      	ldr	r2, [r3, #20]
340055ea:	68fb      	ldr	r3, [r7, #12]
340055ec:	681b      	ldr	r3, [r3, #0]
340055ee:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
340055f2:	615a      	str	r2, [r3, #20]
    }

    /* Check Half suspend callback */
    if (hdma->XferSuspendCallback != NULL)
340055f4:	68fb      	ldr	r3, [r7, #12]
340055f6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340055f8:	2b00      	cmp	r3, #0
340055fa:	d007      	beq.n	3400560c <HAL_DMA_Start_IT+0xac>
    {
      /* If Transfer suspend callback is set, enable the corresponding IT */
      __HAL_DMA_ENABLE_IT(hdma, DMA_IT_SUSP);
340055fc:	68fb      	ldr	r3, [r7, #12]
340055fe:	681b      	ldr	r3, [r3, #0]
34005600:	695a      	ldr	r2, [r3, #20]
34005602:	68fb      	ldr	r3, [r7, #12]
34005604:	681b      	ldr	r3, [r3, #0]
34005606:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
3400560a:	615a      	str	r2, [r3, #20]
    }

    /* Enable DMA channel */
    __HAL_DMA_ENABLE(hdma);
3400560c:	68fb      	ldr	r3, [r7, #12]
3400560e:	681b      	ldr	r3, [r3, #0]
34005610:	695a      	ldr	r2, [r3, #20]
34005612:	68fb      	ldr	r3, [r7, #12]
34005614:	681b      	ldr	r3, [r3, #0]
34005616:	f042 0201 	orr.w	r2, r2, #1
3400561a:	615a      	str	r2, [r3, #20]
    __HAL_UNLOCK(hdma);

    return HAL_ERROR;
  }

  return HAL_OK;
3400561c:	2300      	movs	r3, #0
3400561e:	e007      	b.n	34005630 <HAL_DMA_Start_IT+0xd0>
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
34005620:	68fb      	ldr	r3, [r7, #12]
34005622:	2240      	movs	r2, #64	@ 0x40
34005624:	659a      	str	r2, [r3, #88]	@ 0x58
    __HAL_UNLOCK(hdma);
34005626:	68fb      	ldr	r3, [r7, #12]
34005628:	2200      	movs	r2, #0
3400562a:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c
    return HAL_ERROR;
3400562e:	2301      	movs	r3, #1
}
34005630:	4618      	mov	r0, r3
34005632:	3710      	adds	r7, #16
34005634:	46bd      	mov	sp, r7
34005636:	bd80      	pop	{r7, pc}
34005638:	3401eb0c 	.word	0x3401eb0c

3400563c <HAL_DMA_Abort_IT>:
  * @param  hdma : Pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *const hdma)
{
3400563c:	b480      	push	{r7}
3400563e:	b083      	sub	sp, #12
34005640:	af00      	add	r7, sp, #0
34005642:	6078      	str	r0, [r7, #4]
  /* Check the DMA peripheral handle parameter */
  if (hdma == NULL)
34005644:	687b      	ldr	r3, [r7, #4]
34005646:	2b00      	cmp	r3, #0
34005648:	d101      	bne.n	3400564e <HAL_DMA_Abort_IT+0x12>
  {
    return HAL_ERROR;
3400564a:	2301      	movs	r3, #1
3400564c:	e019      	b.n	34005682 <HAL_DMA_Abort_IT+0x46>
  }

  /* Check DMA channel state */
  if (hdma->State != HAL_DMA_STATE_BUSY)
3400564e:	687b      	ldr	r3, [r7, #4]
34005650:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34005654:	b2db      	uxtb	r3, r3
34005656:	2b02      	cmp	r3, #2
34005658:	d004      	beq.n	34005664 <HAL_DMA_Abort_IT+0x28>
  {
    /* Update the DMA channel error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
3400565a:	687b      	ldr	r3, [r7, #4]
3400565c:	2220      	movs	r2, #32
3400565e:	659a      	str	r2, [r3, #88]	@ 0x58

    return HAL_ERROR;
34005660:	2301      	movs	r3, #1
34005662:	e00e      	b.n	34005682 <HAL_DMA_Abort_IT+0x46>
  }
  else
  {
    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_ABORT;
34005664:	687b      	ldr	r3, [r7, #4]
34005666:	2204      	movs	r2, #4
34005668:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Suspend the channel and activate suspend interrupt */
    hdma->Instance->CCR |= (DMA_CCR_SUSP | DMA_CCR_SUSPIE);
3400566c:	687b      	ldr	r3, [r7, #4]
3400566e:	681b      	ldr	r3, [r3, #0]
34005670:	695b      	ldr	r3, [r3, #20]
34005672:	687a      	ldr	r2, [r7, #4]
34005674:	6812      	ldr	r2, [r2, #0]
34005676:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
3400567a:	f043 0304 	orr.w	r3, r3, #4
3400567e:	6153      	str	r3, [r2, #20]
  }

  return HAL_OK;
34005680:	2300      	movs	r3, #0
}
34005682:	4618      	mov	r0, r3
34005684:	370c      	adds	r7, #12
34005686:	46bd      	mov	sp, r7
34005688:	f85d 7b04 	ldr.w	r7, [sp], #4
3400568c:	4770      	bx	lr

3400568e <HAL_DMA_IRQHandler>:
  * @param  hdma : Pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval None.
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *const hdma)
{
3400568e:	b580      	push	{r7, lr}
34005690:	b086      	sub	sp, #24
34005692:	af00      	add	r7, sp, #0
34005694:	6078      	str	r0, [r7, #4]
  const DMA_TypeDef *p_dma_instance = GET_DMA_INSTANCE(hdma);
34005696:	687b      	ldr	r3, [r7, #4]
34005698:	681b      	ldr	r3, [r3, #0]
3400569a:	f423 637f 	bic.w	r3, r3, #4080	@ 0xff0
3400569e:	f023 030f 	bic.w	r3, r3, #15
340056a2:	617b      	str	r3, [r7, #20]
  uint32_t global_it_flag =  1UL << (GET_DMA_CHANNEL(hdma) & 0x1FU);
340056a4:	687b      	ldr	r3, [r7, #4]
340056a6:	681b      	ldr	r3, [r3, #0]
340056a8:	f3c3 030b 	ubfx	r3, r3, #0, #12
340056ac:	3b50      	subs	r3, #80	@ 0x50
340056ae:	09db      	lsrs	r3, r3, #7
340056b0:	f003 031f 	and.w	r3, r3, #31
340056b4:	2201      	movs	r2, #1
340056b6:	fa02 f303 	lsl.w	r3, r2, r3
340056ba:	613b      	str	r3, [r7, #16]
  uint32_t global_active_flag_ns = IS_DMA_GLOBAL_ACTIVE_FLAG_NS(p_dma_instance, global_it_flag);
340056bc:	697b      	ldr	r3, [r7, #20]
340056be:	68db      	ldr	r3, [r3, #12]
340056c0:	693a      	ldr	r2, [r7, #16]
340056c2:	4013      	ands	r3, r2
340056c4:	60fb      	str	r3, [r7, #12]
#if defined (CPU_IN_SECURE_STATE)
  uint32_t global_active_flag_s = IS_DMA_GLOBAL_ACTIVE_FLAG_S(p_dma_instance, global_it_flag);
340056c6:	697b      	ldr	r3, [r7, #20]
340056c8:	691b      	ldr	r3, [r3, #16]
340056ca:	693a      	ldr	r2, [r7, #16]
340056cc:	4013      	ands	r3, r2
340056ce:	60bb      	str	r3, [r7, #8]
#endif /* CPU_IN_SECURE_STATE */

  /* Global Interrupt Flag management *********************************************************************************/
#if defined (CPU_IN_SECURE_STATE)
  if ((global_active_flag_s == 0U) && (global_active_flag_ns == 0U))
340056d0:	68bb      	ldr	r3, [r7, #8]
340056d2:	2b00      	cmp	r3, #0
340056d4:	d103      	bne.n	340056de <HAL_DMA_IRQHandler+0x50>
340056d6:	68fb      	ldr	r3, [r7, #12]
340056d8:	2b00      	cmp	r3, #0
340056da:	f000 813b 	beq.w	34005954 <HAL_DMA_IRQHandler+0x2c6>
  {
    return; /* the global interrupt flag for the current channel is down , nothing to do */
  }

  /* Data Transfer Error Interrupt management *************************************************************************/
  if (__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_DTE) != 0U)
340056de:	687b      	ldr	r3, [r7, #4]
340056e0:	681b      	ldr	r3, [r3, #0]
340056e2:	691b      	ldr	r3, [r3, #16]
340056e4:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
340056e8:	2b00      	cmp	r3, #0
340056ea:	d011      	beq.n	34005710 <HAL_DMA_IRQHandler+0x82>
  {
    /* Check if interrupt source is enabled */
    if (__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DTE) != 0U)
340056ec:	687b      	ldr	r3, [r7, #4]
340056ee:	681b      	ldr	r3, [r3, #0]
340056f0:	695b      	ldr	r3, [r3, #20]
340056f2:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
340056f6:	2b00      	cmp	r3, #0
340056f8:	d00a      	beq.n	34005710 <HAL_DMA_IRQHandler+0x82>
    {
      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_DTE);
340056fa:	687b      	ldr	r3, [r7, #4]
340056fc:	681b      	ldr	r3, [r3, #0]
340056fe:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34005702:	60da      	str	r2, [r3, #12]

      /* Update the DMA channel error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DTE;
34005704:	687b      	ldr	r3, [r7, #4]
34005706:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34005708:	f043 0201 	orr.w	r2, r3, #1
3400570c:	687b      	ldr	r3, [r7, #4]
3400570e:	659a      	str	r2, [r3, #88]	@ 0x58
    }
  }

  /* Update Linked-list Error Interrupt management ********************************************************************/
  if (__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_ULE) != 0U)
34005710:	687b      	ldr	r3, [r7, #4]
34005712:	681b      	ldr	r3, [r3, #0]
34005714:	691b      	ldr	r3, [r3, #16]
34005716:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3400571a:	2b00      	cmp	r3, #0
3400571c:	d011      	beq.n	34005742 <HAL_DMA_IRQHandler+0xb4>
  {
    /* Check if interrupt source is enabled */
    if (__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_ULE) != 0U)
3400571e:	687b      	ldr	r3, [r7, #4]
34005720:	681b      	ldr	r3, [r3, #0]
34005722:	695b      	ldr	r3, [r3, #20]
34005724:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34005728:	2b00      	cmp	r3, #0
3400572a:	d00a      	beq.n	34005742 <HAL_DMA_IRQHandler+0xb4>
    {
      /* Clear the update linked-list error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_ULE);
3400572c:	687b      	ldr	r3, [r7, #4]
3400572e:	681b      	ldr	r3, [r3, #0]
34005730:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34005734:	60da      	str	r2, [r3, #12]

      /* Update the DMA channel error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_ULE;
34005736:	687b      	ldr	r3, [r7, #4]
34005738:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400573a:	f043 0202 	orr.w	r2, r3, #2
3400573e:	687b      	ldr	r3, [r7, #4]
34005740:	659a      	str	r2, [r3, #88]	@ 0x58
    }
  }

  /* User Setting Error Interrupt management **************************************************************************/
  if (__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_USE) != 0U)
34005742:	687b      	ldr	r3, [r7, #4]
34005744:	681b      	ldr	r3, [r3, #0]
34005746:	691b      	ldr	r3, [r3, #16]
34005748:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3400574c:	2b00      	cmp	r3, #0
3400574e:	d011      	beq.n	34005774 <HAL_DMA_IRQHandler+0xe6>
  {
    /* Check if interrupt source is enabled */
    if (__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_USE) != 0U)
34005750:	687b      	ldr	r3, [r7, #4]
34005752:	681b      	ldr	r3, [r3, #0]
34005754:	695b      	ldr	r3, [r3, #20]
34005756:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3400575a:	2b00      	cmp	r3, #0
3400575c:	d00a      	beq.n	34005774 <HAL_DMA_IRQHandler+0xe6>
    {
      /* Clear the user setting error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_USE);
3400575e:	687b      	ldr	r3, [r7, #4]
34005760:	681b      	ldr	r3, [r3, #0]
34005762:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34005766:	60da      	str	r2, [r3, #12]

      /* Update the DMA channel error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_USE;
34005768:	687b      	ldr	r3, [r7, #4]
3400576a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400576c:	f043 0204 	orr.w	r2, r3, #4
34005770:	687b      	ldr	r3, [r7, #4]
34005772:	659a      	str	r2, [r3, #88]	@ 0x58
    }
  }

  /* Trigger Overrun Interrupt management *****************************************************************************/
  if (__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_TO) != 0U)
34005774:	687b      	ldr	r3, [r7, #4]
34005776:	681b      	ldr	r3, [r3, #0]
34005778:	691b      	ldr	r3, [r3, #16]
3400577a:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3400577e:	2b00      	cmp	r3, #0
34005780:	d011      	beq.n	340057a6 <HAL_DMA_IRQHandler+0x118>
  {
    /* Check if interrupt source is enabled */
    if (__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TO) != 0U)
34005782:	687b      	ldr	r3, [r7, #4]
34005784:	681b      	ldr	r3, [r3, #0]
34005786:	695b      	ldr	r3, [r3, #20]
34005788:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3400578c:	2b00      	cmp	r3, #0
3400578e:	d00a      	beq.n	340057a6 <HAL_DMA_IRQHandler+0x118>
    {
      /* Clear the trigger overrun flag */
      __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_TO);
34005790:	687b      	ldr	r3, [r7, #4]
34005792:	681b      	ldr	r3, [r3, #0]
34005794:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34005798:	60da      	str	r2, [r3, #12]

      /* Update the DMA channel error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TO;
3400579a:	687b      	ldr	r3, [r7, #4]
3400579c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400579e:	f043 0208 	orr.w	r2, r3, #8
340057a2:	687b      	ldr	r3, [r7, #4]
340057a4:	659a      	str	r2, [r3, #88]	@ 0x58
    }
  }

  /* Half Transfer Complete Interrupt management **********************************************************************/
  if (__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_HT) != 0U)
340057a6:	687b      	ldr	r3, [r7, #4]
340057a8:	681b      	ldr	r3, [r3, #0]
340057aa:	691b      	ldr	r3, [r3, #16]
340057ac:	f403 7300 	and.w	r3, r3, #512	@ 0x200
340057b0:	2b00      	cmp	r3, #0
340057b2:	d013      	beq.n	340057dc <HAL_DMA_IRQHandler+0x14e>
  {
    /* Check if interrupt source is enabled */
    if (__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
340057b4:	687b      	ldr	r3, [r7, #4]
340057b6:	681b      	ldr	r3, [r3, #0]
340057b8:	695b      	ldr	r3, [r3, #20]
340057ba:	f403 7300 	and.w	r3, r3, #512	@ 0x200
340057be:	2b00      	cmp	r3, #0
340057c0:	d00c      	beq.n	340057dc <HAL_DMA_IRQHandler+0x14e>
    {
      /* Clear the half transfer flag */
      __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_HT);
340057c2:	687b      	ldr	r3, [r7, #4]
340057c4:	681b      	ldr	r3, [r3, #0]
340057c6:	f44f 7200 	mov.w	r2, #512	@ 0x200
340057ca:	60da      	str	r2, [r3, #12]

      /* Check half transfer complete callback */
      if (hdma->XferHalfCpltCallback != NULL)
340057cc:	687b      	ldr	r3, [r7, #4]
340057ce:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
340057d0:	2b00      	cmp	r3, #0
340057d2:	d003      	beq.n	340057dc <HAL_DMA_IRQHandler+0x14e>
      {
        /* Half transfer callback */
        hdma->XferHalfCpltCallback(hdma);
340057d4:	687b      	ldr	r3, [r7, #4]
340057d6:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
340057d8:	6878      	ldr	r0, [r7, #4]
340057da:	4798      	blx	r3
      }
    }
  }

  /* Suspend Transfer Interrupt management ****************************************************************************/
  if (__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_SUSP) != 0U)
340057dc:	687b      	ldr	r3, [r7, #4]
340057de:	681b      	ldr	r3, [r3, #0]
340057e0:	691b      	ldr	r3, [r3, #16]
340057e2:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
340057e6:	2b00      	cmp	r3, #0
340057e8:	d04c      	beq.n	34005884 <HAL_DMA_IRQHandler+0x1f6>
  {
    /* Check if interrupt source is enabled */
    if (__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_SUSP) != 0U)
340057ea:	687b      	ldr	r3, [r7, #4]
340057ec:	681b      	ldr	r3, [r3, #0]
340057ee:	695b      	ldr	r3, [r3, #20]
340057f0:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
340057f4:	2b00      	cmp	r3, #0
340057f6:	d045      	beq.n	34005884 <HAL_DMA_IRQHandler+0x1f6>
    {
      /* Clear the block transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_SUSP);
340057f8:	687b      	ldr	r3, [r7, #4]
340057fa:	681b      	ldr	r3, [r3, #0]
340057fc:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
34005800:	60da      	str	r2, [r3, #12]

      /* Check DMA channel state */
      if (hdma->State == HAL_DMA_STATE_ABORT)
34005802:	687b      	ldr	r3, [r7, #4]
34005804:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34005808:	b2db      	uxtb	r3, r3
3400580a:	2b04      	cmp	r3, #4
3400580c:	d12e      	bne.n	3400586c <HAL_DMA_IRQHandler+0x1de>
      {
        /* Disable the suspend transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_SUSP);
3400580e:	687b      	ldr	r3, [r7, #4]
34005810:	681b      	ldr	r3, [r3, #0]
34005812:	695a      	ldr	r2, [r3, #20]
34005814:	687b      	ldr	r3, [r7, #4]
34005816:	681b      	ldr	r3, [r3, #0]
34005818:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
3400581c:	615a      	str	r2, [r3, #20]

        /* Reset the channel internal state and reset the FIFO */
        hdma->Instance->CCR |= DMA_CCR_RESET;
3400581e:	687b      	ldr	r3, [r7, #4]
34005820:	681b      	ldr	r3, [r3, #0]
34005822:	695a      	ldr	r2, [r3, #20]
34005824:	687b      	ldr	r3, [r7, #4]
34005826:	681b      	ldr	r3, [r3, #0]
34005828:	f042 0202 	orr.w	r2, r2, #2
3400582c:	615a      	str	r2, [r3, #20]

        /* Update the DMA channel state */
        hdma->State = HAL_DMA_STATE_READY;
3400582e:	687b      	ldr	r3, [r7, #4]
34005830:	2201      	movs	r2, #1
34005832:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

        /* Check DMA channel transfer mode */
        if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
34005836:	687b      	ldr	r3, [r7, #4]
34005838:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400583a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3400583e:	2b00      	cmp	r3, #0
34005840:	d007      	beq.n	34005852 <HAL_DMA_IRQHandler+0x1c4>
        {
          /* Update the linked-list queue state */
          hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
34005842:	687b      	ldr	r3, [r7, #4]
34005844:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34005846:	2201      	movs	r2, #1
34005848:	731a      	strb	r2, [r3, #12]

          /* Clear remaining data size to ensure loading linked-list from memory next start */
          hdma->Instance->CBR1 = 0U;
3400584a:	687b      	ldr	r3, [r7, #4]
3400584c:	681b      	ldr	r3, [r3, #0]
3400584e:	2200      	movs	r2, #0
34005850:	649a      	str	r2, [r3, #72]	@ 0x48
        }

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
34005852:	687b      	ldr	r3, [r7, #4]
34005854:	2200      	movs	r2, #0
34005856:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

        /* Check transfer abort callback */
        if (hdma->XferAbortCallback != NULL)
3400585a:	687b      	ldr	r3, [r7, #4]
3400585c:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
3400585e:	2b00      	cmp	r3, #0
34005860:	d07a      	beq.n	34005958 <HAL_DMA_IRQHandler+0x2ca>
        {
          /* Transfer abort callback */
          hdma->XferAbortCallback(hdma);
34005862:	687b      	ldr	r3, [r7, #4]
34005864:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34005866:	6878      	ldr	r0, [r7, #4]
34005868:	4798      	blx	r3
        }

        return;
3400586a:	e075      	b.n	34005958 <HAL_DMA_IRQHandler+0x2ca>
      }
      else
      {
        /* Update the DMA channel state */
        hdma->State = HAL_DMA_STATE_SUSPEND;
3400586c:	687b      	ldr	r3, [r7, #4]
3400586e:	2205      	movs	r2, #5
34005870:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

        /* Check transfer suspend callback */
        if (hdma->XferSuspendCallback != NULL)
34005874:	687b      	ldr	r3, [r7, #4]
34005876:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34005878:	2b00      	cmp	r3, #0
3400587a:	d003      	beq.n	34005884 <HAL_DMA_IRQHandler+0x1f6>
        {
          /* Transfer suspend callback */
          hdma->XferSuspendCallback(hdma);
3400587c:	687b      	ldr	r3, [r7, #4]
3400587e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34005880:	6878      	ldr	r0, [r7, #4]
34005882:	4798      	blx	r3
      }
    }
  }

  /* Transfer Complete Interrupt management ***************************************************************************/
  if (__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_TC) != 0U)
34005884:	687b      	ldr	r3, [r7, #4]
34005886:	681b      	ldr	r3, [r3, #0]
34005888:	691b      	ldr	r3, [r3, #16]
3400588a:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400588e:	2b00      	cmp	r3, #0
34005890:	d039      	beq.n	34005906 <HAL_DMA_IRQHandler+0x278>
  {
    /* Check if interrupt source is enabled */
    if (__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
34005892:	687b      	ldr	r3, [r7, #4]
34005894:	681b      	ldr	r3, [r3, #0]
34005896:	695b      	ldr	r3, [r3, #20]
34005898:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400589c:	2b00      	cmp	r3, #0
3400589e:	d032      	beq.n	34005906 <HAL_DMA_IRQHandler+0x278>
    {
      /* Check DMA channel transfer mode */
      if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
340058a0:	687b      	ldr	r3, [r7, #4]
340058a2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340058a4:	f003 0380 	and.w	r3, r3, #128	@ 0x80
340058a8:	2b00      	cmp	r3, #0
340058aa:	d012      	beq.n	340058d2 <HAL_DMA_IRQHandler+0x244>
      {
        /* If linked-list transfer */
        if (hdma->Instance->CLLR == 0U)
340058ac:	687b      	ldr	r3, [r7, #4]
340058ae:	681b      	ldr	r3, [r3, #0]
340058b0:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340058b2:	2b00      	cmp	r3, #0
340058b4:	d116      	bne.n	340058e4 <HAL_DMA_IRQHandler+0x256>
        {
          if (hdma->Instance->CBR1 == 0U)
340058b6:	687b      	ldr	r3, [r7, #4]
340058b8:	681b      	ldr	r3, [r3, #0]
340058ba:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340058bc:	2b00      	cmp	r3, #0
340058be:	d111      	bne.n	340058e4 <HAL_DMA_IRQHandler+0x256>
          {
            /* Update the DMA channel state */
            hdma->State = HAL_DMA_STATE_READY;
340058c0:	687b      	ldr	r3, [r7, #4]
340058c2:	2201      	movs	r2, #1
340058c4:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

            /* Update the linked-list queue state */
            hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
340058c8:	687b      	ldr	r3, [r7, #4]
340058ca:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340058cc:	2201      	movs	r2, #1
340058ce:	731a      	strb	r2, [r3, #12]
340058d0:	e008      	b.n	340058e4 <HAL_DMA_IRQHandler+0x256>
        }
      }
      else
      {
        /* If normal transfer */
        if (hdma->Instance->CBR1 == 0U)
340058d2:	687b      	ldr	r3, [r7, #4]
340058d4:	681b      	ldr	r3, [r3, #0]
340058d6:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340058d8:	2b00      	cmp	r3, #0
340058da:	d103      	bne.n	340058e4 <HAL_DMA_IRQHandler+0x256>
        {
          /* Update the DMA channel state */
          hdma->State = HAL_DMA_STATE_READY;
340058dc:	687b      	ldr	r3, [r7, #4]
340058de:	2201      	movs	r2, #1
340058e0:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54
        }
      }

      /* Clear TC and HT transfer flags */
      __HAL_DMA_CLEAR_FLAG(hdma, (DMA_FLAG_TC | DMA_FLAG_HT));
340058e4:	687b      	ldr	r3, [r7, #4]
340058e6:	681b      	ldr	r3, [r3, #0]
340058e8:	f44f 7240 	mov.w	r2, #768	@ 0x300
340058ec:	60da      	str	r2, [r3, #12]

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
340058ee:	687b      	ldr	r3, [r7, #4]
340058f0:	2200      	movs	r2, #0
340058f2:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

      /* Check transfer complete callback */
      if (hdma->XferCpltCallback != NULL)
340058f6:	687b      	ldr	r3, [r7, #4]
340058f8:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
340058fa:	2b00      	cmp	r3, #0
340058fc:	d003      	beq.n	34005906 <HAL_DMA_IRQHandler+0x278>
      {
        /* Channel Transfer Complete callback */
        hdma->XferCpltCallback(hdma);
340058fe:	687b      	ldr	r3, [r7, #4]
34005900:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34005902:	6878      	ldr	r0, [r7, #4]
34005904:	4798      	blx	r3
      }
    }
  }

  /* Manage error case ************************************************************************************************/
  if (hdma->ErrorCode != HAL_DMA_ERROR_NONE)
34005906:	687b      	ldr	r3, [r7, #4]
34005908:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400590a:	2b00      	cmp	r3, #0
3400590c:	d025      	beq.n	3400595a <HAL_DMA_IRQHandler+0x2cc>
  {
    /* Reset the channel internal state and reset the FIFO */
    hdma->Instance->CCR |= DMA_CCR_RESET;
3400590e:	687b      	ldr	r3, [r7, #4]
34005910:	681b      	ldr	r3, [r3, #0]
34005912:	695a      	ldr	r2, [r3, #20]
34005914:	687b      	ldr	r3, [r7, #4]
34005916:	681b      	ldr	r3, [r3, #0]
34005918:	f042 0202 	orr.w	r2, r2, #2
3400591c:	615a      	str	r2, [r3, #20]

    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_READY;
3400591e:	687b      	ldr	r3, [r7, #4]
34005920:	2201      	movs	r2, #1
34005922:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Check DMA channel transfer mode */
    if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
34005926:	687b      	ldr	r3, [r7, #4]
34005928:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400592a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3400592e:	2b00      	cmp	r3, #0
34005930:	d003      	beq.n	3400593a <HAL_DMA_IRQHandler+0x2ac>
    {
      /* Update the linked-list queue state */
      hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
34005932:	687b      	ldr	r3, [r7, #4]
34005934:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34005936:	2201      	movs	r2, #1
34005938:	731a      	strb	r2, [r3, #12]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
3400593a:	687b      	ldr	r3, [r7, #4]
3400593c:	2200      	movs	r2, #0
3400593e:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

    /* Check transfer error callback */
    if (hdma->XferErrorCallback != NULL)
34005942:	687b      	ldr	r3, [r7, #4]
34005944:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
34005946:	2b00      	cmp	r3, #0
34005948:	d007      	beq.n	3400595a <HAL_DMA_IRQHandler+0x2cc>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
3400594a:	687b      	ldr	r3, [r7, #4]
3400594c:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3400594e:	6878      	ldr	r0, [r7, #4]
34005950:	4798      	blx	r3
34005952:	e002      	b.n	3400595a <HAL_DMA_IRQHandler+0x2cc>
    return; /* the global interrupt flag for the current channel is down , nothing to do */
34005954:	bf00      	nop
34005956:	e000      	b.n	3400595a <HAL_DMA_IRQHandler+0x2cc>
        return;
34005958:	bf00      	nop
    }
  }
}
3400595a:	3718      	adds	r7, #24
3400595c:	46bd      	mov	sp, r7
3400595e:	bd80      	pop	{r7, pc}

34005960 <HAL_DMA_GetError>:
  * @param  hdma : Pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval DMA Error Code.
  */
uint32_t HAL_DMA_GetError(DMA_HandleTypeDef const *const hdma)
{
34005960:	b480      	push	{r7}
34005962:	b083      	sub	sp, #12
34005964:	af00      	add	r7, sp, #0
34005966:	6078      	str	r0, [r7, #4]
  /* Return the DMA channel error code */
  return hdma->ErrorCode;
34005968:	687b      	ldr	r3, [r7, #4]
3400596a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
}
3400596c:	4618      	mov	r0, r3
3400596e:	370c      	adds	r7, #12
34005970:	46bd      	mov	sp, r7
34005972:	f85d 7b04 	ldr.w	r7, [sp], #4
34005976:	4770      	bx	lr

34005978 <DMA_SetConfig>:
  */
static void DMA_SetConfig(DMA_HandleTypeDef const *const hdma,
                          uint32_t SrcAddress,
                          uint32_t DstAddress,
                          uint32_t SrcDataSize)
{
34005978:	b480      	push	{r7}
3400597a:	b085      	sub	sp, #20
3400597c:	af00      	add	r7, sp, #0
3400597e:	60f8      	str	r0, [r7, #12]
34005980:	60b9      	str	r1, [r7, #8]
34005982:	607a      	str	r2, [r7, #4]
34005984:	603b      	str	r3, [r7, #0]
  /* Configure the DMA channel data size */
  MODIFY_REG(hdma->Instance->CBR1, DMA_CBR1_BNDT, (SrcDataSize & DMA_CBR1_BNDT));
34005986:	68fb      	ldr	r3, [r7, #12]
34005988:	681b      	ldr	r3, [r3, #0]
3400598a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400598c:	0c1b      	lsrs	r3, r3, #16
3400598e:	041b      	lsls	r3, r3, #16
34005990:	683a      	ldr	r2, [r7, #0]
34005992:	b291      	uxth	r1, r2
34005994:	68fa      	ldr	r2, [r7, #12]
34005996:	6812      	ldr	r2, [r2, #0]
34005998:	430b      	orrs	r3, r1
3400599a:	6493      	str	r3, [r2, #72]	@ 0x48

  /* Clear all interrupt flags */
  __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_TC | DMA_FLAG_HT | DMA_FLAG_DTE | DMA_FLAG_ULE | DMA_FLAG_USE | DMA_FLAG_SUSP |
3400599c:	68fb      	ldr	r3, [r7, #12]
3400599e:	681b      	ldr	r3, [r3, #0]
340059a0:	f44f 42fe 	mov.w	r2, #32512	@ 0x7f00
340059a4:	60da      	str	r2, [r3, #12]
                       DMA_FLAG_TO);

  /* Configure DMA channel source address */
  hdma->Instance->CSAR = SrcAddress;
340059a6:	68fb      	ldr	r3, [r7, #12]
340059a8:	681b      	ldr	r3, [r3, #0]
340059aa:	68ba      	ldr	r2, [r7, #8]
340059ac:	64da      	str	r2, [r3, #76]	@ 0x4c

  /* Configure DMA channel destination address */
  hdma->Instance->CDAR = DstAddress;
340059ae:	68fb      	ldr	r3, [r7, #12]
340059b0:	681b      	ldr	r3, [r3, #0]
340059b2:	687a      	ldr	r2, [r7, #4]
340059b4:	651a      	str	r2, [r3, #80]	@ 0x50
}
340059b6:	bf00      	nop
340059b8:	3714      	adds	r7, #20
340059ba:	46bd      	mov	sp, r7
340059bc:	f85d 7b04 	ldr.w	r7, [sp], #4
340059c0:	4770      	bx	lr

340059c2 <HAL_DMA2D_IRQHandler>:
  * @param  hdma2d Pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL status
  */
void HAL_DMA2D_IRQHandler(DMA2D_HandleTypeDef *hdma2d)
{
340059c2:	b580      	push	{r7, lr}
340059c4:	b084      	sub	sp, #16
340059c6:	af00      	add	r7, sp, #0
340059c8:	6078      	str	r0, [r7, #4]
  uint32_t isrflags = READ_REG(hdma2d->Instance->ISR);
340059ca:	687b      	ldr	r3, [r7, #4]
340059cc:	681b      	ldr	r3, [r3, #0]
340059ce:	685b      	ldr	r3, [r3, #4]
340059d0:	60fb      	str	r3, [r7, #12]
  uint32_t crflags = READ_REG(hdma2d->Instance->CR);
340059d2:	687b      	ldr	r3, [r7, #4]
340059d4:	681b      	ldr	r3, [r3, #0]
340059d6:	681b      	ldr	r3, [r3, #0]
340059d8:	60bb      	str	r3, [r7, #8]

  /* Transfer Error Interrupt management ***************************************/
  if ((isrflags & DMA2D_FLAG_TE) != 0U)
340059da:	68fb      	ldr	r3, [r7, #12]
340059dc:	f003 0301 	and.w	r3, r3, #1
340059e0:	2b00      	cmp	r3, #0
340059e2:	d026      	beq.n	34005a32 <HAL_DMA2D_IRQHandler+0x70>
  {
    if ((crflags & DMA2D_IT_TE) != 0U)
340059e4:	68bb      	ldr	r3, [r7, #8]
340059e6:	f403 7380 	and.w	r3, r3, #256	@ 0x100
340059ea:	2b00      	cmp	r3, #0
340059ec:	d021      	beq.n	34005a32 <HAL_DMA2D_IRQHandler+0x70>
    {
      /* Disable the transfer Error interrupt */
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TE);
340059ee:	687b      	ldr	r3, [r7, #4]
340059f0:	681b      	ldr	r3, [r3, #0]
340059f2:	681a      	ldr	r2, [r3, #0]
340059f4:	687b      	ldr	r3, [r7, #4]
340059f6:	681b      	ldr	r3, [r3, #0]
340059f8:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
340059fc:	601a      	str	r2, [r3, #0]

      /* Update error code */
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
340059fe:	687b      	ldr	r3, [r7, #4]
34005a00:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34005a02:	f043 0201 	orr.w	r2, r3, #1
34005a06:	687b      	ldr	r3, [r7, #4]
34005a08:	665a      	str	r2, [r3, #100]	@ 0x64

      /* Clear the transfer error flag */
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TE);
34005a0a:	687b      	ldr	r3, [r7, #4]
34005a0c:	681b      	ldr	r3, [r3, #0]
34005a0e:	2201      	movs	r2, #1
34005a10:	609a      	str	r2, [r3, #8]

      /* Change DMA2D state */
      hdma2d->State = HAL_DMA2D_STATE_ERROR;
34005a12:	687b      	ldr	r3, [r7, #4]
34005a14:	2204      	movs	r2, #4
34005a16:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

      /* Process Unlocked */
      __HAL_UNLOCK(hdma2d);
34005a1a:	687b      	ldr	r3, [r7, #4]
34005a1c:	2200      	movs	r2, #0
34005a1e:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

      if (hdma2d->XferErrorCallback != NULL)
34005a22:	687b      	ldr	r3, [r7, #4]
34005a24:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34005a26:	2b00      	cmp	r3, #0
34005a28:	d003      	beq.n	34005a32 <HAL_DMA2D_IRQHandler+0x70>
      {
        /* Transfer error Callback */
        hdma2d->XferErrorCallback(hdma2d);
34005a2a:	687b      	ldr	r3, [r7, #4]
34005a2c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34005a2e:	6878      	ldr	r0, [r7, #4]
34005a30:	4798      	blx	r3
      }
    }
  }
  /* Configuration Error Interrupt management **********************************/
  if ((isrflags & DMA2D_FLAG_CE) != 0U)
34005a32:	68fb      	ldr	r3, [r7, #12]
34005a34:	f003 0320 	and.w	r3, r3, #32
34005a38:	2b00      	cmp	r3, #0
34005a3a:	d026      	beq.n	34005a8a <HAL_DMA2D_IRQHandler+0xc8>
  {
    if ((crflags & DMA2D_IT_CE) != 0U)
34005a3c:	68bb      	ldr	r3, [r7, #8]
34005a3e:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
34005a42:	2b00      	cmp	r3, #0
34005a44:	d021      	beq.n	34005a8a <HAL_DMA2D_IRQHandler+0xc8>
    {
      /* Disable the Configuration Error interrupt */
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CE);
34005a46:	687b      	ldr	r3, [r7, #4]
34005a48:	681b      	ldr	r3, [r3, #0]
34005a4a:	681a      	ldr	r2, [r3, #0]
34005a4c:	687b      	ldr	r3, [r7, #4]
34005a4e:	681b      	ldr	r3, [r3, #0]
34005a50:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
34005a54:	601a      	str	r2, [r3, #0]

      /* Clear the Configuration error flag */
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE);
34005a56:	687b      	ldr	r3, [r7, #4]
34005a58:	681b      	ldr	r3, [r3, #0]
34005a5a:	2220      	movs	r2, #32
34005a5c:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
34005a5e:	687b      	ldr	r3, [r7, #4]
34005a60:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34005a62:	f043 0202 	orr.w	r2, r3, #2
34005a66:	687b      	ldr	r3, [r7, #4]
34005a68:	665a      	str	r2, [r3, #100]	@ 0x64

      /* Change DMA2D state */
      hdma2d->State = HAL_DMA2D_STATE_ERROR;
34005a6a:	687b      	ldr	r3, [r7, #4]
34005a6c:	2204      	movs	r2, #4
34005a6e:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

      /* Process Unlocked */
      __HAL_UNLOCK(hdma2d);
34005a72:	687b      	ldr	r3, [r7, #4]
34005a74:	2200      	movs	r2, #0
34005a76:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

      if (hdma2d->XferErrorCallback != NULL)
34005a7a:	687b      	ldr	r3, [r7, #4]
34005a7c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34005a7e:	2b00      	cmp	r3, #0
34005a80:	d003      	beq.n	34005a8a <HAL_DMA2D_IRQHandler+0xc8>
      {
        /* Transfer error Callback */
        hdma2d->XferErrorCallback(hdma2d);
34005a82:	687b      	ldr	r3, [r7, #4]
34005a84:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34005a86:	6878      	ldr	r0, [r7, #4]
34005a88:	4798      	blx	r3
      }
    }
  }
  /* CLUT access Error Interrupt management ***********************************/
  if ((isrflags & DMA2D_FLAG_CAE) != 0U)
34005a8a:	68fb      	ldr	r3, [r7, #12]
34005a8c:	f003 0308 	and.w	r3, r3, #8
34005a90:	2b00      	cmp	r3, #0
34005a92:	d026      	beq.n	34005ae2 <HAL_DMA2D_IRQHandler+0x120>
  {
    if ((crflags & DMA2D_IT_CAE) != 0U)
34005a94:	68bb      	ldr	r3, [r7, #8]
34005a96:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34005a9a:	2b00      	cmp	r3, #0
34005a9c:	d021      	beq.n	34005ae2 <HAL_DMA2D_IRQHandler+0x120>
    {
      /* Disable the CLUT access error interrupt */
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CAE);
34005a9e:	687b      	ldr	r3, [r7, #4]
34005aa0:	681b      	ldr	r3, [r3, #0]
34005aa2:	681a      	ldr	r2, [r3, #0]
34005aa4:	687b      	ldr	r3, [r7, #4]
34005aa6:	681b      	ldr	r3, [r3, #0]
34005aa8:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
34005aac:	601a      	str	r2, [r3, #0]

      /* Clear the CLUT access error flag */
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE);
34005aae:	687b      	ldr	r3, [r7, #4]
34005ab0:	681b      	ldr	r3, [r3, #0]
34005ab2:	2208      	movs	r2, #8
34005ab4:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
34005ab6:	687b      	ldr	r3, [r7, #4]
34005ab8:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34005aba:	f043 0204 	orr.w	r2, r3, #4
34005abe:	687b      	ldr	r3, [r7, #4]
34005ac0:	665a      	str	r2, [r3, #100]	@ 0x64

      /* Change DMA2D state */
      hdma2d->State = HAL_DMA2D_STATE_ERROR;
34005ac2:	687b      	ldr	r3, [r7, #4]
34005ac4:	2204      	movs	r2, #4
34005ac6:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

      /* Process Unlocked */
      __HAL_UNLOCK(hdma2d);
34005aca:	687b      	ldr	r3, [r7, #4]
34005acc:	2200      	movs	r2, #0
34005ace:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

      if (hdma2d->XferErrorCallback != NULL)
34005ad2:	687b      	ldr	r3, [r7, #4]
34005ad4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34005ad6:	2b00      	cmp	r3, #0
34005ad8:	d003      	beq.n	34005ae2 <HAL_DMA2D_IRQHandler+0x120>
      {
        /* Transfer error Callback */
        hdma2d->XferErrorCallback(hdma2d);
34005ada:	687b      	ldr	r3, [r7, #4]
34005adc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34005ade:	6878      	ldr	r0, [r7, #4]
34005ae0:	4798      	blx	r3
      }
    }
  }
  /* Transfer watermark Interrupt management **********************************/
  if ((isrflags & DMA2D_FLAG_TW) != 0U)
34005ae2:	68fb      	ldr	r3, [r7, #12]
34005ae4:	f003 0304 	and.w	r3, r3, #4
34005ae8:	2b00      	cmp	r3, #0
34005aea:	d013      	beq.n	34005b14 <HAL_DMA2D_IRQHandler+0x152>
  {
    if ((crflags & DMA2D_IT_TW) != 0U)
34005aec:	68bb      	ldr	r3, [r7, #8]
34005aee:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34005af2:	2b00      	cmp	r3, #0
34005af4:	d00e      	beq.n	34005b14 <HAL_DMA2D_IRQHandler+0x152>
    {
      /* Disable the transfer watermark interrupt */
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TW);
34005af6:	687b      	ldr	r3, [r7, #4]
34005af8:	681b      	ldr	r3, [r3, #0]
34005afa:	681a      	ldr	r2, [r3, #0]
34005afc:	687b      	ldr	r3, [r7, #4]
34005afe:	681b      	ldr	r3, [r3, #0]
34005b00:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
34005b04:	601a      	str	r2, [r3, #0]

      /* Clear the transfer watermark flag */
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TW);
34005b06:	687b      	ldr	r3, [r7, #4]
34005b08:	681b      	ldr	r3, [r3, #0]
34005b0a:	2204      	movs	r2, #4
34005b0c:	609a      	str	r2, [r3, #8]

      /* Transfer watermark Callback */
#if (USE_HAL_DMA2D_REGISTER_CALLBACKS == 1)
      hdma2d->LineEventCallback(hdma2d);
#else
      HAL_DMA2D_LineEventCallback(hdma2d);
34005b0e:	6878      	ldr	r0, [r7, #4]
34005b10:	f000 f853 	bl	34005bba <HAL_DMA2D_LineEventCallback>
#endif /* USE_HAL_DMA2D_REGISTER_CALLBACKS */

    }
  }
  /* Transfer Complete Interrupt management ************************************/
  if ((isrflags & DMA2D_FLAG_TC) != 0U)
34005b14:	68fb      	ldr	r3, [r7, #12]
34005b16:	f003 0302 	and.w	r3, r3, #2
34005b1a:	2b00      	cmp	r3, #0
34005b1c:	d024      	beq.n	34005b68 <HAL_DMA2D_IRQHandler+0x1a6>
  {
    if ((crflags & DMA2D_IT_TC) != 0U)
34005b1e:	68bb      	ldr	r3, [r7, #8]
34005b20:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34005b24:	2b00      	cmp	r3, #0
34005b26:	d01f      	beq.n	34005b68 <HAL_DMA2D_IRQHandler+0x1a6>
    {
      /* Disable the transfer complete interrupt */
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TC);
34005b28:	687b      	ldr	r3, [r7, #4]
34005b2a:	681b      	ldr	r3, [r3, #0]
34005b2c:	681a      	ldr	r2, [r3, #0]
34005b2e:	687b      	ldr	r3, [r7, #4]
34005b30:	681b      	ldr	r3, [r3, #0]
34005b32:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
34005b36:	601a      	str	r2, [r3, #0]

      /* Clear the transfer complete flag */
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC);
34005b38:	687b      	ldr	r3, [r7, #4]
34005b3a:	681b      	ldr	r3, [r3, #0]
34005b3c:	2202      	movs	r2, #2
34005b3e:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_NONE;
34005b40:	687b      	ldr	r3, [r7, #4]
34005b42:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
34005b44:	687b      	ldr	r3, [r7, #4]
34005b46:	665a      	str	r2, [r3, #100]	@ 0x64

      /* Change DMA2D state */
      hdma2d->State = HAL_DMA2D_STATE_READY;
34005b48:	687b      	ldr	r3, [r7, #4]
34005b4a:	2201      	movs	r2, #1
34005b4c:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

      /* Process Unlocked */
      __HAL_UNLOCK(hdma2d);
34005b50:	687b      	ldr	r3, [r7, #4]
34005b52:	2200      	movs	r2, #0
34005b54:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

      if (hdma2d->XferCpltCallback != NULL)
34005b58:	687b      	ldr	r3, [r7, #4]
34005b5a:	6a1b      	ldr	r3, [r3, #32]
34005b5c:	2b00      	cmp	r3, #0
34005b5e:	d003      	beq.n	34005b68 <HAL_DMA2D_IRQHandler+0x1a6>
      {
        /* Transfer complete Callback */
        hdma2d->XferCpltCallback(hdma2d);
34005b60:	687b      	ldr	r3, [r7, #4]
34005b62:	6a1b      	ldr	r3, [r3, #32]
34005b64:	6878      	ldr	r0, [r7, #4]
34005b66:	4798      	blx	r3
      }
    }
  }
  /* CLUT Transfer Complete Interrupt management ******************************/
  if ((isrflags & DMA2D_FLAG_CTC) != 0U)
34005b68:	68fb      	ldr	r3, [r7, #12]
34005b6a:	f003 0310 	and.w	r3, r3, #16
34005b6e:	2b00      	cmp	r3, #0
34005b70:	d01f      	beq.n	34005bb2 <HAL_DMA2D_IRQHandler+0x1f0>
  {
    if ((crflags & DMA2D_IT_CTC) != 0U)
34005b72:	68bb      	ldr	r3, [r7, #8]
34005b74:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34005b78:	2b00      	cmp	r3, #0
34005b7a:	d01a      	beq.n	34005bb2 <HAL_DMA2D_IRQHandler+0x1f0>
    {
      /* Disable the CLUT transfer complete interrupt */
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CTC);
34005b7c:	687b      	ldr	r3, [r7, #4]
34005b7e:	681b      	ldr	r3, [r3, #0]
34005b80:	681a      	ldr	r2, [r3, #0]
34005b82:	687b      	ldr	r3, [r7, #4]
34005b84:	681b      	ldr	r3, [r3, #0]
34005b86:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
34005b8a:	601a      	str	r2, [r3, #0]

      /* Clear the CLUT transfer complete flag */
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CTC);
34005b8c:	687b      	ldr	r3, [r7, #4]
34005b8e:	681b      	ldr	r3, [r3, #0]
34005b90:	2210      	movs	r2, #16
34005b92:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_NONE;
34005b94:	687b      	ldr	r3, [r7, #4]
34005b96:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
34005b98:	687b      	ldr	r3, [r7, #4]
34005b9a:	665a      	str	r2, [r3, #100]	@ 0x64

      /* Change DMA2D state */
      hdma2d->State = HAL_DMA2D_STATE_READY;
34005b9c:	687b      	ldr	r3, [r7, #4]
34005b9e:	2201      	movs	r2, #1
34005ba0:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

      /* Process Unlocked */
      __HAL_UNLOCK(hdma2d);
34005ba4:	687b      	ldr	r3, [r7, #4]
34005ba6:	2200      	movs	r2, #0
34005ba8:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

      /* CLUT Transfer complete Callback */
#if (USE_HAL_DMA2D_REGISTER_CALLBACKS == 1)
      hdma2d->CLUTLoadingCpltCallback(hdma2d);
#else
      HAL_DMA2D_CLUTLoadingCpltCallback(hdma2d);
34005bac:	6878      	ldr	r0, [r7, #4]
34005bae:	f000 f80e 	bl	34005bce <HAL_DMA2D_CLUTLoadingCpltCallback>
#endif /* USE_HAL_DMA2D_REGISTER_CALLBACKS */
    }
  }

}
34005bb2:	bf00      	nop
34005bb4:	3710      	adds	r7, #16
34005bb6:	46bd      	mov	sp, r7
34005bb8:	bd80      	pop	{r7, pc}

34005bba <HAL_DMA2D_LineEventCallback>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  */
__weak void HAL_DMA2D_LineEventCallback(DMA2D_HandleTypeDef *hdma2d)
{
34005bba:	b480      	push	{r7}
34005bbc:	b083      	sub	sp, #12
34005bbe:	af00      	add	r7, sp, #0
34005bc0:	6078      	str	r0, [r7, #4]
  UNUSED(hdma2d);

  /* NOTE : This function should not be modified; when the callback is needed,
            the HAL_DMA2D_LineEventCallback can be implemented in the user file.
   */
}
34005bc2:	bf00      	nop
34005bc4:	370c      	adds	r7, #12
34005bc6:	46bd      	mov	sp, r7
34005bc8:	f85d 7b04 	ldr.w	r7, [sp], #4
34005bcc:	4770      	bx	lr

34005bce <HAL_DMA2D_CLUTLoadingCpltCallback>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  */
__weak void HAL_DMA2D_CLUTLoadingCpltCallback(DMA2D_HandleTypeDef *hdma2d)
{
34005bce:	b480      	push	{r7}
34005bd0:	b083      	sub	sp, #12
34005bd2:	af00      	add	r7, sp, #0
34005bd4:	6078      	str	r0, [r7, #4]
  UNUSED(hdma2d);

  /* NOTE : This function should not be modified; when the callback is needed,
            the HAL_DMA2D_CLUTLoadingCpltCallback can be implemented in the user file.
   */
}
34005bd6:	bf00      	nop
34005bd8:	370c      	adds	r7, #12
34005bda:	46bd      	mov	sp, r7
34005bdc:	f85d 7b04 	ldr.w	r7, [sp], #4
34005be0:	4770      	bx	lr

34005be2 <HAL_DMAEx_List_Start_IT>:
  * @param  hdma : Pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DMAEx_List_Start_IT(DMA_HandleTypeDef *const hdma)
{
34005be2:	b580      	push	{r7, lr}
34005be4:	b086      	sub	sp, #24
34005be6:	af00      	add	r7, sp, #0
34005be8:	6078      	str	r0, [r7, #4]
  HAL_DMA_StateTypeDef dma_state;
  uint32_t ccr_value;
  uint32_t cllr_mask;

  /* Check the DMA peripheral handle and the linked-list queue parameters */
  if ((hdma == NULL) || (hdma->LinkedListQueue == NULL))
34005bea:	687b      	ldr	r3, [r7, #4]
34005bec:	2b00      	cmp	r3, #0
34005bee:	d003      	beq.n	34005bf8 <HAL_DMAEx_List_Start_IT+0x16>
34005bf0:	687b      	ldr	r3, [r7, #4]
34005bf2:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34005bf4:	2b00      	cmp	r3, #0
34005bf6:	d101      	bne.n	34005bfc <HAL_DMAEx_List_Start_IT+0x1a>
  {
    return HAL_ERROR;
34005bf8:	2301      	movs	r3, #1
34005bfa:	e082      	b.n	34005d02 <HAL_DMAEx_List_Start_IT+0x120>
  }

  /* Check DMA channel state */
  dma_state = hdma->State;
34005bfc:	687b      	ldr	r3, [r7, #4]
34005bfe:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34005c02:	75fb      	strb	r3, [r7, #23]
  ccr_value = hdma->Instance->CCR & DMA_CCR_LSM;
34005c04:	687b      	ldr	r3, [r7, #4]
34005c06:	681b      	ldr	r3, [r3, #0]
34005c08:	695b      	ldr	r3, [r3, #20]
34005c0a:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34005c0e:	613b      	str	r3, [r7, #16]
  if ((dma_state == HAL_DMA_STATE_READY) || ((dma_state == HAL_DMA_STATE_BUSY) && (ccr_value != 0U)))
34005c10:	7dfb      	ldrb	r3, [r7, #23]
34005c12:	2b01      	cmp	r3, #1
34005c14:	d005      	beq.n	34005c22 <HAL_DMAEx_List_Start_IT+0x40>
34005c16:	7dfb      	ldrb	r3, [r7, #23]
34005c18:	2b02      	cmp	r3, #2
34005c1a:	d16a      	bne.n	34005cf2 <HAL_DMAEx_List_Start_IT+0x110>
34005c1c:	693b      	ldr	r3, [r7, #16]
34005c1e:	2b00      	cmp	r3, #0
34005c20:	d067      	beq.n	34005cf2 <HAL_DMAEx_List_Start_IT+0x110>
  {
    /* Check DMA channel state is ready */
    if (hdma->State == HAL_DMA_STATE_READY)
34005c22:	687b      	ldr	r3, [r7, #4]
34005c24:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34005c28:	b2db      	uxtb	r3, r3
34005c2a:	2b01      	cmp	r3, #1
34005c2c:	d157      	bne.n	34005cde <HAL_DMAEx_List_Start_IT+0xfc>
    {
      /* Process locked */
      __HAL_LOCK(hdma);
34005c2e:	687b      	ldr	r3, [r7, #4]
34005c30:	f893 304c 	ldrb.w	r3, [r3, #76]	@ 0x4c
34005c34:	2b01      	cmp	r3, #1
34005c36:	d101      	bne.n	34005c3c <HAL_DMAEx_List_Start_IT+0x5a>
34005c38:	2302      	movs	r3, #2
34005c3a:	e062      	b.n	34005d02 <HAL_DMAEx_List_Start_IT+0x120>
34005c3c:	687b      	ldr	r3, [r7, #4]
34005c3e:	2201      	movs	r2, #1
34005c40:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

      /* Update the DMA channel and the queue states */
      hdma->State                  = HAL_DMA_STATE_BUSY;
34005c44:	687b      	ldr	r3, [r7, #4]
34005c46:	2202      	movs	r2, #2
34005c48:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54
      hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_BUSY;
34005c4c:	687b      	ldr	r3, [r7, #4]
34005c4e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34005c50:	2202      	movs	r2, #2
34005c52:	731a      	strb	r2, [r3, #12]

      /* Update the DMA channel and the queue error codes */
      hdma->ErrorCode                  = HAL_DMA_ERROR_NONE;
34005c54:	687b      	ldr	r3, [r7, #4]
34005c56:	2200      	movs	r2, #0
34005c58:	659a      	str	r2, [r3, #88]	@ 0x58
      hdma->LinkedListQueue->ErrorCode = HAL_DMA_QUEUE_ERROR_NONE;
34005c5a:	687b      	ldr	r3, [r7, #4]
34005c5c:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34005c5e:	2200      	movs	r2, #0
34005c60:	611a      	str	r2, [r3, #16]

      /* Enable common interrupts: Transfer Complete and Transfer Errors ITs */
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_DTE | DMA_IT_ULE | DMA_IT_USE | DMA_IT_TO));
34005c62:	687b      	ldr	r3, [r7, #4]
34005c64:	681b      	ldr	r3, [r3, #0]
34005c66:	695a      	ldr	r2, [r3, #20]
34005c68:	687b      	ldr	r3, [r7, #4]
34005c6a:	681b      	ldr	r3, [r3, #0]
34005c6c:	f442 42ba 	orr.w	r2, r2, #23808	@ 0x5d00
34005c70:	615a      	str	r2, [r3, #20]

      /* Check half transfer complete callback */
      if (hdma->XferHalfCpltCallback != NULL)
34005c72:	687b      	ldr	r3, [r7, #4]
34005c74:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34005c76:	2b00      	cmp	r3, #0
34005c78:	d007      	beq.n	34005c8a <HAL_DMAEx_List_Start_IT+0xa8>
      {
        /* If half transfer complete callback is set, enable the corresponding IT */
        __HAL_DMA_ENABLE_IT(hdma, DMA_IT_HT);
34005c7a:	687b      	ldr	r3, [r7, #4]
34005c7c:	681b      	ldr	r3, [r3, #0]
34005c7e:	695a      	ldr	r2, [r3, #20]
34005c80:	687b      	ldr	r3, [r7, #4]
34005c82:	681b      	ldr	r3, [r3, #0]
34005c84:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
34005c88:	615a      	str	r2, [r3, #20]
      }

      /* Check suspend callback */
      if (hdma->XferSuspendCallback != NULL)
34005c8a:	687b      	ldr	r3, [r7, #4]
34005c8c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34005c8e:	2b00      	cmp	r3, #0
34005c90:	d007      	beq.n	34005ca2 <HAL_DMAEx_List_Start_IT+0xc0>
      {
        /* If transfer suspend callback is set, enable the corresponding IT */
        __HAL_DMA_ENABLE_IT(hdma, DMA_IT_SUSP);
34005c92:	687b      	ldr	r3, [r7, #4]
34005c94:	681b      	ldr	r3, [r3, #0]
34005c96:	695a      	ldr	r2, [r3, #20]
34005c98:	687b      	ldr	r3, [r7, #4]
34005c9a:	681b      	ldr	r3, [r3, #0]
34005c9c:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
34005ca0:	615a      	str	r2, [r3, #20]
      }

      /* Get CLLR register mask and offset */
      DMA_List_GetCLLRNodeInfo(hdma->LinkedListQueue->Head, &cllr_mask, NULL);
34005ca2:	687b      	ldr	r3, [r7, #4]
34005ca4:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34005ca6:	681b      	ldr	r3, [r3, #0]
34005ca8:	f107 010c 	add.w	r1, r7, #12
34005cac:	2200      	movs	r2, #0
34005cae:	4618      	mov	r0, r3
34005cb0:	f000 f82c 	bl	34005d0c <DMA_List_GetCLLRNodeInfo>

      /* Update DMA registers for linked-list transfer */
      hdma->Instance->CLBAR = ((uint32_t)hdma->LinkedListQueue->Head & DMA_CLBAR_LBA);
34005cb4:	687b      	ldr	r3, [r7, #4]
34005cb6:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34005cb8:	681b      	ldr	r3, [r3, #0]
34005cba:	4619      	mov	r1, r3
34005cbc:	687b      	ldr	r3, [r7, #4]
34005cbe:	681a      	ldr	r2, [r3, #0]
34005cc0:	0c0b      	lsrs	r3, r1, #16
34005cc2:	041b      	lsls	r3, r3, #16
34005cc4:	6013      	str	r3, [r2, #0]
      hdma->Instance->CLLR  = ((uint32_t)hdma->LinkedListQueue->Head & DMA_CLLR_LA) | cllr_mask;
34005cc6:	687b      	ldr	r3, [r7, #4]
34005cc8:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34005cca:	681b      	ldr	r3, [r3, #0]
34005ccc:	461a      	mov	r2, r3
34005cce:	f64f 73fc 	movw	r3, #65532	@ 0xfffc
34005cd2:	4013      	ands	r3, r2
34005cd4:	68f9      	ldr	r1, [r7, #12]
34005cd6:	687a      	ldr	r2, [r7, #4]
34005cd8:	6812      	ldr	r2, [r2, #0]
34005cda:	430b      	orrs	r3, r1
34005cdc:	67d3      	str	r3, [r2, #124]	@ 0x7c
    }

    /* Enable DMA channel */
    __HAL_DMA_ENABLE(hdma);
34005cde:	687b      	ldr	r3, [r7, #4]
34005ce0:	681b      	ldr	r3, [r3, #0]
34005ce2:	695a      	ldr	r2, [r3, #20]
34005ce4:	687b      	ldr	r3, [r7, #4]
34005ce6:	681b      	ldr	r3, [r3, #0]
34005ce8:	f042 0201 	orr.w	r2, r2, #1
34005cec:	615a      	str	r2, [r3, #20]
    __HAL_UNLOCK(hdma);

    return HAL_ERROR;
  }

  return HAL_OK;
34005cee:	2300      	movs	r3, #0
34005cf0:	e007      	b.n	34005d02 <HAL_DMAEx_List_Start_IT+0x120>
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
34005cf2:	687b      	ldr	r3, [r7, #4]
34005cf4:	2240      	movs	r2, #64	@ 0x40
34005cf6:	659a      	str	r2, [r3, #88]	@ 0x58
    __HAL_UNLOCK(hdma);
34005cf8:	687b      	ldr	r3, [r7, #4]
34005cfa:	2200      	movs	r2, #0
34005cfc:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c
    return HAL_ERROR;
34005d00:	2301      	movs	r3, #1
}
34005d02:	4618      	mov	r0, r3
34005d04:	3718      	adds	r7, #24
34005d06:	46bd      	mov	sp, r7
34005d08:	bd80      	pop	{r7, pc}
	...

34005d0c <DMA_List_GetCLLRNodeInfo>:
  * @retval None.
  */
static void DMA_List_GetCLLRNodeInfo(DMA_NodeTypeDef const *const pNode,
                                     uint32_t *const cllr_mask,
                                     uint32_t *const cllr_offset)
{
34005d0c:	b480      	push	{r7}
34005d0e:	b085      	sub	sp, #20
34005d10:	af00      	add	r7, sp, #0
34005d12:	60f8      	str	r0, [r7, #12]
34005d14:	60b9      	str	r1, [r7, #8]
34005d16:	607a      	str	r2, [r7, #4]
  /* Check node type */
  if ((pNode->NodeInfo & DMA_CHANNEL_TYPE_2D_ADDR) == DMA_CHANNEL_TYPE_2D_ADDR)
34005d18:	68fb      	ldr	r3, [r7, #12]
34005d1a:	6a1b      	ldr	r3, [r3, #32]
34005d1c:	f003 0302 	and.w	r3, r3, #2
34005d20:	2b00      	cmp	r3, #0
34005d22:	d00c      	beq.n	34005d3e <DMA_List_GetCLLRNodeInfo+0x32>
  {
    /* Update CLLR register mask value */
    if (cllr_mask != NULL)
34005d24:	68bb      	ldr	r3, [r7, #8]
34005d26:	2b00      	cmp	r3, #0
34005d28:	d002      	beq.n	34005d30 <DMA_List_GetCLLRNodeInfo+0x24>
    {
      *cllr_mask = DMA_CLLR_UT1 | DMA_CLLR_UT2 | DMA_CLLR_UB1 | DMA_CLLR_USA | DMA_CLLR_UDA | DMA_CLLR_UT3 |
34005d2a:	68bb      	ldr	r3, [r7, #8]
34005d2c:	4a0d      	ldr	r2, [pc, #52]	@ (34005d64 <DMA_List_GetCLLRNodeInfo+0x58>)
34005d2e:	601a      	str	r2, [r3, #0]
                   DMA_CLLR_UB2 | DMA_CLLR_ULL;
    }

    /* Update CLLR register offset */
    if (cllr_offset != NULL)
34005d30:	687b      	ldr	r3, [r7, #4]
34005d32:	2b00      	cmp	r3, #0
34005d34:	d00f      	beq.n	34005d56 <DMA_List_GetCLLRNodeInfo+0x4a>
    {
      *cllr_offset = NODE_CLLR_2D_DEFAULT_OFFSET;
34005d36:	687b      	ldr	r3, [r7, #4]
34005d38:	2207      	movs	r2, #7
34005d3a:	601a      	str	r2, [r3, #0]
    if (cllr_offset != NULL)
    {
      *cllr_offset = NODE_CLLR_LINEAR_DEFAULT_OFFSET;
    }
  }
}
34005d3c:	e00b      	b.n	34005d56 <DMA_List_GetCLLRNodeInfo+0x4a>
    if (cllr_mask != NULL)
34005d3e:	68bb      	ldr	r3, [r7, #8]
34005d40:	2b00      	cmp	r3, #0
34005d42:	d002      	beq.n	34005d4a <DMA_List_GetCLLRNodeInfo+0x3e>
      *cllr_mask = DMA_CLLR_UT1 | DMA_CLLR_UT2 | DMA_CLLR_UB1 | DMA_CLLR_USA | DMA_CLLR_UDA | DMA_CLLR_ULL;
34005d44:	68bb      	ldr	r3, [r7, #8]
34005d46:	4a08      	ldr	r2, [pc, #32]	@ (34005d68 <DMA_List_GetCLLRNodeInfo+0x5c>)
34005d48:	601a      	str	r2, [r3, #0]
    if (cllr_offset != NULL)
34005d4a:	687b      	ldr	r3, [r7, #4]
34005d4c:	2b00      	cmp	r3, #0
34005d4e:	d002      	beq.n	34005d56 <DMA_List_GetCLLRNodeInfo+0x4a>
      *cllr_offset = NODE_CLLR_LINEAR_DEFAULT_OFFSET;
34005d50:	687b      	ldr	r3, [r7, #4]
34005d52:	2205      	movs	r2, #5
34005d54:	601a      	str	r2, [r3, #0]
}
34005d56:	bf00      	nop
34005d58:	3714      	adds	r7, #20
34005d5a:	46bd      	mov	sp, r7
34005d5c:	f85d 7b04 	ldr.w	r7, [sp], #4
34005d60:	4770      	bx	lr
34005d62:	bf00      	nop
34005d64:	fe010000 	.word	0xfe010000
34005d68:	f8010000 	.word	0xf8010000

34005d6c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
34005d6c:	b580      	push	{r7, lr}
34005d6e:	b086      	sub	sp, #24
34005d70:	af00      	add	r7, sp, #0
34005d72:	6078      	str	r0, [r7, #4]
34005d74:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
34005d76:	2300      	movs	r3, #0
34005d78:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent;
  uint32_t temp;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
34005d7a:	687b      	ldr	r3, [r7, #4]
34005d7c:	4a5b      	ldr	r2, [pc, #364]	@ (34005eec <HAL_GPIO_Init+0x180>)
34005d7e:	4293      	cmp	r3, r2
34005d80:	d05f      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005d82:	687b      	ldr	r3, [r7, #4]
34005d84:	4a5a      	ldr	r2, [pc, #360]	@ (34005ef0 <HAL_GPIO_Init+0x184>)
34005d86:	4293      	cmp	r3, r2
34005d88:	d05b      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005d8a:	687b      	ldr	r3, [r7, #4]
34005d8c:	4a59      	ldr	r2, [pc, #356]	@ (34005ef4 <HAL_GPIO_Init+0x188>)
34005d8e:	4293      	cmp	r3, r2
34005d90:	d057      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005d92:	687b      	ldr	r3, [r7, #4]
34005d94:	4a58      	ldr	r2, [pc, #352]	@ (34005ef8 <HAL_GPIO_Init+0x18c>)
34005d96:	4293      	cmp	r3, r2
34005d98:	d053      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005d9a:	687b      	ldr	r3, [r7, #4]
34005d9c:	4a57      	ldr	r2, [pc, #348]	@ (34005efc <HAL_GPIO_Init+0x190>)
34005d9e:	4293      	cmp	r3, r2
34005da0:	d04f      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005da2:	687b      	ldr	r3, [r7, #4]
34005da4:	4a56      	ldr	r2, [pc, #344]	@ (34005f00 <HAL_GPIO_Init+0x194>)
34005da6:	4293      	cmp	r3, r2
34005da8:	d04b      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005daa:	687b      	ldr	r3, [r7, #4]
34005dac:	4a55      	ldr	r2, [pc, #340]	@ (34005f04 <HAL_GPIO_Init+0x198>)
34005dae:	4293      	cmp	r3, r2
34005db0:	d047      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005db2:	687b      	ldr	r3, [r7, #4]
34005db4:	4a54      	ldr	r2, [pc, #336]	@ (34005f08 <HAL_GPIO_Init+0x19c>)
34005db6:	4293      	cmp	r3, r2
34005db8:	d043      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005dba:	687b      	ldr	r3, [r7, #4]
34005dbc:	4a53      	ldr	r2, [pc, #332]	@ (34005f0c <HAL_GPIO_Init+0x1a0>)
34005dbe:	4293      	cmp	r3, r2
34005dc0:	d03f      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005dc2:	687b      	ldr	r3, [r7, #4]
34005dc4:	4a52      	ldr	r2, [pc, #328]	@ (34005f10 <HAL_GPIO_Init+0x1a4>)
34005dc6:	4293      	cmp	r3, r2
34005dc8:	d03b      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005dca:	687b      	ldr	r3, [r7, #4]
34005dcc:	4a51      	ldr	r2, [pc, #324]	@ (34005f14 <HAL_GPIO_Init+0x1a8>)
34005dce:	4293      	cmp	r3, r2
34005dd0:	d037      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005dd2:	687b      	ldr	r3, [r7, #4]
34005dd4:	4a50      	ldr	r2, [pc, #320]	@ (34005f18 <HAL_GPIO_Init+0x1ac>)
34005dd6:	4293      	cmp	r3, r2
34005dd8:	d033      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005dda:	687b      	ldr	r3, [r7, #4]
34005ddc:	4a4f      	ldr	r2, [pc, #316]	@ (34005f1c <HAL_GPIO_Init+0x1b0>)
34005dde:	4293      	cmp	r3, r2
34005de0:	d02f      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005de2:	687b      	ldr	r3, [r7, #4]
34005de4:	4a4e      	ldr	r2, [pc, #312]	@ (34005f20 <HAL_GPIO_Init+0x1b4>)
34005de6:	4293      	cmp	r3, r2
34005de8:	d02b      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005dea:	687b      	ldr	r3, [r7, #4]
34005dec:	4a4d      	ldr	r2, [pc, #308]	@ (34005f24 <HAL_GPIO_Init+0x1b8>)
34005dee:	4293      	cmp	r3, r2
34005df0:	d027      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005df2:	687b      	ldr	r3, [r7, #4]
34005df4:	4a4c      	ldr	r2, [pc, #304]	@ (34005f28 <HAL_GPIO_Init+0x1bc>)
34005df6:	4293      	cmp	r3, r2
34005df8:	d023      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005dfa:	687b      	ldr	r3, [r7, #4]
34005dfc:	4a4b      	ldr	r2, [pc, #300]	@ (34005f2c <HAL_GPIO_Init+0x1c0>)
34005dfe:	4293      	cmp	r3, r2
34005e00:	d01f      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005e02:	687b      	ldr	r3, [r7, #4]
34005e04:	4a4a      	ldr	r2, [pc, #296]	@ (34005f30 <HAL_GPIO_Init+0x1c4>)
34005e06:	4293      	cmp	r3, r2
34005e08:	d01b      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005e0a:	687b      	ldr	r3, [r7, #4]
34005e0c:	4a49      	ldr	r2, [pc, #292]	@ (34005f34 <HAL_GPIO_Init+0x1c8>)
34005e0e:	4293      	cmp	r3, r2
34005e10:	d017      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005e12:	687b      	ldr	r3, [r7, #4]
34005e14:	4a48      	ldr	r2, [pc, #288]	@ (34005f38 <HAL_GPIO_Init+0x1cc>)
34005e16:	4293      	cmp	r3, r2
34005e18:	d013      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005e1a:	687b      	ldr	r3, [r7, #4]
34005e1c:	4a47      	ldr	r2, [pc, #284]	@ (34005f3c <HAL_GPIO_Init+0x1d0>)
34005e1e:	4293      	cmp	r3, r2
34005e20:	d00f      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005e22:	687b      	ldr	r3, [r7, #4]
34005e24:	4a46      	ldr	r2, [pc, #280]	@ (34005f40 <HAL_GPIO_Init+0x1d4>)
34005e26:	4293      	cmp	r3, r2
34005e28:	d00b      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005e2a:	687b      	ldr	r3, [r7, #4]
34005e2c:	4a45      	ldr	r2, [pc, #276]	@ (34005f44 <HAL_GPIO_Init+0x1d8>)
34005e2e:	4293      	cmp	r3, r2
34005e30:	d007      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005e32:	687b      	ldr	r3, [r7, #4]
34005e34:	4a44      	ldr	r2, [pc, #272]	@ (34005f48 <HAL_GPIO_Init+0x1dc>)
34005e36:	4293      	cmp	r3, r2
34005e38:	d003      	beq.n	34005e42 <HAL_GPIO_Init+0xd6>
34005e3a:	21ad      	movs	r1, #173	@ 0xad
34005e3c:	4843      	ldr	r0, [pc, #268]	@ (34005f4c <HAL_GPIO_Init+0x1e0>)
34005e3e:	f7fc f8e7 	bl	34002010 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
34005e42:	683b      	ldr	r3, [r7, #0]
34005e44:	681b      	ldr	r3, [r3, #0]
34005e46:	b29b      	uxth	r3, r3
34005e48:	2b00      	cmp	r3, #0
34005e4a:	d004      	beq.n	34005e56 <HAL_GPIO_Init+0xea>
34005e4c:	683b      	ldr	r3, [r7, #0]
34005e4e:	681b      	ldr	r3, [r3, #0]
34005e50:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34005e54:	d303      	bcc.n	34005e5e <HAL_GPIO_Init+0xf2>
34005e56:	21ae      	movs	r1, #174	@ 0xae
34005e58:	483c      	ldr	r0, [pc, #240]	@ (34005f4c <HAL_GPIO_Init+0x1e0>)
34005e5a:	f7fc f8d9 	bl	34002010 <assert_failed>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
34005e5e:	683b      	ldr	r3, [r7, #0]
34005e60:	685b      	ldr	r3, [r3, #4]
34005e62:	2b00      	cmp	r3, #0
34005e64:	f000 82bb 	beq.w	340063de <HAL_GPIO_Init+0x672>
34005e68:	683b      	ldr	r3, [r7, #0]
34005e6a:	685b      	ldr	r3, [r3, #4]
34005e6c:	2b01      	cmp	r3, #1
34005e6e:	f000 82b6 	beq.w	340063de <HAL_GPIO_Init+0x672>
34005e72:	683b      	ldr	r3, [r7, #0]
34005e74:	685b      	ldr	r3, [r3, #4]
34005e76:	2b11      	cmp	r3, #17
34005e78:	f000 82b1 	beq.w	340063de <HAL_GPIO_Init+0x672>
34005e7c:	683b      	ldr	r3, [r7, #0]
34005e7e:	685b      	ldr	r3, [r3, #4]
34005e80:	2b02      	cmp	r3, #2
34005e82:	f000 82ac 	beq.w	340063de <HAL_GPIO_Init+0x672>
34005e86:	683b      	ldr	r3, [r7, #0]
34005e88:	685b      	ldr	r3, [r3, #4]
34005e8a:	2b12      	cmp	r3, #18
34005e8c:	f000 82a7 	beq.w	340063de <HAL_GPIO_Init+0x672>
34005e90:	683b      	ldr	r3, [r7, #0]
34005e92:	685b      	ldr	r3, [r3, #4]
34005e94:	f5b3 1f88 	cmp.w	r3, #1114112	@ 0x110000
34005e98:	f000 82a1 	beq.w	340063de <HAL_GPIO_Init+0x672>
34005e9c:	683b      	ldr	r3, [r7, #0]
34005e9e:	685b      	ldr	r3, [r3, #4]
34005ea0:	f5b3 1f04 	cmp.w	r3, #2162688	@ 0x210000
34005ea4:	f000 829b 	beq.w	340063de <HAL_GPIO_Init+0x672>
34005ea8:	683b      	ldr	r3, [r7, #0]
34005eaa:	685b      	ldr	r3, [r3, #4]
34005eac:	f5b3 1f44 	cmp.w	r3, #3211264	@ 0x310000
34005eb0:	f000 8295 	beq.w	340063de <HAL_GPIO_Init+0x672>
34005eb4:	683b      	ldr	r3, [r7, #0]
34005eb6:	685b      	ldr	r3, [r3, #4]
34005eb8:	f5b3 1f90 	cmp.w	r3, #1179648	@ 0x120000
34005ebc:	f000 828f 	beq.w	340063de <HAL_GPIO_Init+0x672>
34005ec0:	683b      	ldr	r3, [r7, #0]
34005ec2:	685b      	ldr	r3, [r3, #4]
34005ec4:	f5b3 1f08 	cmp.w	r3, #2228224	@ 0x220000
34005ec8:	f000 8289 	beq.w	340063de <HAL_GPIO_Init+0x672>
34005ecc:	683b      	ldr	r3, [r7, #0]
34005ece:	685b      	ldr	r3, [r3, #4]
34005ed0:	f5b3 1f48 	cmp.w	r3, #3276800	@ 0x320000
34005ed4:	f000 8283 	beq.w	340063de <HAL_GPIO_Init+0x672>
34005ed8:	683b      	ldr	r3, [r7, #0]
34005eda:	685b      	ldr	r3, [r3, #4]
34005edc:	2b03      	cmp	r3, #3
34005ede:	f000 827e 	beq.w	340063de <HAL_GPIO_Init+0x672>
34005ee2:	21af      	movs	r1, #175	@ 0xaf
34005ee4:	4819      	ldr	r0, [pc, #100]	@ (34005f4c <HAL_GPIO_Init+0x1e0>)
34005ee6:	f7fc f893 	bl	34002010 <assert_failed>

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
34005eea:	e278      	b.n	340063de <HAL_GPIO_Init+0x672>
34005eec:	56020000 	.word	0x56020000
34005ef0:	46020000 	.word	0x46020000
34005ef4:	56020400 	.word	0x56020400
34005ef8:	46020400 	.word	0x46020400
34005efc:	56020800 	.word	0x56020800
34005f00:	46020800 	.word	0x46020800
34005f04:	56020c00 	.word	0x56020c00
34005f08:	46020c00 	.word	0x46020c00
34005f0c:	56021000 	.word	0x56021000
34005f10:	46021000 	.word	0x46021000
34005f14:	56021400 	.word	0x56021400
34005f18:	46021400 	.word	0x46021400
34005f1c:	56021800 	.word	0x56021800
34005f20:	46021800 	.word	0x46021800
34005f24:	56021c00 	.word	0x56021c00
34005f28:	46021c00 	.word	0x46021c00
34005f2c:	56023400 	.word	0x56023400
34005f30:	46023400 	.word	0x46023400
34005f34:	56023800 	.word	0x56023800
34005f38:	46023800 	.word	0x46023800
34005f3c:	56023c00 	.word	0x56023c00
34005f40:	46023c00 	.word	0x46023c00
34005f44:	56024000 	.word	0x56024000
34005f48:	46024000 	.word	0x46024000
34005f4c:	3401ebb4 	.word	0x3401ebb4
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
34005f50:	683b      	ldr	r3, [r7, #0]
34005f52:	681a      	ldr	r2, [r3, #0]
34005f54:	2101      	movs	r1, #1
34005f56:	697b      	ldr	r3, [r7, #20]
34005f58:	fa01 f303 	lsl.w	r3, r1, r3
34005f5c:	4013      	ands	r3, r2
34005f5e:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
34005f60:	68fb      	ldr	r3, [r7, #12]
34005f62:	2b00      	cmp	r3, #0
34005f64:	f000 8238 	beq.w	340063d8 <HAL_GPIO_Init+0x66c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
34005f68:	683b      	ldr	r3, [r7, #0]
34005f6a:	685b      	ldr	r3, [r3, #4]
34005f6c:	f003 0303 	and.w	r3, r3, #3
34005f70:	2b01      	cmp	r3, #1
34005f72:	d005      	beq.n	34005f80 <HAL_GPIO_Init+0x214>
34005f74:	683b      	ldr	r3, [r7, #0]
34005f76:	685b      	ldr	r3, [r3, #4]
34005f78:	f003 0303 	and.w	r3, r3, #3
34005f7c:	2b02      	cmp	r3, #2
34005f7e:	d144      	bne.n	3400600a <HAL_GPIO_Init+0x29e>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
34005f80:	683b      	ldr	r3, [r7, #0]
34005f82:	68db      	ldr	r3, [r3, #12]
34005f84:	2b00      	cmp	r3, #0
34005f86:	d00f      	beq.n	34005fa8 <HAL_GPIO_Init+0x23c>
34005f88:	683b      	ldr	r3, [r7, #0]
34005f8a:	68db      	ldr	r3, [r3, #12]
34005f8c:	2b01      	cmp	r3, #1
34005f8e:	d00b      	beq.n	34005fa8 <HAL_GPIO_Init+0x23c>
34005f90:	683b      	ldr	r3, [r7, #0]
34005f92:	68db      	ldr	r3, [r3, #12]
34005f94:	2b02      	cmp	r3, #2
34005f96:	d007      	beq.n	34005fa8 <HAL_GPIO_Init+0x23c>
34005f98:	683b      	ldr	r3, [r7, #0]
34005f9a:	68db      	ldr	r3, [r3, #12]
34005f9c:	2b03      	cmp	r3, #3
34005f9e:	d003      	beq.n	34005fa8 <HAL_GPIO_Init+0x23c>
34005fa0:	21be      	movs	r1, #190	@ 0xbe
34005fa2:	4896      	ldr	r0, [pc, #600]	@ (340061fc <HAL_GPIO_Init+0x490>)
34005fa4:	f7fc f834 	bl	34002010 <assert_failed>

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
34005fa8:	687b      	ldr	r3, [r7, #4]
34005faa:	689b      	ldr	r3, [r3, #8]
34005fac:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34005fae:	697b      	ldr	r3, [r7, #20]
34005fb0:	005b      	lsls	r3, r3, #1
34005fb2:	2203      	movs	r2, #3
34005fb4:	fa02 f303 	lsl.w	r3, r2, r3
34005fb8:	43db      	mvns	r3, r3
34005fba:	693a      	ldr	r2, [r7, #16]
34005fbc:	4013      	ands	r3, r2
34005fbe:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34005fc0:	683b      	ldr	r3, [r7, #0]
34005fc2:	68da      	ldr	r2, [r3, #12]
34005fc4:	697b      	ldr	r3, [r7, #20]
34005fc6:	005b      	lsls	r3, r3, #1
34005fc8:	fa02 f303 	lsl.w	r3, r2, r3
34005fcc:	693a      	ldr	r2, [r7, #16]
34005fce:	4313      	orrs	r3, r2
34005fd0:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
34005fd2:	687b      	ldr	r3, [r7, #4]
34005fd4:	693a      	ldr	r2, [r7, #16]
34005fd6:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
34005fd8:	687b      	ldr	r3, [r7, #4]
34005fda:	685b      	ldr	r3, [r3, #4]
34005fdc:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
34005fde:	2201      	movs	r2, #1
34005fe0:	697b      	ldr	r3, [r7, #20]
34005fe2:	fa02 f303 	lsl.w	r3, r2, r3
34005fe6:	43db      	mvns	r3, r3
34005fe8:	693a      	ldr	r2, [r7, #16]
34005fea:	4013      	ands	r3, r2
34005fec:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
34005fee:	683b      	ldr	r3, [r7, #0]
34005ff0:	685b      	ldr	r3, [r3, #4]
34005ff2:	091b      	lsrs	r3, r3, #4
34005ff4:	f003 0201 	and.w	r2, r3, #1
34005ff8:	697b      	ldr	r3, [r7, #20]
34005ffa:	fa02 f303 	lsl.w	r3, r2, r3
34005ffe:	693a      	ldr	r2, [r7, #16]
34006000:	4313      	orrs	r3, r2
34006002:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
34006004:	687b      	ldr	r3, [r7, #4]
34006006:	693a      	ldr	r2, [r7, #16]
34006008:	605a      	str	r2, [r3, #4]
      }

      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
3400600a:	683b      	ldr	r3, [r7, #0]
3400600c:	685b      	ldr	r3, [r3, #4]
3400600e:	f003 0303 	and.w	r3, r3, #3
34006012:	2b03      	cmp	r3, #3
34006014:	d109      	bne.n	3400602a <HAL_GPIO_Init+0x2be>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
34006016:	683b      	ldr	r3, [r7, #0]
34006018:	685b      	ldr	r3, [r3, #4]
3400601a:	f003 0303 	and.w	r3, r3, #3
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
3400601e:	2b03      	cmp	r3, #3
34006020:	d12b      	bne.n	3400607a <HAL_GPIO_Init+0x30e>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
34006022:	683b      	ldr	r3, [r7, #0]
34006024:	689b      	ldr	r3, [r3, #8]
34006026:	2b01      	cmp	r3, #1
34006028:	d027      	beq.n	3400607a <HAL_GPIO_Init+0x30e>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
3400602a:	683b      	ldr	r3, [r7, #0]
3400602c:	689b      	ldr	r3, [r3, #8]
3400602e:	2b00      	cmp	r3, #0
34006030:	d00b      	beq.n	3400604a <HAL_GPIO_Init+0x2de>
34006032:	683b      	ldr	r3, [r7, #0]
34006034:	689b      	ldr	r3, [r3, #8]
34006036:	2b01      	cmp	r3, #1
34006038:	d007      	beq.n	3400604a <HAL_GPIO_Init+0x2de>
3400603a:	683b      	ldr	r3, [r7, #0]
3400603c:	689b      	ldr	r3, [r3, #8]
3400603e:	2b02      	cmp	r3, #2
34006040:	d003      	beq.n	3400604a <HAL_GPIO_Init+0x2de>
34006042:	21d1      	movs	r1, #209	@ 0xd1
34006044:	486d      	ldr	r0, [pc, #436]	@ (340061fc <HAL_GPIO_Init+0x490>)
34006046:	f7fb ffe3 	bl	34002010 <assert_failed>

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
3400604a:	687b      	ldr	r3, [r7, #4]
3400604c:	68db      	ldr	r3, [r3, #12]
3400604e:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
34006050:	697b      	ldr	r3, [r7, #20]
34006052:	005b      	lsls	r3, r3, #1
34006054:	2203      	movs	r2, #3
34006056:	fa02 f303 	lsl.w	r3, r2, r3
3400605a:	43db      	mvns	r3, r3
3400605c:	693a      	ldr	r2, [r7, #16]
3400605e:	4013      	ands	r3, r2
34006060:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
34006062:	683b      	ldr	r3, [r7, #0]
34006064:	689a      	ldr	r2, [r3, #8]
34006066:	697b      	ldr	r3, [r7, #20]
34006068:	005b      	lsls	r3, r3, #1
3400606a:	fa02 f303 	lsl.w	r3, r2, r3
3400606e:	693a      	ldr	r2, [r7, #16]
34006070:	4313      	orrs	r3, r2
34006072:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
34006074:	687b      	ldr	r3, [r7, #4]
34006076:	693a      	ldr	r2, [r7, #16]
34006078:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
3400607a:	683b      	ldr	r3, [r7, #0]
3400607c:	685b      	ldr	r3, [r3, #4]
3400607e:	f003 0303 	and.w	r3, r3, #3
34006082:	2b02      	cmp	r3, #2
34006084:	f040 8090 	bne.w	340061a8 <HAL_GPIO_Init+0x43c>
      {
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
34006088:	687b      	ldr	r3, [r7, #4]
3400608a:	4a5d      	ldr	r2, [pc, #372]	@ (34006200 <HAL_GPIO_Init+0x494>)
3400608c:	4293      	cmp	r3, r2
3400608e:	d05f      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
34006090:	687b      	ldr	r3, [r7, #4]
34006092:	4a5c      	ldr	r2, [pc, #368]	@ (34006204 <HAL_GPIO_Init+0x498>)
34006094:	4293      	cmp	r3, r2
34006096:	d05b      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
34006098:	687b      	ldr	r3, [r7, #4]
3400609a:	4a5b      	ldr	r2, [pc, #364]	@ (34006208 <HAL_GPIO_Init+0x49c>)
3400609c:	4293      	cmp	r3, r2
3400609e:	d057      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
340060a0:	687b      	ldr	r3, [r7, #4]
340060a2:	4a5a      	ldr	r2, [pc, #360]	@ (3400620c <HAL_GPIO_Init+0x4a0>)
340060a4:	4293      	cmp	r3, r2
340060a6:	d053      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
340060a8:	687b      	ldr	r3, [r7, #4]
340060aa:	4a59      	ldr	r2, [pc, #356]	@ (34006210 <HAL_GPIO_Init+0x4a4>)
340060ac:	4293      	cmp	r3, r2
340060ae:	d04f      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
340060b0:	687b      	ldr	r3, [r7, #4]
340060b2:	4a58      	ldr	r2, [pc, #352]	@ (34006214 <HAL_GPIO_Init+0x4a8>)
340060b4:	4293      	cmp	r3, r2
340060b6:	d04b      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
340060b8:	687b      	ldr	r3, [r7, #4]
340060ba:	4a57      	ldr	r2, [pc, #348]	@ (34006218 <HAL_GPIO_Init+0x4ac>)
340060bc:	4293      	cmp	r3, r2
340060be:	d047      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
340060c0:	687b      	ldr	r3, [r7, #4]
340060c2:	4a56      	ldr	r2, [pc, #344]	@ (3400621c <HAL_GPIO_Init+0x4b0>)
340060c4:	4293      	cmp	r3, r2
340060c6:	d043      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
340060c8:	687b      	ldr	r3, [r7, #4]
340060ca:	4a55      	ldr	r2, [pc, #340]	@ (34006220 <HAL_GPIO_Init+0x4b4>)
340060cc:	4293      	cmp	r3, r2
340060ce:	d03f      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
340060d0:	687b      	ldr	r3, [r7, #4]
340060d2:	4a54      	ldr	r2, [pc, #336]	@ (34006224 <HAL_GPIO_Init+0x4b8>)
340060d4:	4293      	cmp	r3, r2
340060d6:	d03b      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
340060d8:	687b      	ldr	r3, [r7, #4]
340060da:	4a53      	ldr	r2, [pc, #332]	@ (34006228 <HAL_GPIO_Init+0x4bc>)
340060dc:	4293      	cmp	r3, r2
340060de:	d037      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
340060e0:	687b      	ldr	r3, [r7, #4]
340060e2:	4a52      	ldr	r2, [pc, #328]	@ (3400622c <HAL_GPIO_Init+0x4c0>)
340060e4:	4293      	cmp	r3, r2
340060e6:	d033      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
340060e8:	687b      	ldr	r3, [r7, #4]
340060ea:	4a51      	ldr	r2, [pc, #324]	@ (34006230 <HAL_GPIO_Init+0x4c4>)
340060ec:	4293      	cmp	r3, r2
340060ee:	d02f      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
340060f0:	687b      	ldr	r3, [r7, #4]
340060f2:	4a50      	ldr	r2, [pc, #320]	@ (34006234 <HAL_GPIO_Init+0x4c8>)
340060f4:	4293      	cmp	r3, r2
340060f6:	d02b      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
340060f8:	687b      	ldr	r3, [r7, #4]
340060fa:	4a4f      	ldr	r2, [pc, #316]	@ (34006238 <HAL_GPIO_Init+0x4cc>)
340060fc:	4293      	cmp	r3, r2
340060fe:	d027      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
34006100:	687b      	ldr	r3, [r7, #4]
34006102:	4a4e      	ldr	r2, [pc, #312]	@ (3400623c <HAL_GPIO_Init+0x4d0>)
34006104:	4293      	cmp	r3, r2
34006106:	d023      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
34006108:	687b      	ldr	r3, [r7, #4]
3400610a:	4a4d      	ldr	r2, [pc, #308]	@ (34006240 <HAL_GPIO_Init+0x4d4>)
3400610c:	4293      	cmp	r3, r2
3400610e:	d01f      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
34006110:	687b      	ldr	r3, [r7, #4]
34006112:	4a4c      	ldr	r2, [pc, #304]	@ (34006244 <HAL_GPIO_Init+0x4d8>)
34006114:	4293      	cmp	r3, r2
34006116:	d01b      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
34006118:	687b      	ldr	r3, [r7, #4]
3400611a:	4a4b      	ldr	r2, [pc, #300]	@ (34006248 <HAL_GPIO_Init+0x4dc>)
3400611c:	4293      	cmp	r3, r2
3400611e:	d017      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
34006120:	687b      	ldr	r3, [r7, #4]
34006122:	4a4a      	ldr	r2, [pc, #296]	@ (3400624c <HAL_GPIO_Init+0x4e0>)
34006124:	4293      	cmp	r3, r2
34006126:	d013      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
34006128:	687b      	ldr	r3, [r7, #4]
3400612a:	4a49      	ldr	r2, [pc, #292]	@ (34006250 <HAL_GPIO_Init+0x4e4>)
3400612c:	4293      	cmp	r3, r2
3400612e:	d00f      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
34006130:	687b      	ldr	r3, [r7, #4]
34006132:	4a48      	ldr	r2, [pc, #288]	@ (34006254 <HAL_GPIO_Init+0x4e8>)
34006134:	4293      	cmp	r3, r2
34006136:	d00b      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
34006138:	687b      	ldr	r3, [r7, #4]
3400613a:	4a47      	ldr	r2, [pc, #284]	@ (34006258 <HAL_GPIO_Init+0x4ec>)
3400613c:	4293      	cmp	r3, r2
3400613e:	d007      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
34006140:	687b      	ldr	r3, [r7, #4]
34006142:	4a46      	ldr	r2, [pc, #280]	@ (3400625c <HAL_GPIO_Init+0x4f0>)
34006144:	4293      	cmp	r3, r2
34006146:	d003      	beq.n	34006150 <HAL_GPIO_Init+0x3e4>
34006148:	21de      	movs	r1, #222	@ 0xde
3400614a:	482c      	ldr	r0, [pc, #176]	@ (340061fc <HAL_GPIO_Init+0x490>)
3400614c:	f7fb ff60 	bl	34002010 <assert_failed>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
34006150:	683b      	ldr	r3, [r7, #0]
34006152:	691b      	ldr	r3, [r3, #16]
34006154:	2b0f      	cmp	r3, #15
34006156:	d903      	bls.n	34006160 <HAL_GPIO_Init+0x3f4>
34006158:	21df      	movs	r1, #223	@ 0xdf
3400615a:	4828      	ldr	r0, [pc, #160]	@ (340061fc <HAL_GPIO_Init+0x490>)
3400615c:	f7fb ff58 	bl	34002010 <assert_failed>

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
34006160:	697b      	ldr	r3, [r7, #20]
34006162:	08da      	lsrs	r2, r3, #3
34006164:	687b      	ldr	r3, [r7, #4]
34006166:	3208      	adds	r2, #8
34006168:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
3400616c:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
3400616e:	697b      	ldr	r3, [r7, #20]
34006170:	f003 0307 	and.w	r3, r3, #7
34006174:	009b      	lsls	r3, r3, #2
34006176:	220f      	movs	r2, #15
34006178:	fa02 f303 	lsl.w	r3, r2, r3
3400617c:	43db      	mvns	r3, r3
3400617e:	693a      	ldr	r2, [r7, #16]
34006180:	4013      	ands	r3, r2
34006182:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34006184:	683b      	ldr	r3, [r7, #0]
34006186:	691a      	ldr	r2, [r3, #16]
34006188:	697b      	ldr	r3, [r7, #20]
3400618a:	f003 0307 	and.w	r3, r3, #7
3400618e:	009b      	lsls	r3, r3, #2
34006190:	fa02 f303 	lsl.w	r3, r2, r3
34006194:	693a      	ldr	r2, [r7, #16]
34006196:	4313      	orrs	r3, r2
34006198:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
3400619a:	697b      	ldr	r3, [r7, #20]
3400619c:	08da      	lsrs	r2, r3, #3
3400619e:	687b      	ldr	r3, [r7, #4]
340061a0:	3208      	adds	r2, #8
340061a2:	6939      	ldr	r1, [r7, #16]
340061a4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
340061a8:	687b      	ldr	r3, [r7, #4]
340061aa:	681b      	ldr	r3, [r3, #0]
340061ac:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
340061ae:	697b      	ldr	r3, [r7, #20]
340061b0:	005b      	lsls	r3, r3, #1
340061b2:	2203      	movs	r2, #3
340061b4:	fa02 f303 	lsl.w	r3, r2, r3
340061b8:	43db      	mvns	r3, r3
340061ba:	693a      	ldr	r2, [r7, #16]
340061bc:	4013      	ands	r3, r2
340061be:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
340061c0:	683b      	ldr	r3, [r7, #0]
340061c2:	685b      	ldr	r3, [r3, #4]
340061c4:	f003 0203 	and.w	r2, r3, #3
340061c8:	697b      	ldr	r3, [r7, #20]
340061ca:	005b      	lsls	r3, r3, #1
340061cc:	fa02 f303 	lsl.w	r3, r2, r3
340061d0:	693a      	ldr	r2, [r7, #16]
340061d2:	4313      	orrs	r3, r2
340061d4:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
340061d6:	687b      	ldr	r3, [r7, #4]
340061d8:	693a      	ldr	r2, [r7, #16]
340061da:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
340061dc:	683b      	ldr	r3, [r7, #0]
340061de:	685b      	ldr	r3, [r3, #4]
340061e0:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
340061e4:	2b00      	cmp	r3, #0
340061e6:	f000 80f7 	beq.w	340063d8 <HAL_GPIO_Init+0x66c>
      {
        temp = EXTI->EXTICR[position >> 2u];
340061ea:	4a1d      	ldr	r2, [pc, #116]	@ (34006260 <HAL_GPIO_Init+0x4f4>)
340061ec:	697b      	ldr	r3, [r7, #20]
340061ee:	089b      	lsrs	r3, r3, #2
340061f0:	3318      	adds	r3, #24
340061f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
340061f6:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
340061f8:	697b      	ldr	r3, [r7, #20]
340061fa:	e033      	b.n	34006264 <HAL_GPIO_Init+0x4f8>
340061fc:	3401ebb4 	.word	0x3401ebb4
34006200:	56020000 	.word	0x56020000
34006204:	46020000 	.word	0x46020000
34006208:	56020400 	.word	0x56020400
3400620c:	46020400 	.word	0x46020400
34006210:	56020800 	.word	0x56020800
34006214:	46020800 	.word	0x46020800
34006218:	56020c00 	.word	0x56020c00
3400621c:	46020c00 	.word	0x46020c00
34006220:	56021000 	.word	0x56021000
34006224:	46021000 	.word	0x46021000
34006228:	56021400 	.word	0x56021400
3400622c:	46021400 	.word	0x46021400
34006230:	56021800 	.word	0x56021800
34006234:	46021800 	.word	0x46021800
34006238:	56021c00 	.word	0x56021c00
3400623c:	46021c00 	.word	0x46021c00
34006240:	56023400 	.word	0x56023400
34006244:	46023400 	.word	0x46023400
34006248:	56023800 	.word	0x56023800
3400624c:	46023800 	.word	0x46023800
34006250:	56023c00 	.word	0x56023c00
34006254:	46023c00 	.word	0x46023c00
34006258:	56024000 	.word	0x56024000
3400625c:	46024000 	.word	0x46024000
34006260:	56025000 	.word	0x56025000
34006264:	f003 0303 	and.w	r3, r3, #3
34006268:	00db      	lsls	r3, r3, #3
3400626a:	220f      	movs	r2, #15
3400626c:	fa02 f303 	lsl.w	r3, r2, r3
34006270:	43db      	mvns	r3, r3
34006272:	693a      	ldr	r2, [r7, #16]
34006274:	4013      	ands	r3, r2
34006276:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34006278:	687b      	ldr	r3, [r7, #4]
3400627a:	4a5f      	ldr	r2, [pc, #380]	@ (340063f8 <HAL_GPIO_Init+0x68c>)
3400627c:	4293      	cmp	r3, r2
3400627e:	d043      	beq.n	34006308 <HAL_GPIO_Init+0x59c>
34006280:	687b      	ldr	r3, [r7, #4]
34006282:	4a5e      	ldr	r2, [pc, #376]	@ (340063fc <HAL_GPIO_Init+0x690>)
34006284:	4293      	cmp	r3, r2
34006286:	d03d      	beq.n	34006304 <HAL_GPIO_Init+0x598>
34006288:	687b      	ldr	r3, [r7, #4]
3400628a:	4a5d      	ldr	r2, [pc, #372]	@ (34006400 <HAL_GPIO_Init+0x694>)
3400628c:	4293      	cmp	r3, r2
3400628e:	d037      	beq.n	34006300 <HAL_GPIO_Init+0x594>
34006290:	687b      	ldr	r3, [r7, #4]
34006292:	4a5c      	ldr	r2, [pc, #368]	@ (34006404 <HAL_GPIO_Init+0x698>)
34006294:	4293      	cmp	r3, r2
34006296:	d031      	beq.n	340062fc <HAL_GPIO_Init+0x590>
34006298:	687b      	ldr	r3, [r7, #4]
3400629a:	4a5b      	ldr	r2, [pc, #364]	@ (34006408 <HAL_GPIO_Init+0x69c>)
3400629c:	4293      	cmp	r3, r2
3400629e:	d02b      	beq.n	340062f8 <HAL_GPIO_Init+0x58c>
340062a0:	687b      	ldr	r3, [r7, #4]
340062a2:	4a5a      	ldr	r2, [pc, #360]	@ (3400640c <HAL_GPIO_Init+0x6a0>)
340062a4:	4293      	cmp	r3, r2
340062a6:	d025      	beq.n	340062f4 <HAL_GPIO_Init+0x588>
340062a8:	687b      	ldr	r3, [r7, #4]
340062aa:	4a59      	ldr	r2, [pc, #356]	@ (34006410 <HAL_GPIO_Init+0x6a4>)
340062ac:	4293      	cmp	r3, r2
340062ae:	d01f      	beq.n	340062f0 <HAL_GPIO_Init+0x584>
340062b0:	687b      	ldr	r3, [r7, #4]
340062b2:	4a58      	ldr	r2, [pc, #352]	@ (34006414 <HAL_GPIO_Init+0x6a8>)
340062b4:	4293      	cmp	r3, r2
340062b6:	d019      	beq.n	340062ec <HAL_GPIO_Init+0x580>
340062b8:	687b      	ldr	r3, [r7, #4]
340062ba:	4a57      	ldr	r2, [pc, #348]	@ (34006418 <HAL_GPIO_Init+0x6ac>)
340062bc:	4293      	cmp	r3, r2
340062be:	d013      	beq.n	340062e8 <HAL_GPIO_Init+0x57c>
340062c0:	687b      	ldr	r3, [r7, #4]
340062c2:	4a56      	ldr	r2, [pc, #344]	@ (3400641c <HAL_GPIO_Init+0x6b0>)
340062c4:	4293      	cmp	r3, r2
340062c6:	d00d      	beq.n	340062e4 <HAL_GPIO_Init+0x578>
340062c8:	687b      	ldr	r3, [r7, #4]
340062ca:	4a55      	ldr	r2, [pc, #340]	@ (34006420 <HAL_GPIO_Init+0x6b4>)
340062cc:	4293      	cmp	r3, r2
340062ce:	d007      	beq.n	340062e0 <HAL_GPIO_Init+0x574>
340062d0:	687b      	ldr	r3, [r7, #4]
340062d2:	4a54      	ldr	r2, [pc, #336]	@ (34006424 <HAL_GPIO_Init+0x6b8>)
340062d4:	4293      	cmp	r3, r2
340062d6:	d101      	bne.n	340062dc <HAL_GPIO_Init+0x570>
340062d8:	230b      	movs	r3, #11
340062da:	e016      	b.n	3400630a <HAL_GPIO_Init+0x59e>
340062dc:	2310      	movs	r3, #16
340062de:	e014      	b.n	3400630a <HAL_GPIO_Init+0x59e>
340062e0:	230a      	movs	r3, #10
340062e2:	e012      	b.n	3400630a <HAL_GPIO_Init+0x59e>
340062e4:	2309      	movs	r3, #9
340062e6:	e010      	b.n	3400630a <HAL_GPIO_Init+0x59e>
340062e8:	2308      	movs	r3, #8
340062ea:	e00e      	b.n	3400630a <HAL_GPIO_Init+0x59e>
340062ec:	2307      	movs	r3, #7
340062ee:	e00c      	b.n	3400630a <HAL_GPIO_Init+0x59e>
340062f0:	2306      	movs	r3, #6
340062f2:	e00a      	b.n	3400630a <HAL_GPIO_Init+0x59e>
340062f4:	2305      	movs	r3, #5
340062f6:	e008      	b.n	3400630a <HAL_GPIO_Init+0x59e>
340062f8:	2304      	movs	r3, #4
340062fa:	e006      	b.n	3400630a <HAL_GPIO_Init+0x59e>
340062fc:	2303      	movs	r3, #3
340062fe:	e004      	b.n	3400630a <HAL_GPIO_Init+0x59e>
34006300:	2302      	movs	r3, #2
34006302:	e002      	b.n	3400630a <HAL_GPIO_Init+0x59e>
34006304:	2301      	movs	r3, #1
34006306:	e000      	b.n	3400630a <HAL_GPIO_Init+0x59e>
34006308:	2300      	movs	r3, #0
3400630a:	697a      	ldr	r2, [r7, #20]
3400630c:	f002 0203 	and.w	r2, r2, #3
34006310:	00d2      	lsls	r2, r2, #3
34006312:	4093      	lsls	r3, r2
34006314:	693a      	ldr	r2, [r7, #16]
34006316:	4313      	orrs	r3, r2
34006318:	613b      	str	r3, [r7, #16]
        EXTI->EXTICR[position >> 2u] = temp;
3400631a:	4943      	ldr	r1, [pc, #268]	@ (34006428 <HAL_GPIO_Init+0x6bc>)
3400631c:	697b      	ldr	r3, [r7, #20]
3400631e:	089b      	lsrs	r3, r3, #2
34006320:	3318      	adds	r3, #24
34006322:	693a      	ldr	r2, [r7, #16]
34006324:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
34006328:	4b3f      	ldr	r3, [pc, #252]	@ (34006428 <HAL_GPIO_Init+0x6bc>)
3400632a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400632e:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34006330:	68fb      	ldr	r3, [r7, #12]
34006332:	43db      	mvns	r3, r3
34006334:	693a      	ldr	r2, [r7, #16]
34006336:	4013      	ands	r3, r2
34006338:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
3400633a:	683b      	ldr	r3, [r7, #0]
3400633c:	685b      	ldr	r3, [r3, #4]
3400633e:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34006342:	2b00      	cmp	r3, #0
34006344:	d003      	beq.n	3400634e <HAL_GPIO_Init+0x5e2>
        {
          temp |= iocurrent;
34006346:	693a      	ldr	r2, [r7, #16]
34006348:	68fb      	ldr	r3, [r7, #12]
3400634a:	4313      	orrs	r3, r2
3400634c:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
3400634e:	4a36      	ldr	r2, [pc, #216]	@ (34006428 <HAL_GPIO_Init+0x6bc>)
34006350:	693b      	ldr	r3, [r7, #16]
34006352:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80

        temp = EXTI->EMR1;
34006356:	4b34      	ldr	r3, [pc, #208]	@ (34006428 <HAL_GPIO_Init+0x6bc>)
34006358:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3400635c:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
3400635e:	68fb      	ldr	r3, [r7, #12]
34006360:	43db      	mvns	r3, r3
34006362:	693a      	ldr	r2, [r7, #16]
34006364:	4013      	ands	r3, r2
34006366:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
34006368:	683b      	ldr	r3, [r7, #0]
3400636a:	685b      	ldr	r3, [r3, #4]
3400636c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34006370:	2b00      	cmp	r3, #0
34006372:	d003      	beq.n	3400637c <HAL_GPIO_Init+0x610>
        {
          temp |= iocurrent;
34006374:	693a      	ldr	r2, [r7, #16]
34006376:	68fb      	ldr	r3, [r7, #12]
34006378:	4313      	orrs	r3, r2
3400637a:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
3400637c:	4a2a      	ldr	r2, [pc, #168]	@ (34006428 <HAL_GPIO_Init+0x6bc>)
3400637e:	693b      	ldr	r3, [r7, #16]
34006380:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
34006384:	4b28      	ldr	r3, [pc, #160]	@ (34006428 <HAL_GPIO_Init+0x6bc>)
34006386:	681b      	ldr	r3, [r3, #0]
34006388:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
3400638a:	68fb      	ldr	r3, [r7, #12]
3400638c:	43db      	mvns	r3, r3
3400638e:	693a      	ldr	r2, [r7, #16]
34006390:	4013      	ands	r3, r2
34006392:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
34006394:	683b      	ldr	r3, [r7, #0]
34006396:	685b      	ldr	r3, [r3, #4]
34006398:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
3400639c:	2b00      	cmp	r3, #0
3400639e:	d003      	beq.n	340063a8 <HAL_GPIO_Init+0x63c>
        {
          temp |= iocurrent;
340063a0:	693a      	ldr	r2, [r7, #16]
340063a2:	68fb      	ldr	r3, [r7, #12]
340063a4:	4313      	orrs	r3, r2
340063a6:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
340063a8:	4a1f      	ldr	r2, [pc, #124]	@ (34006428 <HAL_GPIO_Init+0x6bc>)
340063aa:	693b      	ldr	r3, [r7, #16]
340063ac:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
340063ae:	4b1e      	ldr	r3, [pc, #120]	@ (34006428 <HAL_GPIO_Init+0x6bc>)
340063b0:	685b      	ldr	r3, [r3, #4]
340063b2:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
340063b4:	68fb      	ldr	r3, [r7, #12]
340063b6:	43db      	mvns	r3, r3
340063b8:	693a      	ldr	r2, [r7, #16]
340063ba:	4013      	ands	r3, r2
340063bc:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
340063be:	683b      	ldr	r3, [r7, #0]
340063c0:	685b      	ldr	r3, [r3, #4]
340063c2:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
340063c6:	2b00      	cmp	r3, #0
340063c8:	d003      	beq.n	340063d2 <HAL_GPIO_Init+0x666>
        {
          temp |= iocurrent;
340063ca:	693a      	ldr	r2, [r7, #16]
340063cc:	68fb      	ldr	r3, [r7, #12]
340063ce:	4313      	orrs	r3, r2
340063d0:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
340063d2:	4a15      	ldr	r2, [pc, #84]	@ (34006428 <HAL_GPIO_Init+0x6bc>)
340063d4:	693b      	ldr	r3, [r7, #16]
340063d6:	6053      	str	r3, [r2, #4]
      }
    }

    position++;
340063d8:	697b      	ldr	r3, [r7, #20]
340063da:	3301      	adds	r3, #1
340063dc:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
340063de:	683b      	ldr	r3, [r7, #0]
340063e0:	681a      	ldr	r2, [r3, #0]
340063e2:	697b      	ldr	r3, [r7, #20]
340063e4:	fa22 f303 	lsr.w	r3, r2, r3
340063e8:	2b00      	cmp	r3, #0
340063ea:	f47f adb1 	bne.w	34005f50 <HAL_GPIO_Init+0x1e4>
  }
}
340063ee:	bf00      	nop
340063f0:	bf00      	nop
340063f2:	3718      	adds	r7, #24
340063f4:	46bd      	mov	sp, r7
340063f6:	bd80      	pop	{r7, pc}
340063f8:	56020000 	.word	0x56020000
340063fc:	56020400 	.word	0x56020400
34006400:	56020800 	.word	0x56020800
34006404:	56020c00 	.word	0x56020c00
34006408:	56021000 	.word	0x56021000
3400640c:	56021400 	.word	0x56021400
34006410:	56021800 	.word	0x56021800
34006414:	56021c00 	.word	0x56021c00
34006418:	56023400 	.word	0x56023400
3400641c:	56023800 	.word	0x56023800
34006420:	56023c00 	.word	0x56023c00
34006424:	56024000 	.word	0x56024000
34006428:	56025000 	.word	0x56025000

3400642c <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
3400642c:	b580      	push	{r7, lr}
3400642e:	b082      	sub	sp, #8
34006430:	af00      	add	r7, sp, #0
34006432:	6078      	str	r0, [r7, #4]
34006434:	460b      	mov	r3, r1
34006436:	807b      	strh	r3, [r7, #2]
34006438:	4613      	mov	r3, r2
3400643a:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
3400643c:	887b      	ldrh	r3, [r7, #2]
3400643e:	2b00      	cmp	r3, #0
34006440:	d104      	bne.n	3400644c <HAL_GPIO_WritePin+0x20>
34006442:	f44f 71d0 	mov.w	r1, #416	@ 0x1a0
34006446:	480e      	ldr	r0, [pc, #56]	@ (34006480 <HAL_GPIO_WritePin+0x54>)
34006448:	f7fb fde2 	bl	34002010 <assert_failed>
  assert_param(IS_GPIO_PIN_ACTION(PinState));
3400644c:	787b      	ldrb	r3, [r7, #1]
3400644e:	2b00      	cmp	r3, #0
34006450:	d007      	beq.n	34006462 <HAL_GPIO_WritePin+0x36>
34006452:	787b      	ldrb	r3, [r7, #1]
34006454:	2b01      	cmp	r3, #1
34006456:	d004      	beq.n	34006462 <HAL_GPIO_WritePin+0x36>
34006458:	f240 11a1 	movw	r1, #417	@ 0x1a1
3400645c:	4808      	ldr	r0, [pc, #32]	@ (34006480 <HAL_GPIO_WritePin+0x54>)
3400645e:	f7fb fdd7 	bl	34002010 <assert_failed>

  if (PinState != GPIO_PIN_RESET)
34006462:	787b      	ldrb	r3, [r7, #1]
34006464:	2b00      	cmp	r3, #0
34006466:	d003      	beq.n	34006470 <HAL_GPIO_WritePin+0x44>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
34006468:	887a      	ldrh	r2, [r7, #2]
3400646a:	687b      	ldr	r3, [r7, #4]
3400646c:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
3400646e:	e002      	b.n	34006476 <HAL_GPIO_WritePin+0x4a>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
34006470:	887a      	ldrh	r2, [r7, #2]
34006472:	687b      	ldr	r3, [r7, #4]
34006474:	629a      	str	r2, [r3, #40]	@ 0x28
}
34006476:	bf00      	nop
34006478:	3708      	adds	r7, #8
3400647a:	46bd      	mov	sp, r7
3400647c:	bd80      	pop	{r7, pc}
3400647e:	bf00      	nop
34006480:	3401ebb4 	.word	0x3401ebb4

34006484 <HAL_PWREx_ConfigVddIORange>:
  * @note   Setting this configuration while VDDIOx is in 3v3 range
  *         damages the device.
  * @retval None.
  */
void HAL_PWREx_ConfigVddIORange(uint32_t VddIOPort, uint32_t VoltageRange)
{
34006484:	b580      	push	{r7, lr}
34006486:	b082      	sub	sp, #8
34006488:	af00      	add	r7, sp, #0
3400648a:	6078      	str	r0, [r7, #4]
3400648c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_PWR_VDDIO(VddIOPort));
3400648e:	687b      	ldr	r3, [r7, #4]
34006490:	2b00      	cmp	r3, #0
34006492:	d010      	beq.n	340064b6 <HAL_PWREx_ConfigVddIORange+0x32>
34006494:	687b      	ldr	r3, [r7, #4]
34006496:	2b01      	cmp	r3, #1
34006498:	d00d      	beq.n	340064b6 <HAL_PWREx_ConfigVddIORange+0x32>
3400649a:	687b      	ldr	r3, [r7, #4]
3400649c:	2b02      	cmp	r3, #2
3400649e:	d00a      	beq.n	340064b6 <HAL_PWREx_ConfigVddIORange+0x32>
340064a0:	687b      	ldr	r3, [r7, #4]
340064a2:	2b03      	cmp	r3, #3
340064a4:	d007      	beq.n	340064b6 <HAL_PWREx_ConfigVddIORange+0x32>
340064a6:	687b      	ldr	r3, [r7, #4]
340064a8:	2b04      	cmp	r3, #4
340064aa:	d004      	beq.n	340064b6 <HAL_PWREx_ConfigVddIORange+0x32>
340064ac:	f240 316a 	movw	r1, #874	@ 0x36a
340064b0:	482a      	ldr	r0, [pc, #168]	@ (3400655c <HAL_PWREx_ConfigVddIORange+0xd8>)
340064b2:	f7fb fdad 	bl	34002010 <assert_failed>
  assert_param(IS_PWR_VDDIO_RANGE(VoltageRange));
340064b6:	683b      	ldr	r3, [r7, #0]
340064b8:	2b00      	cmp	r3, #0
340064ba:	d007      	beq.n	340064cc <HAL_PWREx_ConfigVddIORange+0x48>
340064bc:	683b      	ldr	r3, [r7, #0]
340064be:	2b01      	cmp	r3, #1
340064c0:	d004      	beq.n	340064cc <HAL_PWREx_ConfigVddIORange+0x48>
340064c2:	f240 316b 	movw	r1, #875	@ 0x36b
340064c6:	4825      	ldr	r0, [pc, #148]	@ (3400655c <HAL_PWREx_ConfigVddIORange+0xd8>)
340064c8:	f7fb fda2 	bl	34002010 <assert_failed>

  switch (VddIOPort)
340064cc:	687b      	ldr	r3, [r7, #4]
340064ce:	2b04      	cmp	r3, #4
340064d0:	d83e      	bhi.n	34006550 <HAL_PWREx_ConfigVddIORange+0xcc>
340064d2:	a201      	add	r2, pc, #4	@ (adr r2, 340064d8 <HAL_PWREx_ConfigVddIORange+0x54>)
340064d4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
340064d8:	340064ed 	.word	0x340064ed
340064dc:	34006501 	.word	0x34006501
340064e0:	34006515 	.word	0x34006515
340064e4:	34006529 	.word	0x34006529
340064e8:	3400653d 	.word	0x3400653d
  {
    case PWR_VDDIO:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIOVRSEL, VoltageRange << PWR_SVMCR3_VDDIOVRSEL_Pos);
340064ec:	4b1c      	ldr	r3, [pc, #112]	@ (34006560 <HAL_PWREx_ConfigVddIORange+0xdc>)
340064ee:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340064f0:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
340064f4:	683b      	ldr	r3, [r7, #0]
340064f6:	061b      	lsls	r3, r3, #24
340064f8:	4919      	ldr	r1, [pc, #100]	@ (34006560 <HAL_PWREx_ConfigVddIORange+0xdc>)
340064fa:	4313      	orrs	r3, r2
340064fc:	63cb      	str	r3, [r1, #60]	@ 0x3c
      break;
340064fe:	e028      	b.n	34006552 <HAL_PWREx_ConfigVddIORange+0xce>

    case PWR_VDDIO2:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO2VRSEL, VoltageRange << PWR_SVMCR3_VDDIO2VRSEL_Pos);
34006500:	4b17      	ldr	r3, [pc, #92]	@ (34006560 <HAL_PWREx_ConfigVddIORange+0xdc>)
34006502:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34006504:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
34006508:	683b      	ldr	r3, [r7, #0]
3400650a:	065b      	lsls	r3, r3, #25
3400650c:	4914      	ldr	r1, [pc, #80]	@ (34006560 <HAL_PWREx_ConfigVddIORange+0xdc>)
3400650e:	4313      	orrs	r3, r2
34006510:	63cb      	str	r3, [r1, #60]	@ 0x3c
      break;
34006512:	e01e      	b.n	34006552 <HAL_PWREx_ConfigVddIORange+0xce>

    case PWR_VDDIO3:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO3VRSEL, VoltageRange << PWR_SVMCR3_VDDIO3VRSEL_Pos);
34006514:	4b12      	ldr	r3, [pc, #72]	@ (34006560 <HAL_PWREx_ConfigVddIORange+0xdc>)
34006516:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34006518:	f023 6280 	bic.w	r2, r3, #67108864	@ 0x4000000
3400651c:	683b      	ldr	r3, [r7, #0]
3400651e:	069b      	lsls	r3, r3, #26
34006520:	490f      	ldr	r1, [pc, #60]	@ (34006560 <HAL_PWREx_ConfigVddIORange+0xdc>)
34006522:	4313      	orrs	r3, r2
34006524:	63cb      	str	r3, [r1, #60]	@ 0x3c
      break;
34006526:	e014      	b.n	34006552 <HAL_PWREx_ConfigVddIORange+0xce>

    case PWR_VDDIO4:
      MODIFY_REG(PWR->SVMCR1, PWR_SVMCR1_VDDIO4VRSEL, VoltageRange << PWR_SVMCR1_VDDIO4VRSEL_Pos);
34006528:	4b0d      	ldr	r3, [pc, #52]	@ (34006560 <HAL_PWREx_ConfigVddIORange+0xdc>)
3400652a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400652c:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34006530:	683b      	ldr	r3, [r7, #0]
34006532:	061b      	lsls	r3, r3, #24
34006534:	490a      	ldr	r1, [pc, #40]	@ (34006560 <HAL_PWREx_ConfigVddIORange+0xdc>)
34006536:	4313      	orrs	r3, r2
34006538:	634b      	str	r3, [r1, #52]	@ 0x34
      break;
3400653a:	e00a      	b.n	34006552 <HAL_PWREx_ConfigVddIORange+0xce>

    case PWR_VDDIO5:
      MODIFY_REG(PWR->SVMCR2, PWR_SVMCR2_VDDIO5VRSEL, VoltageRange << PWR_SVMCR2_VDDIO5VRSEL_Pos);
3400653c:	4b08      	ldr	r3, [pc, #32]	@ (34006560 <HAL_PWREx_ConfigVddIORange+0xdc>)
3400653e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34006540:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34006544:	683b      	ldr	r3, [r7, #0]
34006546:	061b      	lsls	r3, r3, #24
34006548:	4905      	ldr	r1, [pc, #20]	@ (34006560 <HAL_PWREx_ConfigVddIORange+0xdc>)
3400654a:	4313      	orrs	r3, r2
3400654c:	638b      	str	r3, [r1, #56]	@ 0x38
      break;
3400654e:	e000      	b.n	34006552 <HAL_PWREx_ConfigVddIORange+0xce>

    default:
      break;
34006550:	bf00      	nop
  }
}
34006552:	bf00      	nop
34006554:	3708      	adds	r7, #8
34006556:	46bd      	mov	sp, r7
34006558:	bd80      	pop	{r7, pc}
3400655a:	bf00      	nop
3400655c:	3401ec60 	.word	0x3401ec60
34006560:	56024800 	.word	0x56024800

34006564 <HAL_PWREx_EnableVddIO3>:
  * @brief  Enable VDDIO3 supply valid.
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO3(void)
{
34006564:	b480      	push	{r7}
34006566:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO3SV);
34006568:	4b05      	ldr	r3, [pc, #20]	@ (34006580 <HAL_PWREx_EnableVddIO3+0x1c>)
3400656a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400656c:	4a04      	ldr	r2, [pc, #16]	@ (34006580 <HAL_PWREx_EnableVddIO3+0x1c>)
3400656e:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
34006572:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
34006574:	bf00      	nop
34006576:	46bd      	mov	sp, r7
34006578:	f85d 7b04 	ldr.w	r7, [sp], #4
3400657c:	4770      	bx	lr
3400657e:	bf00      	nop
34006580:	56024800 	.word	0x56024800

34006584 <HAL_RAMCFG_EnableAXISRAM>:
  *                   contains the configuration information for the
  *                   specified RAMCFG instance.
  * @retval None.
  */
void HAL_RAMCFG_EnableAXISRAM(const RAMCFG_HandleTypeDef *hramcfg)
{
34006584:	b580      	push	{r7, lr}
34006586:	b082      	sub	sp, #8
34006588:	af00      	add	r7, sp, #0
3400658a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RAMCFG_AXISRAM_POWERDOWN_INSTANCE(hramcfg->Instance));
3400658c:	687b      	ldr	r3, [r7, #4]
3400658e:	681b      	ldr	r3, [r3, #0]
34006590:	4a20      	ldr	r2, [pc, #128]	@ (34006614 <HAL_RAMCFG_EnableAXISRAM+0x90>)
34006592:	4293      	cmp	r3, r2
34006594:	d031      	beq.n	340065fa <HAL_RAMCFG_EnableAXISRAM+0x76>
34006596:	687b      	ldr	r3, [r7, #4]
34006598:	681b      	ldr	r3, [r3, #0]
3400659a:	4a1f      	ldr	r2, [pc, #124]	@ (34006618 <HAL_RAMCFG_EnableAXISRAM+0x94>)
3400659c:	4293      	cmp	r3, r2
3400659e:	d02c      	beq.n	340065fa <HAL_RAMCFG_EnableAXISRAM+0x76>
340065a0:	687b      	ldr	r3, [r7, #4]
340065a2:	681b      	ldr	r3, [r3, #0]
340065a4:	4a1d      	ldr	r2, [pc, #116]	@ (3400661c <HAL_RAMCFG_EnableAXISRAM+0x98>)
340065a6:	4293      	cmp	r3, r2
340065a8:	d027      	beq.n	340065fa <HAL_RAMCFG_EnableAXISRAM+0x76>
340065aa:	687b      	ldr	r3, [r7, #4]
340065ac:	681b      	ldr	r3, [r3, #0]
340065ae:	4a1c      	ldr	r2, [pc, #112]	@ (34006620 <HAL_RAMCFG_EnableAXISRAM+0x9c>)
340065b0:	4293      	cmp	r3, r2
340065b2:	d022      	beq.n	340065fa <HAL_RAMCFG_EnableAXISRAM+0x76>
340065b4:	687b      	ldr	r3, [r7, #4]
340065b6:	681b      	ldr	r3, [r3, #0]
340065b8:	4a1a      	ldr	r2, [pc, #104]	@ (34006624 <HAL_RAMCFG_EnableAXISRAM+0xa0>)
340065ba:	4293      	cmp	r3, r2
340065bc:	d01d      	beq.n	340065fa <HAL_RAMCFG_EnableAXISRAM+0x76>
340065be:	687b      	ldr	r3, [r7, #4]
340065c0:	681b      	ldr	r3, [r3, #0]
340065c2:	4a19      	ldr	r2, [pc, #100]	@ (34006628 <HAL_RAMCFG_EnableAXISRAM+0xa4>)
340065c4:	4293      	cmp	r3, r2
340065c6:	d018      	beq.n	340065fa <HAL_RAMCFG_EnableAXISRAM+0x76>
340065c8:	687b      	ldr	r3, [r7, #4]
340065ca:	681b      	ldr	r3, [r3, #0]
340065cc:	4a17      	ldr	r2, [pc, #92]	@ (3400662c <HAL_RAMCFG_EnableAXISRAM+0xa8>)
340065ce:	4293      	cmp	r3, r2
340065d0:	d013      	beq.n	340065fa <HAL_RAMCFG_EnableAXISRAM+0x76>
340065d2:	687b      	ldr	r3, [r7, #4]
340065d4:	681b      	ldr	r3, [r3, #0]
340065d6:	4a16      	ldr	r2, [pc, #88]	@ (34006630 <HAL_RAMCFG_EnableAXISRAM+0xac>)
340065d8:	4293      	cmp	r3, r2
340065da:	d00e      	beq.n	340065fa <HAL_RAMCFG_EnableAXISRAM+0x76>
340065dc:	687b      	ldr	r3, [r7, #4]
340065de:	681b      	ldr	r3, [r3, #0]
340065e0:	4a14      	ldr	r2, [pc, #80]	@ (34006634 <HAL_RAMCFG_EnableAXISRAM+0xb0>)
340065e2:	4293      	cmp	r3, r2
340065e4:	d009      	beq.n	340065fa <HAL_RAMCFG_EnableAXISRAM+0x76>
340065e6:	687b      	ldr	r3, [r7, #4]
340065e8:	681b      	ldr	r3, [r3, #0]
340065ea:	4a13      	ldr	r2, [pc, #76]	@ (34006638 <HAL_RAMCFG_EnableAXISRAM+0xb4>)
340065ec:	4293      	cmp	r3, r2
340065ee:	d004      	beq.n	340065fa <HAL_RAMCFG_EnableAXISRAM+0x76>
340065f0:	f240 4107 	movw	r1, #1031	@ 0x407
340065f4:	4811      	ldr	r0, [pc, #68]	@ (3400663c <HAL_RAMCFG_EnableAXISRAM+0xb8>)
340065f6:	f7fb fd0b 	bl	34002010 <assert_failed>

  /* AXISRAMi power on */
  CLEAR_BIT(hramcfg->Instance->CR, RAMCFG_AXISRAM_POWERDOWN);
340065fa:	687b      	ldr	r3, [r7, #4]
340065fc:	681b      	ldr	r3, [r3, #0]
340065fe:	681a      	ldr	r2, [r3, #0]
34006600:	687b      	ldr	r3, [r7, #4]
34006602:	681b      	ldr	r3, [r3, #0]
34006604:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
34006608:	601a      	str	r2, [r3, #0]
}
3400660a:	bf00      	nop
3400660c:	3708      	adds	r7, #8
3400660e:	46bd      	mov	sp, r7
34006610:	bd80      	pop	{r7, pc}
34006612:	bf00      	nop
34006614:	52023080 	.word	0x52023080
34006618:	42023080 	.word	0x42023080
3400661c:	52023100 	.word	0x52023100
34006620:	42023100 	.word	0x42023100
34006624:	52023180 	.word	0x52023180
34006628:	42023180 	.word	0x42023180
3400662c:	52023200 	.word	0x52023200
34006630:	42023200 	.word	0x42023200
34006634:	52023280 	.word	0x52023280
34006638:	42023280 	.word	0x42023280
3400663c:	3401ed0c 	.word	0x3401ed0c

34006640 <LL_RCC_HSE_IsReady>:
{
34006640:	b480      	push	{r7}
34006642:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
34006644:	4b06      	ldr	r3, [pc, #24]	@ (34006660 <LL_RCC_HSE_IsReady+0x20>)
34006646:	685b      	ldr	r3, [r3, #4]
34006648:	f003 0310 	and.w	r3, r3, #16
3400664c:	2b00      	cmp	r3, #0
3400664e:	d001      	beq.n	34006654 <LL_RCC_HSE_IsReady+0x14>
34006650:	2301      	movs	r3, #1
34006652:	e000      	b.n	34006656 <LL_RCC_HSE_IsReady+0x16>
34006654:	2300      	movs	r3, #0
}
34006656:	4618      	mov	r0, r3
34006658:	46bd      	mov	sp, r7
3400665a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400665e:	4770      	bx	lr
34006660:	56028000 	.word	0x56028000

34006664 <LL_RCC_HSI_Enable>:
{
34006664:	b480      	push	{r7}
34006666:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_HSIONS);
34006668:	4b04      	ldr	r3, [pc, #16]	@ (3400667c <LL_RCC_HSI_Enable+0x18>)
3400666a:	2208      	movs	r2, #8
3400666c:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
34006670:	bf00      	nop
34006672:	46bd      	mov	sp, r7
34006674:	f85d 7b04 	ldr.w	r7, [sp], #4
34006678:	4770      	bx	lr
3400667a:	bf00      	nop
3400667c:	56028000 	.word	0x56028000

34006680 <LL_RCC_HSI_Disable>:
{
34006680:	b480      	push	{r7}
34006682:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_HSIONC);
34006684:	4b05      	ldr	r3, [pc, #20]	@ (3400669c <LL_RCC_HSI_Disable+0x1c>)
34006686:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400668a:	461a      	mov	r2, r3
3400668c:	2308      	movs	r3, #8
3400668e:	6013      	str	r3, [r2, #0]
}
34006690:	bf00      	nop
34006692:	46bd      	mov	sp, r7
34006694:	f85d 7b04 	ldr.w	r7, [sp], #4
34006698:	4770      	bx	lr
3400669a:	bf00      	nop
3400669c:	56028000 	.word	0x56028000

340066a0 <LL_RCC_HSI_IsReady>:
{
340066a0:	b480      	push	{r7}
340066a2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
340066a4:	4b06      	ldr	r3, [pc, #24]	@ (340066c0 <LL_RCC_HSI_IsReady+0x20>)
340066a6:	685b      	ldr	r3, [r3, #4]
340066a8:	f003 0308 	and.w	r3, r3, #8
340066ac:	2b00      	cmp	r3, #0
340066ae:	d001      	beq.n	340066b4 <LL_RCC_HSI_IsReady+0x14>
340066b0:	2301      	movs	r3, #1
340066b2:	e000      	b.n	340066b6 <LL_RCC_HSI_IsReady+0x16>
340066b4:	2300      	movs	r3, #0
}
340066b6:	4618      	mov	r0, r3
340066b8:	46bd      	mov	sp, r7
340066ba:	f85d 7b04 	ldr.w	r7, [sp], #4
340066be:	4770      	bx	lr
340066c0:	56028000 	.word	0x56028000

340066c4 <LL_RCC_HSI_SetDivider>:
{
340066c4:	b480      	push	{r7}
340066c6:	b083      	sub	sp, #12
340066c8:	af00      	add	r7, sp, #0
340066ca:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSIDIV, Divider);
340066cc:	4b06      	ldr	r3, [pc, #24]	@ (340066e8 <LL_RCC_HSI_SetDivider+0x24>)
340066ce:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340066d0:	f423 72c0 	bic.w	r2, r3, #384	@ 0x180
340066d4:	4904      	ldr	r1, [pc, #16]	@ (340066e8 <LL_RCC_HSI_SetDivider+0x24>)
340066d6:	687b      	ldr	r3, [r7, #4]
340066d8:	4313      	orrs	r3, r2
340066da:	648b      	str	r3, [r1, #72]	@ 0x48
}
340066dc:	bf00      	nop
340066de:	370c      	adds	r7, #12
340066e0:	46bd      	mov	sp, r7
340066e2:	f85d 7b04 	ldr.w	r7, [sp], #4
340066e6:	4770      	bx	lr
340066e8:	56028000 	.word	0x56028000

340066ec <LL_RCC_HSI_GetDivider>:
{
340066ec:	b480      	push	{r7}
340066ee:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
340066f0:	4b04      	ldr	r3, [pc, #16]	@ (34006704 <LL_RCC_HSI_GetDivider+0x18>)
340066f2:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340066f4:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
340066f8:	4618      	mov	r0, r3
340066fa:	46bd      	mov	sp, r7
340066fc:	f85d 7b04 	ldr.w	r7, [sp], #4
34006700:	4770      	bx	lr
34006702:	bf00      	nop
34006704:	56028000 	.word	0x56028000

34006708 <LL_RCC_HSI_SetCalibTrimming>:
{
34006708:	b480      	push	{r7}
3400670a:	b083      	sub	sp, #12
3400670c:	af00      	add	r7, sp, #0
3400670e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSITRIM, Value << RCC_HSICFGR_HSITRIM_Pos);
34006710:	4b07      	ldr	r3, [pc, #28]	@ (34006730 <LL_RCC_HSI_SetCalibTrimming+0x28>)
34006712:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34006714:	f423 02fe 	bic.w	r2, r3, #8323072	@ 0x7f0000
34006718:	687b      	ldr	r3, [r7, #4]
3400671a:	041b      	lsls	r3, r3, #16
3400671c:	4904      	ldr	r1, [pc, #16]	@ (34006730 <LL_RCC_HSI_SetCalibTrimming+0x28>)
3400671e:	4313      	orrs	r3, r2
34006720:	648b      	str	r3, [r1, #72]	@ 0x48
}
34006722:	bf00      	nop
34006724:	370c      	adds	r7, #12
34006726:	46bd      	mov	sp, r7
34006728:	f85d 7b04 	ldr.w	r7, [sp], #4
3400672c:	4770      	bx	lr
3400672e:	bf00      	nop
34006730:	56028000 	.word	0x56028000

34006734 <LL_RCC_MSI_Enable>:
{
34006734:	b480      	push	{r7}
34006736:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_MSIONS);
34006738:	4b04      	ldr	r3, [pc, #16]	@ (3400674c <LL_RCC_MSI_Enable+0x18>)
3400673a:	2204      	movs	r2, #4
3400673c:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
34006740:	bf00      	nop
34006742:	46bd      	mov	sp, r7
34006744:	f85d 7b04 	ldr.w	r7, [sp], #4
34006748:	4770      	bx	lr
3400674a:	bf00      	nop
3400674c:	56028000 	.word	0x56028000

34006750 <LL_RCC_MSI_Disable>:
{
34006750:	b480      	push	{r7}
34006752:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_MSIONC);
34006754:	4b05      	ldr	r3, [pc, #20]	@ (3400676c <LL_RCC_MSI_Disable+0x1c>)
34006756:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400675a:	461a      	mov	r2, r3
3400675c:	2304      	movs	r3, #4
3400675e:	6013      	str	r3, [r2, #0]
}
34006760:	bf00      	nop
34006762:	46bd      	mov	sp, r7
34006764:	f85d 7b04 	ldr.w	r7, [sp], #4
34006768:	4770      	bx	lr
3400676a:	bf00      	nop
3400676c:	56028000 	.word	0x56028000

34006770 <LL_RCC_MSI_IsReady>:
{
34006770:	b480      	push	{r7}
34006772:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
34006774:	4b06      	ldr	r3, [pc, #24]	@ (34006790 <LL_RCC_MSI_IsReady+0x20>)
34006776:	685b      	ldr	r3, [r3, #4]
34006778:	f003 0304 	and.w	r3, r3, #4
3400677c:	2b00      	cmp	r3, #0
3400677e:	d001      	beq.n	34006784 <LL_RCC_MSI_IsReady+0x14>
34006780:	2301      	movs	r3, #1
34006782:	e000      	b.n	34006786 <LL_RCC_MSI_IsReady+0x16>
34006784:	2300      	movs	r3, #0
}
34006786:	4618      	mov	r0, r3
34006788:	46bd      	mov	sp, r7
3400678a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400678e:	4770      	bx	lr
34006790:	56028000 	.word	0x56028000

34006794 <LL_RCC_MSI_SetFrequency>:
{
34006794:	b480      	push	{r7}
34006796:	b083      	sub	sp, #12
34006798:	af00      	add	r7, sp, #0
3400679a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL, Value);
3400679c:	4b06      	ldr	r3, [pc, #24]	@ (340067b8 <LL_RCC_MSI_SetFrequency+0x24>)
3400679e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340067a0:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
340067a4:	4904      	ldr	r1, [pc, #16]	@ (340067b8 <LL_RCC_MSI_SetFrequency+0x24>)
340067a6:	687b      	ldr	r3, [r7, #4]
340067a8:	4313      	orrs	r3, r2
340067aa:	644b      	str	r3, [r1, #68]	@ 0x44
}
340067ac:	bf00      	nop
340067ae:	370c      	adds	r7, #12
340067b0:	46bd      	mov	sp, r7
340067b2:	f85d 7b04 	ldr.w	r7, [sp], #4
340067b6:	4770      	bx	lr
340067b8:	56028000 	.word	0x56028000

340067bc <LL_RCC_MSI_GetFrequency>:
{
340067bc:	b480      	push	{r7}
340067be:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
340067c0:	4b04      	ldr	r3, [pc, #16]	@ (340067d4 <LL_RCC_MSI_GetFrequency+0x18>)
340067c2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340067c4:	f403 7300 	and.w	r3, r3, #512	@ 0x200
}
340067c8:	4618      	mov	r0, r3
340067ca:	46bd      	mov	sp, r7
340067cc:	f85d 7b04 	ldr.w	r7, [sp], #4
340067d0:	4770      	bx	lr
340067d2:	bf00      	nop
340067d4:	56028000 	.word	0x56028000

340067d8 <LL_RCC_MSI_SetCalibTrimming>:
{
340067d8:	b480      	push	{r7}
340067da:	b083      	sub	sp, #12
340067dc:	af00      	add	r7, sp, #0
340067de:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSITRIM, Value << RCC_MSICFGR_MSITRIM_Pos);
340067e0:	4b07      	ldr	r3, [pc, #28]	@ (34006800 <LL_RCC_MSI_SetCalibTrimming+0x28>)
340067e2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340067e4:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
340067e8:	687b      	ldr	r3, [r7, #4]
340067ea:	041b      	lsls	r3, r3, #16
340067ec:	4904      	ldr	r1, [pc, #16]	@ (34006800 <LL_RCC_MSI_SetCalibTrimming+0x28>)
340067ee:	4313      	orrs	r3, r2
340067f0:	644b      	str	r3, [r1, #68]	@ 0x44
}
340067f2:	bf00      	nop
340067f4:	370c      	adds	r7, #12
340067f6:	46bd      	mov	sp, r7
340067f8:	f85d 7b04 	ldr.w	r7, [sp], #4
340067fc:	4770      	bx	lr
340067fe:	bf00      	nop
34006800:	56028000 	.word	0x56028000

34006804 <LL_RCC_LSE_IsReady>:
{
34006804:	b480      	push	{r7}
34006806:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
34006808:	4b06      	ldr	r3, [pc, #24]	@ (34006824 <LL_RCC_LSE_IsReady+0x20>)
3400680a:	685b      	ldr	r3, [r3, #4]
3400680c:	f003 0302 	and.w	r3, r3, #2
34006810:	2b00      	cmp	r3, #0
34006812:	d001      	beq.n	34006818 <LL_RCC_LSE_IsReady+0x14>
34006814:	2301      	movs	r3, #1
34006816:	e000      	b.n	3400681a <LL_RCC_LSE_IsReady+0x16>
34006818:	2300      	movs	r3, #0
}
3400681a:	4618      	mov	r0, r3
3400681c:	46bd      	mov	sp, r7
3400681e:	f85d 7b04 	ldr.w	r7, [sp], #4
34006822:	4770      	bx	lr
34006824:	56028000 	.word	0x56028000

34006828 <LL_RCC_LSI_Enable>:
{
34006828:	b480      	push	{r7}
3400682a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_LSIONS);
3400682c:	4b04      	ldr	r3, [pc, #16]	@ (34006840 <LL_RCC_LSI_Enable+0x18>)
3400682e:	2201      	movs	r2, #1
34006830:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
34006834:	bf00      	nop
34006836:	46bd      	mov	sp, r7
34006838:	f85d 7b04 	ldr.w	r7, [sp], #4
3400683c:	4770      	bx	lr
3400683e:	bf00      	nop
34006840:	56028000 	.word	0x56028000

34006844 <LL_RCC_LSI_Disable>:
{
34006844:	b480      	push	{r7}
34006846:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_LSIONC);
34006848:	4b05      	ldr	r3, [pc, #20]	@ (34006860 <LL_RCC_LSI_Disable+0x1c>)
3400684a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400684e:	461a      	mov	r2, r3
34006850:	2301      	movs	r3, #1
34006852:	6013      	str	r3, [r2, #0]
}
34006854:	bf00      	nop
34006856:	46bd      	mov	sp, r7
34006858:	f85d 7b04 	ldr.w	r7, [sp], #4
3400685c:	4770      	bx	lr
3400685e:	bf00      	nop
34006860:	56028000 	.word	0x56028000

34006864 <LL_RCC_LSI_IsReady>:
{
34006864:	b480      	push	{r7}
34006866:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
34006868:	4b04      	ldr	r3, [pc, #16]	@ (3400687c <LL_RCC_LSI_IsReady+0x18>)
3400686a:	685b      	ldr	r3, [r3, #4]
3400686c:	f003 0301 	and.w	r3, r3, #1
}
34006870:	4618      	mov	r0, r3
34006872:	46bd      	mov	sp, r7
34006874:	f85d 7b04 	ldr.w	r7, [sp], #4
34006878:	4770      	bx	lr
3400687a:	bf00      	nop
3400687c:	56028000 	.word	0x56028000

34006880 <LL_RCC_GetCpuClkSource>:
{
34006880:	b480      	push	{r7}
34006882:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
34006884:	4b04      	ldr	r3, [pc, #16]	@ (34006898 <LL_RCC_GetCpuClkSource+0x18>)
34006886:	6a1b      	ldr	r3, [r3, #32]
34006888:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
}
3400688c:	4618      	mov	r0, r3
3400688e:	46bd      	mov	sp, r7
34006890:	f85d 7b04 	ldr.w	r7, [sp], #4
34006894:	4770      	bx	lr
34006896:	bf00      	nop
34006898:	56028000 	.word	0x56028000

3400689c <LL_RCC_GetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_MSI
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_IC2_IC6_IC11
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
{
3400689c:	b480      	push	{r7}
3400689e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
340068a0:	4b04      	ldr	r3, [pc, #16]	@ (340068b4 <LL_RCC_GetSysClkSource+0x18>)
340068a2:	6a1b      	ldr	r3, [r3, #32]
340068a4:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
340068a8:	4618      	mov	r0, r3
340068aa:	46bd      	mov	sp, r7
340068ac:	f85d 7b04 	ldr.w	r7, [sp], #4
340068b0:	4770      	bx	lr
340068b2:	bf00      	nop
340068b4:	56028000 	.word	0x56028000

340068b8 <LL_RCC_PLL1_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_GetSource(void)
{
340068b8:	b480      	push	{r7}
340068ba:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
340068bc:	4b04      	ldr	r3, [pc, #16]	@ (340068d0 <LL_RCC_PLL1_GetSource+0x18>)
340068be:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340068c2:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
340068c6:	4618      	mov	r0, r3
340068c8:	46bd      	mov	sp, r7
340068ca:	f85d 7b04 	ldr.w	r7, [sp], #4
340068ce:	4770      	bx	lr
340068d0:	56028000 	.word	0x56028000

340068d4 <LL_RCC_PLL1_IsReady>:
  * @brief  Check if PLL1 Ready
  * @rmtoll SR           PLL1RDY         LL_RCC_PLL1_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsReady(void)
{
340068d4:	b480      	push	{r7}
340068d6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
340068d8:	4b07      	ldr	r3, [pc, #28]	@ (340068f8 <LL_RCC_PLL1_IsReady+0x24>)
340068da:	685b      	ldr	r3, [r3, #4]
340068dc:	f403 7380 	and.w	r3, r3, #256	@ 0x100
340068e0:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340068e4:	d101      	bne.n	340068ea <LL_RCC_PLL1_IsReady+0x16>
340068e6:	2301      	movs	r3, #1
340068e8:	e000      	b.n	340068ec <LL_RCC_PLL1_IsReady+0x18>
340068ea:	2300      	movs	r3, #0
}
340068ec:	4618      	mov	r0, r3
340068ee:	46bd      	mov	sp, r7
340068f0:	f85d 7b04 	ldr.w	r7, [sp], #4
340068f4:	4770      	bx	lr
340068f6:	bf00      	nop
340068f8:	56028000 	.word	0x56028000

340068fc <LL_RCC_PLL1_IsEnabledBypass>:
  * @brief  Check if PLL1 bypass is enabled
  * @rmtoll PLL1CFGR1    PLL1BYP         LL_RCC_PLL1_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsEnabledBypass(void)
{
340068fc:	b480      	push	{r7}
340068fe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
34006900:	4b07      	ldr	r3, [pc, #28]	@ (34006920 <LL_RCC_PLL1_IsEnabledBypass+0x24>)
34006902:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34006906:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400690a:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400690e:	d101      	bne.n	34006914 <LL_RCC_PLL1_IsEnabledBypass+0x18>
34006910:	2301      	movs	r3, #1
34006912:	e000      	b.n	34006916 <LL_RCC_PLL1_IsEnabledBypass+0x1a>
34006914:	2300      	movs	r3, #0
}
34006916:	4618      	mov	r0, r3
34006918:	46bd      	mov	sp, r7
3400691a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400691e:	4770      	bx	lr
34006920:	56028000 	.word	0x56028000

34006924 <LL_RCC_PLL2_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_GetSource(void)
{
34006924:	b480      	push	{r7}
34006926:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
34006928:	4b04      	ldr	r3, [pc, #16]	@ (3400693c <LL_RCC_PLL2_GetSource+0x18>)
3400692a:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400692e:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34006932:	4618      	mov	r0, r3
34006934:	46bd      	mov	sp, r7
34006936:	f85d 7b04 	ldr.w	r7, [sp], #4
3400693a:	4770      	bx	lr
3400693c:	56028000 	.word	0x56028000

34006940 <LL_RCC_PLL2_IsReady>:
  * @brief  Check if PLL2 Ready
  * @rmtoll SR           PLL2RDY         LL_RCC_PLL2_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsReady(void)
{
34006940:	b480      	push	{r7}
34006942:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
34006944:	4b07      	ldr	r3, [pc, #28]	@ (34006964 <LL_RCC_PLL2_IsReady+0x24>)
34006946:	685b      	ldr	r3, [r3, #4]
34006948:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400694c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34006950:	d101      	bne.n	34006956 <LL_RCC_PLL2_IsReady+0x16>
34006952:	2301      	movs	r3, #1
34006954:	e000      	b.n	34006958 <LL_RCC_PLL2_IsReady+0x18>
34006956:	2300      	movs	r3, #0
}
34006958:	4618      	mov	r0, r3
3400695a:	46bd      	mov	sp, r7
3400695c:	f85d 7b04 	ldr.w	r7, [sp], #4
34006960:	4770      	bx	lr
34006962:	bf00      	nop
34006964:	56028000 	.word	0x56028000

34006968 <LL_RCC_PLL2_IsEnabledBypass>:
  * @brief  Check if PLL2 bypass is enabled
  * @rmtoll PLL2CFGR1    PLL2BYP         LL_RCC_PLL2_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsEnabledBypass(void)
{
34006968:	b480      	push	{r7}
3400696a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
3400696c:	4b07      	ldr	r3, [pc, #28]	@ (3400698c <LL_RCC_PLL2_IsEnabledBypass+0x24>)
3400696e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34006972:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34006976:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400697a:	d101      	bne.n	34006980 <LL_RCC_PLL2_IsEnabledBypass+0x18>
3400697c:	2301      	movs	r3, #1
3400697e:	e000      	b.n	34006982 <LL_RCC_PLL2_IsEnabledBypass+0x1a>
34006980:	2300      	movs	r3, #0
}
34006982:	4618      	mov	r0, r3
34006984:	46bd      	mov	sp, r7
34006986:	f85d 7b04 	ldr.w	r7, [sp], #4
3400698a:	4770      	bx	lr
3400698c:	56028000 	.word	0x56028000

34006990 <LL_RCC_PLL3_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_GetSource(void)
{
34006990:	b480      	push	{r7}
34006992:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
34006994:	4b04      	ldr	r3, [pc, #16]	@ (340069a8 <LL_RCC_PLL3_GetSource+0x18>)
34006996:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400699a:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400699e:	4618      	mov	r0, r3
340069a0:	46bd      	mov	sp, r7
340069a2:	f85d 7b04 	ldr.w	r7, [sp], #4
340069a6:	4770      	bx	lr
340069a8:	56028000 	.word	0x56028000

340069ac <LL_RCC_PLL3_IsReady>:
  * @brief  Check if PLL3 Ready
  * @rmtoll SR           PLL3RDY         LL_RCC_PLL3_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsReady(void)
{
340069ac:	b480      	push	{r7}
340069ae:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
340069b0:	4b07      	ldr	r3, [pc, #28]	@ (340069d0 <LL_RCC_PLL3_IsReady+0x24>)
340069b2:	685b      	ldr	r3, [r3, #4]
340069b4:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
340069b8:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
340069bc:	d101      	bne.n	340069c2 <LL_RCC_PLL3_IsReady+0x16>
340069be:	2301      	movs	r3, #1
340069c0:	e000      	b.n	340069c4 <LL_RCC_PLL3_IsReady+0x18>
340069c2:	2300      	movs	r3, #0
}
340069c4:	4618      	mov	r0, r3
340069c6:	46bd      	mov	sp, r7
340069c8:	f85d 7b04 	ldr.w	r7, [sp], #4
340069cc:	4770      	bx	lr
340069ce:	bf00      	nop
340069d0:	56028000 	.word	0x56028000

340069d4 <LL_RCC_PLL3_IsEnabledBypass>:
  * @brief  Check if PLL3 bypass is enabled
  * @rmtoll PLL3CFGR1    PLL3BYP         LL_RCC_PLL3_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsEnabledBypass(void)
{
340069d4:	b480      	push	{r7}
340069d6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
340069d8:	4b07      	ldr	r3, [pc, #28]	@ (340069f8 <LL_RCC_PLL3_IsEnabledBypass+0x24>)
340069da:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
340069de:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
340069e2:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
340069e6:	d101      	bne.n	340069ec <LL_RCC_PLL3_IsEnabledBypass+0x18>
340069e8:	2301      	movs	r3, #1
340069ea:	e000      	b.n	340069ee <LL_RCC_PLL3_IsEnabledBypass+0x1a>
340069ec:	2300      	movs	r3, #0
}
340069ee:	4618      	mov	r0, r3
340069f0:	46bd      	mov	sp, r7
340069f2:	f85d 7b04 	ldr.w	r7, [sp], #4
340069f6:	4770      	bx	lr
340069f8:	56028000 	.word	0x56028000

340069fc <LL_RCC_PLL4_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_GetSource(void)
{
340069fc:	b480      	push	{r7}
340069fe:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
34006a00:	4b04      	ldr	r3, [pc, #16]	@ (34006a14 <LL_RCC_PLL4_GetSource+0x18>)
34006a02:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34006a06:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34006a0a:	4618      	mov	r0, r3
34006a0c:	46bd      	mov	sp, r7
34006a0e:	f85d 7b04 	ldr.w	r7, [sp], #4
34006a12:	4770      	bx	lr
34006a14:	56028000 	.word	0x56028000

34006a18 <LL_RCC_PLL4_IsReady>:
  * @brief  Check if PLL4 Ready
  * @rmtoll SR           PLL4RDY         LL_RCC_PLL4_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsReady(void)
{
34006a18:	b480      	push	{r7}
34006a1a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
34006a1c:	4b07      	ldr	r3, [pc, #28]	@ (34006a3c <LL_RCC_PLL4_IsReady+0x24>)
34006a1e:	685b      	ldr	r3, [r3, #4]
34006a20:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34006a24:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006a28:	d101      	bne.n	34006a2e <LL_RCC_PLL4_IsReady+0x16>
34006a2a:	2301      	movs	r3, #1
34006a2c:	e000      	b.n	34006a30 <LL_RCC_PLL4_IsReady+0x18>
34006a2e:	2300      	movs	r3, #0
}
34006a30:	4618      	mov	r0, r3
34006a32:	46bd      	mov	sp, r7
34006a34:	f85d 7b04 	ldr.w	r7, [sp], #4
34006a38:	4770      	bx	lr
34006a3a:	bf00      	nop
34006a3c:	56028000 	.word	0x56028000

34006a40 <LL_RCC_PLL4_IsEnabledBypass>:
  * @brief  Check if PLL4 bypass is enabled
  * @rmtoll PLL4CFGR1    PLL4BYP         LL_RCC_PLL4_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsEnabledBypass(void)
{
34006a40:	b480      	push	{r7}
34006a42:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
34006a44:	4b07      	ldr	r3, [pc, #28]	@ (34006a64 <LL_RCC_PLL4_IsEnabledBypass+0x24>)
34006a46:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34006a4a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34006a4e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34006a52:	d101      	bne.n	34006a58 <LL_RCC_PLL4_IsEnabledBypass+0x18>
34006a54:	2301      	movs	r3, #1
34006a56:	e000      	b.n	34006a5a <LL_RCC_PLL4_IsEnabledBypass+0x1a>
34006a58:	2300      	movs	r3, #0
}
34006a5a:	4618      	mov	r0, r3
34006a5c:	46bd      	mov	sp, r7
34006a5e:	f85d 7b04 	ldr.w	r7, [sp], #4
34006a62:	4770      	bx	lr
34006a64:	56028000 	.word	0x56028000

34006a68 <LL_RCC_IC1_Enable>:
  * @brief  Enable IC1
  * @rmtoll DIVENSR      IC1ENS        LL_RCC_IC1_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC1_Enable(void)
{
34006a68:	b480      	push	{r7}
34006a6a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC1ENS);
34006a6c:	4b04      	ldr	r3, [pc, #16]	@ (34006a80 <LL_RCC_IC1_Enable+0x18>)
34006a6e:	2201      	movs	r2, #1
34006a70:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34006a74:	bf00      	nop
34006a76:	46bd      	mov	sp, r7
34006a78:	f85d 7b04 	ldr.w	r7, [sp], #4
34006a7c:	4770      	bx	lr
34006a7e:	bf00      	nop
34006a80:	56028000 	.word	0x56028000

34006a84 <LL_RCC_IC1_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetSource(void)
{
34006a84:	b480      	push	{r7}
34006a86:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34006a88:	4b04      	ldr	r3, [pc, #16]	@ (34006a9c <LL_RCC_IC1_GetSource+0x18>)
34006a8a:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34006a8e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34006a92:	4618      	mov	r0, r3
34006a94:	46bd      	mov	sp, r7
34006a96:	f85d 7b04 	ldr.w	r7, [sp], #4
34006a9a:	4770      	bx	lr
34006a9c:	56028000 	.word	0x56028000

34006aa0 <LL_RCC_IC1_GetDivider>:
  * @brief  Get IC1 divider
  * @rmtoll IC1CFGR      IC1INT        LL_RCC_IC1_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetDivider(void)
{
34006aa0:	b480      	push	{r7}
34006aa2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL);
34006aa4:	4b05      	ldr	r3, [pc, #20]	@ (34006abc <LL_RCC_IC1_GetDivider+0x1c>)
34006aa6:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34006aaa:	0c1b      	lsrs	r3, r3, #16
34006aac:	b2db      	uxtb	r3, r3
34006aae:	3301      	adds	r3, #1
}
34006ab0:	4618      	mov	r0, r3
34006ab2:	46bd      	mov	sp, r7
34006ab4:	f85d 7b04 	ldr.w	r7, [sp], #4
34006ab8:	4770      	bx	lr
34006aba:	bf00      	nop
34006abc:	56028000 	.word	0x56028000

34006ac0 <LL_RCC_IC2_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetSource(void)
{
34006ac0:	b480      	push	{r7}
34006ac2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
34006ac4:	4b04      	ldr	r3, [pc, #16]	@ (34006ad8 <LL_RCC_IC2_GetSource+0x18>)
34006ac6:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34006aca:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34006ace:	4618      	mov	r0, r3
34006ad0:	46bd      	mov	sp, r7
34006ad2:	f85d 7b04 	ldr.w	r7, [sp], #4
34006ad6:	4770      	bx	lr
34006ad8:	56028000 	.word	0x56028000

34006adc <LL_RCC_IC2_GetDivider>:
  * @brief  Get IC2 divider
  * @rmtoll IC2CFGR      IC2INT        LL_RCC_IC2_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetDivider(void)
{
34006adc:	b480      	push	{r7}
34006ade:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1UL);
34006ae0:	4b05      	ldr	r3, [pc, #20]	@ (34006af8 <LL_RCC_IC2_GetDivider+0x1c>)
34006ae2:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34006ae6:	0c1b      	lsrs	r3, r3, #16
34006ae8:	b2db      	uxtb	r3, r3
34006aea:	3301      	adds	r3, #1
}
34006aec:	4618      	mov	r0, r3
34006aee:	46bd      	mov	sp, r7
34006af0:	f85d 7b04 	ldr.w	r7, [sp], #4
34006af4:	4770      	bx	lr
34006af6:	bf00      	nop
34006af8:	56028000 	.word	0x56028000

34006afc <LL_RCC_IC6_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC6_GetSource(void)
{
34006afc:	b480      	push	{r7}
34006afe:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
34006b00:	4b04      	ldr	r3, [pc, #16]	@ (34006b14 <LL_RCC_IC6_GetSource+0x18>)
34006b02:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
34006b06:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34006b0a:	4618      	mov	r0, r3
34006b0c:	46bd      	mov	sp, r7
34006b0e:	f85d 7b04 	ldr.w	r7, [sp], #4
34006b12:	4770      	bx	lr
34006b14:	56028000 	.word	0x56028000

34006b18 <LL_RCC_IC11_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC11_GetSource(void)
{
34006b18:	b480      	push	{r7}
34006b1a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
34006b1c:	4b04      	ldr	r3, [pc, #16]	@ (34006b30 <LL_RCC_IC11_GetSource+0x18>)
34006b1e:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
34006b22:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34006b26:	4618      	mov	r0, r3
34006b28:	46bd      	mov	sp, r7
34006b2a:	f85d 7b04 	ldr.w	r7, [sp], #4
34006b2e:	4770      	bx	lr
34006b30:	56028000 	.word	0x56028000

34006b34 <HAL_RCC_OscConfig>:
  * @note   This function activates HSE but does not wait for the startup time defined in the datasheet.
  *         This must be ensured by the application when the HSE is selected as PLL source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(const RCC_OscInitTypeDef  *pRCC_OscInitStruct)
{
34006b34:	b580      	push	{r7, lr}
34006b36:	b0a2      	sub	sp, #136	@ 0x88
34006b38:	af00      	add	r7, sp, #0
34006b3a:	6078      	str	r0, [r7, #4]
  uint32_t pll3src;
  uint32_t pll4src;
  uint32_t rccsr;

  /* Check Null pointer */
  if (pRCC_OscInitStruct == NULL)
34006b3c:	687b      	ldr	r3, [r7, #4]
34006b3e:	2b00      	cmp	r3, #0
34006b40:	d102      	bne.n	34006b48 <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
34006b42:	2301      	movs	r3, #1
34006b44:	f000 bd10 	b.w	34007568 <HAL_RCC_OscConfig+0xa34>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(pRCC_OscInitStruct->OscillatorType));
34006b48:	687b      	ldr	r3, [r7, #4]
34006b4a:	681b      	ldr	r3, [r3, #0]
34006b4c:	2b00      	cmp	r3, #0
34006b4e:	d022      	beq.n	34006b96 <HAL_RCC_OscConfig+0x62>
34006b50:	687b      	ldr	r3, [r7, #4]
34006b52:	681b      	ldr	r3, [r3, #0]
34006b54:	f003 0301 	and.w	r3, r3, #1
34006b58:	2b00      	cmp	r3, #0
34006b5a:	d11c      	bne.n	34006b96 <HAL_RCC_OscConfig+0x62>
34006b5c:	687b      	ldr	r3, [r7, #4]
34006b5e:	681b      	ldr	r3, [r3, #0]
34006b60:	f003 0302 	and.w	r3, r3, #2
34006b64:	2b00      	cmp	r3, #0
34006b66:	d116      	bne.n	34006b96 <HAL_RCC_OscConfig+0x62>
34006b68:	687b      	ldr	r3, [r7, #4]
34006b6a:	681b      	ldr	r3, [r3, #0]
34006b6c:	f003 0310 	and.w	r3, r3, #16
34006b70:	2b00      	cmp	r3, #0
34006b72:	d110      	bne.n	34006b96 <HAL_RCC_OscConfig+0x62>
34006b74:	687b      	ldr	r3, [r7, #4]
34006b76:	681b      	ldr	r3, [r3, #0]
34006b78:	f003 0308 	and.w	r3, r3, #8
34006b7c:	2b00      	cmp	r3, #0
34006b7e:	d10a      	bne.n	34006b96 <HAL_RCC_OscConfig+0x62>
34006b80:	687b      	ldr	r3, [r7, #4]
34006b82:	681b      	ldr	r3, [r3, #0]
34006b84:	f003 0304 	and.w	r3, r3, #4
34006b88:	2b00      	cmp	r3, #0
34006b8a:	d104      	bne.n	34006b96 <HAL_RCC_OscConfig+0x62>
34006b8c:	f44f 71b9 	mov.w	r1, #370	@ 0x172
34006b90:	4892      	ldr	r0, [pc, #584]	@ (34006ddc <HAL_RCC_OscConfig+0x2a8>)
34006b92:	f7fb fa3d 	bl	34002010 <assert_failed>

  cpuclksrc = LL_RCC_GetCpuClkSource();
34006b96:	f7ff fe73 	bl	34006880 <LL_RCC_GetCpuClkSource>
34006b9a:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
  sysclksrc = LL_RCC_GetSysClkSource();
34006b9e:	f7ff fe7d 	bl	3400689c <LL_RCC_GetSysClkSource>
34006ba2:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
  pll1src = LL_RCC_PLL1_GetSource();
34006ba6:	f7ff fe87 	bl	340068b8 <LL_RCC_PLL1_GetSource>
34006baa:	67f8      	str	r0, [r7, #124]	@ 0x7c
  pll2src = LL_RCC_PLL2_GetSource();
34006bac:	f7ff feba 	bl	34006924 <LL_RCC_PLL2_GetSource>
34006bb0:	67b8      	str	r0, [r7, #120]	@ 0x78
  pll3src = LL_RCC_PLL3_GetSource();
34006bb2:	f7ff feed 	bl	34006990 <LL_RCC_PLL3_GetSource>
34006bb6:	6778      	str	r0, [r7, #116]	@ 0x74
  pll4src = LL_RCC_PLL4_GetSource();
34006bb8:	f7ff ff20 	bl	340069fc <LL_RCC_PLL4_GetSource>
34006bbc:	6738      	str	r0, [r7, #112]	@ 0x70
  rccsr = RCC->SR;
34006bbe:	4b88      	ldr	r3, [pc, #544]	@ (34006de0 <HAL_RCC_OscConfig+0x2ac>)
34006bc0:	685b      	ldr	r3, [r3, #4]
34006bc2:	66fb      	str	r3, [r7, #108]	@ 0x6c

  /*------------------------------- HSE Configuration ------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
34006bc4:	687b      	ldr	r3, [r7, #4]
34006bc6:	681b      	ldr	r3, [r3, #0]
34006bc8:	f003 0301 	and.w	r3, r3, #1
34006bcc:	2b00      	cmp	r3, #0
34006bce:	f000 80c3 	beq.w	34006d58 <HAL_RCC_OscConfig+0x224>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(pRCC_OscInitStruct->HSEState));
34006bd2:	687b      	ldr	r3, [r7, #4]
34006bd4:	685b      	ldr	r3, [r3, #4]
34006bd6:	2b00      	cmp	r3, #0
34006bd8:	d013      	beq.n	34006c02 <HAL_RCC_OscConfig+0xce>
34006bda:	687b      	ldr	r3, [r7, #4]
34006bdc:	685b      	ldr	r3, [r3, #4]
34006bde:	2b10      	cmp	r3, #16
34006be0:	d00f      	beq.n	34006c02 <HAL_RCC_OscConfig+0xce>
34006be2:	687b      	ldr	r3, [r7, #4]
34006be4:	685b      	ldr	r3, [r3, #4]
34006be6:	f248 0210 	movw	r2, #32784	@ 0x8010
34006bea:	4293      	cmp	r3, r2
34006bec:	d009      	beq.n	34006c02 <HAL_RCC_OscConfig+0xce>
34006bee:	687b      	ldr	r3, [r7, #4]
34006bf0:	685b      	ldr	r3, [r3, #4]
34006bf2:	4a7c      	ldr	r2, [pc, #496]	@ (34006de4 <HAL_RCC_OscConfig+0x2b0>)
34006bf4:	4293      	cmp	r3, r2
34006bf6:	d004      	beq.n	34006c02 <HAL_RCC_OscConfig+0xce>
34006bf8:	f44f 71c0 	mov.w	r1, #384	@ 0x180
34006bfc:	4877      	ldr	r0, [pc, #476]	@ (34006ddc <HAL_RCC_OscConfig+0x2a8>)
34006bfe:	f7fb fa07 	bl	34002010 <assert_failed>

    /* When the HSE is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSE) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
34006c02:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34006c06:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34006c0a:	d028      	beq.n	34006c5e <HAL_RCC_OscConfig+0x12a>
34006c0c:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34006c10:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34006c14:	d023      	beq.n	34006c5e <HAL_RCC_OscConfig+0x12a>
34006c16:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34006c18:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34006c1c:	d104      	bne.n	34006c28 <HAL_RCC_OscConfig+0xf4>
        ((pll1src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
34006c1e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34006c20:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34006c24:	2b00      	cmp	r3, #0
34006c26:	d11a      	bne.n	34006c5e <HAL_RCC_OscConfig+0x12a>
34006c28:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
34006c2a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34006c2e:	d104      	bne.n	34006c3a <HAL_RCC_OscConfig+0x106>
        ((pll2src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
34006c30:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34006c32:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34006c36:	2b00      	cmp	r3, #0
34006c38:	d111      	bne.n	34006c5e <HAL_RCC_OscConfig+0x12a>
34006c3a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34006c3c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34006c40:	d104      	bne.n	34006c4c <HAL_RCC_OscConfig+0x118>
        ((pll3src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
34006c42:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34006c44:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34006c48:	2b00      	cmp	r3, #0
34006c4a:	d108      	bne.n	34006c5e <HAL_RCC_OscConfig+0x12a>
34006c4c:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34006c4e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34006c52:	d10b      	bne.n	34006c6c <HAL_RCC_OscConfig+0x138>
        ((pll4src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
34006c54:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34006c56:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34006c5a:	2b00      	cmp	r3, #0
34006c5c:	d006      	beq.n	34006c6c <HAL_RCC_OscConfig+0x138>
    {
      if (pRCC_OscInitStruct->HSEState == RCC_HSE_OFF)
34006c5e:	687b      	ldr	r3, [r7, #4]
34006c60:	685b      	ldr	r3, [r3, #4]
34006c62:	2b00      	cmp	r3, #0
34006c64:	d178      	bne.n	34006d58 <HAL_RCC_OscConfig+0x224>
      {
        return HAL_ERROR;
34006c66:	2301      	movs	r3, #1
34006c68:	f000 bc7e 	b.w	34007568 <HAL_RCC_OscConfig+0xa34>
      /* HSE ON , nothing to do */
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
34006c6c:	687b      	ldr	r3, [r7, #4]
34006c6e:	685b      	ldr	r3, [r3, #4]
34006c70:	2b10      	cmp	r3, #16
34006c72:	d104      	bne.n	34006c7e <HAL_RCC_OscConfig+0x14a>
34006c74:	4b5a      	ldr	r3, [pc, #360]	@ (34006de0 <HAL_RCC_OscConfig+0x2ac>)
34006c76:	2210      	movs	r2, #16
34006c78:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
34006c7c:	e043      	b.n	34006d06 <HAL_RCC_OscConfig+0x1d2>
34006c7e:	687b      	ldr	r3, [r7, #4]
34006c80:	685b      	ldr	r3, [r3, #4]
34006c82:	2b00      	cmp	r3, #0
34006c84:	d10c      	bne.n	34006ca0 <HAL_RCC_OscConfig+0x16c>
34006c86:	4b56      	ldr	r3, [pc, #344]	@ (34006de0 <HAL_RCC_OscConfig+0x2ac>)
34006c88:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34006c8c:	461a      	mov	r2, r3
34006c8e:	2310      	movs	r3, #16
34006c90:	6013      	str	r3, [r2, #0]
34006c92:	4b53      	ldr	r3, [pc, #332]	@ (34006de0 <HAL_RCC_OscConfig+0x2ac>)
34006c94:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34006c96:	4a52      	ldr	r2, [pc, #328]	@ (34006de0 <HAL_RCC_OscConfig+0x2ac>)
34006c98:	f423 33c0 	bic.w	r3, r3, #98304	@ 0x18000
34006c9c:	6553      	str	r3, [r2, #84]	@ 0x54
34006c9e:	e032      	b.n	34006d06 <HAL_RCC_OscConfig+0x1d2>
34006ca0:	687b      	ldr	r3, [r7, #4]
34006ca2:	685b      	ldr	r3, [r3, #4]
34006ca4:	f248 0210 	movw	r2, #32784	@ 0x8010
34006ca8:	4293      	cmp	r3, r2
34006caa:	d110      	bne.n	34006cce <HAL_RCC_OscConfig+0x19a>
34006cac:	4b4c      	ldr	r3, [pc, #304]	@ (34006de0 <HAL_RCC_OscConfig+0x2ac>)
34006cae:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34006cb0:	4a4b      	ldr	r2, [pc, #300]	@ (34006de0 <HAL_RCC_OscConfig+0x2ac>)
34006cb2:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34006cb6:	6553      	str	r3, [r2, #84]	@ 0x54
34006cb8:	4b49      	ldr	r3, [pc, #292]	@ (34006de0 <HAL_RCC_OscConfig+0x2ac>)
34006cba:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34006cbc:	4a48      	ldr	r2, [pc, #288]	@ (34006de0 <HAL_RCC_OscConfig+0x2ac>)
34006cbe:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
34006cc2:	6553      	str	r3, [r2, #84]	@ 0x54
34006cc4:	4b46      	ldr	r3, [pc, #280]	@ (34006de0 <HAL_RCC_OscConfig+0x2ac>)
34006cc6:	2210      	movs	r2, #16
34006cc8:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
34006ccc:	e01b      	b.n	34006d06 <HAL_RCC_OscConfig+0x1d2>
34006cce:	687b      	ldr	r3, [r7, #4]
34006cd0:	685b      	ldr	r3, [r3, #4]
34006cd2:	4a44      	ldr	r2, [pc, #272]	@ (34006de4 <HAL_RCC_OscConfig+0x2b0>)
34006cd4:	4293      	cmp	r3, r2
34006cd6:	d10a      	bne.n	34006cee <HAL_RCC_OscConfig+0x1ba>
34006cd8:	4b41      	ldr	r3, [pc, #260]	@ (34006de0 <HAL_RCC_OscConfig+0x2ac>)
34006cda:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34006cdc:	4a40      	ldr	r2, [pc, #256]	@ (34006de0 <HAL_RCC_OscConfig+0x2ac>)
34006cde:	f443 33c0 	orr.w	r3, r3, #98304	@ 0x18000
34006ce2:	6553      	str	r3, [r2, #84]	@ 0x54
34006ce4:	4b3e      	ldr	r3, [pc, #248]	@ (34006de0 <HAL_RCC_OscConfig+0x2ac>)
34006ce6:	2210      	movs	r2, #16
34006ce8:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
34006cec:	e00b      	b.n	34006d06 <HAL_RCC_OscConfig+0x1d2>
34006cee:	4b3c      	ldr	r3, [pc, #240]	@ (34006de0 <HAL_RCC_OscConfig+0x2ac>)
34006cf0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34006cf4:	461a      	mov	r2, r3
34006cf6:	2310      	movs	r3, #16
34006cf8:	6013      	str	r3, [r2, #0]
34006cfa:	4b39      	ldr	r3, [pc, #228]	@ (34006de0 <HAL_RCC_OscConfig+0x2ac>)
34006cfc:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34006cfe:	4a38      	ldr	r2, [pc, #224]	@ (34006de0 <HAL_RCC_OscConfig+0x2ac>)
34006d00:	f423 33c0 	bic.w	r3, r3, #98304	@ 0x18000
34006d04:	6553      	str	r3, [r2, #84]	@ 0x54

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
34006d06:	f7fd f9a5 	bl	34004054 <HAL_GetTick>
34006d0a:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Check the HSE State */
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
34006d0c:	687b      	ldr	r3, [r7, #4]
34006d0e:	685b      	ldr	r3, [r3, #4]
34006d10:	2b00      	cmp	r3, #0
34006d12:	d01b      	beq.n	34006d4c <HAL_RCC_OscConfig+0x218>
      {
        /* Wait till HSE is ready */
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
34006d14:	e009      	b.n	34006d2a <HAL_RCC_OscConfig+0x1f6>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
34006d16:	f7fd f99d 	bl	34004054 <HAL_GetTick>
34006d1a:	4602      	mov	r2, r0
34006d1c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34006d1e:	1ad3      	subs	r3, r2, r3
34006d20:	2b64      	cmp	r3, #100	@ 0x64
34006d22:	d902      	bls.n	34006d2a <HAL_RCC_OscConfig+0x1f6>
          {
            return HAL_TIMEOUT;
34006d24:	2303      	movs	r3, #3
34006d26:	f000 bc1f 	b.w	34007568 <HAL_RCC_OscConfig+0xa34>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
34006d2a:	4b2d      	ldr	r3, [pc, #180]	@ (34006de0 <HAL_RCC_OscConfig+0x2ac>)
34006d2c:	685b      	ldr	r3, [r3, #4]
34006d2e:	f003 0310 	and.w	r3, r3, #16
34006d32:	2b00      	cmp	r3, #0
34006d34:	d0ef      	beq.n	34006d16 <HAL_RCC_OscConfig+0x1e2>
34006d36:	e00f      	b.n	34006d58 <HAL_RCC_OscConfig+0x224>
      else
      {
        /* Wait till HSE is disabled */
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
34006d38:	f7fd f98c 	bl	34004054 <HAL_GetTick>
34006d3c:	4602      	mov	r2, r0
34006d3e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34006d40:	1ad3      	subs	r3, r2, r3
34006d42:	2b64      	cmp	r3, #100	@ 0x64
34006d44:	d902      	bls.n	34006d4c <HAL_RCC_OscConfig+0x218>
          {
            return HAL_TIMEOUT;
34006d46:	2303      	movs	r3, #3
34006d48:	f000 bc0e 	b.w	34007568 <HAL_RCC_OscConfig+0xa34>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
34006d4c:	4b24      	ldr	r3, [pc, #144]	@ (34006de0 <HAL_RCC_OscConfig+0x2ac>)
34006d4e:	685b      	ldr	r3, [r3, #4]
34006d50:	f003 0310 	and.w	r3, r3, #16
34006d54:	2b00      	cmp	r3, #0
34006d56:	d1ef      	bne.n	34006d38 <HAL_RCC_OscConfig+0x204>
      }
    }
  }

  /*----------------------------- HSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
34006d58:	687b      	ldr	r3, [r7, #4]
34006d5a:	681b      	ldr	r3, [r3, #0]
34006d5c:	f003 0302 	and.w	r3, r3, #2
34006d60:	2b00      	cmp	r3, #0
34006d62:	f000 80c3 	beq.w	34006eec <HAL_RCC_OscConfig+0x3b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(pRCC_OscInitStruct->HSIState));
34006d66:	687b      	ldr	r3, [r7, #4]
34006d68:	68db      	ldr	r3, [r3, #12]
34006d6a:	2b00      	cmp	r3, #0
34006d6c:	d008      	beq.n	34006d80 <HAL_RCC_OscConfig+0x24c>
34006d6e:	687b      	ldr	r3, [r7, #4]
34006d70:	68db      	ldr	r3, [r3, #12]
34006d72:	2b08      	cmp	r3, #8
34006d74:	d004      	beq.n	34006d80 <HAL_RCC_OscConfig+0x24c>
34006d76:	f240 11b5 	movw	r1, #437	@ 0x1b5
34006d7a:	4818      	ldr	r0, [pc, #96]	@ (34006ddc <HAL_RCC_OscConfig+0x2a8>)
34006d7c:	f7fb f948 	bl	34002010 <assert_failed>

    /* When the HSI is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
34006d80:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34006d84:	2b00      	cmp	r3, #0
34006d86:	d023      	beq.n	34006dd0 <HAL_RCC_OscConfig+0x29c>
34006d88:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34006d8c:	2b00      	cmp	r3, #0
34006d8e:	d01f      	beq.n	34006dd0 <HAL_RCC_OscConfig+0x29c>
34006d90:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34006d92:	2b00      	cmp	r3, #0
34006d94:	d104      	bne.n	34006da0 <HAL_RCC_OscConfig+0x26c>
        ((pll1src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
34006d96:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34006d98:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34006d9c:	2b00      	cmp	r3, #0
34006d9e:	d117      	bne.n	34006dd0 <HAL_RCC_OscConfig+0x29c>
34006da0:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
34006da2:	2b00      	cmp	r3, #0
34006da4:	d104      	bne.n	34006db0 <HAL_RCC_OscConfig+0x27c>
        ((pll2src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
34006da6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34006da8:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34006dac:	2b00      	cmp	r3, #0
34006dae:	d10f      	bne.n	34006dd0 <HAL_RCC_OscConfig+0x29c>
34006db0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34006db2:	2b00      	cmp	r3, #0
34006db4:	d104      	bne.n	34006dc0 <HAL_RCC_OscConfig+0x28c>
        ((pll3src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
34006db6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34006db8:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34006dbc:	2b00      	cmp	r3, #0
34006dbe:	d107      	bne.n	34006dd0 <HAL_RCC_OscConfig+0x29c>
34006dc0:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34006dc2:	2b00      	cmp	r3, #0
34006dc4:	d13b      	bne.n	34006e3e <HAL_RCC_OscConfig+0x30a>
        ((pll4src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
34006dc6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34006dc8:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34006dcc:	2b00      	cmp	r3, #0
34006dce:	d036      	beq.n	34006e3e <HAL_RCC_OscConfig+0x30a>
    {
      /* When HSI is used as system clock it will not be disabled */
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
34006dd0:	687b      	ldr	r3, [r7, #4]
34006dd2:	68db      	ldr	r3, [r3, #12]
34006dd4:	2b00      	cmp	r3, #0
34006dd6:	d107      	bne.n	34006de8 <HAL_RCC_OscConfig+0x2b4>
      {
        return HAL_ERROR;
34006dd8:	2301      	movs	r3, #1
34006dda:	e3c5      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
34006ddc:	3401edb8 	.word	0x3401edb8
34006de0:	56028000 	.word	0x56028000
34006de4:	00018010 	.word	0x00018010
      }
      /* Otherwise, just the divider and calibration is allowed */
      else
      {
        /* Check the parameters */
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
34006de8:	687b      	ldr	r3, [r7, #4]
34006dea:	691b      	ldr	r3, [r3, #16]
34006dec:	2b00      	cmp	r3, #0
34006dee:	d012      	beq.n	34006e16 <HAL_RCC_OscConfig+0x2e2>
34006df0:	687b      	ldr	r3, [r7, #4]
34006df2:	691b      	ldr	r3, [r3, #16]
34006df4:	2b80      	cmp	r3, #128	@ 0x80
34006df6:	d00e      	beq.n	34006e16 <HAL_RCC_OscConfig+0x2e2>
34006df8:	687b      	ldr	r3, [r7, #4]
34006dfa:	691b      	ldr	r3, [r3, #16]
34006dfc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34006e00:	d009      	beq.n	34006e16 <HAL_RCC_OscConfig+0x2e2>
34006e02:	687b      	ldr	r3, [r7, #4]
34006e04:	691b      	ldr	r3, [r3, #16]
34006e06:	f5b3 7fc0 	cmp.w	r3, #384	@ 0x180
34006e0a:	d004      	beq.n	34006e16 <HAL_RCC_OscConfig+0x2e2>
34006e0c:	f240 11c7 	movw	r1, #455	@ 0x1c7
34006e10:	48a2      	ldr	r0, [pc, #648]	@ (3400709c <HAL_RCC_OscConfig+0x568>)
34006e12:	f7fb f8fd 	bl	34002010 <assert_failed>
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));
34006e16:	687b      	ldr	r3, [r7, #4]
34006e18:	695b      	ldr	r3, [r3, #20]
34006e1a:	2b7f      	cmp	r3, #127	@ 0x7f
34006e1c:	d904      	bls.n	34006e28 <HAL_RCC_OscConfig+0x2f4>
34006e1e:	f44f 71e4 	mov.w	r1, #456	@ 0x1c8
34006e22:	489e      	ldr	r0, [pc, #632]	@ (3400709c <HAL_RCC_OscConfig+0x568>)
34006e24:	f7fb f8f4 	bl	34002010 <assert_failed>

        /* Set the HSI Divider */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pRCC_OscInitStruct->HSIDiv);
34006e28:	687b      	ldr	r3, [r7, #4]
34006e2a:	691b      	ldr	r3, [r3, #16]
34006e2c:	4618      	mov	r0, r3
34006e2e:	f7ff fc49 	bl	340066c4 <LL_RCC_HSI_SetDivider>
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
34006e32:	687b      	ldr	r3, [r7, #4]
34006e34:	695b      	ldr	r3, [r3, #20]
34006e36:	4618      	mov	r0, r3
34006e38:	f7ff fc66 	bl	34006708 <LL_RCC_HSI_SetCalibTrimming>
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
34006e3c:	e056      	b.n	34006eec <HAL_RCC_OscConfig+0x3b8>
      }
    }
    else
    {
      /* Check the HSI State */
      if (pRCC_OscInitStruct->HSIState != RCC_HSI_OFF)
34006e3e:	687b      	ldr	r3, [r7, #4]
34006e40:	68db      	ldr	r3, [r3, #12]
34006e42:	2b00      	cmp	r3, #0
34006e44:	d03e      	beq.n	34006ec4 <HAL_RCC_OscConfig+0x390>
      {
        /* Check the parameters */
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
34006e46:	687b      	ldr	r3, [r7, #4]
34006e48:	691b      	ldr	r3, [r3, #16]
34006e4a:	2b00      	cmp	r3, #0
34006e4c:	d012      	beq.n	34006e74 <HAL_RCC_OscConfig+0x340>
34006e4e:	687b      	ldr	r3, [r7, #4]
34006e50:	691b      	ldr	r3, [r3, #16]
34006e52:	2b80      	cmp	r3, #128	@ 0x80
34006e54:	d00e      	beq.n	34006e74 <HAL_RCC_OscConfig+0x340>
34006e56:	687b      	ldr	r3, [r7, #4]
34006e58:	691b      	ldr	r3, [r3, #16]
34006e5a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34006e5e:	d009      	beq.n	34006e74 <HAL_RCC_OscConfig+0x340>
34006e60:	687b      	ldr	r3, [r7, #4]
34006e62:	691b      	ldr	r3, [r3, #16]
34006e64:	f5b3 7fc0 	cmp.w	r3, #384	@ 0x180
34006e68:	d004      	beq.n	34006e74 <HAL_RCC_OscConfig+0x340>
34006e6a:	f44f 71eb 	mov.w	r1, #470	@ 0x1d6
34006e6e:	488b      	ldr	r0, [pc, #556]	@ (3400709c <HAL_RCC_OscConfig+0x568>)
34006e70:	f7fb f8ce 	bl	34002010 <assert_failed>
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));
34006e74:	687b      	ldr	r3, [r7, #4]
34006e76:	695b      	ldr	r3, [r3, #20]
34006e78:	2b7f      	cmp	r3, #127	@ 0x7f
34006e7a:	d904      	bls.n	34006e86 <HAL_RCC_OscConfig+0x352>
34006e7c:	f240 11d7 	movw	r1, #471	@ 0x1d7
34006e80:	4886      	ldr	r0, [pc, #536]	@ (3400709c <HAL_RCC_OscConfig+0x568>)
34006e82:	f7fb f8c5 	bl	34002010 <assert_failed>

        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
34006e86:	f7ff fbed 	bl	34006664 <LL_RCC_HSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
34006e8a:	f7fd f8e3 	bl	34004054 <HAL_GetTick>
34006e8e:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till HSI is ready */
        while (LL_RCC_HSI_IsReady() == 0U)
34006e90:	e008      	b.n	34006ea4 <HAL_RCC_OscConfig+0x370>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
34006e92:	f7fd f8df 	bl	34004054 <HAL_GetTick>
34006e96:	4602      	mov	r2, r0
34006e98:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34006e9a:	1ad3      	subs	r3, r2, r3
34006e9c:	2b01      	cmp	r3, #1
34006e9e:	d901      	bls.n	34006ea4 <HAL_RCC_OscConfig+0x370>
          {
            return HAL_TIMEOUT;
34006ea0:	2303      	movs	r3, #3
34006ea2:	e361      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
        while (LL_RCC_HSI_IsReady() == 0U)
34006ea4:	f7ff fbfc 	bl	340066a0 <LL_RCC_HSI_IsReady>
34006ea8:	4603      	mov	r3, r0
34006eaa:	2b00      	cmp	r3, #0
34006eac:	d0f1      	beq.n	34006e92 <HAL_RCC_OscConfig+0x35e>
          }
        }

        /* Set the HSI Divider */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pRCC_OscInitStruct->HSIDiv);
34006eae:	687b      	ldr	r3, [r7, #4]
34006eb0:	691b      	ldr	r3, [r3, #16]
34006eb2:	4618      	mov	r0, r3
34006eb4:	f7ff fc06 	bl	340066c4 <LL_RCC_HSI_SetDivider>
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
34006eb8:	687b      	ldr	r3, [r7, #4]
34006eba:	695b      	ldr	r3, [r3, #20]
34006ebc:	4618      	mov	r0, r3
34006ebe:	f7ff fc23 	bl	34006708 <LL_RCC_HSI_SetCalibTrimming>
34006ec2:	e013      	b.n	34006eec <HAL_RCC_OscConfig+0x3b8>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
34006ec4:	f7ff fbdc 	bl	34006680 <LL_RCC_HSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
34006ec8:	f7fd f8c4 	bl	34004054 <HAL_GetTick>
34006ecc:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till HSI is disabled */
        while (LL_RCC_HSI_IsReady() != 0U)
34006ece:	e008      	b.n	34006ee2 <HAL_RCC_OscConfig+0x3ae>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
34006ed0:	f7fd f8c0 	bl	34004054 <HAL_GetTick>
34006ed4:	4602      	mov	r2, r0
34006ed6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34006ed8:	1ad3      	subs	r3, r2, r3
34006eda:	2b01      	cmp	r3, #1
34006edc:	d901      	bls.n	34006ee2 <HAL_RCC_OscConfig+0x3ae>
          {
            return HAL_TIMEOUT;
34006ede:	2303      	movs	r3, #3
34006ee0:	e342      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
        while (LL_RCC_HSI_IsReady() != 0U)
34006ee2:	f7ff fbdd 	bl	340066a0 <LL_RCC_HSI_IsReady>
34006ee6:	4603      	mov	r3, r0
34006ee8:	2b00      	cmp	r3, #0
34006eea:	d1f1      	bne.n	34006ed0 <HAL_RCC_OscConfig+0x39c>
      }
    }
  }

  /*----------------------------- MSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
34006eec:	687b      	ldr	r3, [r7, #4]
34006eee:	681b      	ldr	r3, [r3, #0]
34006ef0:	f003 0310 	and.w	r3, r3, #16
34006ef4:	2b00      	cmp	r3, #0
34006ef6:	f000 809e 	beq.w	34007036 <HAL_RCC_OscConfig+0x502>
  {
    /* Check the parameters */
    assert_param(IS_RCC_MSI(pRCC_OscInitStruct->MSIState));
34006efa:	687b      	ldr	r3, [r7, #4]
34006efc:	69db      	ldr	r3, [r3, #28]
34006efe:	2b00      	cmp	r3, #0
34006f00:	d008      	beq.n	34006f14 <HAL_RCC_OscConfig+0x3e0>
34006f02:	687b      	ldr	r3, [r7, #4]
34006f04:	69db      	ldr	r3, [r3, #28]
34006f06:	2b04      	cmp	r3, #4
34006f08:	d004      	beq.n	34006f14 <HAL_RCC_OscConfig+0x3e0>
34006f0a:	f240 2105 	movw	r1, #517	@ 0x205
34006f0e:	4863      	ldr	r0, [pc, #396]	@ (3400709c <HAL_RCC_OscConfig+0x568>)
34006f10:	f7fb f87e 	bl	34002010 <assert_failed>

    /* When the MSI is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    /* but just to update the MSI calibration value */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_MSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
34006f14:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34006f18:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34006f1c:	d028      	beq.n	34006f70 <HAL_RCC_OscConfig+0x43c>
34006f1e:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34006f22:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34006f26:	d023      	beq.n	34006f70 <HAL_RCC_OscConfig+0x43c>
34006f28:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34006f2a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34006f2e:	d104      	bne.n	34006f3a <HAL_RCC_OscConfig+0x406>
        ((pll1src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
34006f30:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34006f32:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34006f36:	2b00      	cmp	r3, #0
34006f38:	d11a      	bne.n	34006f70 <HAL_RCC_OscConfig+0x43c>
34006f3a:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
34006f3c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34006f40:	d104      	bne.n	34006f4c <HAL_RCC_OscConfig+0x418>
        ((pll2src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
34006f42:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34006f44:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34006f48:	2b00      	cmp	r3, #0
34006f4a:	d111      	bne.n	34006f70 <HAL_RCC_OscConfig+0x43c>
34006f4c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34006f4e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34006f52:	d104      	bne.n	34006f5e <HAL_RCC_OscConfig+0x42a>
        ((pll3src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
34006f54:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34006f56:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34006f5a:	2b00      	cmp	r3, #0
34006f5c:	d108      	bne.n	34006f70 <HAL_RCC_OscConfig+0x43c>
34006f5e:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34006f60:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34006f64:	d119      	bne.n	34006f9a <HAL_RCC_OscConfig+0x466>
        ((pll4src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
34006f66:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34006f68:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34006f6c:	2b00      	cmp	r3, #0
34006f6e:	d014      	beq.n	34006f9a <HAL_RCC_OscConfig+0x466>
    {
      /* When MSI is used as system clock it will not disabled */
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
34006f70:	687b      	ldr	r3, [r7, #4]
34006f72:	69db      	ldr	r3, [r3, #28]
34006f74:	2b00      	cmp	r3, #0
34006f76:	d101      	bne.n	34006f7c <HAL_RCC_OscConfig+0x448>
      {
        return HAL_ERROR;
34006f78:	2301      	movs	r3, #1
34006f7a:	e2f5      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Check the parameters */
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));
34006f7c:	687b      	ldr	r3, [r7, #4]
34006f7e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34006f80:	2b1f      	cmp	r3, #31
34006f82:	d904      	bls.n	34006f8e <HAL_RCC_OscConfig+0x45a>
34006f84:	f44f 7106 	mov.w	r1, #536	@ 0x218
34006f88:	4844      	ldr	r0, [pc, #272]	@ (3400709c <HAL_RCC_OscConfig+0x568>)
34006f8a:	f7fb f841 	bl	34002010 <assert_failed>

        /* Adjusts the Internal High Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->MSICalibrationValue);
34006f8e:	687b      	ldr	r3, [r7, #4]
34006f90:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34006f92:	4618      	mov	r0, r3
34006f94:	f7ff fc20 	bl	340067d8 <LL_RCC_MSI_SetCalibTrimming>
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
34006f98:	e04d      	b.n	34007036 <HAL_RCC_OscConfig+0x502>
      }
    }
    else
    {
      /* Check the MSI State */
      if ((pRCC_OscInitStruct->MSIState) != RCC_MSI_OFF)
34006f9a:	687b      	ldr	r3, [r7, #4]
34006f9c:	69db      	ldr	r3, [r3, #28]
34006f9e:	2b00      	cmp	r3, #0
34006fa0:	d035      	beq.n	3400700e <HAL_RCC_OscConfig+0x4da>
      {
        /* Check the parameters */
        assert_param(IS_RCC_MSI_FREQUENCY(pRCC_OscInitStruct->MSIFrequency));
34006fa2:	687b      	ldr	r3, [r7, #4]
34006fa4:	6a1b      	ldr	r3, [r3, #32]
34006fa6:	2b00      	cmp	r3, #0
34006fa8:	d009      	beq.n	34006fbe <HAL_RCC_OscConfig+0x48a>
34006faa:	687b      	ldr	r3, [r7, #4]
34006fac:	6a1b      	ldr	r3, [r3, #32]
34006fae:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34006fb2:	d004      	beq.n	34006fbe <HAL_RCC_OscConfig+0x48a>
34006fb4:	f44f 7109 	mov.w	r1, #548	@ 0x224
34006fb8:	4838      	ldr	r0, [pc, #224]	@ (3400709c <HAL_RCC_OscConfig+0x568>)
34006fba:	f7fb f829 	bl	34002010 <assert_failed>
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));
34006fbe:	687b      	ldr	r3, [r7, #4]
34006fc0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34006fc2:	2b1f      	cmp	r3, #31
34006fc4:	d904      	bls.n	34006fd0 <HAL_RCC_OscConfig+0x49c>
34006fc6:	f240 2125 	movw	r1, #549	@ 0x225
34006fca:	4834      	ldr	r0, [pc, #208]	@ (3400709c <HAL_RCC_OscConfig+0x568>)
34006fcc:	f7fb f820 	bl	34002010 <assert_failed>

        /* Set the frequency */
        __HAL_RCC_MSI_FREQUENCY_CONFIG(pRCC_OscInitStruct->MSIFrequency);
34006fd0:	687b      	ldr	r3, [r7, #4]
34006fd2:	6a1b      	ldr	r3, [r3, #32]
34006fd4:	4618      	mov	r0, r3
34006fd6:	f7ff fbdd 	bl	34006794 <LL_RCC_MSI_SetFrequency>

        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
34006fda:	f7ff fbab 	bl	34006734 <LL_RCC_MSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
34006fde:	f7fd f839 	bl	34004054 <HAL_GetTick>
34006fe2:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till MSI is ready */
        while (LL_RCC_MSI_IsReady() == 0U)
34006fe4:	e008      	b.n	34006ff8 <HAL_RCC_OscConfig+0x4c4>
        {
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
34006fe6:	f7fd f835 	bl	34004054 <HAL_GetTick>
34006fea:	4602      	mov	r2, r0
34006fec:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34006fee:	1ad3      	subs	r3, r2, r3
34006ff0:	2b01      	cmp	r3, #1
34006ff2:	d901      	bls.n	34006ff8 <HAL_RCC_OscConfig+0x4c4>
          {
            return HAL_TIMEOUT;
34006ff4:	2303      	movs	r3, #3
34006ff6:	e2b7      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
        while (LL_RCC_MSI_IsReady() == 0U)
34006ff8:	f7ff fbba 	bl	34006770 <LL_RCC_MSI_IsReady>
34006ffc:	4603      	mov	r3, r0
34006ffe:	2b00      	cmp	r3, #0
34007000:	d0f1      	beq.n	34006fe6 <HAL_RCC_OscConfig+0x4b2>
          }
        }

        /* Adjusts the Internal High Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->MSICalibrationValue);
34007002:	687b      	ldr	r3, [r7, #4]
34007004:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34007006:	4618      	mov	r0, r3
34007008:	f7ff fbe6 	bl	340067d8 <LL_RCC_MSI_SetCalibTrimming>
3400700c:	e013      	b.n	34007036 <HAL_RCC_OscConfig+0x502>
      }
      else
      {
        /* Ignore MSI frequency and calibration values in disable case */
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
3400700e:	f7ff fb9f 	bl	34006750 <LL_RCC_MSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
34007012:	f7fd f81f 	bl	34004054 <HAL_GetTick>
34007016:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till MSI is disabled */
        while (LL_RCC_MSI_IsReady() != 0U)
34007018:	e008      	b.n	3400702c <HAL_RCC_OscConfig+0x4f8>
        {
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
3400701a:	f7fd f81b 	bl	34004054 <HAL_GetTick>
3400701e:	4602      	mov	r2, r0
34007020:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34007022:	1ad3      	subs	r3, r2, r3
34007024:	2b01      	cmp	r3, #1
34007026:	d901      	bls.n	3400702c <HAL_RCC_OscConfig+0x4f8>
          {
            return HAL_TIMEOUT;
34007028:	2303      	movs	r3, #3
3400702a:	e29d      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
        while (LL_RCC_MSI_IsReady() != 0U)
3400702c:	f7ff fba0 	bl	34006770 <LL_RCC_MSI_IsReady>
34007030:	4603      	mov	r3, r0
34007032:	2b00      	cmp	r3, #0
34007034:	d1f1      	bne.n	3400701a <HAL_RCC_OscConfig+0x4e6>
      }
    }
  }

  /*------------------------------ LSI Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
34007036:	687b      	ldr	r3, [r7, #4]
34007038:	681b      	ldr	r3, [r3, #0]
3400703a:	f003 0308 	and.w	r3, r3, #8
3400703e:	2b00      	cmp	r3, #0
34007040:	d03c      	beq.n	340070bc <HAL_RCC_OscConfig+0x588>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(pRCC_OscInitStruct->LSIState));
34007042:	687b      	ldr	r3, [r7, #4]
34007044:	699b      	ldr	r3, [r3, #24]
34007046:	2b00      	cmp	r3, #0
34007048:	d008      	beq.n	3400705c <HAL_RCC_OscConfig+0x528>
3400704a:	687b      	ldr	r3, [r7, #4]
3400704c:	699b      	ldr	r3, [r3, #24]
3400704e:	2b01      	cmp	r3, #1
34007050:	d004      	beq.n	3400705c <HAL_RCC_OscConfig+0x528>
34007052:	f240 2155 	movw	r1, #597	@ 0x255
34007056:	4811      	ldr	r0, [pc, #68]	@ (3400709c <HAL_RCC_OscConfig+0x568>)
34007058:	f7fa ffda 	bl	34002010 <assert_failed>

    /* Check the LSI State */
    if ((pRCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
3400705c:	687b      	ldr	r3, [r7, #4]
3400705e:	699b      	ldr	r3, [r3, #24]
34007060:	2b00      	cmp	r3, #0
34007062:	d014      	beq.n	3400708e <HAL_RCC_OscConfig+0x55a>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
34007064:	f7ff fbe0 	bl	34006828 <LL_RCC_LSI_Enable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
34007068:	f7fc fff4 	bl	34004054 <HAL_GetTick>
3400706c:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() == 0U)
3400706e:	e008      	b.n	34007082 <HAL_RCC_OscConfig+0x54e>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
34007070:	f7fc fff0 	bl	34004054 <HAL_GetTick>
34007074:	4602      	mov	r2, r0
34007076:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34007078:	1ad3      	subs	r3, r2, r3
3400707a:	2b01      	cmp	r3, #1
3400707c:	d901      	bls.n	34007082 <HAL_RCC_OscConfig+0x54e>
        {
          return HAL_TIMEOUT;
3400707e:	2303      	movs	r3, #3
34007080:	e272      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
      while (LL_RCC_LSI_IsReady() == 0U)
34007082:	f7ff fbef 	bl	34006864 <LL_RCC_LSI_IsReady>
34007086:	4603      	mov	r3, r0
34007088:	2b00      	cmp	r3, #0
3400708a:	d0f1      	beq.n	34007070 <HAL_RCC_OscConfig+0x53c>
3400708c:	e016      	b.n	340070bc <HAL_RCC_OscConfig+0x588>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
3400708e:	f7ff fbd9 	bl	34006844 <LL_RCC_LSI_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
34007092:	f7fc ffdf 	bl	34004054 <HAL_GetTick>
34007096:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() != 0U)
34007098:	e00b      	b.n	340070b2 <HAL_RCC_OscConfig+0x57e>
3400709a:	bf00      	nop
3400709c:	3401edb8 	.word	0x3401edb8
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
340070a0:	f7fc ffd8 	bl	34004054 <HAL_GetTick>
340070a4:	4602      	mov	r2, r0
340070a6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
340070a8:	1ad3      	subs	r3, r2, r3
340070aa:	2b01      	cmp	r3, #1
340070ac:	d901      	bls.n	340070b2 <HAL_RCC_OscConfig+0x57e>
        {
          return HAL_TIMEOUT;
340070ae:	2303      	movs	r3, #3
340070b0:	e25a      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
      while (LL_RCC_LSI_IsReady() != 0U)
340070b2:	f7ff fbd7 	bl	34006864 <LL_RCC_LSI_IsReady>
340070b6:	4603      	mov	r3, r0
340070b8:	2b00      	cmp	r3, #0
340070ba:	d1f1      	bne.n	340070a0 <HAL_RCC_OscConfig+0x56c>
      }
    }
  }

  /*------------------------------ LSE Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
340070bc:	687b      	ldr	r3, [r7, #4]
340070be:	681b      	ldr	r3, [r3, #0]
340070c0:	f003 0304 	and.w	r3, r3, #4
340070c4:	2b00      	cmp	r3, #0
340070c6:	f000 80a4 	beq.w	34007212 <HAL_RCC_OscConfig+0x6de>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(pRCC_OscInitStruct->LSEState));
340070ca:	687b      	ldr	r3, [r7, #4]
340070cc:	689b      	ldr	r3, [r3, #8]
340070ce:	2b00      	cmp	r3, #0
340070d0:	d013      	beq.n	340070fa <HAL_RCC_OscConfig+0x5c6>
340070d2:	687b      	ldr	r3, [r7, #4]
340070d4:	689b      	ldr	r3, [r3, #8]
340070d6:	2b02      	cmp	r3, #2
340070d8:	d00f      	beq.n	340070fa <HAL_RCC_OscConfig+0x5c6>
340070da:	687b      	ldr	r3, [r7, #4]
340070dc:	689b      	ldr	r3, [r3, #8]
340070de:	f248 0202 	movw	r2, #32770	@ 0x8002
340070e2:	4293      	cmp	r3, r2
340070e4:	d009      	beq.n	340070fa <HAL_RCC_OscConfig+0x5c6>
340070e6:	687b      	ldr	r3, [r7, #4]
340070e8:	689b      	ldr	r3, [r3, #8]
340070ea:	4a9b      	ldr	r2, [pc, #620]	@ (34007358 <HAL_RCC_OscConfig+0x824>)
340070ec:	4293      	cmp	r3, r2
340070ee:	d004      	beq.n	340070fa <HAL_RCC_OscConfig+0x5c6>
340070f0:	f44f 7120 	mov.w	r1, #640	@ 0x280
340070f4:	4899      	ldr	r0, [pc, #612]	@ (3400735c <HAL_RCC_OscConfig+0x828>)
340070f6:	f7fa ff8b 	bl	34002010 <assert_failed>

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
340070fa:	687b      	ldr	r3, [r7, #4]
340070fc:	689b      	ldr	r3, [r3, #8]
340070fe:	2b02      	cmp	r3, #2
34007100:	d104      	bne.n	3400710c <HAL_RCC_OscConfig+0x5d8>
34007102:	4b97      	ldr	r3, [pc, #604]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
34007104:	2202      	movs	r2, #2
34007106:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3400710a:	e055      	b.n	340071b8 <HAL_RCC_OscConfig+0x684>
3400710c:	687b      	ldr	r3, [r7, #4]
3400710e:	689b      	ldr	r3, [r3, #8]
34007110:	2b00      	cmp	r3, #0
34007112:	d112      	bne.n	3400713a <HAL_RCC_OscConfig+0x606>
34007114:	4b92      	ldr	r3, [pc, #584]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
34007116:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400711a:	461a      	mov	r2, r3
3400711c:	2302      	movs	r3, #2
3400711e:	6013      	str	r3, [r2, #0]
34007120:	4b8f      	ldr	r3, [pc, #572]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
34007122:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34007124:	4a8e      	ldr	r2, [pc, #568]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
34007126:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400712a:	6413      	str	r3, [r2, #64]	@ 0x40
3400712c:	4b8c      	ldr	r3, [pc, #560]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
3400712e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34007130:	4a8b      	ldr	r2, [pc, #556]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
34007132:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
34007136:	6413      	str	r3, [r2, #64]	@ 0x40
34007138:	e03e      	b.n	340071b8 <HAL_RCC_OscConfig+0x684>
3400713a:	687b      	ldr	r3, [r7, #4]
3400713c:	689b      	ldr	r3, [r3, #8]
3400713e:	f248 0202 	movw	r2, #32770	@ 0x8002
34007142:	4293      	cmp	r3, r2
34007144:	d110      	bne.n	34007168 <HAL_RCC_OscConfig+0x634>
34007146:	4b86      	ldr	r3, [pc, #536]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
34007148:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400714a:	4a85      	ldr	r2, [pc, #532]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
3400714c:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34007150:	6413      	str	r3, [r2, #64]	@ 0x40
34007152:	4b83      	ldr	r3, [pc, #524]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
34007154:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34007156:	4a82      	ldr	r2, [pc, #520]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
34007158:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400715c:	6413      	str	r3, [r2, #64]	@ 0x40
3400715e:	4b80      	ldr	r3, [pc, #512]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
34007160:	2202      	movs	r2, #2
34007162:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
34007166:	e027      	b.n	340071b8 <HAL_RCC_OscConfig+0x684>
34007168:	687b      	ldr	r3, [r7, #4]
3400716a:	689b      	ldr	r3, [r3, #8]
3400716c:	4a7a      	ldr	r2, [pc, #488]	@ (34007358 <HAL_RCC_OscConfig+0x824>)
3400716e:	4293      	cmp	r3, r2
34007170:	d110      	bne.n	34007194 <HAL_RCC_OscConfig+0x660>
34007172:	4b7b      	ldr	r3, [pc, #492]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
34007174:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34007176:	4a7a      	ldr	r2, [pc, #488]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
34007178:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3400717c:	6413      	str	r3, [r2, #64]	@ 0x40
3400717e:	4b78      	ldr	r3, [pc, #480]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
34007180:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34007182:	4a77      	ldr	r2, [pc, #476]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
34007184:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34007188:	6413      	str	r3, [r2, #64]	@ 0x40
3400718a:	4b75      	ldr	r3, [pc, #468]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
3400718c:	2202      	movs	r2, #2
3400718e:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
34007192:	e011      	b.n	340071b8 <HAL_RCC_OscConfig+0x684>
34007194:	4b72      	ldr	r3, [pc, #456]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
34007196:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400719a:	461a      	mov	r2, r3
3400719c:	2302      	movs	r3, #2
3400719e:	6013      	str	r3, [r2, #0]
340071a0:	4b6f      	ldr	r3, [pc, #444]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
340071a2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
340071a4:	4a6e      	ldr	r2, [pc, #440]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
340071a6:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
340071aa:	6413      	str	r3, [r2, #64]	@ 0x40
340071ac:	4b6c      	ldr	r3, [pc, #432]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
340071ae:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
340071b0:	4a6b      	ldr	r2, [pc, #428]	@ (34007360 <HAL_RCC_OscConfig+0x82c>)
340071b2:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
340071b6:	6413      	str	r3, [r2, #64]	@ 0x40
    /* Check the LSE State */
    if ((pRCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
340071b8:	687b      	ldr	r3, [r7, #4]
340071ba:	689b      	ldr	r3, [r3, #8]
340071bc:	2b00      	cmp	r3, #0
340071be:	d014      	beq.n	340071ea <HAL_RCC_OscConfig+0x6b6>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
340071c0:	f7fc ff48 	bl	34004054 <HAL_GetTick>
340071c4:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSE is ready */
      while (LL_RCC_LSE_IsReady() == 0U)
340071c6:	e00a      	b.n	340071de <HAL_RCC_OscConfig+0x6aa>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
340071c8:	f7fc ff44 	bl	34004054 <HAL_GetTick>
340071cc:	4602      	mov	r2, r0
340071ce:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
340071d0:	1ad3      	subs	r3, r2, r3
340071d2:	f241 3288 	movw	r2, #5000	@ 0x1388
340071d6:	4293      	cmp	r3, r2
340071d8:	d901      	bls.n	340071de <HAL_RCC_OscConfig+0x6aa>
        {
          return HAL_TIMEOUT;
340071da:	2303      	movs	r3, #3
340071dc:	e1c4      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
      while (LL_RCC_LSE_IsReady() == 0U)
340071de:	f7ff fb11 	bl	34006804 <LL_RCC_LSE_IsReady>
340071e2:	4603      	mov	r3, r0
340071e4:	2b00      	cmp	r3, #0
340071e6:	d0ef      	beq.n	340071c8 <HAL_RCC_OscConfig+0x694>
340071e8:	e013      	b.n	34007212 <HAL_RCC_OscConfig+0x6de>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
340071ea:	f7fc ff33 	bl	34004054 <HAL_GetTick>
340071ee:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSE is disabled */
      while (LL_RCC_LSE_IsReady() != 0U)
340071f0:	e00a      	b.n	34007208 <HAL_RCC_OscConfig+0x6d4>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
340071f2:	f7fc ff2f 	bl	34004054 <HAL_GetTick>
340071f6:	4602      	mov	r2, r0
340071f8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
340071fa:	1ad3      	subs	r3, r2, r3
340071fc:	f241 3288 	movw	r2, #5000	@ 0x1388
34007200:	4293      	cmp	r3, r2
34007202:	d901      	bls.n	34007208 <HAL_RCC_OscConfig+0x6d4>
        {
          return HAL_TIMEOUT;
34007204:	2303      	movs	r3, #3
34007206:	e1af      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
      while (LL_RCC_LSE_IsReady() != 0U)
34007208:	f7ff fafc 	bl	34006804 <LL_RCC_LSE_IsReady>
3400720c:	4603      	mov	r3, r0
3400720e:	2b00      	cmp	r3, #0
34007210:	d1ef      	bne.n	340071f2 <HAL_RCC_OscConfig+0x6be>
    }
  }

  /*-------------------------------- PLL1 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL1.PLLState));
34007212:	687b      	ldr	r3, [r7, #4]
34007214:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34007216:	2b00      	cmp	r3, #0
34007218:	d010      	beq.n	3400723c <HAL_RCC_OscConfig+0x708>
3400721a:	687b      	ldr	r3, [r7, #4]
3400721c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400721e:	2b01      	cmp	r3, #1
34007220:	d00c      	beq.n	3400723c <HAL_RCC_OscConfig+0x708>
34007222:	687b      	ldr	r3, [r7, #4]
34007224:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34007226:	2b02      	cmp	r3, #2
34007228:	d008      	beq.n	3400723c <HAL_RCC_OscConfig+0x708>
3400722a:	687b      	ldr	r3, [r7, #4]
3400722c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400722e:	2b03      	cmp	r3, #3
34007230:	d004      	beq.n	3400723c <HAL_RCC_OscConfig+0x708>
34007232:	f240 21a5 	movw	r1, #677	@ 0x2a5
34007236:	4849      	ldr	r0, [pc, #292]	@ (3400735c <HAL_RCC_OscConfig+0x828>)
34007238:	f7fa feea 	bl	34002010 <assert_failed>

  if (pRCC_OscInitStruct->PLL1.PLLState != RCC_PLL_NONE)
3400723c:	687b      	ldr	r3, [r7, #4]
3400723e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34007240:	2b00      	cmp	r3, #0
34007242:	d04c      	beq.n	340072de <HAL_RCC_OscConfig+0x7aa>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1));
34007244:	687b      	ldr	r3, [r7, #4]
34007246:	3328      	adds	r3, #40	@ 0x28
34007248:	4619      	mov	r1, r3
3400724a:	2000      	movs	r0, #0
3400724c:	f001 f8e0 	bl	34008410 <RCC_PLL_IsNewConfig>
34007250:	6678      	str	r0, [r7, #100]	@ 0x64
    uint32_t pll1_ready = LL_RCC_PLL1_IsReady();
34007252:	f7ff fb3f 	bl	340068d4 <LL_RCC_PLL1_IsReady>
34007256:	6638      	str	r0, [r7, #96]	@ 0x60
    if (new_pll_config == 1U)
34007258:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3400725a:	2b01      	cmp	r3, #1
3400725c:	d130      	bne.n	340072c0 <HAL_RCC_OscConfig+0x78c>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3400725e:	f7ff fc11 	bl	34006a84 <LL_RCC_IC1_GetSource>
34007262:	65f8      	str	r0, [r7, #92]	@ 0x5c
      uint32_t ic2src = LL_RCC_IC2_GetSource();
34007264:	f7ff fc2c 	bl	34006ac0 <LL_RCC_IC2_GetSource>
34007268:	65b8      	str	r0, [r7, #88]	@ 0x58
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3400726a:	f7ff fc47 	bl	34006afc <LL_RCC_IC6_GetSource>
3400726e:	6578      	str	r0, [r7, #84]	@ 0x54
      uint32_t ic11src = LL_RCC_IC11_GetSource();
34007270:	f7ff fc52 	bl	34006b18 <LL_RCC_IC11_GetSource>
34007274:	6538      	str	r0, [r7, #80]	@ 0x50
      /* PLL1 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL1))
34007276:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3400727a:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400727e:	d104      	bne.n	3400728a <HAL_RCC_OscConfig+0x756>
34007280:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34007282:	2b00      	cmp	r3, #0
34007284:	d101      	bne.n	3400728a <HAL_RCC_OscConfig+0x756>
      {
        return HAL_ERROR;
34007286:	2301      	movs	r3, #1
34007288:	e16e      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
      }

      /* PLL1 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL1) ||
3400728a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3400728e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34007292:	d10a      	bne.n	340072aa <HAL_RCC_OscConfig+0x776>
34007294:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
34007296:	2b00      	cmp	r3, #0
34007298:	d005      	beq.n	340072a6 <HAL_RCC_OscConfig+0x772>
3400729a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3400729c:	2b00      	cmp	r3, #0
3400729e:	d002      	beq.n	340072a6 <HAL_RCC_OscConfig+0x772>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL1) ||
340072a0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
340072a2:	2b00      	cmp	r3, #0
340072a4:	d101      	bne.n	340072aa <HAL_RCC_OscConfig+0x776>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL1)))
      {
        return HAL_ERROR;
340072a6:	2301      	movs	r3, #1
340072a8:	e15e      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
      }
      /* PLL1 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1)) != HAL_OK)
340072aa:	687b      	ldr	r3, [r7, #4]
340072ac:	3328      	adds	r3, #40	@ 0x28
340072ae:	4619      	mov	r1, r3
340072b0:	2000      	movs	r0, #0
340072b2:	f000 fedd 	bl	34008070 <RCC_PLL_Config>
340072b6:	4603      	mov	r3, r0
340072b8:	2b00      	cmp	r3, #0
340072ba:	d010      	beq.n	340072de <HAL_RCC_OscConfig+0x7aa>
      {
        return HAL_ERROR;
340072bc:	2301      	movs	r3, #1
340072be:	e153      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
      }
    }
    else if ((pRCC_OscInitStruct->PLL1.PLLState == RCC_PLL_ON) && (pll1_ready == 0U))
340072c0:	687b      	ldr	r3, [r7, #4]
340072c2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
340072c4:	2b02      	cmp	r3, #2
340072c6:	d10a      	bne.n	340072de <HAL_RCC_OscConfig+0x7aa>
340072c8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
340072ca:	2b00      	cmp	r3, #0
340072cc:	d107      	bne.n	340072de <HAL_RCC_OscConfig+0x7aa>
    {
      if (RCC_PLL_Enable(RCC_PLL1_CONFIG) != HAL_OK)
340072ce:	2000      	movs	r0, #0
340072d0:	f001 f872 	bl	340083b8 <RCC_PLL_Enable>
340072d4:	4603      	mov	r3, r0
340072d6:	2b00      	cmp	r3, #0
340072d8:	d001      	beq.n	340072de <HAL_RCC_OscConfig+0x7aa>
      {
        return HAL_ERROR;
340072da:	2301      	movs	r3, #1
340072dc:	e144      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
    }
  }

  /*-------------------------------- PLL2 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL2.PLLState));
340072de:	687b      	ldr	r3, [r7, #4]
340072e0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340072e2:	2b00      	cmp	r3, #0
340072e4:	d010      	beq.n	34007308 <HAL_RCC_OscConfig+0x7d4>
340072e6:	687b      	ldr	r3, [r7, #4]
340072e8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340072ea:	2b01      	cmp	r3, #1
340072ec:	d00c      	beq.n	34007308 <HAL_RCC_OscConfig+0x7d4>
340072ee:	687b      	ldr	r3, [r7, #4]
340072f0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340072f2:	2b02      	cmp	r3, #2
340072f4:	d008      	beq.n	34007308 <HAL_RCC_OscConfig+0x7d4>
340072f6:	687b      	ldr	r3, [r7, #4]
340072f8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340072fa:	2b03      	cmp	r3, #3
340072fc:	d004      	beq.n	34007308 <HAL_RCC_OscConfig+0x7d4>
340072fe:	f240 21d3 	movw	r1, #723	@ 0x2d3
34007302:	4816      	ldr	r0, [pc, #88]	@ (3400735c <HAL_RCC_OscConfig+0x828>)
34007304:	f7fa fe84 	bl	34002010 <assert_failed>

  if (pRCC_OscInitStruct->PLL2.PLLState != RCC_PLL_NONE)
34007308:	687b      	ldr	r3, [r7, #4]
3400730a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400730c:	2b00      	cmp	r3, #0
3400730e:	d056      	beq.n	340073be <HAL_RCC_OscConfig+0x88a>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2));
34007310:	687b      	ldr	r3, [r7, #4]
34007312:	3344      	adds	r3, #68	@ 0x44
34007314:	4619      	mov	r1, r3
34007316:	2001      	movs	r0, #1
34007318:	f001 f87a 	bl	34008410 <RCC_PLL_IsNewConfig>
3400731c:	64f8      	str	r0, [r7, #76]	@ 0x4c
    uint32_t pll2_ready = LL_RCC_PLL2_IsReady();
3400731e:	f7ff fb0f 	bl	34006940 <LL_RCC_PLL2_IsReady>
34007322:	64b8      	str	r0, [r7, #72]	@ 0x48
    if (new_pll_config == 1U)
34007324:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34007326:	2b01      	cmp	r3, #1
34007328:	d13a      	bne.n	340073a0 <HAL_RCC_OscConfig+0x86c>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3400732a:	f7ff fbab 	bl	34006a84 <LL_RCC_IC1_GetSource>
3400732e:	6478      	str	r0, [r7, #68]	@ 0x44
      uint32_t ic2src = LL_RCC_IC2_GetSource();
34007330:	f7ff fbc6 	bl	34006ac0 <LL_RCC_IC2_GetSource>
34007334:	6438      	str	r0, [r7, #64]	@ 0x40
      uint32_t ic6src = LL_RCC_IC6_GetSource();
34007336:	f7ff fbe1 	bl	34006afc <LL_RCC_IC6_GetSource>
3400733a:	63f8      	str	r0, [r7, #60]	@ 0x3c
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3400733c:	f7ff fbec 	bl	34006b18 <LL_RCC_IC11_GetSource>
34007340:	63b8      	str	r0, [r7, #56]	@ 0x38
      /* PLL2 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL2))
34007342:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34007346:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400734a:	d10b      	bne.n	34007364 <HAL_RCC_OscConfig+0x830>
3400734c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3400734e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34007352:	d107      	bne.n	34007364 <HAL_RCC_OscConfig+0x830>
      {
        return HAL_ERROR;
34007354:	2301      	movs	r3, #1
34007356:	e107      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
34007358:	00018002 	.word	0x00018002
3400735c:	3401edb8 	.word	0x3401edb8
34007360:	56028000 	.word	0x56028000
      }

      /* PLL2 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL2) ||
34007364:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34007368:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400736c:	d10d      	bne.n	3400738a <HAL_RCC_OscConfig+0x856>
3400736e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34007370:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34007374:	d007      	beq.n	34007386 <HAL_RCC_OscConfig+0x852>
34007376:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34007378:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400737c:	d003      	beq.n	34007386 <HAL_RCC_OscConfig+0x852>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL2) ||
3400737e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34007380:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34007384:	d101      	bne.n	3400738a <HAL_RCC_OscConfig+0x856>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL2)))
      {
        return HAL_ERROR;
34007386:	2301      	movs	r3, #1
34007388:	e0ee      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
      }
      /* PLL2 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2)) != HAL_OK)
3400738a:	687b      	ldr	r3, [r7, #4]
3400738c:	3344      	adds	r3, #68	@ 0x44
3400738e:	4619      	mov	r1, r3
34007390:	2001      	movs	r0, #1
34007392:	f000 fe6d 	bl	34008070 <RCC_PLL_Config>
34007396:	4603      	mov	r3, r0
34007398:	2b00      	cmp	r3, #0
3400739a:	d010      	beq.n	340073be <HAL_RCC_OscConfig+0x88a>
      {
        return HAL_ERROR;
3400739c:	2301      	movs	r3, #1
3400739e:	e0e3      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
      }
    }
    else if ((pRCC_OscInitStruct->PLL2.PLLState == RCC_PLL_ON) && (pll2_ready == 0U))
340073a0:	687b      	ldr	r3, [r7, #4]
340073a2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340073a4:	2b02      	cmp	r3, #2
340073a6:	d10a      	bne.n	340073be <HAL_RCC_OscConfig+0x88a>
340073a8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
340073aa:	2b00      	cmp	r3, #0
340073ac:	d107      	bne.n	340073be <HAL_RCC_OscConfig+0x88a>
    {
      if (RCC_PLL_Enable(RCC_PLL2_CONFIG) != HAL_OK)
340073ae:	2001      	movs	r0, #1
340073b0:	f001 f802 	bl	340083b8 <RCC_PLL_Enable>
340073b4:	4603      	mov	r3, r0
340073b6:	2b00      	cmp	r3, #0
340073b8:	d001      	beq.n	340073be <HAL_RCC_OscConfig+0x88a>
      {
        return HAL_ERROR;
340073ba:	2301      	movs	r3, #1
340073bc:	e0d4      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
    }
  }

  /*-------------------------------- PLL3 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL3.PLLState));
340073be:	687b      	ldr	r3, [r7, #4]
340073c0:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
340073c2:	2b00      	cmp	r3, #0
340073c4:	d010      	beq.n	340073e8 <HAL_RCC_OscConfig+0x8b4>
340073c6:	687b      	ldr	r3, [r7, #4]
340073c8:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
340073ca:	2b01      	cmp	r3, #1
340073cc:	d00c      	beq.n	340073e8 <HAL_RCC_OscConfig+0x8b4>
340073ce:	687b      	ldr	r3, [r7, #4]
340073d0:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
340073d2:	2b02      	cmp	r3, #2
340073d4:	d008      	beq.n	340073e8 <HAL_RCC_OscConfig+0x8b4>
340073d6:	687b      	ldr	r3, [r7, #4]
340073d8:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
340073da:	2b03      	cmp	r3, #3
340073dc:	d004      	beq.n	340073e8 <HAL_RCC_OscConfig+0x8b4>
340073de:	f240 3101 	movw	r1, #769	@ 0x301
340073e2:	4863      	ldr	r0, [pc, #396]	@ (34007570 <HAL_RCC_OscConfig+0xa3c>)
340073e4:	f7fa fe14 	bl	34002010 <assert_failed>

  if (pRCC_OscInitStruct->PLL3.PLLState != RCC_PLL_NONE)
340073e8:	687b      	ldr	r3, [r7, #4]
340073ea:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
340073ec:	2b00      	cmp	r3, #0
340073ee:	d050      	beq.n	34007492 <HAL_RCC_OscConfig+0x95e>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3));
340073f0:	687b      	ldr	r3, [r7, #4]
340073f2:	3360      	adds	r3, #96	@ 0x60
340073f4:	4619      	mov	r1, r3
340073f6:	2002      	movs	r0, #2
340073f8:	f001 f80a 	bl	34008410 <RCC_PLL_IsNewConfig>
340073fc:	6378      	str	r0, [r7, #52]	@ 0x34
    uint32_t pll3_ready = LL_RCC_PLL1_IsReady();
340073fe:	f7ff fa69 	bl	340068d4 <LL_RCC_PLL1_IsReady>
34007402:	6338      	str	r0, [r7, #48]	@ 0x30
    if (new_pll_config == 1U)
34007404:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34007406:	2b01      	cmp	r3, #1
34007408:	d134      	bne.n	34007474 <HAL_RCC_OscConfig+0x940>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3400740a:	f7ff fb3b 	bl	34006a84 <LL_RCC_IC1_GetSource>
3400740e:	62f8      	str	r0, [r7, #44]	@ 0x2c
      uint32_t ic2src = LL_RCC_IC2_GetSource();
34007410:	f7ff fb56 	bl	34006ac0 <LL_RCC_IC2_GetSource>
34007414:	62b8      	str	r0, [r7, #40]	@ 0x28
      uint32_t ic6src = LL_RCC_IC6_GetSource();
34007416:	f7ff fb71 	bl	34006afc <LL_RCC_IC6_GetSource>
3400741a:	6278      	str	r0, [r7, #36]	@ 0x24
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3400741c:	f7ff fb7c 	bl	34006b18 <LL_RCC_IC11_GetSource>
34007420:	6238      	str	r0, [r7, #32]
      /* PLL3 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL3))
34007422:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34007426:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400742a:	d105      	bne.n	34007438 <HAL_RCC_OscConfig+0x904>
3400742c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400742e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34007432:	d101      	bne.n	34007438 <HAL_RCC_OscConfig+0x904>
      {
        return HAL_ERROR;
34007434:	2301      	movs	r3, #1
34007436:	e097      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
      }
      /* PLL3 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL3) ||
34007438:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3400743c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34007440:	d10d      	bne.n	3400745e <HAL_RCC_OscConfig+0x92a>
34007442:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007444:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34007448:	d007      	beq.n	3400745a <HAL_RCC_OscConfig+0x926>
3400744a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400744c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34007450:	d003      	beq.n	3400745a <HAL_RCC_OscConfig+0x926>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL3) ||
34007452:	6a3b      	ldr	r3, [r7, #32]
34007454:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34007458:	d101      	bne.n	3400745e <HAL_RCC_OscConfig+0x92a>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL3)))
      {
        return HAL_ERROR;
3400745a:	2301      	movs	r3, #1
3400745c:	e084      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
      }
      /* PLL3 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3)) != HAL_OK)
3400745e:	687b      	ldr	r3, [r7, #4]
34007460:	3360      	adds	r3, #96	@ 0x60
34007462:	4619      	mov	r1, r3
34007464:	2002      	movs	r0, #2
34007466:	f000 fe03 	bl	34008070 <RCC_PLL_Config>
3400746a:	4603      	mov	r3, r0
3400746c:	2b00      	cmp	r3, #0
3400746e:	d010      	beq.n	34007492 <HAL_RCC_OscConfig+0x95e>
      {
        return HAL_ERROR;
34007470:	2301      	movs	r3, #1
34007472:	e079      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
      }
    }
    else if ((pRCC_OscInitStruct->PLL3.PLLState == RCC_PLL_ON) && (pll3_ready == 0U))
34007474:	687b      	ldr	r3, [r7, #4]
34007476:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34007478:	2b02      	cmp	r3, #2
3400747a:	d10a      	bne.n	34007492 <HAL_RCC_OscConfig+0x95e>
3400747c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400747e:	2b00      	cmp	r3, #0
34007480:	d107      	bne.n	34007492 <HAL_RCC_OscConfig+0x95e>
    {
      if (RCC_PLL_Enable(RCC_PLL3_CONFIG) != HAL_OK)
34007482:	2002      	movs	r0, #2
34007484:	f000 ff98 	bl	340083b8 <RCC_PLL_Enable>
34007488:	4603      	mov	r3, r0
3400748a:	2b00      	cmp	r3, #0
3400748c:	d001      	beq.n	34007492 <HAL_RCC_OscConfig+0x95e>
      {
        return HAL_ERROR;
3400748e:	2301      	movs	r3, #1
34007490:	e06a      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
    }
  }

  /*-------------------------------- PLL4 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL4.PLLState));
34007492:	687b      	ldr	r3, [r7, #4]
34007494:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34007496:	2b00      	cmp	r3, #0
34007498:	d010      	beq.n	340074bc <HAL_RCC_OscConfig+0x988>
3400749a:	687b      	ldr	r3, [r7, #4]
3400749c:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400749e:	2b01      	cmp	r3, #1
340074a0:	d00c      	beq.n	340074bc <HAL_RCC_OscConfig+0x988>
340074a2:	687b      	ldr	r3, [r7, #4]
340074a4:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340074a6:	2b02      	cmp	r3, #2
340074a8:	d008      	beq.n	340074bc <HAL_RCC_OscConfig+0x988>
340074aa:	687b      	ldr	r3, [r7, #4]
340074ac:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340074ae:	2b03      	cmp	r3, #3
340074b0:	d004      	beq.n	340074bc <HAL_RCC_OscConfig+0x988>
340074b2:	f240 312e 	movw	r1, #814	@ 0x32e
340074b6:	482e      	ldr	r0, [pc, #184]	@ (34007570 <HAL_RCC_OscConfig+0xa3c>)
340074b8:	f7fa fdaa 	bl	34002010 <assert_failed>

  if (pRCC_OscInitStruct->PLL4.PLLState != RCC_PLL_NONE)
340074bc:	687b      	ldr	r3, [r7, #4]
340074be:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340074c0:	2b00      	cmp	r3, #0
340074c2:	d050      	beq.n	34007566 <HAL_RCC_OscConfig+0xa32>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4));
340074c4:	687b      	ldr	r3, [r7, #4]
340074c6:	337c      	adds	r3, #124	@ 0x7c
340074c8:	4619      	mov	r1, r3
340074ca:	2003      	movs	r0, #3
340074cc:	f000 ffa0 	bl	34008410 <RCC_PLL_IsNewConfig>
340074d0:	61f8      	str	r0, [r7, #28]
    uint32_t pll4_ready = LL_RCC_PLL4_IsReady();
340074d2:	f7ff faa1 	bl	34006a18 <LL_RCC_PLL4_IsReady>
340074d6:	61b8      	str	r0, [r7, #24]

    if (new_pll_config == 1U)
340074d8:	69fb      	ldr	r3, [r7, #28]
340074da:	2b01      	cmp	r3, #1
340074dc:	d134      	bne.n	34007548 <HAL_RCC_OscConfig+0xa14>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
340074de:	f7ff fad1 	bl	34006a84 <LL_RCC_IC1_GetSource>
340074e2:	6178      	str	r0, [r7, #20]
      uint32_t ic2src = LL_RCC_IC2_GetSource();
340074e4:	f7ff faec 	bl	34006ac0 <LL_RCC_IC2_GetSource>
340074e8:	6138      	str	r0, [r7, #16]
      uint32_t ic6src = LL_RCC_IC6_GetSource();
340074ea:	f7ff fb07 	bl	34006afc <LL_RCC_IC6_GetSource>
340074ee:	60f8      	str	r0, [r7, #12]
      uint32_t ic11src = LL_RCC_IC11_GetSource();
340074f0:	f7ff fb12 	bl	34006b18 <LL_RCC_IC11_GetSource>
340074f4:	60b8      	str	r0, [r7, #8]
      /* PLL4 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL4))
340074f6:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
340074fa:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
340074fe:	d105      	bne.n	3400750c <HAL_RCC_OscConfig+0x9d8>
34007500:	697b      	ldr	r3, [r7, #20]
34007502:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34007506:	d101      	bne.n	3400750c <HAL_RCC_OscConfig+0x9d8>
      {
        return HAL_ERROR;
34007508:	2301      	movs	r3, #1
3400750a:	e02d      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
      }
      /* PLL4 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL4) ||
3400750c:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34007510:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34007514:	d10d      	bne.n	34007532 <HAL_RCC_OscConfig+0x9fe>
34007516:	693b      	ldr	r3, [r7, #16]
34007518:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400751c:	d007      	beq.n	3400752e <HAL_RCC_OscConfig+0x9fa>
3400751e:	68fb      	ldr	r3, [r7, #12]
34007520:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34007524:	d003      	beq.n	3400752e <HAL_RCC_OscConfig+0x9fa>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL4) ||
34007526:	68bb      	ldr	r3, [r7, #8]
34007528:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400752c:	d101      	bne.n	34007532 <HAL_RCC_OscConfig+0x9fe>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL4)))
      {
        return HAL_ERROR;
3400752e:	2301      	movs	r3, #1
34007530:	e01a      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
      }
      /* PLL4 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4)) != HAL_OK)
34007532:	687b      	ldr	r3, [r7, #4]
34007534:	337c      	adds	r3, #124	@ 0x7c
34007536:	4619      	mov	r1, r3
34007538:	2003      	movs	r0, #3
3400753a:	f000 fd99 	bl	34008070 <RCC_PLL_Config>
3400753e:	4603      	mov	r3, r0
34007540:	2b00      	cmp	r3, #0
34007542:	d010      	beq.n	34007566 <HAL_RCC_OscConfig+0xa32>
      {
        return HAL_ERROR;
34007544:	2301      	movs	r3, #1
34007546:	e00f      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
      }
    }
    else if ((pRCC_OscInitStruct->PLL4.PLLState == RCC_PLL_ON) && (pll4_ready == 0U))
34007548:	687b      	ldr	r3, [r7, #4]
3400754a:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400754c:	2b02      	cmp	r3, #2
3400754e:	d10a      	bne.n	34007566 <HAL_RCC_OscConfig+0xa32>
34007550:	69bb      	ldr	r3, [r7, #24]
34007552:	2b00      	cmp	r3, #0
34007554:	d107      	bne.n	34007566 <HAL_RCC_OscConfig+0xa32>
    {
      if (RCC_PLL_Enable(RCC_PLL4_CONFIG) != HAL_OK)
34007556:	2003      	movs	r0, #3
34007558:	f000 ff2e 	bl	340083b8 <RCC_PLL_Enable>
3400755c:	4603      	mov	r3, r0
3400755e:	2b00      	cmp	r3, #0
34007560:	d001      	beq.n	34007566 <HAL_RCC_OscConfig+0xa32>
      {
        return HAL_ERROR;
34007562:	2301      	movs	r3, #1
34007564:	e000      	b.n	34007568 <HAL_RCC_OscConfig+0xa34>
    {
      /* Nothing to do */
    }
  }

  return HAL_OK;
34007566:	2300      	movs	r3, #0
}
34007568:	4618      	mov	r0, r3
3400756a:	3788      	adds	r7, #136	@ 0x88
3400756c:	46bd      	mov	sp, r7
3400756e:	bd80      	pop	{r7, pc}
34007570:	3401edb8 	.word	0x3401edb8

34007574 <HAL_RCC_ClockConfig>:
  *         You can use HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(const RCC_ClkInitTypeDef  *pRCC_ClkInitStruct)
{
34007574:	b580      	push	{r7, lr}
34007576:	b084      	sub	sp, #16
34007578:	af00      	add	r7, sp, #0
3400757a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check Null pointer */
  if (pRCC_ClkInitStruct == NULL)
3400757c:	687b      	ldr	r3, [r7, #4]
3400757e:	2b00      	cmp	r3, #0
34007580:	d102      	bne.n	34007588 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
34007582:	2301      	movs	r3, #1
34007584:	f000 bc6d 	b.w	34007e62 <HAL_RCC_ClockConfig+0x8ee>
  }

  /* Check the parameters */
  assert_param(IS_RCC_CLOCKTYPE(pRCC_ClkInitStruct->ClockType));
34007588:	687b      	ldr	r3, [r7, #4]
3400758a:	681b      	ldr	r3, [r3, #0]
3400758c:	2b7f      	cmp	r3, #127	@ 0x7f
3400758e:	d904      	bls.n	3400759a <HAL_RCC_ClockConfig+0x26>
34007590:	f240 317e 	movw	r1, #894	@ 0x37e
34007594:	4880      	ldr	r0, [pc, #512]	@ (34007798 <HAL_RCC_ClockConfig+0x224>)
34007596:	f7fa fd3b 	bl	34002010 <assert_failed>

  /* Increasing the BUS frequency divider ? */

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
3400759a:	687b      	ldr	r3, [r7, #4]
3400759c:	681b      	ldr	r3, [r3, #0]
3400759e:	f003 0308 	and.w	r3, r3, #8
340075a2:	2b00      	cmp	r3, #0
340075a4:	d035      	beq.n	34007612 <HAL_RCC_ClockConfig+0x9e>
  {
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
340075a6:	687b      	ldr	r3, [r7, #4]
340075a8:	691b      	ldr	r3, [r3, #16]
340075aa:	2b00      	cmp	r3, #0
340075ac:	d020      	beq.n	340075f0 <HAL_RCC_ClockConfig+0x7c>
340075ae:	687b      	ldr	r3, [r7, #4]
340075b0:	691b      	ldr	r3, [r3, #16]
340075b2:	2b01      	cmp	r3, #1
340075b4:	d01c      	beq.n	340075f0 <HAL_RCC_ClockConfig+0x7c>
340075b6:	687b      	ldr	r3, [r7, #4]
340075b8:	691b      	ldr	r3, [r3, #16]
340075ba:	2b02      	cmp	r3, #2
340075bc:	d018      	beq.n	340075f0 <HAL_RCC_ClockConfig+0x7c>
340075be:	687b      	ldr	r3, [r7, #4]
340075c0:	691b      	ldr	r3, [r3, #16]
340075c2:	2b03      	cmp	r3, #3
340075c4:	d014      	beq.n	340075f0 <HAL_RCC_ClockConfig+0x7c>
340075c6:	687b      	ldr	r3, [r7, #4]
340075c8:	691b      	ldr	r3, [r3, #16]
340075ca:	2b04      	cmp	r3, #4
340075cc:	d010      	beq.n	340075f0 <HAL_RCC_ClockConfig+0x7c>
340075ce:	687b      	ldr	r3, [r7, #4]
340075d0:	691b      	ldr	r3, [r3, #16]
340075d2:	2b05      	cmp	r3, #5
340075d4:	d00c      	beq.n	340075f0 <HAL_RCC_ClockConfig+0x7c>
340075d6:	687b      	ldr	r3, [r7, #4]
340075d8:	691b      	ldr	r3, [r3, #16]
340075da:	2b06      	cmp	r3, #6
340075dc:	d008      	beq.n	340075f0 <HAL_RCC_ClockConfig+0x7c>
340075de:	687b      	ldr	r3, [r7, #4]
340075e0:	691b      	ldr	r3, [r3, #16]
340075e2:	2b07      	cmp	r3, #7
340075e4:	d004      	beq.n	340075f0 <HAL_RCC_ClockConfig+0x7c>
340075e6:	f240 3185 	movw	r1, #901	@ 0x385
340075ea:	486b      	ldr	r0, [pc, #428]	@ (34007798 <HAL_RCC_ClockConfig+0x224>)
340075ec:	f7fa fd10 	bl	34002010 <assert_failed>
    if ((pRCC_ClkInitStruct->APB1CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE1))
340075f0:	687b      	ldr	r3, [r7, #4]
340075f2:	691a      	ldr	r2, [r3, #16]
340075f4:	4b69      	ldr	r3, [pc, #420]	@ (3400779c <HAL_RCC_ClockConfig+0x228>)
340075f6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340075f8:	f003 0307 	and.w	r3, r3, #7
340075fc:	429a      	cmp	r2, r3
340075fe:	d908      	bls.n	34007612 <HAL_RCC_ClockConfig+0x9e>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
34007600:	4b66      	ldr	r3, [pc, #408]	@ (3400779c <HAL_RCC_ClockConfig+0x228>)
34007602:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34007604:	f023 0207 	bic.w	r2, r3, #7
34007608:	687b      	ldr	r3, [r7, #4]
3400760a:	691b      	ldr	r3, [r3, #16]
3400760c:	4963      	ldr	r1, [pc, #396]	@ (3400779c <HAL_RCC_ClockConfig+0x228>)
3400760e:	4313      	orrs	r3, r2
34007610:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
34007612:	687b      	ldr	r3, [r7, #4]
34007614:	681b      	ldr	r3, [r3, #0]
34007616:	f003 0310 	and.w	r3, r3, #16
3400761a:	2b00      	cmp	r3, #0
3400761c:	d035      	beq.n	3400768a <HAL_RCC_ClockConfig+0x116>
  {
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
3400761e:	687b      	ldr	r3, [r7, #4]
34007620:	695b      	ldr	r3, [r3, #20]
34007622:	2b00      	cmp	r3, #0
34007624:	d020      	beq.n	34007668 <HAL_RCC_ClockConfig+0xf4>
34007626:	687b      	ldr	r3, [r7, #4]
34007628:	695b      	ldr	r3, [r3, #20]
3400762a:	2b10      	cmp	r3, #16
3400762c:	d01c      	beq.n	34007668 <HAL_RCC_ClockConfig+0xf4>
3400762e:	687b      	ldr	r3, [r7, #4]
34007630:	695b      	ldr	r3, [r3, #20]
34007632:	2b20      	cmp	r3, #32
34007634:	d018      	beq.n	34007668 <HAL_RCC_ClockConfig+0xf4>
34007636:	687b      	ldr	r3, [r7, #4]
34007638:	695b      	ldr	r3, [r3, #20]
3400763a:	2b30      	cmp	r3, #48	@ 0x30
3400763c:	d014      	beq.n	34007668 <HAL_RCC_ClockConfig+0xf4>
3400763e:	687b      	ldr	r3, [r7, #4]
34007640:	695b      	ldr	r3, [r3, #20]
34007642:	2b40      	cmp	r3, #64	@ 0x40
34007644:	d010      	beq.n	34007668 <HAL_RCC_ClockConfig+0xf4>
34007646:	687b      	ldr	r3, [r7, #4]
34007648:	695b      	ldr	r3, [r3, #20]
3400764a:	2b50      	cmp	r3, #80	@ 0x50
3400764c:	d00c      	beq.n	34007668 <HAL_RCC_ClockConfig+0xf4>
3400764e:	687b      	ldr	r3, [r7, #4]
34007650:	695b      	ldr	r3, [r3, #20]
34007652:	2b60      	cmp	r3, #96	@ 0x60
34007654:	d008      	beq.n	34007668 <HAL_RCC_ClockConfig+0xf4>
34007656:	687b      	ldr	r3, [r7, #4]
34007658:	695b      	ldr	r3, [r3, #20]
3400765a:	2b70      	cmp	r3, #112	@ 0x70
3400765c:	d004      	beq.n	34007668 <HAL_RCC_ClockConfig+0xf4>
3400765e:	f240 318f 	movw	r1, #911	@ 0x38f
34007662:	484d      	ldr	r0, [pc, #308]	@ (34007798 <HAL_RCC_ClockConfig+0x224>)
34007664:	f7fa fcd4 	bl	34002010 <assert_failed>
    if ((pRCC_ClkInitStruct->APB2CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE2))
34007668:	687b      	ldr	r3, [r7, #4]
3400766a:	695a      	ldr	r2, [r3, #20]
3400766c:	4b4b      	ldr	r3, [pc, #300]	@ (3400779c <HAL_RCC_ClockConfig+0x228>)
3400766e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34007670:	f003 0370 	and.w	r3, r3, #112	@ 0x70
34007674:	429a      	cmp	r2, r3
34007676:	d908      	bls.n	3400768a <HAL_RCC_ClockConfig+0x116>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
34007678:	4b48      	ldr	r3, [pc, #288]	@ (3400779c <HAL_RCC_ClockConfig+0x228>)
3400767a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400767c:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
34007680:	687b      	ldr	r3, [r7, #4]
34007682:	695b      	ldr	r3, [r3, #20]
34007684:	4945      	ldr	r1, [pc, #276]	@ (3400779c <HAL_RCC_ClockConfig+0x228>)
34007686:	4313      	orrs	r3, r2
34007688:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK4 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
3400768a:	687b      	ldr	r3, [r7, #4]
3400768c:	681b      	ldr	r3, [r3, #0]
3400768e:	f003 0320 	and.w	r3, r3, #32
34007692:	2b00      	cmp	r3, #0
34007694:	d03c      	beq.n	34007710 <HAL_RCC_ClockConfig+0x19c>
  {
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
34007696:	687b      	ldr	r3, [r7, #4]
34007698:	699b      	ldr	r3, [r3, #24]
3400769a:	2b00      	cmp	r3, #0
3400769c:	d027      	beq.n	340076ee <HAL_RCC_ClockConfig+0x17a>
3400769e:	687b      	ldr	r3, [r7, #4]
340076a0:	699b      	ldr	r3, [r3, #24]
340076a2:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340076a6:	d022      	beq.n	340076ee <HAL_RCC_ClockConfig+0x17a>
340076a8:	687b      	ldr	r3, [r7, #4]
340076aa:	699b      	ldr	r3, [r3, #24]
340076ac:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
340076b0:	d01d      	beq.n	340076ee <HAL_RCC_ClockConfig+0x17a>
340076b2:	687b      	ldr	r3, [r7, #4]
340076b4:	699b      	ldr	r3, [r3, #24]
340076b6:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
340076ba:	d018      	beq.n	340076ee <HAL_RCC_ClockConfig+0x17a>
340076bc:	687b      	ldr	r3, [r7, #4]
340076be:	699b      	ldr	r3, [r3, #24]
340076c0:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
340076c4:	d013      	beq.n	340076ee <HAL_RCC_ClockConfig+0x17a>
340076c6:	687b      	ldr	r3, [r7, #4]
340076c8:	699b      	ldr	r3, [r3, #24]
340076ca:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
340076ce:	d00e      	beq.n	340076ee <HAL_RCC_ClockConfig+0x17a>
340076d0:	687b      	ldr	r3, [r7, #4]
340076d2:	699b      	ldr	r3, [r3, #24]
340076d4:	f5b3 4fc0 	cmp.w	r3, #24576	@ 0x6000
340076d8:	d009      	beq.n	340076ee <HAL_RCC_ClockConfig+0x17a>
340076da:	687b      	ldr	r3, [r7, #4]
340076dc:	699b      	ldr	r3, [r3, #24]
340076de:	f5b3 4fe0 	cmp.w	r3, #28672	@ 0x7000
340076e2:	d004      	beq.n	340076ee <HAL_RCC_ClockConfig+0x17a>
340076e4:	f240 3199 	movw	r1, #921	@ 0x399
340076e8:	482b      	ldr	r0, [pc, #172]	@ (34007798 <HAL_RCC_ClockConfig+0x224>)
340076ea:	f7fa fc91 	bl	34002010 <assert_failed>
    if ((pRCC_ClkInitStruct->APB4CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE4))
340076ee:	687b      	ldr	r3, [r7, #4]
340076f0:	699a      	ldr	r2, [r3, #24]
340076f2:	4b2a      	ldr	r3, [pc, #168]	@ (3400779c <HAL_RCC_ClockConfig+0x228>)
340076f4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340076f6:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
340076fa:	429a      	cmp	r2, r3
340076fc:	d908      	bls.n	34007710 <HAL_RCC_ClockConfig+0x19c>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
340076fe:	4b27      	ldr	r3, [pc, #156]	@ (3400779c <HAL_RCC_ClockConfig+0x228>)
34007700:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34007702:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
34007706:	687b      	ldr	r3, [r7, #4]
34007708:	699b      	ldr	r3, [r3, #24]
3400770a:	4924      	ldr	r1, [pc, #144]	@ (3400779c <HAL_RCC_ClockConfig+0x228>)
3400770c:	4313      	orrs	r3, r2
3400770e:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK5 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
34007710:	687b      	ldr	r3, [r7, #4]
34007712:	681b      	ldr	r3, [r3, #0]
34007714:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34007718:	2b00      	cmp	r3, #0
3400771a:	d041      	beq.n	340077a0 <HAL_RCC_ClockConfig+0x22c>
  {
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
3400771c:	687b      	ldr	r3, [r7, #4]
3400771e:	69db      	ldr	r3, [r3, #28]
34007720:	2b00      	cmp	r3, #0
34007722:	d027      	beq.n	34007774 <HAL_RCC_ClockConfig+0x200>
34007724:	687b      	ldr	r3, [r7, #4]
34007726:	69db      	ldr	r3, [r3, #28]
34007728:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3400772c:	d022      	beq.n	34007774 <HAL_RCC_ClockConfig+0x200>
3400772e:	687b      	ldr	r3, [r7, #4]
34007730:	69db      	ldr	r3, [r3, #28]
34007732:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34007736:	d01d      	beq.n	34007774 <HAL_RCC_ClockConfig+0x200>
34007738:	687b      	ldr	r3, [r7, #4]
3400773a:	69db      	ldr	r3, [r3, #28]
3400773c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34007740:	d018      	beq.n	34007774 <HAL_RCC_ClockConfig+0x200>
34007742:	687b      	ldr	r3, [r7, #4]
34007744:	69db      	ldr	r3, [r3, #28]
34007746:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400774a:	d013      	beq.n	34007774 <HAL_RCC_ClockConfig+0x200>
3400774c:	687b      	ldr	r3, [r7, #4]
3400774e:	69db      	ldr	r3, [r3, #28]
34007750:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
34007754:	d00e      	beq.n	34007774 <HAL_RCC_ClockConfig+0x200>
34007756:	687b      	ldr	r3, [r7, #4]
34007758:	69db      	ldr	r3, [r3, #28]
3400775a:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
3400775e:	d009      	beq.n	34007774 <HAL_RCC_ClockConfig+0x200>
34007760:	687b      	ldr	r3, [r7, #4]
34007762:	69db      	ldr	r3, [r3, #28]
34007764:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
34007768:	d004      	beq.n	34007774 <HAL_RCC_ClockConfig+0x200>
3400776a:	f240 31a3 	movw	r1, #931	@ 0x3a3
3400776e:	480a      	ldr	r0, [pc, #40]	@ (34007798 <HAL_RCC_ClockConfig+0x224>)
34007770:	f7fa fc4e 	bl	34002010 <assert_failed>
    if ((pRCC_ClkInitStruct->APB5CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE5))
34007774:	687b      	ldr	r3, [r7, #4]
34007776:	69da      	ldr	r2, [r3, #28]
34007778:	4b08      	ldr	r3, [pc, #32]	@ (3400779c <HAL_RCC_ClockConfig+0x228>)
3400777a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400777c:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
34007780:	429a      	cmp	r2, r3
34007782:	d90d      	bls.n	340077a0 <HAL_RCC_ClockConfig+0x22c>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
34007784:	4b05      	ldr	r3, [pc, #20]	@ (3400779c <HAL_RCC_ClockConfig+0x228>)
34007786:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34007788:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3400778c:	687b      	ldr	r3, [r7, #4]
3400778e:	69db      	ldr	r3, [r3, #28]
34007790:	4902      	ldr	r1, [pc, #8]	@ (3400779c <HAL_RCC_ClockConfig+0x228>)
34007792:	4313      	orrs	r3, r2
34007794:	624b      	str	r3, [r1, #36]	@ 0x24
34007796:	e003      	b.n	340077a0 <HAL_RCC_ClockConfig+0x22c>
34007798:	3401edb8 	.word	0x3401edb8
3400779c:	56028000 	.word	0x56028000
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
340077a0:	687b      	ldr	r3, [r7, #4]
340077a2:	681b      	ldr	r3, [r3, #0]
340077a4:	f003 0304 	and.w	r3, r3, #4
340077a8:	2b00      	cmp	r3, #0
340077aa:	d03c      	beq.n	34007826 <HAL_RCC_ClockConfig+0x2b2>
  {
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
340077ac:	687b      	ldr	r3, [r7, #4]
340077ae:	68db      	ldr	r3, [r3, #12]
340077b0:	2b00      	cmp	r3, #0
340077b2:	d027      	beq.n	34007804 <HAL_RCC_ClockConfig+0x290>
340077b4:	687b      	ldr	r3, [r7, #4]
340077b6:	68db      	ldr	r3, [r3, #12]
340077b8:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
340077bc:	d022      	beq.n	34007804 <HAL_RCC_ClockConfig+0x290>
340077be:	687b      	ldr	r3, [r7, #4]
340077c0:	68db      	ldr	r3, [r3, #12]
340077c2:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
340077c6:	d01d      	beq.n	34007804 <HAL_RCC_ClockConfig+0x290>
340077c8:	687b      	ldr	r3, [r7, #4]
340077ca:	68db      	ldr	r3, [r3, #12]
340077cc:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
340077d0:	d018      	beq.n	34007804 <HAL_RCC_ClockConfig+0x290>
340077d2:	687b      	ldr	r3, [r7, #4]
340077d4:	68db      	ldr	r3, [r3, #12]
340077d6:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
340077da:	d013      	beq.n	34007804 <HAL_RCC_ClockConfig+0x290>
340077dc:	687b      	ldr	r3, [r7, #4]
340077de:	68db      	ldr	r3, [r3, #12]
340077e0:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
340077e4:	d00e      	beq.n	34007804 <HAL_RCC_ClockConfig+0x290>
340077e6:	687b      	ldr	r3, [r7, #4]
340077e8:	68db      	ldr	r3, [r3, #12]
340077ea:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
340077ee:	d009      	beq.n	34007804 <HAL_RCC_ClockConfig+0x290>
340077f0:	687b      	ldr	r3, [r7, #4]
340077f2:	68db      	ldr	r3, [r3, #12]
340077f4:	f5b3 0fe0 	cmp.w	r3, #7340032	@ 0x700000
340077f8:	d004      	beq.n	34007804 <HAL_RCC_ClockConfig+0x290>
340077fa:	f240 31ad 	movw	r1, #941	@ 0x3ad
340077fe:	4874      	ldr	r0, [pc, #464]	@ (340079d0 <HAL_RCC_ClockConfig+0x45c>)
34007800:	f7fa fc06 	bl	34002010 <assert_failed>
    if ((pRCC_ClkInitStruct->AHBCLKDivider) > (RCC->CFGR2 & RCC_CFGR2_HPRE))
34007804:	687b      	ldr	r3, [r7, #4]
34007806:	68da      	ldr	r2, [r3, #12]
34007808:	4b72      	ldr	r3, [pc, #456]	@ (340079d4 <HAL_RCC_ClockConfig+0x460>)
3400780a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400780c:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
34007810:	429a      	cmp	r2, r3
34007812:	d908      	bls.n	34007826 <HAL_RCC_ClockConfig+0x2b2>
    {
      /* Set the new HCLK clock divider */
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
34007814:	4b6f      	ldr	r3, [pc, #444]	@ (340079d4 <HAL_RCC_ClockConfig+0x460>)
34007816:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34007818:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
3400781c:	687b      	ldr	r3, [r7, #4]
3400781e:	68db      	ldr	r3, [r3, #12]
34007820:	496c      	ldr	r1, [pc, #432]	@ (340079d4 <HAL_RCC_ClockConfig+0x460>)
34007822:	4313      	orrs	r3, r2
34007824:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*------------------------- CPUCLK Configuration -------------------------*/
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_CPUCLK) == RCC_CLOCKTYPE_CPUCLK)
34007826:	687b      	ldr	r3, [r7, #4]
34007828:	681b      	ldr	r3, [r3, #0]
3400782a:	f003 0301 	and.w	r3, r3, #1
3400782e:	2b00      	cmp	r3, #0
34007830:	f000 80a2 	beq.w	34007978 <HAL_RCC_ClockConfig+0x404>
  {
    assert_param(IS_RCC_CPUCLKSOURCE(pRCC_ClkInitStruct->CPUCLKSource));
34007834:	687b      	ldr	r3, [r7, #4]
34007836:	685b      	ldr	r3, [r3, #4]
34007838:	2b00      	cmp	r3, #0
3400783a:	d013      	beq.n	34007864 <HAL_RCC_ClockConfig+0x2f0>
3400783c:	687b      	ldr	r3, [r7, #4]
3400783e:	685b      	ldr	r3, [r3, #4]
34007840:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34007844:	d00e      	beq.n	34007864 <HAL_RCC_ClockConfig+0x2f0>
34007846:	687b      	ldr	r3, [r7, #4]
34007848:	685b      	ldr	r3, [r3, #4]
3400784a:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400784e:	d009      	beq.n	34007864 <HAL_RCC_ClockConfig+0x2f0>
34007850:	687b      	ldr	r3, [r7, #4]
34007852:	685b      	ldr	r3, [r3, #4]
34007854:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34007858:	d004      	beq.n	34007864 <HAL_RCC_ClockConfig+0x2f0>
3400785a:	f44f 716e 	mov.w	r1, #952	@ 0x3b8
3400785e:	485c      	ldr	r0, [pc, #368]	@ (340079d0 <HAL_RCC_ClockConfig+0x45c>)
34007860:	f7fa fbd6 	bl	34002010 <assert_failed>

    /* HSE is selected as CPU Clock Source */
    if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_HSE)
34007864:	687b      	ldr	r3, [r7, #4]
34007866:	685b      	ldr	r3, [r3, #4]
34007868:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400786c:	d106      	bne.n	3400787c <HAL_RCC_ClockConfig+0x308>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
3400786e:	f7fe fee7 	bl	34006640 <LL_RCC_HSE_IsReady>
34007872:	4603      	mov	r3, r0
34007874:	2b00      	cmp	r3, #0
34007876:	d15a      	bne.n	3400792e <HAL_RCC_ClockConfig+0x3ba>
      {
        return HAL_ERROR;
34007878:	2301      	movs	r3, #1
3400787a:	e2f2      	b.n	34007e62 <HAL_RCC_ClockConfig+0x8ee>
      }
    }
    /* PLL is selected as CPU Clock Source */
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_IC1)
3400787c:	687b      	ldr	r3, [r7, #4]
3400787e:	685b      	ldr	r3, [r3, #4]
34007880:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34007884:	d140      	bne.n	34007908 <HAL_RCC_ClockConfig+0x394>
    {
      /* Check parameters */
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC1Selection.ClockSelection));
34007886:	687b      	ldr	r3, [r7, #4]
34007888:	6a1b      	ldr	r3, [r3, #32]
3400788a:	2b00      	cmp	r3, #0
3400788c:	d013      	beq.n	340078b6 <HAL_RCC_ClockConfig+0x342>
3400788e:	687b      	ldr	r3, [r7, #4]
34007890:	6a1b      	ldr	r3, [r3, #32]
34007892:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34007896:	d00e      	beq.n	340078b6 <HAL_RCC_ClockConfig+0x342>
34007898:	687b      	ldr	r3, [r7, #4]
3400789a:	6a1b      	ldr	r3, [r3, #32]
3400789c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340078a0:	d009      	beq.n	340078b6 <HAL_RCC_ClockConfig+0x342>
340078a2:	687b      	ldr	r3, [r7, #4]
340078a4:	6a1b      	ldr	r3, [r3, #32]
340078a6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340078aa:	d004      	beq.n	340078b6 <HAL_RCC_ClockConfig+0x342>
340078ac:	f240 31c7 	movw	r1, #967	@ 0x3c7
340078b0:	4847      	ldr	r0, [pc, #284]	@ (340079d0 <HAL_RCC_ClockConfig+0x45c>)
340078b2:	f7fa fbad 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC1Selection.ClockDivider));
340078b6:	687b      	ldr	r3, [r7, #4]
340078b8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340078ba:	2b00      	cmp	r3, #0
340078bc:	d004      	beq.n	340078c8 <HAL_RCC_ClockConfig+0x354>
340078be:	687b      	ldr	r3, [r7, #4]
340078c0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340078c2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340078c6:	d904      	bls.n	340078d2 <HAL_RCC_ClockConfig+0x35e>
340078c8:	f44f 7172 	mov.w	r1, #968	@ 0x3c8
340078cc:	4840      	ldr	r0, [pc, #256]	@ (340079d0 <HAL_RCC_ClockConfig+0x45c>)
340078ce:	f7fa fb9f 	bl	34002010 <assert_failed>

      /* ICx clock switch requires both origin and destination clock source to be active */
      /* Check IC1 origin and target clock sources availability */
      if (RCC_IC_CheckPLLSources(LL_RCC_IC1_GetSource(), pRCC_ClkInitStruct->IC1Selection.ClockSelection) != 1U)
340078d2:	f7ff f8d7 	bl	34006a84 <LL_RCC_IC1_GetSource>
340078d6:	4602      	mov	r2, r0
340078d8:	687b      	ldr	r3, [r7, #4]
340078da:	6a1b      	ldr	r3, [r3, #32]
340078dc:	4619      	mov	r1, r3
340078de:	4610      	mov	r0, r2
340078e0:	f000 fe4a 	bl	34008578 <RCC_IC_CheckPLLSources>
340078e4:	4603      	mov	r3, r0
340078e6:	2b01      	cmp	r3, #1
340078e8:	d001      	beq.n	340078ee <HAL_RCC_ClockConfig+0x37a>
      {
        return HAL_ERROR;
340078ea:	2301      	movs	r3, #1
340078ec:	e2b9      	b.n	34007e62 <HAL_RCC_ClockConfig+0x8ee>
      }

      /* Configure IC1 source and divider */
      WRITE_REG(RCC->IC1CFGR, pRCC_ClkInitStruct->IC1Selection.ClockSelection | \
340078ee:	687b      	ldr	r3, [r7, #4]
340078f0:	6a1a      	ldr	r2, [r3, #32]
340078f2:	687b      	ldr	r3, [r7, #4]
340078f4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340078f6:	3b01      	subs	r3, #1
340078f8:	041b      	lsls	r3, r3, #16
340078fa:	4936      	ldr	r1, [pc, #216]	@ (340079d4 <HAL_RCC_ClockConfig+0x460>)
340078fc:	4313      	orrs	r3, r2
340078fe:	f8c1 30c4 	str.w	r3, [r1, #196]	@ 0xc4
                ((pRCC_ClkInitStruct->IC1Selection.ClockDivider - 1U) << RCC_IC1CFGR_IC1INT_Pos));

      /* Enable IC1 */
      LL_RCC_IC1_Enable();
34007902:	f7ff f8b1 	bl	34006a68 <LL_RCC_IC1_Enable>
34007906:	e012      	b.n	3400792e <HAL_RCC_ClockConfig+0x3ba>
    }
    /* MSI is selected as CPU Clock Source */
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_MSI)
34007908:	687b      	ldr	r3, [r7, #4]
3400790a:	685b      	ldr	r3, [r3, #4]
3400790c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34007910:	d106      	bne.n	34007920 <HAL_RCC_ClockConfig+0x3ac>
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
34007912:	f7fe ff2d 	bl	34006770 <LL_RCC_MSI_IsReady>
34007916:	4603      	mov	r3, r0
34007918:	2b00      	cmp	r3, #0
3400791a:	d108      	bne.n	3400792e <HAL_RCC_ClockConfig+0x3ba>
      {
        return HAL_ERROR;
3400791c:	2301      	movs	r3, #1
3400791e:	e2a0      	b.n	34007e62 <HAL_RCC_ClockConfig+0x8ee>
    }
    /* HSI is selected as CPU Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
34007920:	f7fe febe 	bl	340066a0 <LL_RCC_HSI_IsReady>
34007924:	4603      	mov	r3, r0
34007926:	2b00      	cmp	r3, #0
34007928:	d101      	bne.n	3400792e <HAL_RCC_ClockConfig+0x3ba>
      {
        return HAL_ERROR;
3400792a:	2301      	movs	r3, #1
3400792c:	e299      	b.n	34007e62 <HAL_RCC_ClockConfig+0x8ee>
      }
    }

    /* Switch the CPU clock */
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, pRCC_ClkInitStruct->CPUCLKSource);
3400792e:	4b29      	ldr	r3, [pc, #164]	@ (340079d4 <HAL_RCC_ClockConfig+0x460>)
34007930:	6a1b      	ldr	r3, [r3, #32]
34007932:	f423 3240 	bic.w	r2, r3, #196608	@ 0x30000
34007936:	687b      	ldr	r3, [r7, #4]
34007938:	685b      	ldr	r3, [r3, #4]
3400793a:	4926      	ldr	r1, [pc, #152]	@ (340079d4 <HAL_RCC_ClockConfig+0x460>)
3400793c:	4313      	orrs	r3, r2
3400793e:	620b      	str	r3, [r1, #32]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
34007940:	f7fc fb88 	bl	34004054 <HAL_GetTick>
34007944:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
34007946:	e00a      	b.n	3400795e <HAL_RCC_ClockConfig+0x3ea>
    {
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
34007948:	f7fc fb84 	bl	34004054 <HAL_GetTick>
3400794c:	4602      	mov	r2, r0
3400794e:	68fb      	ldr	r3, [r7, #12]
34007950:	1ad3      	subs	r3, r2, r3
34007952:	f241 3288 	movw	r2, #5000	@ 0x1388
34007956:	4293      	cmp	r3, r2
34007958:	d901      	bls.n	3400795e <HAL_RCC_ClockConfig+0x3ea>
      {
        return HAL_TIMEOUT;
3400795a:	2303      	movs	r3, #3
3400795c:	e281      	b.n	34007e62 <HAL_RCC_ClockConfig+0x8ee>
    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
3400795e:	f7fe ff8f 	bl	34006880 <LL_RCC_GetCpuClkSource>
34007962:	4602      	mov	r2, r0
34007964:	687b      	ldr	r3, [r7, #4]
34007966:	685b      	ldr	r3, [r3, #4]
34007968:	011b      	lsls	r3, r3, #4
3400796a:	429a      	cmp	r2, r3
3400796c:	d1ec      	bne.n	34007948 <HAL_RCC_ClockConfig+0x3d4>
      }
    }

    /* Update the SystemCoreClock global variable with CPU clock */
    SystemCoreClock = HAL_RCC_GetCpuClockFreq();
3400796e:	f000 fa83 	bl	34007e78 <HAL_RCC_GetCpuClockFreq>
34007972:	4603      	mov	r3, r0
34007974:	4a18      	ldr	r2, [pc, #96]	@ (340079d8 <HAL_RCC_ClockConfig+0x464>)
34007976:	6013      	str	r3, [r2, #0]

  }

  /*------------------------- SYSCLK Configuration -------------------------*/
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
34007978:	687b      	ldr	r3, [r7, #4]
3400797a:	681b      	ldr	r3, [r3, #0]
3400797c:	f003 0302 	and.w	r3, r3, #2
34007980:	2b00      	cmp	r3, #0
34007982:	f000 8127 	beq.w	34007bd4 <HAL_RCC_ClockConfig+0x660>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(pRCC_ClkInitStruct->SYSCLKSource));
34007986:	687b      	ldr	r3, [r7, #4]
34007988:	689b      	ldr	r3, [r3, #8]
3400798a:	2b00      	cmp	r3, #0
3400798c:	d013      	beq.n	340079b6 <HAL_RCC_ClockConfig+0x442>
3400798e:	687b      	ldr	r3, [r7, #4]
34007990:	689b      	ldr	r3, [r3, #8]
34007992:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34007996:	d00e      	beq.n	340079b6 <HAL_RCC_ClockConfig+0x442>
34007998:	687b      	ldr	r3, [r7, #4]
3400799a:	689b      	ldr	r3, [r3, #8]
3400799c:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
340079a0:	d009      	beq.n	340079b6 <HAL_RCC_ClockConfig+0x442>
340079a2:	687b      	ldr	r3, [r7, #4]
340079a4:	689b      	ldr	r3, [r3, #8]
340079a6:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
340079aa:	d004      	beq.n	340079b6 <HAL_RCC_ClockConfig+0x442>
340079ac:	f240 4101 	movw	r1, #1025	@ 0x401
340079b0:	4807      	ldr	r0, [pc, #28]	@ (340079d0 <HAL_RCC_ClockConfig+0x45c>)
340079b2:	f7fa fb2d 	bl	34002010 <assert_failed>

    /* HSE is selected as System bus clock source */
    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
340079b6:	687b      	ldr	r3, [r7, #4]
340079b8:	689b      	ldr	r3, [r3, #8]
340079ba:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
340079be:	d10d      	bne.n	340079dc <HAL_RCC_ClockConfig+0x468>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
340079c0:	f7fe fe3e 	bl	34006640 <LL_RCC_HSE_IsReady>
340079c4:	4603      	mov	r3, r0
340079c6:	2b00      	cmp	r3, #0
340079c8:	f040 80e0 	bne.w	34007b8c <HAL_RCC_ClockConfig+0x618>
      {
        return HAL_ERROR;
340079cc:	2301      	movs	r3, #1
340079ce:	e248      	b.n	34007e62 <HAL_RCC_ClockConfig+0x8ee>
340079d0:	3401edb8 	.word	0x3401edb8
340079d4:	56028000 	.word	0x56028000
340079d8:	34020c54 	.word	0x34020c54
      }
    }
    /* PLL output is selected as System bus clock source */
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11)
340079dc:	687b      	ldr	r3, [r7, #4]
340079de:	689b      	ldr	r3, [r3, #8]
340079e0:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
340079e4:	f040 80c0 	bne.w	34007b68 <HAL_RCC_ClockConfig+0x5f4>
    {
      /* Check parameters */
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC2Selection.ClockSelection));
340079e8:	687b      	ldr	r3, [r7, #4]
340079ea:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
340079ec:	2b00      	cmp	r3, #0
340079ee:	d013      	beq.n	34007a18 <HAL_RCC_ClockConfig+0x4a4>
340079f0:	687b      	ldr	r3, [r7, #4]
340079f2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
340079f4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340079f8:	d00e      	beq.n	34007a18 <HAL_RCC_ClockConfig+0x4a4>
340079fa:	687b      	ldr	r3, [r7, #4]
340079fc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
340079fe:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34007a02:	d009      	beq.n	34007a18 <HAL_RCC_ClockConfig+0x4a4>
34007a04:	687b      	ldr	r3, [r7, #4]
34007a06:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34007a08:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34007a0c:	d004      	beq.n	34007a18 <HAL_RCC_ClockConfig+0x4a4>
34007a0e:	f44f 6182 	mov.w	r1, #1040	@ 0x410
34007a12:	486a      	ldr	r0, [pc, #424]	@ (34007bbc <HAL_RCC_ClockConfig+0x648>)
34007a14:	f7fa fafc 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC2Selection.ClockDivider));
34007a18:	687b      	ldr	r3, [r7, #4]
34007a1a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34007a1c:	2b00      	cmp	r3, #0
34007a1e:	d004      	beq.n	34007a2a <HAL_RCC_ClockConfig+0x4b6>
34007a20:	687b      	ldr	r3, [r7, #4]
34007a22:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34007a24:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34007a28:	d904      	bls.n	34007a34 <HAL_RCC_ClockConfig+0x4c0>
34007a2a:	f240 4111 	movw	r1, #1041	@ 0x411
34007a2e:	4863      	ldr	r0, [pc, #396]	@ (34007bbc <HAL_RCC_ClockConfig+0x648>)
34007a30:	f7fa faee 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC6Selection.ClockSelection));
34007a34:	687b      	ldr	r3, [r7, #4]
34007a36:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34007a38:	2b00      	cmp	r3, #0
34007a3a:	d013      	beq.n	34007a64 <HAL_RCC_ClockConfig+0x4f0>
34007a3c:	687b      	ldr	r3, [r7, #4]
34007a3e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34007a40:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34007a44:	d00e      	beq.n	34007a64 <HAL_RCC_ClockConfig+0x4f0>
34007a46:	687b      	ldr	r3, [r7, #4]
34007a48:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34007a4a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34007a4e:	d009      	beq.n	34007a64 <HAL_RCC_ClockConfig+0x4f0>
34007a50:	687b      	ldr	r3, [r7, #4]
34007a52:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34007a54:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34007a58:	d004      	beq.n	34007a64 <HAL_RCC_ClockConfig+0x4f0>
34007a5a:	f240 4112 	movw	r1, #1042	@ 0x412
34007a5e:	4857      	ldr	r0, [pc, #348]	@ (34007bbc <HAL_RCC_ClockConfig+0x648>)
34007a60:	f7fa fad6 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC6Selection.ClockDivider));
34007a64:	687b      	ldr	r3, [r7, #4]
34007a66:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34007a68:	2b00      	cmp	r3, #0
34007a6a:	d004      	beq.n	34007a76 <HAL_RCC_ClockConfig+0x502>
34007a6c:	687b      	ldr	r3, [r7, #4]
34007a6e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34007a70:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34007a74:	d904      	bls.n	34007a80 <HAL_RCC_ClockConfig+0x50c>
34007a76:	f240 4113 	movw	r1, #1043	@ 0x413
34007a7a:	4850      	ldr	r0, [pc, #320]	@ (34007bbc <HAL_RCC_ClockConfig+0x648>)
34007a7c:	f7fa fac8 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC11Selection.ClockSelection));
34007a80:	687b      	ldr	r3, [r7, #4]
34007a82:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34007a84:	2b00      	cmp	r3, #0
34007a86:	d013      	beq.n	34007ab0 <HAL_RCC_ClockConfig+0x53c>
34007a88:	687b      	ldr	r3, [r7, #4]
34007a8a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34007a8c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34007a90:	d00e      	beq.n	34007ab0 <HAL_RCC_ClockConfig+0x53c>
34007a92:	687b      	ldr	r3, [r7, #4]
34007a94:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34007a96:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34007a9a:	d009      	beq.n	34007ab0 <HAL_RCC_ClockConfig+0x53c>
34007a9c:	687b      	ldr	r3, [r7, #4]
34007a9e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34007aa0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34007aa4:	d004      	beq.n	34007ab0 <HAL_RCC_ClockConfig+0x53c>
34007aa6:	f240 4114 	movw	r1, #1044	@ 0x414
34007aaa:	4844      	ldr	r0, [pc, #272]	@ (34007bbc <HAL_RCC_ClockConfig+0x648>)
34007aac:	f7fa fab0 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC11Selection.ClockDivider));
34007ab0:	687b      	ldr	r3, [r7, #4]
34007ab2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34007ab4:	2b00      	cmp	r3, #0
34007ab6:	d004      	beq.n	34007ac2 <HAL_RCC_ClockConfig+0x54e>
34007ab8:	687b      	ldr	r3, [r7, #4]
34007aba:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34007abc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34007ac0:	d904      	bls.n	34007acc <HAL_RCC_ClockConfig+0x558>
34007ac2:	f240 4115 	movw	r1, #1045	@ 0x415
34007ac6:	483d      	ldr	r0, [pc, #244]	@ (34007bbc <HAL_RCC_ClockConfig+0x648>)
34007ac8:	f7fa faa2 	bl	34002010 <assert_failed>

      /* ICx clock switch requires both origin and destination clock source to be active */
      /* Check IC2/IC6/IC11 origin and target clock sources availability */
      if (RCC_IC_CheckPLLSources(LL_RCC_IC2_GetSource(), pRCC_ClkInitStruct->IC2Selection.ClockSelection) != 1U)
34007acc:	f7fe fff8 	bl	34006ac0 <LL_RCC_IC2_GetSource>
34007ad0:	4602      	mov	r2, r0
34007ad2:	687b      	ldr	r3, [r7, #4]
34007ad4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34007ad6:	4619      	mov	r1, r3
34007ad8:	4610      	mov	r0, r2
34007ada:	f000 fd4d 	bl	34008578 <RCC_IC_CheckPLLSources>
34007ade:	4603      	mov	r3, r0
34007ae0:	2b01      	cmp	r3, #1
34007ae2:	d001      	beq.n	34007ae8 <HAL_RCC_ClockConfig+0x574>
      {
        return HAL_ERROR;
34007ae4:	2301      	movs	r3, #1
34007ae6:	e1bc      	b.n	34007e62 <HAL_RCC_ClockConfig+0x8ee>
      }
      if (RCC_IC_CheckPLLSources(LL_RCC_IC6_GetSource(), pRCC_ClkInitStruct->IC6Selection.ClockSelection) != 1U)
34007ae8:	f7ff f808 	bl	34006afc <LL_RCC_IC6_GetSource>
34007aec:	4602      	mov	r2, r0
34007aee:	687b      	ldr	r3, [r7, #4]
34007af0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34007af2:	4619      	mov	r1, r3
34007af4:	4610      	mov	r0, r2
34007af6:	f000 fd3f 	bl	34008578 <RCC_IC_CheckPLLSources>
34007afa:	4603      	mov	r3, r0
34007afc:	2b01      	cmp	r3, #1
34007afe:	d001      	beq.n	34007b04 <HAL_RCC_ClockConfig+0x590>
      {
        return HAL_ERROR;
34007b00:	2301      	movs	r3, #1
34007b02:	e1ae      	b.n	34007e62 <HAL_RCC_ClockConfig+0x8ee>
      }
      if (RCC_IC_CheckPLLSources(LL_RCC_IC11_GetSource(), pRCC_ClkInitStruct->IC11Selection.ClockSelection) != 1U)
34007b04:	f7ff f808 	bl	34006b18 <LL_RCC_IC11_GetSource>
34007b08:	4602      	mov	r2, r0
34007b0a:	687b      	ldr	r3, [r7, #4]
34007b0c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34007b0e:	4619      	mov	r1, r3
34007b10:	4610      	mov	r0, r2
34007b12:	f000 fd31 	bl	34008578 <RCC_IC_CheckPLLSources>
34007b16:	4603      	mov	r3, r0
34007b18:	2b01      	cmp	r3, #1
34007b1a:	d001      	beq.n	34007b20 <HAL_RCC_ClockConfig+0x5ac>
      {
        return HAL_ERROR;
34007b1c:	2301      	movs	r3, #1
34007b1e:	e1a0      	b.n	34007e62 <HAL_RCC_ClockConfig+0x8ee>
      }

      /* Configure IC2, IC6 and IC11 sources and dividers */
      WRITE_REG(RCC->IC2CFGR, pRCC_ClkInitStruct->IC2Selection.ClockSelection | \
34007b20:	687b      	ldr	r3, [r7, #4]
34007b22:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34007b24:	687b      	ldr	r3, [r7, #4]
34007b26:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34007b28:	3b01      	subs	r3, #1
34007b2a:	041b      	lsls	r3, r3, #16
34007b2c:	4924      	ldr	r1, [pc, #144]	@ (34007bc0 <HAL_RCC_ClockConfig+0x64c>)
34007b2e:	4313      	orrs	r3, r2
34007b30:	f8c1 30c8 	str.w	r3, [r1, #200]	@ 0xc8
                ((pRCC_ClkInitStruct->IC2Selection.ClockDivider - 1U) << RCC_IC2CFGR_IC2INT_Pos));
      WRITE_REG(RCC->IC6CFGR, pRCC_ClkInitStruct->IC6Selection.ClockSelection | \
34007b34:	687b      	ldr	r3, [r7, #4]
34007b36:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
34007b38:	687b      	ldr	r3, [r7, #4]
34007b3a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34007b3c:	3b01      	subs	r3, #1
34007b3e:	041b      	lsls	r3, r3, #16
34007b40:	491f      	ldr	r1, [pc, #124]	@ (34007bc0 <HAL_RCC_ClockConfig+0x64c>)
34007b42:	4313      	orrs	r3, r2
34007b44:	f8c1 30d8 	str.w	r3, [r1, #216]	@ 0xd8
                ((pRCC_ClkInitStruct->IC6Selection.ClockDivider - 1U) << RCC_IC6CFGR_IC6INT_Pos));
      WRITE_REG(RCC->IC11CFGR, pRCC_ClkInitStruct->IC11Selection.ClockSelection | \
34007b48:	687b      	ldr	r3, [r7, #4]
34007b4a:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34007b4c:	687b      	ldr	r3, [r7, #4]
34007b4e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34007b50:	3b01      	subs	r3, #1
34007b52:	041b      	lsls	r3, r3, #16
34007b54:	491a      	ldr	r1, [pc, #104]	@ (34007bc0 <HAL_RCC_ClockConfig+0x64c>)
34007b56:	4313      	orrs	r3, r2
34007b58:	f8c1 30ec 	str.w	r3, [r1, #236]	@ 0xec
                ((pRCC_ClkInitStruct->IC11Selection.ClockDivider - 1U) << RCC_IC11CFGR_IC11INT_Pos));

      /* Require to have IC2, IC6 and IC11 outputs enabled */
      WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC2ENS | RCC_DIVENSR_IC6ENS | RCC_DIVENSR_IC11ENS);
34007b5c:	4b18      	ldr	r3, [pc, #96]	@ (34007bc0 <HAL_RCC_ClockConfig+0x64c>)
34007b5e:	f240 4222 	movw	r2, #1058	@ 0x422
34007b62:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
34007b66:	e011      	b.n	34007b8c <HAL_RCC_ClockConfig+0x618>
    }
    /* HSI is selected as System bus clock source */
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
34007b68:	687b      	ldr	r3, [r7, #4]
34007b6a:	689b      	ldr	r3, [r3, #8]
34007b6c:	2b00      	cmp	r3, #0
34007b6e:	d106      	bne.n	34007b7e <HAL_RCC_ClockConfig+0x60a>
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
34007b70:	f7fe fd96 	bl	340066a0 <LL_RCC_HSI_IsReady>
34007b74:	4603      	mov	r3, r0
34007b76:	2b00      	cmp	r3, #0
34007b78:	d108      	bne.n	34007b8c <HAL_RCC_ClockConfig+0x618>
      {
        return HAL_ERROR;
34007b7a:	2301      	movs	r3, #1
34007b7c:	e171      	b.n	34007e62 <HAL_RCC_ClockConfig+0x8ee>
    }
    /* MSI is selected as System bus clock source */
    else
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
34007b7e:	f7fe fdf7 	bl	34006770 <LL_RCC_MSI_IsReady>
34007b82:	4603      	mov	r3, r0
34007b84:	2b00      	cmp	r3, #0
34007b86:	d101      	bne.n	34007b8c <HAL_RCC_ClockConfig+0x618>
      {
        return HAL_ERROR;
34007b88:	2301      	movs	r3, #1
34007b8a:	e16a      	b.n	34007e62 <HAL_RCC_ClockConfig+0x8ee>
      }
    }

    /* Switch the system bus clocks */
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, pRCC_ClkInitStruct->SYSCLKSource);
34007b8c:	4b0c      	ldr	r3, [pc, #48]	@ (34007bc0 <HAL_RCC_ClockConfig+0x64c>)
34007b8e:	6a1b      	ldr	r3, [r3, #32]
34007b90:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
34007b94:	687b      	ldr	r3, [r7, #4]
34007b96:	689b      	ldr	r3, [r3, #8]
34007b98:	4909      	ldr	r1, [pc, #36]	@ (34007bc0 <HAL_RCC_ClockConfig+0x64c>)
34007b9a:	4313      	orrs	r3, r2
34007b9c:	620b      	str	r3, [r1, #32]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
34007b9e:	f7fc fa59 	bl	34004054 <HAL_GetTick>
34007ba2:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
34007ba4:	e00e      	b.n	34007bc4 <HAL_RCC_ClockConfig+0x650>
    {
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
34007ba6:	f7fc fa55 	bl	34004054 <HAL_GetTick>
34007baa:	4602      	mov	r2, r0
34007bac:	68fb      	ldr	r3, [r7, #12]
34007bae:	1ad3      	subs	r3, r2, r3
34007bb0:	f241 3288 	movw	r2, #5000	@ 0x1388
34007bb4:	4293      	cmp	r3, r2
34007bb6:	d905      	bls.n	34007bc4 <HAL_RCC_ClockConfig+0x650>
      {
        return HAL_TIMEOUT;
34007bb8:	2303      	movs	r3, #3
34007bba:	e152      	b.n	34007e62 <HAL_RCC_ClockConfig+0x8ee>
34007bbc:	3401edb8 	.word	0x3401edb8
34007bc0:	56028000 	.word	0x56028000
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
34007bc4:	f7fe fe6a 	bl	3400689c <LL_RCC_GetSysClkSource>
34007bc8:	4602      	mov	r2, r0
34007bca:	687b      	ldr	r3, [r7, #4]
34007bcc:	689b      	ldr	r3, [r3, #8]
34007bce:	011b      	lsls	r3, r3, #4
34007bd0:	429a      	cmp	r2, r3
34007bd2:	d1e8      	bne.n	34007ba6 <HAL_RCC_ClockConfig+0x632>
  }

  /* Decreasing the BUS frequency divider ? */

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
34007bd4:	687b      	ldr	r3, [r7, #4]
34007bd6:	681b      	ldr	r3, [r3, #0]
34007bd8:	f003 0304 	and.w	r3, r3, #4
34007bdc:	2b00      	cmp	r3, #0
34007bde:	d03c      	beq.n	34007c5a <HAL_RCC_ClockConfig+0x6e6>
  {
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
34007be0:	687b      	ldr	r3, [r7, #4]
34007be2:	68db      	ldr	r3, [r3, #12]
34007be4:	2b00      	cmp	r3, #0
34007be6:	d027      	beq.n	34007c38 <HAL_RCC_ClockConfig+0x6c4>
34007be8:	687b      	ldr	r3, [r7, #4]
34007bea:	68db      	ldr	r3, [r3, #12]
34007bec:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34007bf0:	d022      	beq.n	34007c38 <HAL_RCC_ClockConfig+0x6c4>
34007bf2:	687b      	ldr	r3, [r7, #4]
34007bf4:	68db      	ldr	r3, [r3, #12]
34007bf6:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34007bfa:	d01d      	beq.n	34007c38 <HAL_RCC_ClockConfig+0x6c4>
34007bfc:	687b      	ldr	r3, [r7, #4]
34007bfe:	68db      	ldr	r3, [r3, #12]
34007c00:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34007c04:	d018      	beq.n	34007c38 <HAL_RCC_ClockConfig+0x6c4>
34007c06:	687b      	ldr	r3, [r7, #4]
34007c08:	68db      	ldr	r3, [r3, #12]
34007c0a:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
34007c0e:	d013      	beq.n	34007c38 <HAL_RCC_ClockConfig+0x6c4>
34007c10:	687b      	ldr	r3, [r7, #4]
34007c12:	68db      	ldr	r3, [r3, #12]
34007c14:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
34007c18:	d00e      	beq.n	34007c38 <HAL_RCC_ClockConfig+0x6c4>
34007c1a:	687b      	ldr	r3, [r7, #4]
34007c1c:	68db      	ldr	r3, [r3, #12]
34007c1e:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
34007c22:	d009      	beq.n	34007c38 <HAL_RCC_ClockConfig+0x6c4>
34007c24:	687b      	ldr	r3, [r7, #4]
34007c26:	68db      	ldr	r3, [r3, #12]
34007c28:	f5b3 0fe0 	cmp.w	r3, #7340032	@ 0x700000
34007c2c:	d004      	beq.n	34007c38 <HAL_RCC_ClockConfig+0x6c4>
34007c2e:	f44f 618b 	mov.w	r1, #1112	@ 0x458
34007c32:	488e      	ldr	r0, [pc, #568]	@ (34007e6c <HAL_RCC_ClockConfig+0x8f8>)
34007c34:	f7fa f9ec 	bl	34002010 <assert_failed>
    if ((pRCC_ClkInitStruct->AHBCLKDivider) < (RCC->CFGR2 & RCC_CFGR2_HPRE))
34007c38:	687b      	ldr	r3, [r7, #4]
34007c3a:	68da      	ldr	r2, [r3, #12]
34007c3c:	4b8c      	ldr	r3, [pc, #560]	@ (34007e70 <HAL_RCC_ClockConfig+0x8fc>)
34007c3e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34007c40:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
34007c44:	429a      	cmp	r2, r3
34007c46:	d208      	bcs.n	34007c5a <HAL_RCC_ClockConfig+0x6e6>
    {
      /* Set the new HCLK clock divider */
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
34007c48:	4b89      	ldr	r3, [pc, #548]	@ (34007e70 <HAL_RCC_ClockConfig+0x8fc>)
34007c4a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34007c4c:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
34007c50:	687b      	ldr	r3, [r7, #4]
34007c52:	68db      	ldr	r3, [r3, #12]
34007c54:	4986      	ldr	r1, [pc, #536]	@ (34007e70 <HAL_RCC_ClockConfig+0x8fc>)
34007c56:	4313      	orrs	r3, r2
34007c58:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
34007c5a:	687b      	ldr	r3, [r7, #4]
34007c5c:	681b      	ldr	r3, [r3, #0]
34007c5e:	f003 0308 	and.w	r3, r3, #8
34007c62:	2b00      	cmp	r3, #0
34007c64:	d035      	beq.n	34007cd2 <HAL_RCC_ClockConfig+0x75e>
  {
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
34007c66:	687b      	ldr	r3, [r7, #4]
34007c68:	691b      	ldr	r3, [r3, #16]
34007c6a:	2b00      	cmp	r3, #0
34007c6c:	d020      	beq.n	34007cb0 <HAL_RCC_ClockConfig+0x73c>
34007c6e:	687b      	ldr	r3, [r7, #4]
34007c70:	691b      	ldr	r3, [r3, #16]
34007c72:	2b01      	cmp	r3, #1
34007c74:	d01c      	beq.n	34007cb0 <HAL_RCC_ClockConfig+0x73c>
34007c76:	687b      	ldr	r3, [r7, #4]
34007c78:	691b      	ldr	r3, [r3, #16]
34007c7a:	2b02      	cmp	r3, #2
34007c7c:	d018      	beq.n	34007cb0 <HAL_RCC_ClockConfig+0x73c>
34007c7e:	687b      	ldr	r3, [r7, #4]
34007c80:	691b      	ldr	r3, [r3, #16]
34007c82:	2b03      	cmp	r3, #3
34007c84:	d014      	beq.n	34007cb0 <HAL_RCC_ClockConfig+0x73c>
34007c86:	687b      	ldr	r3, [r7, #4]
34007c88:	691b      	ldr	r3, [r3, #16]
34007c8a:	2b04      	cmp	r3, #4
34007c8c:	d010      	beq.n	34007cb0 <HAL_RCC_ClockConfig+0x73c>
34007c8e:	687b      	ldr	r3, [r7, #4]
34007c90:	691b      	ldr	r3, [r3, #16]
34007c92:	2b05      	cmp	r3, #5
34007c94:	d00c      	beq.n	34007cb0 <HAL_RCC_ClockConfig+0x73c>
34007c96:	687b      	ldr	r3, [r7, #4]
34007c98:	691b      	ldr	r3, [r3, #16]
34007c9a:	2b06      	cmp	r3, #6
34007c9c:	d008      	beq.n	34007cb0 <HAL_RCC_ClockConfig+0x73c>
34007c9e:	687b      	ldr	r3, [r7, #4]
34007ca0:	691b      	ldr	r3, [r3, #16]
34007ca2:	2b07      	cmp	r3, #7
34007ca4:	d004      	beq.n	34007cb0 <HAL_RCC_ClockConfig+0x73c>
34007ca6:	f240 4163 	movw	r1, #1123	@ 0x463
34007caa:	4870      	ldr	r0, [pc, #448]	@ (34007e6c <HAL_RCC_ClockConfig+0x8f8>)
34007cac:	f7fa f9b0 	bl	34002010 <assert_failed>
    if ((pRCC_ClkInitStruct->APB1CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE1))
34007cb0:	687b      	ldr	r3, [r7, #4]
34007cb2:	691a      	ldr	r2, [r3, #16]
34007cb4:	4b6e      	ldr	r3, [pc, #440]	@ (34007e70 <HAL_RCC_ClockConfig+0x8fc>)
34007cb6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34007cb8:	f003 0307 	and.w	r3, r3, #7
34007cbc:	429a      	cmp	r2, r3
34007cbe:	d208      	bcs.n	34007cd2 <HAL_RCC_ClockConfig+0x75e>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
34007cc0:	4b6b      	ldr	r3, [pc, #428]	@ (34007e70 <HAL_RCC_ClockConfig+0x8fc>)
34007cc2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34007cc4:	f023 0207 	bic.w	r2, r3, #7
34007cc8:	687b      	ldr	r3, [r7, #4]
34007cca:	691b      	ldr	r3, [r3, #16]
34007ccc:	4968      	ldr	r1, [pc, #416]	@ (34007e70 <HAL_RCC_ClockConfig+0x8fc>)
34007cce:	4313      	orrs	r3, r2
34007cd0:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
34007cd2:	687b      	ldr	r3, [r7, #4]
34007cd4:	681b      	ldr	r3, [r3, #0]
34007cd6:	f003 0310 	and.w	r3, r3, #16
34007cda:	2b00      	cmp	r3, #0
34007cdc:	d035      	beq.n	34007d4a <HAL_RCC_ClockConfig+0x7d6>
  {
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
34007cde:	687b      	ldr	r3, [r7, #4]
34007ce0:	695b      	ldr	r3, [r3, #20]
34007ce2:	2b00      	cmp	r3, #0
34007ce4:	d020      	beq.n	34007d28 <HAL_RCC_ClockConfig+0x7b4>
34007ce6:	687b      	ldr	r3, [r7, #4]
34007ce8:	695b      	ldr	r3, [r3, #20]
34007cea:	2b10      	cmp	r3, #16
34007cec:	d01c      	beq.n	34007d28 <HAL_RCC_ClockConfig+0x7b4>
34007cee:	687b      	ldr	r3, [r7, #4]
34007cf0:	695b      	ldr	r3, [r3, #20]
34007cf2:	2b20      	cmp	r3, #32
34007cf4:	d018      	beq.n	34007d28 <HAL_RCC_ClockConfig+0x7b4>
34007cf6:	687b      	ldr	r3, [r7, #4]
34007cf8:	695b      	ldr	r3, [r3, #20]
34007cfa:	2b30      	cmp	r3, #48	@ 0x30
34007cfc:	d014      	beq.n	34007d28 <HAL_RCC_ClockConfig+0x7b4>
34007cfe:	687b      	ldr	r3, [r7, #4]
34007d00:	695b      	ldr	r3, [r3, #20]
34007d02:	2b40      	cmp	r3, #64	@ 0x40
34007d04:	d010      	beq.n	34007d28 <HAL_RCC_ClockConfig+0x7b4>
34007d06:	687b      	ldr	r3, [r7, #4]
34007d08:	695b      	ldr	r3, [r3, #20]
34007d0a:	2b50      	cmp	r3, #80	@ 0x50
34007d0c:	d00c      	beq.n	34007d28 <HAL_RCC_ClockConfig+0x7b4>
34007d0e:	687b      	ldr	r3, [r7, #4]
34007d10:	695b      	ldr	r3, [r3, #20]
34007d12:	2b60      	cmp	r3, #96	@ 0x60
34007d14:	d008      	beq.n	34007d28 <HAL_RCC_ClockConfig+0x7b4>
34007d16:	687b      	ldr	r3, [r7, #4]
34007d18:	695b      	ldr	r3, [r3, #20]
34007d1a:	2b70      	cmp	r3, #112	@ 0x70
34007d1c:	d004      	beq.n	34007d28 <HAL_RCC_ClockConfig+0x7b4>
34007d1e:	f240 416d 	movw	r1, #1133	@ 0x46d
34007d22:	4852      	ldr	r0, [pc, #328]	@ (34007e6c <HAL_RCC_ClockConfig+0x8f8>)
34007d24:	f7fa f974 	bl	34002010 <assert_failed>
    if ((pRCC_ClkInitStruct->APB2CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE2))
34007d28:	687b      	ldr	r3, [r7, #4]
34007d2a:	695a      	ldr	r2, [r3, #20]
34007d2c:	4b50      	ldr	r3, [pc, #320]	@ (34007e70 <HAL_RCC_ClockConfig+0x8fc>)
34007d2e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34007d30:	f003 0370 	and.w	r3, r3, #112	@ 0x70
34007d34:	429a      	cmp	r2, r3
34007d36:	d208      	bcs.n	34007d4a <HAL_RCC_ClockConfig+0x7d6>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
34007d38:	4b4d      	ldr	r3, [pc, #308]	@ (34007e70 <HAL_RCC_ClockConfig+0x8fc>)
34007d3a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34007d3c:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
34007d40:	687b      	ldr	r3, [r7, #4]
34007d42:	695b      	ldr	r3, [r3, #20]
34007d44:	494a      	ldr	r1, [pc, #296]	@ (34007e70 <HAL_RCC_ClockConfig+0x8fc>)
34007d46:	4313      	orrs	r3, r2
34007d48:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK4 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
34007d4a:	687b      	ldr	r3, [r7, #4]
34007d4c:	681b      	ldr	r3, [r3, #0]
34007d4e:	f003 0320 	and.w	r3, r3, #32
34007d52:	2b00      	cmp	r3, #0
34007d54:	d03c      	beq.n	34007dd0 <HAL_RCC_ClockConfig+0x85c>
  {
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
34007d56:	687b      	ldr	r3, [r7, #4]
34007d58:	699b      	ldr	r3, [r3, #24]
34007d5a:	2b00      	cmp	r3, #0
34007d5c:	d027      	beq.n	34007dae <HAL_RCC_ClockConfig+0x83a>
34007d5e:	687b      	ldr	r3, [r7, #4]
34007d60:	699b      	ldr	r3, [r3, #24]
34007d62:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34007d66:	d022      	beq.n	34007dae <HAL_RCC_ClockConfig+0x83a>
34007d68:	687b      	ldr	r3, [r7, #4]
34007d6a:	699b      	ldr	r3, [r3, #24]
34007d6c:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34007d70:	d01d      	beq.n	34007dae <HAL_RCC_ClockConfig+0x83a>
34007d72:	687b      	ldr	r3, [r7, #4]
34007d74:	699b      	ldr	r3, [r3, #24]
34007d76:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
34007d7a:	d018      	beq.n	34007dae <HAL_RCC_ClockConfig+0x83a>
34007d7c:	687b      	ldr	r3, [r7, #4]
34007d7e:	699b      	ldr	r3, [r3, #24]
34007d80:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34007d84:	d013      	beq.n	34007dae <HAL_RCC_ClockConfig+0x83a>
34007d86:	687b      	ldr	r3, [r7, #4]
34007d88:	699b      	ldr	r3, [r3, #24]
34007d8a:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
34007d8e:	d00e      	beq.n	34007dae <HAL_RCC_ClockConfig+0x83a>
34007d90:	687b      	ldr	r3, [r7, #4]
34007d92:	699b      	ldr	r3, [r3, #24]
34007d94:	f5b3 4fc0 	cmp.w	r3, #24576	@ 0x6000
34007d98:	d009      	beq.n	34007dae <HAL_RCC_ClockConfig+0x83a>
34007d9a:	687b      	ldr	r3, [r7, #4]
34007d9c:	699b      	ldr	r3, [r3, #24]
34007d9e:	f5b3 4fe0 	cmp.w	r3, #28672	@ 0x7000
34007da2:	d004      	beq.n	34007dae <HAL_RCC_ClockConfig+0x83a>
34007da4:	f240 4177 	movw	r1, #1143	@ 0x477
34007da8:	4830      	ldr	r0, [pc, #192]	@ (34007e6c <HAL_RCC_ClockConfig+0x8f8>)
34007daa:	f7fa f931 	bl	34002010 <assert_failed>
    if ((pRCC_ClkInitStruct->APB4CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE4))
34007dae:	687b      	ldr	r3, [r7, #4]
34007db0:	699a      	ldr	r2, [r3, #24]
34007db2:	4b2f      	ldr	r3, [pc, #188]	@ (34007e70 <HAL_RCC_ClockConfig+0x8fc>)
34007db4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34007db6:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
34007dba:	429a      	cmp	r2, r3
34007dbc:	d208      	bcs.n	34007dd0 <HAL_RCC_ClockConfig+0x85c>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
34007dbe:	4b2c      	ldr	r3, [pc, #176]	@ (34007e70 <HAL_RCC_ClockConfig+0x8fc>)
34007dc0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34007dc2:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
34007dc6:	687b      	ldr	r3, [r7, #4]
34007dc8:	699b      	ldr	r3, [r3, #24]
34007dca:	4929      	ldr	r1, [pc, #164]	@ (34007e70 <HAL_RCC_ClockConfig+0x8fc>)
34007dcc:	4313      	orrs	r3, r2
34007dce:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK5 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
34007dd0:	687b      	ldr	r3, [r7, #4]
34007dd2:	681b      	ldr	r3, [r3, #0]
34007dd4:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34007dd8:	2b00      	cmp	r3, #0
34007dda:	d03c      	beq.n	34007e56 <HAL_RCC_ClockConfig+0x8e2>
  {
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
34007ddc:	687b      	ldr	r3, [r7, #4]
34007dde:	69db      	ldr	r3, [r3, #28]
34007de0:	2b00      	cmp	r3, #0
34007de2:	d027      	beq.n	34007e34 <HAL_RCC_ClockConfig+0x8c0>
34007de4:	687b      	ldr	r3, [r7, #4]
34007de6:	69db      	ldr	r3, [r3, #28]
34007de8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34007dec:	d022      	beq.n	34007e34 <HAL_RCC_ClockConfig+0x8c0>
34007dee:	687b      	ldr	r3, [r7, #4]
34007df0:	69db      	ldr	r3, [r3, #28]
34007df2:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34007df6:	d01d      	beq.n	34007e34 <HAL_RCC_ClockConfig+0x8c0>
34007df8:	687b      	ldr	r3, [r7, #4]
34007dfa:	69db      	ldr	r3, [r3, #28]
34007dfc:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34007e00:	d018      	beq.n	34007e34 <HAL_RCC_ClockConfig+0x8c0>
34007e02:	687b      	ldr	r3, [r7, #4]
34007e04:	69db      	ldr	r3, [r3, #28]
34007e06:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34007e0a:	d013      	beq.n	34007e34 <HAL_RCC_ClockConfig+0x8c0>
34007e0c:	687b      	ldr	r3, [r7, #4]
34007e0e:	69db      	ldr	r3, [r3, #28]
34007e10:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
34007e14:	d00e      	beq.n	34007e34 <HAL_RCC_ClockConfig+0x8c0>
34007e16:	687b      	ldr	r3, [r7, #4]
34007e18:	69db      	ldr	r3, [r3, #28]
34007e1a:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
34007e1e:	d009      	beq.n	34007e34 <HAL_RCC_ClockConfig+0x8c0>
34007e20:	687b      	ldr	r3, [r7, #4]
34007e22:	69db      	ldr	r3, [r3, #28]
34007e24:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
34007e28:	d004      	beq.n	34007e34 <HAL_RCC_ClockConfig+0x8c0>
34007e2a:	f240 4181 	movw	r1, #1153	@ 0x481
34007e2e:	480f      	ldr	r0, [pc, #60]	@ (34007e6c <HAL_RCC_ClockConfig+0x8f8>)
34007e30:	f7fa f8ee 	bl	34002010 <assert_failed>
    if ((pRCC_ClkInitStruct->APB5CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE5))
34007e34:	687b      	ldr	r3, [r7, #4]
34007e36:	69da      	ldr	r2, [r3, #28]
34007e38:	4b0d      	ldr	r3, [pc, #52]	@ (34007e70 <HAL_RCC_ClockConfig+0x8fc>)
34007e3a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34007e3c:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
34007e40:	429a      	cmp	r2, r3
34007e42:	d208      	bcs.n	34007e56 <HAL_RCC_ClockConfig+0x8e2>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
34007e44:	4b0a      	ldr	r3, [pc, #40]	@ (34007e70 <HAL_RCC_ClockConfig+0x8fc>)
34007e46:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34007e48:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
34007e4c:	687b      	ldr	r3, [r7, #4]
34007e4e:	69db      	ldr	r3, [r3, #28]
34007e50:	4907      	ldr	r1, [pc, #28]	@ (34007e70 <HAL_RCC_ClockConfig+0x8fc>)
34007e52:	4313      	orrs	r3, r2
34007e54:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(uwTickPrio);
34007e56:	4b07      	ldr	r3, [pc, #28]	@ (34007e74 <HAL_RCC_ClockConfig+0x900>)
34007e58:	681b      	ldr	r3, [r3, #0]
34007e5a:	4618      	mov	r0, r3
34007e5c:	f7fc f8b0 	bl	34003fc0 <HAL_InitTick>
34007e60:	4603      	mov	r3, r0
}
34007e62:	4618      	mov	r0, r3
34007e64:	3710      	adds	r7, #16
34007e66:	46bd      	mov	sp, r7
34007e68:	bd80      	pop	{r7, pc}
34007e6a:	bf00      	nop
34007e6c:	3401edb8 	.word	0x3401edb8
34007e70:	56028000 	.word	0x56028000
34007e74:	34020c58 	.word	0x34020c58

34007e78 <HAL_RCC_GetCpuClockFreq>:
  *         will be incorrect.
  *
  * @retval CPUCLK frequency
  */
uint32_t HAL_RCC_GetCpuClockFreq(void)
{
34007e78:	b580      	push	{r7, lr}
34007e7a:	b082      	sub	sp, #8
34007e7c:	af00      	add	r7, sp, #0
  uint32_t frequency = 0U;
34007e7e:	2300      	movs	r3, #0
34007e80:	607b      	str	r3, [r7, #4]
  uint32_t ic_divider;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetCpuClkSource())
34007e82:	f7fe fcfd 	bl	34006880 <LL_RCC_GetCpuClkSource>
34007e86:	4603      	mov	r3, r0
34007e88:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34007e8c:	d025      	beq.n	34007eda <HAL_RCC_GetCpuClockFreq+0x62>
34007e8e:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34007e92:	d860      	bhi.n	34007f56 <HAL_RCC_GetCpuClockFreq+0xde>
34007e94:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34007e98:	d01c      	beq.n	34007ed4 <HAL_RCC_GetCpuClockFreq+0x5c>
34007e9a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34007e9e:	d85a      	bhi.n	34007f56 <HAL_RCC_GetCpuClockFreq+0xde>
34007ea0:	2b00      	cmp	r3, #0
34007ea2:	d003      	beq.n	34007eac <HAL_RCC_GetCpuClockFreq+0x34>
34007ea4:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34007ea8:	d009      	beq.n	34007ebe <HAL_RCC_GetCpuClockFreq+0x46>
      }
      break;

    default:
      /* Unexpected case */
      break;
34007eaa:	e054      	b.n	34007f56 <HAL_RCC_GetCpuClockFreq+0xde>
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34007eac:	f7fe fc1e 	bl	340066ec <LL_RCC_HSI_GetDivider>
34007eb0:	4603      	mov	r3, r0
34007eb2:	09db      	lsrs	r3, r3, #7
34007eb4:	4a2b      	ldr	r2, [pc, #172]	@ (34007f64 <HAL_RCC_GetCpuClockFreq+0xec>)
34007eb6:	fa22 f303 	lsr.w	r3, r2, r3
34007eba:	607b      	str	r3, [r7, #4]
      break;
34007ebc:	e04c      	b.n	34007f58 <HAL_RCC_GetCpuClockFreq+0xe0>
      if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
34007ebe:	f7fe fc7d 	bl	340067bc <LL_RCC_MSI_GetFrequency>
34007ec2:	4603      	mov	r3, r0
34007ec4:	2b00      	cmp	r3, #0
34007ec6:	d102      	bne.n	34007ece <HAL_RCC_GetCpuClockFreq+0x56>
        frequency = MSI_VALUE;
34007ec8:	4b27      	ldr	r3, [pc, #156]	@ (34007f68 <HAL_RCC_GetCpuClockFreq+0xf0>)
34007eca:	607b      	str	r3, [r7, #4]
      break;
34007ecc:	e044      	b.n	34007f58 <HAL_RCC_GetCpuClockFreq+0xe0>
        frequency = 16000000UL;
34007ece:	4b27      	ldr	r3, [pc, #156]	@ (34007f6c <HAL_RCC_GetCpuClockFreq+0xf4>)
34007ed0:	607b      	str	r3, [r7, #4]
      break;
34007ed2:	e041      	b.n	34007f58 <HAL_RCC_GetCpuClockFreq+0xe0>
      frequency = HSE_VALUE;
34007ed4:	4b26      	ldr	r3, [pc, #152]	@ (34007f70 <HAL_RCC_GetCpuClockFreq+0xf8>)
34007ed6:	607b      	str	r3, [r7, #4]
      break;
34007ed8:	e03e      	b.n	34007f58 <HAL_RCC_GetCpuClockFreq+0xe0>
      ic_divider = LL_RCC_IC1_GetDivider();
34007eda:	f7fe fde1 	bl	34006aa0 <LL_RCC_IC1_GetDivider>
34007ede:	6038      	str	r0, [r7, #0]
      switch (LL_RCC_IC1_GetSource())
34007ee0:	f7fe fdd0 	bl	34006a84 <LL_RCC_IC1_GetSource>
34007ee4:	4603      	mov	r3, r0
34007ee6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34007eea:	d029      	beq.n	34007f40 <HAL_RCC_GetCpuClockFreq+0xc8>
34007eec:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34007ef0:	d82f      	bhi.n	34007f52 <HAL_RCC_GetCpuClockFreq+0xda>
34007ef2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34007ef6:	d01a      	beq.n	34007f2e <HAL_RCC_GetCpuClockFreq+0xb6>
34007ef8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34007efc:	d829      	bhi.n	34007f52 <HAL_RCC_GetCpuClockFreq+0xda>
34007efe:	2b00      	cmp	r3, #0
34007f00:	d003      	beq.n	34007f0a <HAL_RCC_GetCpuClockFreq+0x92>
34007f02:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34007f06:	d009      	beq.n	34007f1c <HAL_RCC_GetCpuClockFreq+0xa4>
          break;
34007f08:	e023      	b.n	34007f52 <HAL_RCC_GetCpuClockFreq+0xda>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
34007f0a:	f009 f813 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34007f0e:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
34007f10:	687a      	ldr	r2, [r7, #4]
34007f12:	683b      	ldr	r3, [r7, #0]
34007f14:	fbb2 f3f3 	udiv	r3, r2, r3
34007f18:	607b      	str	r3, [r7, #4]
          break;
34007f1a:	e01b      	b.n	34007f54 <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
34007f1c:	f009 f850 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34007f20:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
34007f22:	687a      	ldr	r2, [r7, #4]
34007f24:	683b      	ldr	r3, [r7, #0]
34007f26:	fbb2 f3f3 	udiv	r3, r2, r3
34007f2a:	607b      	str	r3, [r7, #4]
          break;
34007f2c:	e012      	b.n	34007f54 <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
34007f2e:	f009 f88d 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34007f32:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
34007f34:	687a      	ldr	r2, [r7, #4]
34007f36:	683b      	ldr	r3, [r7, #0]
34007f38:	fbb2 f3f3 	udiv	r3, r2, r3
34007f3c:	607b      	str	r3, [r7, #4]
          break;
34007f3e:	e009      	b.n	34007f54 <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
34007f40:	f009 f8ca 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34007f44:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
34007f46:	687a      	ldr	r2, [r7, #4]
34007f48:	683b      	ldr	r3, [r7, #0]
34007f4a:	fbb2 f3f3 	udiv	r3, r2, r3
34007f4e:	607b      	str	r3, [r7, #4]
          break;
34007f50:	e000      	b.n	34007f54 <HAL_RCC_GetCpuClockFreq+0xdc>
          break;
34007f52:	bf00      	nop
      break;
34007f54:	e000      	b.n	34007f58 <HAL_RCC_GetCpuClockFreq+0xe0>
      break;
34007f56:	bf00      	nop
  }

  return frequency;
34007f58:	687b      	ldr	r3, [r7, #4]
}
34007f5a:	4618      	mov	r0, r3
34007f5c:	3708      	adds	r7, #8
34007f5e:	46bd      	mov	sp, r7
34007f60:	bd80      	pop	{r7, pc}
34007f62:	bf00      	nop
34007f64:	03d09000 	.word	0x03d09000
34007f68:	003d0900 	.word	0x003d0900
34007f6c:	00f42400 	.word	0x00f42400
34007f70:	02dc6c00 	.word	0x02dc6c00

34007f74 <HAL_RCC_GetSysClockFreq>:
  *         will be incorrect.
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
34007f74:	b580      	push	{r7, lr}
34007f76:	b082      	sub	sp, #8
34007f78:	af00      	add	r7, sp, #0
  uint32_t frequency = 0U;
34007f7a:	2300      	movs	r3, #0
34007f7c:	607b      	str	r3, [r7, #4]
  uint32_t ic_divider;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetSysClkSource())
34007f7e:	f7fe fc8d 	bl	3400689c <LL_RCC_GetSysClkSource>
34007f82:	4603      	mov	r3, r0
34007f84:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34007f88:	d025      	beq.n	34007fd6 <HAL_RCC_GetSysClockFreq+0x62>
34007f8a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34007f8e:	d860      	bhi.n	34008052 <HAL_RCC_GetSysClockFreq+0xde>
34007f90:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34007f94:	d01c      	beq.n	34007fd0 <HAL_RCC_GetSysClockFreq+0x5c>
34007f96:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34007f9a:	d85a      	bhi.n	34008052 <HAL_RCC_GetSysClockFreq+0xde>
34007f9c:	2b00      	cmp	r3, #0
34007f9e:	d003      	beq.n	34007fa8 <HAL_RCC_GetSysClockFreq+0x34>
34007fa0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34007fa4:	d009      	beq.n	34007fba <HAL_RCC_GetSysClockFreq+0x46>
      }
      break;

    default:
      /* Unexpected case */
      break;
34007fa6:	e054      	b.n	34008052 <HAL_RCC_GetSysClockFreq+0xde>
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34007fa8:	f7fe fba0 	bl	340066ec <LL_RCC_HSI_GetDivider>
34007fac:	4603      	mov	r3, r0
34007fae:	09db      	lsrs	r3, r3, #7
34007fb0:	4a2b      	ldr	r2, [pc, #172]	@ (34008060 <HAL_RCC_GetSysClockFreq+0xec>)
34007fb2:	fa22 f303 	lsr.w	r3, r2, r3
34007fb6:	607b      	str	r3, [r7, #4]
      break;
34007fb8:	e04c      	b.n	34008054 <HAL_RCC_GetSysClockFreq+0xe0>
      if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
34007fba:	f7fe fbff 	bl	340067bc <LL_RCC_MSI_GetFrequency>
34007fbe:	4603      	mov	r3, r0
34007fc0:	2b00      	cmp	r3, #0
34007fc2:	d102      	bne.n	34007fca <HAL_RCC_GetSysClockFreq+0x56>
        frequency = MSI_VALUE;
34007fc4:	4b27      	ldr	r3, [pc, #156]	@ (34008064 <HAL_RCC_GetSysClockFreq+0xf0>)
34007fc6:	607b      	str	r3, [r7, #4]
      break;
34007fc8:	e044      	b.n	34008054 <HAL_RCC_GetSysClockFreq+0xe0>
        frequency = 16000000UL;
34007fca:	4b27      	ldr	r3, [pc, #156]	@ (34008068 <HAL_RCC_GetSysClockFreq+0xf4>)
34007fcc:	607b      	str	r3, [r7, #4]
      break;
34007fce:	e041      	b.n	34008054 <HAL_RCC_GetSysClockFreq+0xe0>
      frequency = HSE_VALUE;
34007fd0:	4b26      	ldr	r3, [pc, #152]	@ (3400806c <HAL_RCC_GetSysClockFreq+0xf8>)
34007fd2:	607b      	str	r3, [r7, #4]
      break;
34007fd4:	e03e      	b.n	34008054 <HAL_RCC_GetSysClockFreq+0xe0>
      ic_divider = LL_RCC_IC2_GetDivider();
34007fd6:	f7fe fd81 	bl	34006adc <LL_RCC_IC2_GetDivider>
34007fda:	6038      	str	r0, [r7, #0]
      switch (LL_RCC_IC2_GetSource())
34007fdc:	f7fe fd70 	bl	34006ac0 <LL_RCC_IC2_GetSource>
34007fe0:	4603      	mov	r3, r0
34007fe2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34007fe6:	d029      	beq.n	3400803c <HAL_RCC_GetSysClockFreq+0xc8>
34007fe8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34007fec:	d82f      	bhi.n	3400804e <HAL_RCC_GetSysClockFreq+0xda>
34007fee:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34007ff2:	d01a      	beq.n	3400802a <HAL_RCC_GetSysClockFreq+0xb6>
34007ff4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34007ff8:	d829      	bhi.n	3400804e <HAL_RCC_GetSysClockFreq+0xda>
34007ffa:	2b00      	cmp	r3, #0
34007ffc:	d003      	beq.n	34008006 <HAL_RCC_GetSysClockFreq+0x92>
34007ffe:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34008002:	d009      	beq.n	34008018 <HAL_RCC_GetSysClockFreq+0xa4>
          break;
34008004:	e023      	b.n	3400804e <HAL_RCC_GetSysClockFreq+0xda>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
34008006:	f008 ff95 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
3400800a:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3400800c:	687a      	ldr	r2, [r7, #4]
3400800e:	683b      	ldr	r3, [r7, #0]
34008010:	fbb2 f3f3 	udiv	r3, r2, r3
34008014:	607b      	str	r3, [r7, #4]
          break;
34008016:	e01b      	b.n	34008050 <HAL_RCC_GetSysClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
34008018:	f008 ffd2 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
3400801c:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3400801e:	687a      	ldr	r2, [r7, #4]
34008020:	683b      	ldr	r3, [r7, #0]
34008022:	fbb2 f3f3 	udiv	r3, r2, r3
34008026:	607b      	str	r3, [r7, #4]
          break;
34008028:	e012      	b.n	34008050 <HAL_RCC_GetSysClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400802a:	f009 f80f 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
3400802e:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
34008030:	687a      	ldr	r2, [r7, #4]
34008032:	683b      	ldr	r3, [r7, #0]
34008034:	fbb2 f3f3 	udiv	r3, r2, r3
34008038:	607b      	str	r3, [r7, #4]
          break;
3400803a:	e009      	b.n	34008050 <HAL_RCC_GetSysClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400803c:	f009 f84c 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34008040:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
34008042:	687a      	ldr	r2, [r7, #4]
34008044:	683b      	ldr	r3, [r7, #0]
34008046:	fbb2 f3f3 	udiv	r3, r2, r3
3400804a:	607b      	str	r3, [r7, #4]
          break;
3400804c:	e000      	b.n	34008050 <HAL_RCC_GetSysClockFreq+0xdc>
          break;
3400804e:	bf00      	nop
      break;
34008050:	e000      	b.n	34008054 <HAL_RCC_GetSysClockFreq+0xe0>
      break;
34008052:	bf00      	nop
  }

  return frequency;
34008054:	687b      	ldr	r3, [r7, #4]
}
34008056:	4618      	mov	r0, r3
34008058:	3708      	adds	r7, #8
3400805a:	46bd      	mov	sp, r7
3400805c:	bd80      	pop	{r7, pc}
3400805e:	bf00      	nop
34008060:	03d09000 	.word	0x03d09000
34008064:	003d0900 	.word	0x003d0900
34008068:	00f42400 	.word	0x00f42400
3400806c:	02dc6c00 	.word	0x02dc6c00

34008070 <RCC_PLL_Config>:
  * @note   PLL is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_PLL_Config(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
34008070:	b580      	push	{r7, lr}
34008072:	b088      	sub	sp, #32
34008074:	af00      	add	r7, sp, #0
34008076:	6078      	str	r0, [r7, #4]
34008078:	6039      	str	r1, [r7, #0]
  __IO uint32_t *p_rcc_pll_cfgr1_reg;
  __IO uint32_t *p_rcc_pll_cfgr2_reg;
  __IO uint32_t *p_rcc_pll_cfgr3_reg;
  HAL_StatusTypeDef ret = HAL_OK;
3400807a:	2300      	movs	r3, #0
3400807c:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart;

  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
3400807e:	687b      	ldr	r3, [r7, #4]
34008080:	011a      	lsls	r2, r3, #4
34008082:	4b9a      	ldr	r3, [pc, #616]	@ (340082ec <RCC_PLL_Config+0x27c>)
34008084:	4413      	add	r3, r2
34008086:	61bb      	str	r3, [r7, #24]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
34008088:	687b      	ldr	r3, [r7, #4]
3400808a:	011a      	lsls	r2, r3, #4
3400808c:	4b98      	ldr	r3, [pc, #608]	@ (340082f0 <RCC_PLL_Config+0x280>)
3400808e:	4413      	add	r3, r2
34008090:	617b      	str	r3, [r7, #20]
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
34008092:	687b      	ldr	r3, [r7, #4]
34008094:	011a      	lsls	r2, r3, #4
34008096:	4b97      	ldr	r3, [pc, #604]	@ (340082f4 <RCC_PLL_Config+0x284>)
34008098:	4413      	add	r3, r2
3400809a:	613b      	str	r3, [r7, #16]

  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */
  if (pPLLInit->PLLState == RCC_PLL_ON)
3400809c:	683b      	ldr	r3, [r7, #0]
3400809e:	681b      	ldr	r3, [r3, #0]
340080a0:	2b02      	cmp	r3, #2
340080a2:	f040 80e9 	bne.w	34008278 <RCC_PLL_Config+0x208>
  {
    /* Check the parameters */
    assert_param(IS_RCC_PLLSOURCE(pPLLInit->PLLSource));
340080a6:	683b      	ldr	r3, [r7, #0]
340080a8:	685b      	ldr	r3, [r3, #4]
340080aa:	2b00      	cmp	r3, #0
340080ac:	d013      	beq.n	340080d6 <RCC_PLL_Config+0x66>
340080ae:	683b      	ldr	r3, [r7, #0]
340080b0:	685b      	ldr	r3, [r3, #4]
340080b2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340080b6:	d00e      	beq.n	340080d6 <RCC_PLL_Config+0x66>
340080b8:	683b      	ldr	r3, [r7, #0]
340080ba:	685b      	ldr	r3, [r3, #4]
340080bc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340080c0:	d009      	beq.n	340080d6 <RCC_PLL_Config+0x66>
340080c2:	683b      	ldr	r3, [r7, #0]
340080c4:	685b      	ldr	r3, [r3, #4]
340080c6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340080ca:	d004      	beq.n	340080d6 <RCC_PLL_Config+0x66>
340080cc:	f240 71fa 	movw	r1, #2042	@ 0x7fa
340080d0:	4889      	ldr	r0, [pc, #548]	@ (340082f8 <RCC_PLL_Config+0x288>)
340080d2:	f7f9 ff9d 	bl	34002010 <assert_failed>
    assert_param(IS_RCC_PLLFRACN_VALUE(pPLLInit->PLLFractional));
340080d6:	683b      	ldr	r3, [r7, #0]
340080d8:	68db      	ldr	r3, [r3, #12]
340080da:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
340080de:	d304      	bcc.n	340080ea <RCC_PLL_Config+0x7a>
340080e0:	f240 71fb 	movw	r1, #2043	@ 0x7fb
340080e4:	4884      	ldr	r0, [pc, #528]	@ (340082f8 <RCC_PLL_Config+0x288>)
340080e6:	f7f9 ff93 	bl	34002010 <assert_failed>
    assert_param(IS_RCC_PLLM_VALUE(pPLLInit->PLLM));
340080ea:	683b      	ldr	r3, [r7, #0]
340080ec:	689b      	ldr	r3, [r3, #8]
340080ee:	2b00      	cmp	r3, #0
340080f0:	d003      	beq.n	340080fa <RCC_PLL_Config+0x8a>
340080f2:	683b      	ldr	r3, [r7, #0]
340080f4:	689b      	ldr	r3, [r3, #8]
340080f6:	2b3f      	cmp	r3, #63	@ 0x3f
340080f8:	d904      	bls.n	34008104 <RCC_PLL_Config+0x94>
340080fa:	f240 71fc 	movw	r1, #2044	@ 0x7fc
340080fe:	487e      	ldr	r0, [pc, #504]	@ (340082f8 <RCC_PLL_Config+0x288>)
34008100:	f7f9 ff86 	bl	34002010 <assert_failed>
    assert_param(IS_RCC_PLLN_VALUE(pPLLInit->PLLN));
34008104:	683b      	ldr	r3, [r7, #0]
34008106:	691b      	ldr	r3, [r3, #16]
34008108:	2b09      	cmp	r3, #9
3400810a:	d905      	bls.n	34008118 <RCC_PLL_Config+0xa8>
3400810c:	683b      	ldr	r3, [r7, #0]
3400810e:	691b      	ldr	r3, [r3, #16]
34008110:	f640 12c4 	movw	r2, #2500	@ 0x9c4
34008114:	4293      	cmp	r3, r2
34008116:	d904      	bls.n	34008122 <RCC_PLL_Config+0xb2>
34008118:	f240 71fd 	movw	r1, #2045	@ 0x7fd
3400811c:	4876      	ldr	r0, [pc, #472]	@ (340082f8 <RCC_PLL_Config+0x288>)
3400811e:	f7f9 ff77 	bl	34002010 <assert_failed>
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP1));
34008122:	683b      	ldr	r3, [r7, #0]
34008124:	695b      	ldr	r3, [r3, #20]
34008126:	2b00      	cmp	r3, #0
34008128:	d003      	beq.n	34008132 <RCC_PLL_Config+0xc2>
3400812a:	683b      	ldr	r3, [r7, #0]
3400812c:	695b      	ldr	r3, [r3, #20]
3400812e:	2b07      	cmp	r3, #7
34008130:	d904      	bls.n	3400813c <RCC_PLL_Config+0xcc>
34008132:	f240 71fe 	movw	r1, #2046	@ 0x7fe
34008136:	4870      	ldr	r0, [pc, #448]	@ (340082f8 <RCC_PLL_Config+0x288>)
34008138:	f7f9 ff6a 	bl	34002010 <assert_failed>
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP2));
3400813c:	683b      	ldr	r3, [r7, #0]
3400813e:	699b      	ldr	r3, [r3, #24]
34008140:	2b00      	cmp	r3, #0
34008142:	d003      	beq.n	3400814c <RCC_PLL_Config+0xdc>
34008144:	683b      	ldr	r3, [r7, #0]
34008146:	699b      	ldr	r3, [r3, #24]
34008148:	2b07      	cmp	r3, #7
3400814a:	d904      	bls.n	34008156 <RCC_PLL_Config+0xe6>
3400814c:	f240 71ff 	movw	r1, #2047	@ 0x7ff
34008150:	4869      	ldr	r0, [pc, #420]	@ (340082f8 <RCC_PLL_Config+0x288>)
34008152:	f7f9 ff5d 	bl	34002010 <assert_failed>

    /* Ensure PLLx is disabled */
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
34008156:	4a69      	ldr	r2, [pc, #420]	@ (340082fc <RCC_PLL_Config+0x28c>)
34008158:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400815c:	687b      	ldr	r3, [r7, #4]
3400815e:	fa01 f303 	lsl.w	r3, r1, r3
34008162:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34008166:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
34008168:	f7fb ff74 	bl	34004054 <HAL_GetTick>
3400816c:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is disabled */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3400816e:	e008      	b.n	34008182 <RCC_PLL_Config+0x112>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
34008170:	f7fb ff70 	bl	34004054 <HAL_GetTick>
34008174:	4602      	mov	r2, r0
34008176:	68fb      	ldr	r3, [r7, #12]
34008178:	1ad3      	subs	r3, r2, r3
3400817a:	2b01      	cmp	r3, #1
3400817c:	d901      	bls.n	34008182 <RCC_PLL_Config+0x112>
      {
        return HAL_TIMEOUT;
3400817e:	2303      	movs	r3, #3
34008180:	e114      	b.n	340083ac <RCC_PLL_Config+0x33c>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34008182:	4b5e      	ldr	r3, [pc, #376]	@ (340082fc <RCC_PLL_Config+0x28c>)
34008184:	685a      	ldr	r2, [r3, #4]
34008186:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400818a:	687b      	ldr	r3, [r7, #4]
3400818c:	fa01 f303 	lsl.w	r3, r1, r3
34008190:	401a      	ands	r2, r3
34008192:	f44f 7180 	mov.w	r1, #256	@ 0x100
34008196:	687b      	ldr	r3, [r7, #4]
34008198:	fa01 f303 	lsl.w	r3, r1, r3
3400819c:	429a      	cmp	r2, r3
3400819e:	d0e7      	beq.n	34008170 <RCC_PLL_Config+0x100>
      }
    }

    /* Ensure PLLxMODSSDIS='1' */
    SET_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODSSDIS);
340081a0:	693b      	ldr	r3, [r7, #16]
340081a2:	681b      	ldr	r3, [r3, #0]
340081a4:	f043 0204 	orr.w	r2, r3, #4
340081a8:	693b      	ldr	r3, [r7, #16]
340081aa:	601a      	str	r2, [r3, #0]

    /* Clear bypass mode */
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
340081ac:	69bb      	ldr	r3, [r7, #24]
340081ae:	681b      	ldr	r3, [r3, #0]
340081b0:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
340081b4:	69bb      	ldr	r3, [r7, #24]
340081b6:	601a      	str	r2, [r3, #0]

    /* Configure the PLLx clock source, multiplication and division factors. */
    MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN), \
340081b8:	69bb      	ldr	r3, [r7, #24]
340081ba:	681a      	ldr	r2, [r3, #0]
340081bc:	4b50      	ldr	r3, [pc, #320]	@ (34008300 <RCC_PLL_Config+0x290>)
340081be:	4013      	ands	r3, r2
340081c0:	683a      	ldr	r2, [r7, #0]
340081c2:	6851      	ldr	r1, [r2, #4]
340081c4:	683a      	ldr	r2, [r7, #0]
340081c6:	6892      	ldr	r2, [r2, #8]
340081c8:	0512      	lsls	r2, r2, #20
340081ca:	4311      	orrs	r1, r2
340081cc:	683a      	ldr	r2, [r7, #0]
340081ce:	6912      	ldr	r2, [r2, #16]
340081d0:	0212      	lsls	r2, r2, #8
340081d2:	430a      	orrs	r2, r1
340081d4:	431a      	orrs	r2, r3
340081d6:	69bb      	ldr	r3, [r7, #24]
340081d8:	601a      	str	r2, [r3, #0]
               (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
                | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)));
    MODIFY_REG(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2), \
340081da:	693b      	ldr	r3, [r7, #16]
340081dc:	681b      	ldr	r3, [r3, #0]
340081de:	f023 527c 	bic.w	r2, r3, #1056964608	@ 0x3f000000
340081e2:	683b      	ldr	r3, [r7, #0]
340081e4:	695b      	ldr	r3, [r3, #20]
340081e6:	06d9      	lsls	r1, r3, #27
340081e8:	683b      	ldr	r3, [r7, #0]
340081ea:	699b      	ldr	r3, [r3, #24]
340081ec:	061b      	lsls	r3, r3, #24
340081ee:	430b      	orrs	r3, r1
340081f0:	431a      	orrs	r2, r3
340081f2:	693b      	ldr	r3, [r7, #16]
340081f4:	601a      	str	r2, [r3, #0]
               ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)));

    /* Configure PLLx DIVNFRAC */
    MODIFY_REG(*p_rcc_pll_cfgr2_reg, RCC_PLL1CFGR2_PLL1DIVNFRAC, \
340081f6:	697b      	ldr	r3, [r7, #20]
340081f8:	681b      	ldr	r3, [r3, #0]
340081fa:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
340081fe:	683b      	ldr	r3, [r7, #0]
34008200:	68db      	ldr	r3, [r3, #12]
34008202:	431a      	orrs	r2, r3
34008204:	697b      	ldr	r3, [r7, #20]
34008206:	601a      	str	r2, [r3, #0]
               pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);

    /* Clear PLLxMODDSEN (Also clear in Fractional Mode to ensure the latch of updated FRAC value when set again) */
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODDSEN);
34008208:	693b      	ldr	r3, [r7, #16]
3400820a:	681b      	ldr	r3, [r3, #0]
3400820c:	f023 0208 	bic.w	r2, r3, #8
34008210:	693b      	ldr	r3, [r7, #16]
34008212:	601a      	str	r2, [r3, #0]

    /* Fractional Mode specificities Management */
    if (pPLLInit->PLLFractional != 0U)
34008214:	683b      	ldr	r3, [r7, #0]
34008216:	68db      	ldr	r3, [r3, #12]
34008218:	2b00      	cmp	r3, #0
3400821a:	d005      	beq.n	34008228 <RCC_PLL_Config+0x1b8>
    {
      /* Set PLLxMODDSEN and DACEN */
      SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODDSEN | RCC_PLL1CFGR3_PLL1DACEN));
3400821c:	693b      	ldr	r3, [r7, #16]
3400821e:	681b      	ldr	r3, [r3, #0]
34008220:	f043 020a 	orr.w	r2, r3, #10
34008224:	693b      	ldr	r3, [r7, #16]
34008226:	601a      	str	r2, [r3, #0]
    }

    /* Ensure PLLxMODSSRST='1' and Enable PLLx post divider output */
    SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODSSRST | RCC_PLL1CFGR3_PLL1PDIVEN));
34008228:	693b      	ldr	r3, [r7, #16]
3400822a:	681b      	ldr	r3, [r3, #0]
3400822c:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
34008230:	f043 0301 	orr.w	r3, r3, #1
34008234:	693a      	ldr	r2, [r7, #16]
34008236:	6013      	str	r3, [r2, #0]

    /* Enable the PLLx */
    WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
34008238:	4a30      	ldr	r2, [pc, #192]	@ (340082fc <RCC_PLL_Config+0x28c>)
3400823a:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400823e:	687b      	ldr	r3, [r7, #4]
34008240:	fa01 f303 	lsl.w	r3, r1, r3
34008244:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
34008248:	f7fb ff04 	bl	34004054 <HAL_GetTick>
3400824c:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is ready */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3400824e:	e008      	b.n	34008262 <RCC_PLL_Config+0x1f2>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
34008250:	f7fb ff00 	bl	34004054 <HAL_GetTick>
34008254:	4602      	mov	r2, r0
34008256:	68fb      	ldr	r3, [r7, #12]
34008258:	1ad3      	subs	r3, r2, r3
3400825a:	2b01      	cmp	r3, #1
3400825c:	d901      	bls.n	34008262 <RCC_PLL_Config+0x1f2>
      {
        return HAL_TIMEOUT;
3400825e:	2303      	movs	r3, #3
34008260:	e0a4      	b.n	340083ac <RCC_PLL_Config+0x33c>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
34008262:	4b26      	ldr	r3, [pc, #152]	@ (340082fc <RCC_PLL_Config+0x28c>)
34008264:	685a      	ldr	r2, [r3, #4]
34008266:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400826a:	687b      	ldr	r3, [r7, #4]
3400826c:	fa01 f303 	lsl.w	r3, r1, r3
34008270:	4013      	ands	r3, r2
34008272:	2b00      	cmp	r3, #0
34008274:	d0ec      	beq.n	34008250 <RCC_PLL_Config+0x1e0>
34008276:	e098      	b.n	340083aa <RCC_PLL_Config+0x33a>
      }
    }
  }
  else if (pPLLInit->PLLState == RCC_PLL_BYPASS)
34008278:	683b      	ldr	r3, [r7, #0]
3400827a:	681b      	ldr	r3, [r3, #0]
3400827c:	2b03      	cmp	r3, #3
3400827e:	d15f      	bne.n	34008340 <RCC_PLL_Config+0x2d0>
  {
    assert_param(IS_RCC_PLLSOURCE(pPLLInit->PLLSource));
34008280:	683b      	ldr	r3, [r7, #0]
34008282:	685b      	ldr	r3, [r3, #4]
34008284:	2b00      	cmp	r3, #0
34008286:	d013      	beq.n	340082b0 <RCC_PLL_Config+0x240>
34008288:	683b      	ldr	r3, [r7, #0]
3400828a:	685b      	ldr	r3, [r3, #4]
3400828c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34008290:	d00e      	beq.n	340082b0 <RCC_PLL_Config+0x240>
34008292:	683b      	ldr	r3, [r7, #0]
34008294:	685b      	ldr	r3, [r3, #4]
34008296:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400829a:	d009      	beq.n	340082b0 <RCC_PLL_Config+0x240>
3400829c:	683b      	ldr	r3, [r7, #0]
3400829e:	685b      	ldr	r3, [r3, #4]
340082a0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340082a4:	d004      	beq.n	340082b0 <RCC_PLL_Config+0x240>
340082a6:	f640 013f 	movw	r1, #2111	@ 0x83f
340082aa:	4813      	ldr	r0, [pc, #76]	@ (340082f8 <RCC_PLL_Config+0x288>)
340082ac:	f7f9 feb0 	bl	34002010 <assert_failed>

    /* Check selected source is ready */
    if (RCC_PLL_Source_IsReady(pPLLInit->PLLSource) == 1U)
340082b0:	683b      	ldr	r3, [r7, #0]
340082b2:	685b      	ldr	r3, [r3, #4]
340082b4:	4618      	mov	r0, r3
340082b6:	f000 f925 	bl	34008504 <RCC_PLL_Source_IsReady>
340082ba:	4603      	mov	r3, r0
340082bc:	2b01      	cmp	r3, #1
340082be:	d13c      	bne.n	3400833a <RCC_PLL_Config+0x2ca>
    {
      /* Ensure PLLx is disabled */
      WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
340082c0:	4a0e      	ldr	r2, [pc, #56]	@ (340082fc <RCC_PLL_Config+0x28c>)
340082c2:	f44f 7180 	mov.w	r1, #256	@ 0x100
340082c6:	687b      	ldr	r3, [r7, #4]
340082c8:	fa01 f303 	lsl.w	r3, r1, r3
340082cc:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
340082d0:	6013      	str	r3, [r2, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
340082d2:	f7fb febf 	bl	34004054 <HAL_GetTick>
340082d6:	60f8      	str	r0, [r7, #12]

      /* Wait till PLLx is disabled */
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
340082d8:	e014      	b.n	34008304 <RCC_PLL_Config+0x294>
      {
        if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
340082da:	f7fb febb 	bl	34004054 <HAL_GetTick>
340082de:	4602      	mov	r2, r0
340082e0:	68fb      	ldr	r3, [r7, #12]
340082e2:	1ad3      	subs	r3, r2, r3
340082e4:	2b01      	cmp	r3, #1
340082e6:	d90d      	bls.n	34008304 <RCC_PLL_Config+0x294>
        {
          return HAL_TIMEOUT;
340082e8:	2303      	movs	r3, #3
340082ea:	e05f      	b.n	340083ac <RCC_PLL_Config+0x33c>
340082ec:	56028080 	.word	0x56028080
340082f0:	56028084 	.word	0x56028084
340082f4:	56028088 	.word	0x56028088
340082f8:	3401edb8 	.word	0x3401edb8
340082fc:	56028000 	.word	0x56028000
34008300:	8c0000ff 	.word	0x8c0000ff
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34008304:	4b2b      	ldr	r3, [pc, #172]	@ (340083b4 <RCC_PLL_Config+0x344>)
34008306:	685a      	ldr	r2, [r3, #4]
34008308:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400830c:	687b      	ldr	r3, [r7, #4]
3400830e:	fa01 f303 	lsl.w	r3, r1, r3
34008312:	401a      	ands	r2, r3
34008314:	f44f 7180 	mov.w	r1, #256	@ 0x100
34008318:	687b      	ldr	r3, [r7, #4]
3400831a:	fa01 f303 	lsl.w	r3, r1, r3
3400831e:	429a      	cmp	r2, r3
34008320:	d0db      	beq.n	340082da <RCC_PLL_Config+0x26a>
        }
      }

      /* Set bypass mode with selected source */
      MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1BYP | RCC_PLL1CFGR1_PLL1SEL), \
34008322:	69bb      	ldr	r3, [r7, #24]
34008324:	681b      	ldr	r3, [r3, #0]
34008326:	f023 42f0 	bic.w	r2, r3, #2013265920	@ 0x78000000
3400832a:	683b      	ldr	r3, [r7, #0]
3400832c:	685b      	ldr	r3, [r3, #4]
3400832e:	4313      	orrs	r3, r2
34008330:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
34008334:	69bb      	ldr	r3, [r7, #24]
34008336:	601a      	str	r2, [r3, #0]
34008338:	e037      	b.n	340083aa <RCC_PLL_Config+0x33a>
                 (RCC_PLL1CFGR1_PLL1BYP | pPLLInit->PLLSource));
    }
    else
    {
      ret = HAL_ERROR;
3400833a:	2301      	movs	r3, #1
3400833c:	77fb      	strb	r3, [r7, #31]
3400833e:	e034      	b.n	340083aa <RCC_PLL_Config+0x33a>
    }
  }
  else if (pPLLInit->PLLState == RCC_PLL_OFF)
34008340:	683b      	ldr	r3, [r7, #0]
34008342:	681b      	ldr	r3, [r3, #0]
34008344:	2b01      	cmp	r3, #1
34008346:	d130      	bne.n	340083aa <RCC_PLL_Config+0x33a>
  {
    /* Disable PLLx post divider output */
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1PDIVEN);
34008348:	693b      	ldr	r3, [r7, #16]
3400834a:	681b      	ldr	r3, [r3, #0]
3400834c:	f023 4280 	bic.w	r2, r3, #1073741824	@ 0x40000000
34008350:	693b      	ldr	r3, [r7, #16]
34008352:	601a      	str	r2, [r3, #0]

    /* Ensure PLLx is disabled */
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
34008354:	4a17      	ldr	r2, [pc, #92]	@ (340083b4 <RCC_PLL_Config+0x344>)
34008356:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400835a:	687b      	ldr	r3, [r7, #4]
3400835c:	fa01 f303 	lsl.w	r3, r1, r3
34008360:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34008364:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
34008366:	f7fb fe75 	bl	34004054 <HAL_GetTick>
3400836a:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is disabled */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3400836c:	e008      	b.n	34008380 <RCC_PLL_Config+0x310>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3400836e:	f7fb fe71 	bl	34004054 <HAL_GetTick>
34008372:	4602      	mov	r2, r0
34008374:	68fb      	ldr	r3, [r7, #12]
34008376:	1ad3      	subs	r3, r2, r3
34008378:	2b01      	cmp	r3, #1
3400837a:	d901      	bls.n	34008380 <RCC_PLL_Config+0x310>
      {
        return HAL_TIMEOUT;
3400837c:	2303      	movs	r3, #3
3400837e:	e015      	b.n	340083ac <RCC_PLL_Config+0x33c>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34008380:	4b0c      	ldr	r3, [pc, #48]	@ (340083b4 <RCC_PLL_Config+0x344>)
34008382:	685a      	ldr	r2, [r3, #4]
34008384:	f44f 7180 	mov.w	r1, #256	@ 0x100
34008388:	687b      	ldr	r3, [r7, #4]
3400838a:	fa01 f303 	lsl.w	r3, r1, r3
3400838e:	401a      	ands	r2, r3
34008390:	f44f 7180 	mov.w	r1, #256	@ 0x100
34008394:	687b      	ldr	r3, [r7, #4]
34008396:	fa01 f303 	lsl.w	r3, r1, r3
3400839a:	429a      	cmp	r2, r3
3400839c:	d0e7      	beq.n	3400836e <RCC_PLL_Config+0x2fe>
      }
    }

    /* Clear bypass mode */
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
3400839e:	69bb      	ldr	r3, [r7, #24]
340083a0:	681b      	ldr	r3, [r3, #0]
340083a2:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
340083a6:	69bb      	ldr	r3, [r7, #24]
340083a8:	601a      	str	r2, [r3, #0]
  else
  {
    /* Nothing to do */
  }

  return ret;
340083aa:	7ffb      	ldrb	r3, [r7, #31]
}
340083ac:	4618      	mov	r0, r3
340083ae:	3720      	adds	r7, #32
340083b0:	46bd      	mov	sp, r7
340083b2:	bd80      	pop	{r7, pc}
340083b4:	56028000 	.word	0x56028000

340083b8 <RCC_PLL_Enable>:
  * @param  PLLnumber PLL number to enable
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_PLL_Enable(uint32_t PLLnumber)
{
340083b8:	b580      	push	{r7, lr}
340083ba:	b084      	sub	sp, #16
340083bc:	af00      	add	r7, sp, #0
340083be:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
340083c0:	2300      	movs	r3, #0
340083c2:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart;

  /* Enable the PLLx */
  WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
340083c4:	4a11      	ldr	r2, [pc, #68]	@ (3400840c <RCC_PLL_Enable+0x54>)
340083c6:	f44f 7180 	mov.w	r1, #256	@ 0x100
340083ca:	687b      	ldr	r3, [r7, #4]
340083cc:	fa01 f303 	lsl.w	r3, r1, r3
340083d0:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
340083d4:	f7fb fe3e 	bl	34004054 <HAL_GetTick>
340083d8:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLx is ready */
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
340083da:	e008      	b.n	340083ee <RCC_PLL_Enable+0x36>
  {
    if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
340083dc:	f7fb fe3a 	bl	34004054 <HAL_GetTick>
340083e0:	4602      	mov	r2, r0
340083e2:	68bb      	ldr	r3, [r7, #8]
340083e4:	1ad3      	subs	r3, r2, r3
340083e6:	2b01      	cmp	r3, #1
340083e8:	d901      	bls.n	340083ee <RCC_PLL_Enable+0x36>
    {
      return HAL_TIMEOUT;
340083ea:	2303      	movs	r3, #3
340083ec:	e00a      	b.n	34008404 <RCC_PLL_Enable+0x4c>
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
340083ee:	4b07      	ldr	r3, [pc, #28]	@ (3400840c <RCC_PLL_Enable+0x54>)
340083f0:	685a      	ldr	r2, [r3, #4]
340083f2:	f44f 7180 	mov.w	r1, #256	@ 0x100
340083f6:	687b      	ldr	r3, [r7, #4]
340083f8:	fa01 f303 	lsl.w	r3, r1, r3
340083fc:	4013      	ands	r3, r2
340083fe:	2b00      	cmp	r3, #0
34008400:	d0ec      	beq.n	340083dc <RCC_PLL_Enable+0x24>
    }
  }

  return ret;
34008402:	7bfb      	ldrb	r3, [r7, #15]
}
34008404:	4618      	mov	r0, r3
34008406:	3710      	adds	r7, #16
34008408:	46bd      	mov	sp, r7
3400840a:	bd80      	pop	{r7, pc}
3400840c:	56028000 	.word	0x56028000

34008410 <RCC_PLL_IsNewConfig>:
  * @param  pPLLInit Pointer to an RCC_PLLInitTypeDef structure that
  *                  contains the configuration parameters.  *
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_IsNewConfig(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
34008410:	b480      	push	{r7}
34008412:	b089      	sub	sp, #36	@ 0x24
34008414:	af00      	add	r7, sp, #0
34008416:	6078      	str	r0, [r7, #4]
34008418:	6039      	str	r1, [r7, #0]
  __IO const uint32_t *p_rcc_pll_cfgr1_reg, *p_rcc_pll_cfgr2_reg, *p_rcc_pll_cfgr3_reg;
  uint32_t ret = 0U;
3400841a:	2300      	movs	r3, #0
3400841c:	61fb      	str	r3, [r7, #28]

  /* No assert since done in calling function */

  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
3400841e:	687b      	ldr	r3, [r7, #4]
34008420:	011a      	lsls	r2, r3, #4
34008422:	4b34      	ldr	r3, [pc, #208]	@ (340084f4 <RCC_PLL_IsNewConfig+0xe4>)
34008424:	4413      	add	r3, r2
34008426:	617b      	str	r3, [r7, #20]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
34008428:	687b      	ldr	r3, [r7, #4]
3400842a:	011a      	lsls	r2, r3, #4
3400842c:	4b32      	ldr	r3, [pc, #200]	@ (340084f8 <RCC_PLL_IsNewConfig+0xe8>)
3400842e:	4413      	add	r3, r2
34008430:	613b      	str	r3, [r7, #16]
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
34008432:	687b      	ldr	r3, [r7, #4]
34008434:	011a      	lsls	r2, r3, #4
34008436:	4b31      	ldr	r3, [pc, #196]	@ (340084fc <RCC_PLL_IsNewConfig+0xec>)
34008438:	4413      	add	r3, r2
3400843a:	60fb      	str	r3, [r7, #12]

  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */

  /* Check for PLLCFGR1, PLLCFGR2 and PLLCFGR3 parameters updates */
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
3400843c:	697b      	ldr	r3, [r7, #20]
3400843e:	681b      	ldr	r3, [r3, #0]
34008440:	f023 430c 	bic.w	r3, r3, #2348810240	@ 0x8c000000
34008444:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
      (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
34008448:	683a      	ldr	r2, [r7, #0]
3400844a:	6851      	ldr	r1, [r2, #4]
3400844c:	683a      	ldr	r2, [r7, #0]
3400844e:	6892      	ldr	r2, [r2, #8]
34008450:	0512      	lsls	r2, r2, #20
34008452:	4311      	orrs	r1, r2
       | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)))
34008454:	683a      	ldr	r2, [r7, #0]
34008456:	6912      	ldr	r2, [r2, #16]
34008458:	0212      	lsls	r2, r2, #8
3400845a:	430a      	orrs	r2, r1
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
3400845c:	4293      	cmp	r3, r2
3400845e:	d002      	beq.n	34008466 <RCC_PLL_IsNewConfig+0x56>
  {
    ret = 1U; /* New PLL configuration */
34008460:	2301      	movs	r3, #1
34008462:	61fb      	str	r3, [r7, #28]
34008464:	e03e      	b.n	340084e4 <RCC_PLL_IsNewConfig+0xd4>
  }
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
34008466:	693b      	ldr	r3, [r7, #16]
34008468:	681b      	ldr	r3, [r3, #0]
3400846a:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
           (pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos))
3400846e:	683b      	ldr	r3, [r7, #0]
34008470:	68db      	ldr	r3, [r3, #12]
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
34008472:	429a      	cmp	r2, r3
34008474:	d002      	beq.n	3400847c <RCC_PLL_IsNewConfig+0x6c>
  {
    ret = 1U; /* New PLL configuration */
34008476:	2301      	movs	r3, #1
34008478:	61fb      	str	r3, [r7, #28]
3400847a:	e033      	b.n	340084e4 <RCC_PLL_IsNewConfig+0xd4>
  }
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
3400847c:	68fb      	ldr	r3, [r7, #12]
3400847e:	681b      	ldr	r3, [r3, #0]
34008480:	f003 527c 	and.w	r2, r3, #1056964608	@ 0x3f000000
           ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)))
34008484:	683b      	ldr	r3, [r7, #0]
34008486:	695b      	ldr	r3, [r3, #20]
34008488:	06d9      	lsls	r1, r3, #27
3400848a:	683b      	ldr	r3, [r7, #0]
3400848c:	699b      	ldr	r3, [r3, #24]
3400848e:	061b      	lsls	r3, r3, #24
34008490:	430b      	orrs	r3, r1
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
34008492:	429a      	cmp	r2, r3
34008494:	d002      	beq.n	3400849c <RCC_PLL_IsNewConfig+0x8c>
  {
    ret = 1U; /* New PLL configuration */
34008496:	2301      	movs	r3, #1
34008498:	61fb      	str	r3, [r7, #28]
3400849a:	e023      	b.n	340084e4 <RCC_PLL_IsNewConfig+0xd4>
  {
    /* Mode change detection*/
    uint32_t pllState;

    /* Get current Mode*/
    if (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3400849c:	4b18      	ldr	r3, [pc, #96]	@ (34008500 <RCC_PLL_IsNewConfig+0xf0>)
3400849e:	685a      	ldr	r2, [r3, #4]
340084a0:	f44f 7180 	mov.w	r1, #256	@ 0x100
340084a4:	687b      	ldr	r3, [r7, #4]
340084a6:	fa01 f303 	lsl.w	r3, r1, r3
340084aa:	401a      	ands	r2, r3
340084ac:	f44f 7180 	mov.w	r1, #256	@ 0x100
340084b0:	687b      	ldr	r3, [r7, #4]
340084b2:	fa01 f303 	lsl.w	r3, r1, r3
340084b6:	429a      	cmp	r2, r3
340084b8:	d102      	bne.n	340084c0 <RCC_PLL_IsNewConfig+0xb0>
    {
      pllState = RCC_PLL_ON;
340084ba:	2302      	movs	r3, #2
340084bc:	61bb      	str	r3, [r7, #24]
340084be:	e00a      	b.n	340084d6 <RCC_PLL_IsNewConfig+0xc6>
    }
    else
    {
      if ((*p_rcc_pll_cfgr1_reg & RCC_PLL1CFGR1_PLL1BYP) != 0UL)
340084c0:	697b      	ldr	r3, [r7, #20]
340084c2:	681b      	ldr	r3, [r3, #0]
340084c4:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
340084c8:	2b00      	cmp	r3, #0
340084ca:	d002      	beq.n	340084d2 <RCC_PLL_IsNewConfig+0xc2>
      {
        pllState = RCC_PLL_BYPASS;
340084cc:	2303      	movs	r3, #3
340084ce:	61bb      	str	r3, [r7, #24]
340084d0:	e001      	b.n	340084d6 <RCC_PLL_IsNewConfig+0xc6>
      }
      else
      {
        pllState = RCC_PLL_OFF;
340084d2:	2301      	movs	r3, #1
340084d4:	61bb      	str	r3, [r7, #24]
      }
    }

    /* Compare with new mode */
    if (pllState != pPLLInit->PLLState)
340084d6:	683b      	ldr	r3, [r7, #0]
340084d8:	681b      	ldr	r3, [r3, #0]
340084da:	69ba      	ldr	r2, [r7, #24]
340084dc:	429a      	cmp	r2, r3
340084de:	d001      	beq.n	340084e4 <RCC_PLL_IsNewConfig+0xd4>
    {
      ret = 1U; /* New PLL configuration */
340084e0:	2301      	movs	r3, #1
340084e2:	61fb      	str	r3, [r7, #28]
    }
  }

  return ret;
340084e4:	69fb      	ldr	r3, [r7, #28]
}
340084e6:	4618      	mov	r0, r3
340084e8:	3724      	adds	r7, #36	@ 0x24
340084ea:	46bd      	mov	sp, r7
340084ec:	f85d 7b04 	ldr.w	r7, [sp], #4
340084f0:	4770      	bx	lr
340084f2:	bf00      	nop
340084f4:	56028080 	.word	0x56028080
340084f8:	56028084 	.word	0x56028084
340084fc:	56028088 	.word	0x56028088
34008500:	56028000 	.word	0x56028000

34008504 <RCC_PLL_Source_IsReady>:
  * @brief  Check whether the PLL source is ready
  * @param  PLLSource PLL source
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_Source_IsReady(uint32_t PLLSource)
{
34008504:	b580      	push	{r7, lr}
34008506:	b084      	sub	sp, #16
34008508:	af00      	add	r7, sp, #0
3400850a:	6078      	str	r0, [r7, #4]
  uint32_t ret = 1U;
3400850c:	2301      	movs	r3, #1
3400850e:	60fb      	str	r3, [r7, #12]

  /* No assert since done in calling function */

  switch (PLLSource)
34008510:	687b      	ldr	r3, [r7, #4]
34008512:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008516:	d01b      	beq.n	34008550 <RCC_PLL_Source_IsReady+0x4c>
34008518:	687b      	ldr	r3, [r7, #4]
3400851a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400851e:	d81f      	bhi.n	34008560 <RCC_PLL_Source_IsReady+0x5c>
34008520:	687b      	ldr	r3, [r7, #4]
34008522:	2b00      	cmp	r3, #0
34008524:	d004      	beq.n	34008530 <RCC_PLL_Source_IsReady+0x2c>
34008526:	687b      	ldr	r3, [r7, #4]
34008528:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400852c:	d008      	beq.n	34008540 <RCC_PLL_Source_IsReady+0x3c>
        ret = 0U;
      }
      break;
    case RCC_PLLSOURCE_PIN:
    default:
      break;
3400852e:	e017      	b.n	34008560 <RCC_PLL_Source_IsReady+0x5c>
      if (LL_RCC_HSI_IsReady() == 0U)
34008530:	f7fe f8b6 	bl	340066a0 <LL_RCC_HSI_IsReady>
34008534:	4603      	mov	r3, r0
34008536:	2b00      	cmp	r3, #0
34008538:	d114      	bne.n	34008564 <RCC_PLL_Source_IsReady+0x60>
        ret = 0U;
3400853a:	2300      	movs	r3, #0
3400853c:	60fb      	str	r3, [r7, #12]
      break;
3400853e:	e011      	b.n	34008564 <RCC_PLL_Source_IsReady+0x60>
      if (LL_RCC_MSI_IsReady() == 0U)
34008540:	f7fe f916 	bl	34006770 <LL_RCC_MSI_IsReady>
34008544:	4603      	mov	r3, r0
34008546:	2b00      	cmp	r3, #0
34008548:	d10e      	bne.n	34008568 <RCC_PLL_Source_IsReady+0x64>
        ret = 0U;
3400854a:	2300      	movs	r3, #0
3400854c:	60fb      	str	r3, [r7, #12]
      break;
3400854e:	e00b      	b.n	34008568 <RCC_PLL_Source_IsReady+0x64>
      if (LL_RCC_HSE_IsReady() == 0U)
34008550:	f7fe f876 	bl	34006640 <LL_RCC_HSE_IsReady>
34008554:	4603      	mov	r3, r0
34008556:	2b00      	cmp	r3, #0
34008558:	d108      	bne.n	3400856c <RCC_PLL_Source_IsReady+0x68>
        ret = 0U;
3400855a:	2300      	movs	r3, #0
3400855c:	60fb      	str	r3, [r7, #12]
      break;
3400855e:	e005      	b.n	3400856c <RCC_PLL_Source_IsReady+0x68>
      break;
34008560:	bf00      	nop
34008562:	e004      	b.n	3400856e <RCC_PLL_Source_IsReady+0x6a>
      break;
34008564:	bf00      	nop
34008566:	e002      	b.n	3400856e <RCC_PLL_Source_IsReady+0x6a>
      break;
34008568:	bf00      	nop
3400856a:	e000      	b.n	3400856e <RCC_PLL_Source_IsReady+0x6a>
      break;
3400856c:	bf00      	nop
  }

  return ret;
3400856e:	68fb      	ldr	r3, [r7, #12]
}
34008570:	4618      	mov	r0, r3
34008572:	3710      	adds	r7, #16
34008574:	46bd      	mov	sp, r7
34008576:	bd80      	pop	{r7, pc}

34008578 <RCC_IC_CheckPLLSources>:
  * @param  PLLSource1 First PLL source
  * @param  PLLSource2 Second PLL source
  * @retval 1 if success else 0
  */
static uint32_t RCC_IC_CheckPLLSources(uint32_t PLLSource1, uint32_t PLLSource2)
{
34008578:	b580      	push	{r7, lr}
3400857a:	b084      	sub	sp, #16
3400857c:	af00      	add	r7, sp, #0
3400857e:	6078      	str	r0, [r7, #4]
34008580:	6039      	str	r1, [r7, #0]
  uint32_t ret = 1U;
34008582:	2301      	movs	r3, #1
34008584:	60fb      	str	r3, [r7, #12]

  /* No assert since done in calling function */

  /* Check PLLSource1 clock source */
  switch (PLLSource1)
34008586:	687b      	ldr	r3, [r7, #4]
34008588:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400858c:	d03a      	beq.n	34008604 <RCC_IC_CheckPLLSources+0x8c>
3400858e:	687b      	ldr	r3, [r7, #4]
34008590:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008594:	d843      	bhi.n	3400861e <RCC_IC_CheckPLLSources+0xa6>
34008596:	687b      	ldr	r3, [r7, #4]
34008598:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400859c:	d025      	beq.n	340085ea <RCC_IC_CheckPLLSources+0x72>
3400859e:	687b      	ldr	r3, [r7, #4]
340085a0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340085a4:	d83b      	bhi.n	3400861e <RCC_IC_CheckPLLSources+0xa6>
340085a6:	687b      	ldr	r3, [r7, #4]
340085a8:	2b00      	cmp	r3, #0
340085aa:	d004      	beq.n	340085b6 <RCC_IC_CheckPLLSources+0x3e>
340085ac:	687b      	ldr	r3, [r7, #4]
340085ae:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340085b2:	d00d      	beq.n	340085d0 <RCC_IC_CheckPLLSources+0x58>
340085b4:	e033      	b.n	3400861e <RCC_IC_CheckPLLSources+0xa6>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
340085b6:	f7fe f98d 	bl	340068d4 <LL_RCC_PLL1_IsReady>
340085ba:	4603      	mov	r3, r0
340085bc:	2b00      	cmp	r3, #0
340085be:	d131      	bne.n	34008624 <RCC_IC_CheckPLLSources+0xac>
      {
        if (LL_RCC_PLL1_IsEnabledBypass() == 0U)
340085c0:	f7fe f99c 	bl	340068fc <LL_RCC_PLL1_IsEnabledBypass>
340085c4:	4603      	mov	r3, r0
340085c6:	2b00      	cmp	r3, #0
340085c8:	d12c      	bne.n	34008624 <RCC_IC_CheckPLLSources+0xac>
        {
          ret = 0U;
340085ca:	2300      	movs	r3, #0
340085cc:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
340085ce:	e029      	b.n	34008624 <RCC_IC_CheckPLLSources+0xac>
    case LL_RCC_ICCLKSOURCE_PLL2:
      if (LL_RCC_PLL2_IsReady() == 0U)
340085d0:	f7fe f9b6 	bl	34006940 <LL_RCC_PLL2_IsReady>
340085d4:	4603      	mov	r3, r0
340085d6:	2b00      	cmp	r3, #0
340085d8:	d126      	bne.n	34008628 <RCC_IC_CheckPLLSources+0xb0>
      {
        if (LL_RCC_PLL2_IsEnabledBypass() == 0U)
340085da:	f7fe f9c5 	bl	34006968 <LL_RCC_PLL2_IsEnabledBypass>
340085de:	4603      	mov	r3, r0
340085e0:	2b00      	cmp	r3, #0
340085e2:	d121      	bne.n	34008628 <RCC_IC_CheckPLLSources+0xb0>
        {
          ret = 0U;
340085e4:	2300      	movs	r3, #0
340085e6:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
340085e8:	e01e      	b.n	34008628 <RCC_IC_CheckPLLSources+0xb0>
    case LL_RCC_ICCLKSOURCE_PLL3:
      if (LL_RCC_PLL3_IsReady() == 0U)
340085ea:	f7fe f9df 	bl	340069ac <LL_RCC_PLL3_IsReady>
340085ee:	4603      	mov	r3, r0
340085f0:	2b00      	cmp	r3, #0
340085f2:	d11b      	bne.n	3400862c <RCC_IC_CheckPLLSources+0xb4>
      {
        if (LL_RCC_PLL3_IsEnabledBypass() == 0U)
340085f4:	f7fe f9ee 	bl	340069d4 <LL_RCC_PLL3_IsEnabledBypass>
340085f8:	4603      	mov	r3, r0
340085fa:	2b00      	cmp	r3, #0
340085fc:	d116      	bne.n	3400862c <RCC_IC_CheckPLLSources+0xb4>
        {
          ret = 0U;
340085fe:	2300      	movs	r3, #0
34008600:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
34008602:	e013      	b.n	3400862c <RCC_IC_CheckPLLSources+0xb4>
    case LL_RCC_ICCLKSOURCE_PLL4:
      if (LL_RCC_PLL4_IsReady() == 0U)
34008604:	f7fe fa08 	bl	34006a18 <LL_RCC_PLL4_IsReady>
34008608:	4603      	mov	r3, r0
3400860a:	2b00      	cmp	r3, #0
3400860c:	d110      	bne.n	34008630 <RCC_IC_CheckPLLSources+0xb8>
      {
        if (LL_RCC_PLL4_IsEnabledBypass() == 0U)
3400860e:	f7fe fa17 	bl	34006a40 <LL_RCC_PLL4_IsEnabledBypass>
34008612:	4603      	mov	r3, r0
34008614:	2b00      	cmp	r3, #0
34008616:	d10b      	bne.n	34008630 <RCC_IC_CheckPLLSources+0xb8>
        {
          ret = 0U;
34008618:	2300      	movs	r3, #0
3400861a:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3400861c:	e008      	b.n	34008630 <RCC_IC_CheckPLLSources+0xb8>
    default:
      /* Unexpected */
      ret = 0U;
3400861e:	2300      	movs	r3, #0
34008620:	60fb      	str	r3, [r7, #12]
      break;
34008622:	e006      	b.n	34008632 <RCC_IC_CheckPLLSources+0xba>
      break;
34008624:	bf00      	nop
34008626:	e004      	b.n	34008632 <RCC_IC_CheckPLLSources+0xba>
      break;
34008628:	bf00      	nop
3400862a:	e002      	b.n	34008632 <RCC_IC_CheckPLLSources+0xba>
      break;
3400862c:	bf00      	nop
3400862e:	e000      	b.n	34008632 <RCC_IC_CheckPLLSources+0xba>
      break;
34008630:	bf00      	nop
  }

  /* Check PLLSource2 clock source */
  switch (PLLSource2)
34008632:	683b      	ldr	r3, [r7, #0]
34008634:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008638:	d03a      	beq.n	340086b0 <RCC_IC_CheckPLLSources+0x138>
3400863a:	683b      	ldr	r3, [r7, #0]
3400863c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008640:	d843      	bhi.n	340086ca <RCC_IC_CheckPLLSources+0x152>
34008642:	683b      	ldr	r3, [r7, #0]
34008644:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008648:	d025      	beq.n	34008696 <RCC_IC_CheckPLLSources+0x11e>
3400864a:	683b      	ldr	r3, [r7, #0]
3400864c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008650:	d83b      	bhi.n	340086ca <RCC_IC_CheckPLLSources+0x152>
34008652:	683b      	ldr	r3, [r7, #0]
34008654:	2b00      	cmp	r3, #0
34008656:	d004      	beq.n	34008662 <RCC_IC_CheckPLLSources+0xea>
34008658:	683b      	ldr	r3, [r7, #0]
3400865a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400865e:	d00d      	beq.n	3400867c <RCC_IC_CheckPLLSources+0x104>
34008660:	e033      	b.n	340086ca <RCC_IC_CheckPLLSources+0x152>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
34008662:	f7fe f937 	bl	340068d4 <LL_RCC_PLL1_IsReady>
34008666:	4603      	mov	r3, r0
34008668:	2b00      	cmp	r3, #0
3400866a:	d131      	bne.n	340086d0 <RCC_IC_CheckPLLSources+0x158>
      {
        if (LL_RCC_PLL1_IsEnabledBypass() == 0U)
3400866c:	f7fe f946 	bl	340068fc <LL_RCC_PLL1_IsEnabledBypass>
34008670:	4603      	mov	r3, r0
34008672:	2b00      	cmp	r3, #0
34008674:	d12c      	bne.n	340086d0 <RCC_IC_CheckPLLSources+0x158>
        {
          ret = 0U;
34008676:	2300      	movs	r3, #0
34008678:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3400867a:	e029      	b.n	340086d0 <RCC_IC_CheckPLLSources+0x158>
    case LL_RCC_ICCLKSOURCE_PLL2:
      if (LL_RCC_PLL2_IsReady() == 0U)
3400867c:	f7fe f960 	bl	34006940 <LL_RCC_PLL2_IsReady>
34008680:	4603      	mov	r3, r0
34008682:	2b00      	cmp	r3, #0
34008684:	d126      	bne.n	340086d4 <RCC_IC_CheckPLLSources+0x15c>
      {
        if (LL_RCC_PLL2_IsEnabledBypass() == 0U)
34008686:	f7fe f96f 	bl	34006968 <LL_RCC_PLL2_IsEnabledBypass>
3400868a:	4603      	mov	r3, r0
3400868c:	2b00      	cmp	r3, #0
3400868e:	d121      	bne.n	340086d4 <RCC_IC_CheckPLLSources+0x15c>
        {
          ret = 0U;
34008690:	2300      	movs	r3, #0
34008692:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
34008694:	e01e      	b.n	340086d4 <RCC_IC_CheckPLLSources+0x15c>
    case LL_RCC_ICCLKSOURCE_PLL3:
      if (LL_RCC_PLL3_IsReady() == 0U)
34008696:	f7fe f989 	bl	340069ac <LL_RCC_PLL3_IsReady>
3400869a:	4603      	mov	r3, r0
3400869c:	2b00      	cmp	r3, #0
3400869e:	d11b      	bne.n	340086d8 <RCC_IC_CheckPLLSources+0x160>
      {
        if (LL_RCC_PLL3_IsEnabledBypass() == 0U)
340086a0:	f7fe f998 	bl	340069d4 <LL_RCC_PLL3_IsEnabledBypass>
340086a4:	4603      	mov	r3, r0
340086a6:	2b00      	cmp	r3, #0
340086a8:	d116      	bne.n	340086d8 <RCC_IC_CheckPLLSources+0x160>
        {
          ret = 0U;
340086aa:	2300      	movs	r3, #0
340086ac:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
340086ae:	e013      	b.n	340086d8 <RCC_IC_CheckPLLSources+0x160>
    case LL_RCC_ICCLKSOURCE_PLL4:
      if (LL_RCC_PLL4_IsReady() == 0U)
340086b0:	f7fe f9b2 	bl	34006a18 <LL_RCC_PLL4_IsReady>
340086b4:	4603      	mov	r3, r0
340086b6:	2b00      	cmp	r3, #0
340086b8:	d110      	bne.n	340086dc <RCC_IC_CheckPLLSources+0x164>
      {
        if (LL_RCC_PLL4_IsEnabledBypass() == 0U)
340086ba:	f7fe f9c1 	bl	34006a40 <LL_RCC_PLL4_IsEnabledBypass>
340086be:	4603      	mov	r3, r0
340086c0:	2b00      	cmp	r3, #0
340086c2:	d10b      	bne.n	340086dc <RCC_IC_CheckPLLSources+0x164>
        {
          ret = 0U;
340086c4:	2300      	movs	r3, #0
340086c6:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
340086c8:	e008      	b.n	340086dc <RCC_IC_CheckPLLSources+0x164>
    default:
      /* Unexpected */
      ret = 0U;
340086ca:	2300      	movs	r3, #0
340086cc:	60fb      	str	r3, [r7, #12]
      break;
340086ce:	e006      	b.n	340086de <RCC_IC_CheckPLLSources+0x166>
      break;
340086d0:	bf00      	nop
340086d2:	e004      	b.n	340086de <RCC_IC_CheckPLLSources+0x166>
      break;
340086d4:	bf00      	nop
340086d6:	e002      	b.n	340086de <RCC_IC_CheckPLLSources+0x166>
      break;
340086d8:	bf00      	nop
340086da:	e000      	b.n	340086de <RCC_IC_CheckPLLSources+0x166>
      break;
340086dc:	bf00      	nop
  }

  return ret;
340086de:	68fb      	ldr	r3, [r7, #12]
}
340086e0:	4618      	mov	r0, r3
340086e2:	3710      	adds	r7, #16
340086e4:	46bd      	mov	sp, r7
340086e6:	bd80      	pop	{r7, pc}

340086e8 <LL_RCC_HSE_SelectHSEAsDiv2Clock>:
{
340086e8:	b480      	push	{r7}
340086ea:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
340086ec:	4b05      	ldr	r3, [pc, #20]	@ (34008704 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
340086ee:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340086f0:	4a04      	ldr	r2, [pc, #16]	@ (34008704 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
340086f2:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
340086f6:	6553      	str	r3, [r2, #84]	@ 0x54
}
340086f8:	bf00      	nop
340086fa:	46bd      	mov	sp, r7
340086fc:	f85d 7b04 	ldr.w	r7, [sp], #4
34008700:	4770      	bx	lr
34008702:	bf00      	nop
34008704:	56028000 	.word	0x56028000

34008708 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>:
{
34008708:	b480      	push	{r7}
3400870a:	af00      	add	r7, sp, #0
  SET_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3400870c:	4b05      	ldr	r3, [pc, #20]	@ (34008724 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
3400870e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34008710:	4a04      	ldr	r2, [pc, #16]	@ (34008724 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
34008712:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
34008716:	6553      	str	r3, [r2, #84]	@ 0x54
}
34008718:	bf00      	nop
3400871a:	46bd      	mov	sp, r7
3400871c:	f85d 7b04 	ldr.w	r7, [sp], #4
34008720:	4770      	bx	lr
34008722:	bf00      	nop
34008724:	56028000 	.word	0x56028000

34008728 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>:
{
34008728:	b480      	push	{r7}
3400872a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL) == RCC_HSECFGR_HSEDIV2SEL) ? 1UL : 0UL);
3400872c:	4b06      	ldr	r3, [pc, #24]	@ (34008748 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0x20>)
3400872e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34008730:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34008734:	2b40      	cmp	r3, #64	@ 0x40
34008736:	d101      	bne.n	3400873c <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0x14>
34008738:	2301      	movs	r3, #1
3400873a:	e000      	b.n	3400873e <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0x16>
3400873c:	2300      	movs	r3, #0
}
3400873e:	4618      	mov	r0, r3
34008740:	46bd      	mov	sp, r7
34008742:	f85d 7b04 	ldr.w	r7, [sp], #4
34008746:	4770      	bx	lr
34008748:	56028000 	.word	0x56028000

3400874c <LL_RCC_HSE_IsReady>:
{
3400874c:	b480      	push	{r7}
3400874e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
34008750:	4b06      	ldr	r3, [pc, #24]	@ (3400876c <LL_RCC_HSE_IsReady+0x20>)
34008752:	685b      	ldr	r3, [r3, #4]
34008754:	f003 0310 	and.w	r3, r3, #16
34008758:	2b00      	cmp	r3, #0
3400875a:	d001      	beq.n	34008760 <LL_RCC_HSE_IsReady+0x14>
3400875c:	2301      	movs	r3, #1
3400875e:	e000      	b.n	34008762 <LL_RCC_HSE_IsReady+0x16>
34008760:	2300      	movs	r3, #0
}
34008762:	4618      	mov	r0, r3
34008764:	46bd      	mov	sp, r7
34008766:	f85d 7b04 	ldr.w	r7, [sp], #4
3400876a:	4770      	bx	lr
3400876c:	56028000 	.word	0x56028000

34008770 <LL_RCC_HSI_IsReady>:
{
34008770:	b480      	push	{r7}
34008772:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
34008774:	4b06      	ldr	r3, [pc, #24]	@ (34008790 <LL_RCC_HSI_IsReady+0x20>)
34008776:	685b      	ldr	r3, [r3, #4]
34008778:	f003 0308 	and.w	r3, r3, #8
3400877c:	2b00      	cmp	r3, #0
3400877e:	d001      	beq.n	34008784 <LL_RCC_HSI_IsReady+0x14>
34008780:	2301      	movs	r3, #1
34008782:	e000      	b.n	34008786 <LL_RCC_HSI_IsReady+0x16>
34008784:	2300      	movs	r3, #0
}
34008786:	4618      	mov	r0, r3
34008788:	46bd      	mov	sp, r7
3400878a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400878e:	4770      	bx	lr
34008790:	56028000 	.word	0x56028000

34008794 <LL_RCC_HSI_GetDivider>:
{
34008794:	b480      	push	{r7}
34008796:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
34008798:	4b04      	ldr	r3, [pc, #16]	@ (340087ac <LL_RCC_HSI_GetDivider+0x18>)
3400879a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400879c:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
340087a0:	4618      	mov	r0, r3
340087a2:	46bd      	mov	sp, r7
340087a4:	f85d 7b04 	ldr.w	r7, [sp], #4
340087a8:	4770      	bx	lr
340087aa:	bf00      	nop
340087ac:	56028000 	.word	0x56028000

340087b0 <LL_RCC_MSI_IsReady>:
{
340087b0:	b480      	push	{r7}
340087b2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
340087b4:	4b06      	ldr	r3, [pc, #24]	@ (340087d0 <LL_RCC_MSI_IsReady+0x20>)
340087b6:	685b      	ldr	r3, [r3, #4]
340087b8:	f003 0304 	and.w	r3, r3, #4
340087bc:	2b00      	cmp	r3, #0
340087be:	d001      	beq.n	340087c4 <LL_RCC_MSI_IsReady+0x14>
340087c0:	2301      	movs	r3, #1
340087c2:	e000      	b.n	340087c6 <LL_RCC_MSI_IsReady+0x16>
340087c4:	2300      	movs	r3, #0
}
340087c6:	4618      	mov	r0, r3
340087c8:	46bd      	mov	sp, r7
340087ca:	f85d 7b04 	ldr.w	r7, [sp], #4
340087ce:	4770      	bx	lr
340087d0:	56028000 	.word	0x56028000

340087d4 <LL_RCC_MSI_GetFrequency>:
{
340087d4:	b480      	push	{r7}
340087d6:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
340087d8:	4b04      	ldr	r3, [pc, #16]	@ (340087ec <LL_RCC_MSI_GetFrequency+0x18>)
340087da:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340087dc:	f403 7300 	and.w	r3, r3, #512	@ 0x200
}
340087e0:	4618      	mov	r0, r3
340087e2:	46bd      	mov	sp, r7
340087e4:	f85d 7b04 	ldr.w	r7, [sp], #4
340087e8:	4770      	bx	lr
340087ea:	bf00      	nop
340087ec:	56028000 	.word	0x56028000

340087f0 <LL_RCC_LSE_IsReady>:
{
340087f0:	b480      	push	{r7}
340087f2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
340087f4:	4b06      	ldr	r3, [pc, #24]	@ (34008810 <LL_RCC_LSE_IsReady+0x20>)
340087f6:	685b      	ldr	r3, [r3, #4]
340087f8:	f003 0302 	and.w	r3, r3, #2
340087fc:	2b00      	cmp	r3, #0
340087fe:	d001      	beq.n	34008804 <LL_RCC_LSE_IsReady+0x14>
34008800:	2301      	movs	r3, #1
34008802:	e000      	b.n	34008806 <LL_RCC_LSE_IsReady+0x16>
34008804:	2300      	movs	r3, #0
}
34008806:	4618      	mov	r0, r3
34008808:	46bd      	mov	sp, r7
3400880a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400880e:	4770      	bx	lr
34008810:	56028000 	.word	0x56028000

34008814 <LL_RCC_LSI_IsReady>:
{
34008814:	b480      	push	{r7}
34008816:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
34008818:	4b04      	ldr	r3, [pc, #16]	@ (3400882c <LL_RCC_LSI_IsReady+0x18>)
3400881a:	685b      	ldr	r3, [r3, #4]
3400881c:	f003 0301 	and.w	r3, r3, #1
}
34008820:	4618      	mov	r0, r3
34008822:	46bd      	mov	sp, r7
34008824:	f85d 7b04 	ldr.w	r7, [sp], #4
34008828:	4770      	bx	lr
3400882a:	bf00      	nop
3400882c:	56028000 	.word	0x56028000

34008830 <LL_RCC_GetAHBPrescaler>:
{
34008830:	b480      	push	{r7}
34008832:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_HPRE));
34008834:	4b04      	ldr	r3, [pc, #16]	@ (34008848 <LL_RCC_GetAHBPrescaler+0x18>)
34008836:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34008838:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
}
3400883c:	4618      	mov	r0, r3
3400883e:	46bd      	mov	sp, r7
34008840:	f85d 7b04 	ldr.w	r7, [sp], #4
34008844:	4770      	bx	lr
34008846:	bf00      	nop
34008848:	56028000 	.word	0x56028000

3400884c <LL_RCC_GetAPB1Prescaler>:
{
3400884c:	b480      	push	{r7}
3400884e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
34008850:	4b04      	ldr	r3, [pc, #16]	@ (34008864 <LL_RCC_GetAPB1Prescaler+0x18>)
34008852:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34008854:	f003 0307 	and.w	r3, r3, #7
}
34008858:	4618      	mov	r0, r3
3400885a:	46bd      	mov	sp, r7
3400885c:	f85d 7b04 	ldr.w	r7, [sp], #4
34008860:	4770      	bx	lr
34008862:	bf00      	nop
34008864:	56028000 	.word	0x56028000

34008868 <LL_RCC_GetAPB2Prescaler>:
{
34008868:	b480      	push	{r7}
3400886a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3400886c:	4b04      	ldr	r3, [pc, #16]	@ (34008880 <LL_RCC_GetAPB2Prescaler+0x18>)
3400886e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34008870:	f003 0370 	and.w	r3, r3, #112	@ 0x70
}
34008874:	4618      	mov	r0, r3
34008876:	46bd      	mov	sp, r7
34008878:	f85d 7b04 	ldr.w	r7, [sp], #4
3400887c:	4770      	bx	lr
3400887e:	bf00      	nop
34008880:	56028000 	.word	0x56028000

34008884 <LL_RCC_GetAPB4Prescaler>:
{
34008884:	b480      	push	{r7}
34008886:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
34008888:	4b04      	ldr	r3, [pc, #16]	@ (3400889c <LL_RCC_GetAPB4Prescaler+0x18>)
3400888a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400888c:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
}
34008890:	4618      	mov	r0, r3
34008892:	46bd      	mov	sp, r7
34008894:	f85d 7b04 	ldr.w	r7, [sp], #4
34008898:	4770      	bx	lr
3400889a:	bf00      	nop
3400889c:	56028000 	.word	0x56028000

340088a0 <LL_RCC_GetAPB5Prescaler>:
{
340088a0:	b480      	push	{r7}
340088a2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE5));
340088a4:	4b04      	ldr	r3, [pc, #16]	@ (340088b8 <LL_RCC_GetAPB5Prescaler+0x18>)
340088a6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340088a8:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
}
340088ac:	4618      	mov	r0, r3
340088ae:	46bd      	mov	sp, r7
340088b0:	f85d 7b04 	ldr.w	r7, [sp], #4
340088b4:	4770      	bx	lr
340088b6:	bf00      	nop
340088b8:	56028000 	.word	0x56028000

340088bc <LL_RCC_SetClockSource>:
{
340088bc:	b480      	push	{r7}
340088be:	b085      	sub	sp, #20
340088c0:	af00      	add	r7, sp, #0
340088c2:	6078      	str	r0, [r7, #4]
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
340088c4:	687b      	ldr	r3, [r7, #4]
340088c6:	b2da      	uxtb	r2, r3
340088c8:	4b10      	ldr	r3, [pc, #64]	@ (3400890c <LL_RCC_SetClockSource+0x50>)
340088ca:	4413      	add	r3, r2
340088cc:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(*pReg, LL_CLKSOURCE_MASK(ClkSource), LL_CLKSOURCE_CONFIG(ClkSource));
340088ce:	68fb      	ldr	r3, [r7, #12]
340088d0:	681a      	ldr	r2, [r3, #0]
340088d2:	687b      	ldr	r3, [r7, #4]
340088d4:	0e19      	lsrs	r1, r3, #24
340088d6:	687b      	ldr	r3, [r7, #4]
340088d8:	0a1b      	lsrs	r3, r3, #8
340088da:	f003 031f 	and.w	r3, r3, #31
340088de:	fa01 f303 	lsl.w	r3, r1, r3
340088e2:	43db      	mvns	r3, r3
340088e4:	401a      	ands	r2, r3
340088e6:	687b      	ldr	r3, [r7, #4]
340088e8:	0c1b      	lsrs	r3, r3, #16
340088ea:	b2d9      	uxtb	r1, r3
340088ec:	687b      	ldr	r3, [r7, #4]
340088ee:	0a1b      	lsrs	r3, r3, #8
340088f0:	f003 031f 	and.w	r3, r3, #31
340088f4:	fa01 f303 	lsl.w	r3, r1, r3
340088f8:	431a      	orrs	r2, r3
340088fa:	68fb      	ldr	r3, [r7, #12]
340088fc:	601a      	str	r2, [r3, #0]
}
340088fe:	bf00      	nop
34008900:	3714      	adds	r7, #20
34008902:	46bd      	mov	sp, r7
34008904:	f85d 7b04 	ldr.w	r7, [sp], #4
34008908:	4770      	bx	lr
3400890a:	bf00      	nop
3400890c:	56028144 	.word	0x56028144

34008910 <LL_RCC_GetADCPrescaler>:
{
34008910:	b480      	push	{r7}
34008912:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADCPRE) >> RCC_CCIPR1_ADCPRE_Pos);
34008914:	4b04      	ldr	r3, [pc, #16]	@ (34008928 <LL_RCC_GetADCPrescaler+0x18>)
34008916:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400891a:	0a1b      	lsrs	r3, r3, #8
3400891c:	b2db      	uxtb	r3, r3
}
3400891e:	4618      	mov	r0, r3
34008920:	46bd      	mov	sp, r7
34008922:	f85d 7b04 	ldr.w	r7, [sp], #4
34008926:	4770      	bx	lr
34008928:	56028000 	.word	0x56028000

3400892c <LL_RCC_SetADFClockSource>:
{
3400892c:	b480      	push	{r7}
3400892e:	b083      	sub	sp, #12
34008930:	af00      	add	r7, sp, #0
34008932:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL, ClkSource);
34008934:	4b07      	ldr	r3, [pc, #28]	@ (34008954 <LL_RCC_SetADFClockSource+0x28>)
34008936:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400893a:	f023 0207 	bic.w	r2, r3, #7
3400893e:	4905      	ldr	r1, [pc, #20]	@ (34008954 <LL_RCC_SetADFClockSource+0x28>)
34008940:	687b      	ldr	r3, [r7, #4]
34008942:	4313      	orrs	r3, r2
34008944:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
34008948:	bf00      	nop
3400894a:	370c      	adds	r7, #12
3400894c:	46bd      	mov	sp, r7
3400894e:	f85d 7b04 	ldr.w	r7, [sp], #4
34008952:	4770      	bx	lr
34008954:	56028000 	.word	0x56028000

34008958 <LL_RCC_SetCLKPClockSource>:
{
34008958:	b480      	push	{r7}
3400895a:	b083      	sub	sp, #12
3400895c:	af00      	add	r7, sp, #0
3400895e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PERSEL, ClkSource);
34008960:	4b07      	ldr	r3, [pc, #28]	@ (34008980 <LL_RCC_SetCLKPClockSource+0x28>)
34008962:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34008966:	f023 0207 	bic.w	r2, r3, #7
3400896a:	4905      	ldr	r1, [pc, #20]	@ (34008980 <LL_RCC_SetCLKPClockSource+0x28>)
3400896c:	687b      	ldr	r3, [r7, #4]
3400896e:	4313      	orrs	r3, r2
34008970:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
34008974:	bf00      	nop
34008976:	370c      	adds	r7, #12
34008978:	46bd      	mov	sp, r7
3400897a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400897e:	4770      	bx	lr
34008980:	56028000 	.word	0x56028000

34008984 <LL_RCC_SetDCMIPPClockSource>:
{
34008984:	b480      	push	{r7}
34008986:	b083      	sub	sp, #12
34008988:	af00      	add	r7, sp, #0
3400898a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL, ClkSource);
3400898c:	4b07      	ldr	r3, [pc, #28]	@ (340089ac <LL_RCC_SetDCMIPPClockSource+0x28>)
3400898e:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34008992:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
34008996:	4905      	ldr	r1, [pc, #20]	@ (340089ac <LL_RCC_SetDCMIPPClockSource+0x28>)
34008998:	687b      	ldr	r3, [r7, #4]
3400899a:	4313      	orrs	r3, r2
3400899c:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
340089a0:	bf00      	nop
340089a2:	370c      	adds	r7, #12
340089a4:	46bd      	mov	sp, r7
340089a6:	f85d 7b04 	ldr.w	r7, [sp], #4
340089aa:	4770      	bx	lr
340089ac:	56028000 	.word	0x56028000

340089b0 <LL_RCC_SetETHClockSource>:
{
340089b0:	b480      	push	{r7}
340089b2:	b083      	sub	sp, #12
340089b4:	af00      	add	r7, sp, #0
340089b6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL, ClkSource);
340089b8:	4b07      	ldr	r3, [pc, #28]	@ (340089d8 <LL_RCC_SetETHClockSource+0x28>)
340089ba:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
340089be:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
340089c2:	4905      	ldr	r1, [pc, #20]	@ (340089d8 <LL_RCC_SetETHClockSource+0x28>)
340089c4:	687b      	ldr	r3, [r7, #4]
340089c6:	4313      	orrs	r3, r2
340089c8:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
340089cc:	bf00      	nop
340089ce:	370c      	adds	r7, #12
340089d0:	46bd      	mov	sp, r7
340089d2:	f85d 7b04 	ldr.w	r7, [sp], #4
340089d6:	4770      	bx	lr
340089d8:	56028000 	.word	0x56028000

340089dc <LL_RCC_SetETHPHYInterface>:
{
340089dc:	b480      	push	{r7}
340089de:	b083      	sub	sp, #12
340089e0:	af00      	add	r7, sp, #0
340089e2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1SEL, Interface);
340089e4:	4b07      	ldr	r3, [pc, #28]	@ (34008a04 <LL_RCC_SetETHPHYInterface+0x28>)
340089e6:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
340089ea:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
340089ee:	4905      	ldr	r1, [pc, #20]	@ (34008a04 <LL_RCC_SetETHPHYInterface+0x28>)
340089f0:	687b      	ldr	r3, [r7, #4]
340089f2:	4313      	orrs	r3, r2
340089f4:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
340089f8:	bf00      	nop
340089fa:	370c      	adds	r7, #12
340089fc:	46bd      	mov	sp, r7
340089fe:	f85d 7b04 	ldr.w	r7, [sp], #4
34008a02:	4770      	bx	lr
34008a04:	56028000 	.word	0x56028000

34008a08 <LL_RCC_GetETH1PTPDivider>:
{
34008a08:	b480      	push	{r7}
34008a0a:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPDIV));
34008a0c:	4b04      	ldr	r3, [pc, #16]	@ (34008a20 <LL_RCC_GetETH1PTPDivider+0x18>)
34008a0e:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34008a12:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
}
34008a16:	4618      	mov	r0, r3
34008a18:	46bd      	mov	sp, r7
34008a1a:	f85d 7b04 	ldr.w	r7, [sp], #4
34008a1e:	4770      	bx	lr
34008a20:	56028000 	.word	0x56028000

34008a24 <LL_RCC_SetETHREFRXClockSource>:
{
34008a24:	b480      	push	{r7}
34008a26:	b083      	sub	sp, #12
34008a28:	af00      	add	r7, sp, #0
34008a2a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1REFCLKSEL, ClkSource);
34008a2c:	4b07      	ldr	r3, [pc, #28]	@ (34008a4c <LL_RCC_SetETHREFRXClockSource+0x28>)
34008a2e:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34008a32:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
34008a36:	4905      	ldr	r1, [pc, #20]	@ (34008a4c <LL_RCC_SetETHREFRXClockSource+0x28>)
34008a38:	687b      	ldr	r3, [r7, #4]
34008a3a:	4313      	orrs	r3, r2
34008a3c:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
34008a40:	bf00      	nop
34008a42:	370c      	adds	r7, #12
34008a44:	46bd      	mov	sp, r7
34008a46:	f85d 7b04 	ldr.w	r7, [sp], #4
34008a4a:	4770      	bx	lr
34008a4c:	56028000 	.word	0x56028000

34008a50 <LL_RCC_SetETHREFTXClockSource>:
{
34008a50:	b480      	push	{r7}
34008a52:	b083      	sub	sp, #12
34008a54:	af00      	add	r7, sp, #0
34008a56:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1GTXCLKSEL, ClkSource);
34008a58:	4b07      	ldr	r3, [pc, #28]	@ (34008a78 <LL_RCC_SetETHREFTXClockSource+0x28>)
34008a5a:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34008a5e:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34008a62:	4905      	ldr	r1, [pc, #20]	@ (34008a78 <LL_RCC_SetETHREFTXClockSource+0x28>)
34008a64:	687b      	ldr	r3, [r7, #4]
34008a66:	4313      	orrs	r3, r2
34008a68:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
34008a6c:	bf00      	nop
34008a6e:	370c      	adds	r7, #12
34008a70:	46bd      	mov	sp, r7
34008a72:	f85d 7b04 	ldr.w	r7, [sp], #4
34008a76:	4770      	bx	lr
34008a78:	56028000 	.word	0x56028000

34008a7c <LL_RCC_SetFDCANClockSource>:
{
34008a7c:	b480      	push	{r7}
34008a7e:	b083      	sub	sp, #12
34008a80:	af00      	add	r7, sp, #0
34008a82:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL, ClkSource);
34008a84:	4b07      	ldr	r3, [pc, #28]	@ (34008aa4 <LL_RCC_SetFDCANClockSource+0x28>)
34008a86:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34008a8a:	f023 0203 	bic.w	r2, r3, #3
34008a8e:	4905      	ldr	r1, [pc, #20]	@ (34008aa4 <LL_RCC_SetFDCANClockSource+0x28>)
34008a90:	687b      	ldr	r3, [r7, #4]
34008a92:	4313      	orrs	r3, r2
34008a94:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
34008a98:	bf00      	nop
34008a9a:	370c      	adds	r7, #12
34008a9c:	46bd      	mov	sp, r7
34008a9e:	f85d 7b04 	ldr.w	r7, [sp], #4
34008aa2:	4770      	bx	lr
34008aa4:	56028000 	.word	0x56028000

34008aa8 <LL_RCC_SetFMCClockSource>:
{
34008aa8:	b480      	push	{r7}
34008aaa:	b083      	sub	sp, #12
34008aac:	af00      	add	r7, sp, #0
34008aae:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FMCSEL, ClkSource);
34008ab0:	4b07      	ldr	r3, [pc, #28]	@ (34008ad0 <LL_RCC_SetFMCClockSource+0x28>)
34008ab2:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34008ab6:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
34008aba:	4905      	ldr	r1, [pc, #20]	@ (34008ad0 <LL_RCC_SetFMCClockSource+0x28>)
34008abc:	687b      	ldr	r3, [r7, #4]
34008abe:	4313      	orrs	r3, r2
34008ac0:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
34008ac4:	bf00      	nop
34008ac6:	370c      	adds	r7, #12
34008ac8:	46bd      	mov	sp, r7
34008aca:	f85d 7b04 	ldr.w	r7, [sp], #4
34008ace:	4770      	bx	lr
34008ad0:	56028000 	.word	0x56028000

34008ad4 <LL_RCC_SetI2CClockSource>:
{
34008ad4:	b580      	push	{r7, lr}
34008ad6:	b082      	sub	sp, #8
34008ad8:	af00      	add	r7, sp, #0
34008ada:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34008adc:	6878      	ldr	r0, [r7, #4]
34008ade:	f7ff feed 	bl	340088bc <LL_RCC_SetClockSource>
}
34008ae2:	bf00      	nop
34008ae4:	3708      	adds	r7, #8
34008ae6:	46bd      	mov	sp, r7
34008ae8:	bd80      	pop	{r7, pc}

34008aea <LL_RCC_SetI3CClockSource>:
{
34008aea:	b580      	push	{r7, lr}
34008aec:	b082      	sub	sp, #8
34008aee:	af00      	add	r7, sp, #0
34008af0:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34008af2:	6878      	ldr	r0, [r7, #4]
34008af4:	f7ff fee2 	bl	340088bc <LL_RCC_SetClockSource>
}
34008af8:	bf00      	nop
34008afa:	3708      	adds	r7, #8
34008afc:	46bd      	mov	sp, r7
34008afe:	bd80      	pop	{r7, pc}

34008b00 <LL_RCC_SetLPTIMClockSource>:
{
34008b00:	b580      	push	{r7, lr}
34008b02:	b082      	sub	sp, #8
34008b04:	af00      	add	r7, sp, #0
34008b06:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34008b08:	6878      	ldr	r0, [r7, #4]
34008b0a:	f7ff fed7 	bl	340088bc <LL_RCC_SetClockSource>
}
34008b0e:	bf00      	nop
34008b10:	3708      	adds	r7, #8
34008b12:	46bd      	mov	sp, r7
34008b14:	bd80      	pop	{r7, pc}
	...

34008b18 <LL_RCC_SetLPUARTClockSource>:
{
34008b18:	b480      	push	{r7}
34008b1a:	b083      	sub	sp, #12
34008b1c:	af00      	add	r7, sp, #0
34008b1e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL, ClkSource);
34008b20:	4b07      	ldr	r3, [pc, #28]	@ (34008b40 <LL_RCC_SetLPUARTClockSource+0x28>)
34008b22:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34008b26:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
34008b2a:	4905      	ldr	r1, [pc, #20]	@ (34008b40 <LL_RCC_SetLPUARTClockSource+0x28>)
34008b2c:	687b      	ldr	r3, [r7, #4]
34008b2e:	4313      	orrs	r3, r2
34008b30:	f8c1 3178 	str.w	r3, [r1, #376]	@ 0x178
}
34008b34:	bf00      	nop
34008b36:	370c      	adds	r7, #12
34008b38:	46bd      	mov	sp, r7
34008b3a:	f85d 7b04 	ldr.w	r7, [sp], #4
34008b3e:	4770      	bx	lr
34008b40:	56028000 	.word	0x56028000

34008b44 <LL_RCC_SetLTDCClockSource>:
{
34008b44:	b480      	push	{r7}
34008b46:	b083      	sub	sp, #12
34008b48:	af00      	add	r7, sp, #0
34008b4a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL, ClkSource);
34008b4c:	4b07      	ldr	r3, [pc, #28]	@ (34008b6c <LL_RCC_SetLTDCClockSource+0x28>)
34008b4e:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
34008b52:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
34008b56:	4905      	ldr	r1, [pc, #20]	@ (34008b6c <LL_RCC_SetLTDCClockSource+0x28>)
34008b58:	687b      	ldr	r3, [r7, #4]
34008b5a:	4313      	orrs	r3, r2
34008b5c:	f8c1 3150 	str.w	r3, [r1, #336]	@ 0x150
}
34008b60:	bf00      	nop
34008b62:	370c      	adds	r7, #12
34008b64:	46bd      	mov	sp, r7
34008b66:	f85d 7b04 	ldr.w	r7, [sp], #4
34008b6a:	4770      	bx	lr
34008b6c:	56028000 	.word	0x56028000

34008b70 <LL_RCC_SetMDFClockSource>:
{
34008b70:	b480      	push	{r7}
34008b72:	b083      	sub	sp, #12
34008b74:	af00      	add	r7, sp, #0
34008b76:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL, ClkSource);
34008b78:	4b07      	ldr	r3, [pc, #28]	@ (34008b98 <LL_RCC_SetMDFClockSource+0x28>)
34008b7a:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
34008b7e:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
34008b82:	4905      	ldr	r1, [pc, #20]	@ (34008b98 <LL_RCC_SetMDFClockSource+0x28>)
34008b84:	687b      	ldr	r3, [r7, #4]
34008b86:	4313      	orrs	r3, r2
34008b88:	f8c1 3154 	str.w	r3, [r1, #340]	@ 0x154
}
34008b8c:	bf00      	nop
34008b8e:	370c      	adds	r7, #12
34008b90:	46bd      	mov	sp, r7
34008b92:	f85d 7b04 	ldr.w	r7, [sp], #4
34008b96:	4770      	bx	lr
34008b98:	56028000 	.word	0x56028000

34008b9c <LL_RCC_SetOTGPHYClockSource>:
{
34008b9c:	b580      	push	{r7, lr}
34008b9e:	b082      	sub	sp, #8
34008ba0:	af00      	add	r7, sp, #0
34008ba2:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34008ba4:	6878      	ldr	r0, [r7, #4]
34008ba6:	f7ff fe89 	bl	340088bc <LL_RCC_SetClockSource>
}
34008baa:	bf00      	nop
34008bac:	3708      	adds	r7, #8
34008bae:	46bd      	mov	sp, r7
34008bb0:	bd80      	pop	{r7, pc}

34008bb2 <LL_RCC_SetOTGPHYCKREFClockSource>:
{
34008bb2:	b580      	push	{r7, lr}
34008bb4:	b082      	sub	sp, #8
34008bb6:	af00      	add	r7, sp, #0
34008bb8:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34008bba:	6878      	ldr	r0, [r7, #4]
34008bbc:	f7ff fe7e 	bl	340088bc <LL_RCC_SetClockSource>
}
34008bc0:	bf00      	nop
34008bc2:	3708      	adds	r7, #8
34008bc4:	46bd      	mov	sp, r7
34008bc6:	bd80      	pop	{r7, pc}

34008bc8 <LL_RCC_SetPSSIClockSource>:
{
34008bc8:	b480      	push	{r7}
34008bca:	b083      	sub	sp, #12
34008bcc:	af00      	add	r7, sp, #0
34008bce:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PSSISEL, ClkSource);
34008bd0:	4b07      	ldr	r3, [pc, #28]	@ (34008bf0 <LL_RCC_SetPSSIClockSource+0x28>)
34008bd2:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34008bd6:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
34008bda:	4905      	ldr	r1, [pc, #20]	@ (34008bf0 <LL_RCC_SetPSSIClockSource+0x28>)
34008bdc:	687b      	ldr	r3, [r7, #4]
34008bde:	4313      	orrs	r3, r2
34008be0:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
34008be4:	bf00      	nop
34008be6:	370c      	adds	r7, #12
34008be8:	46bd      	mov	sp, r7
34008bea:	f85d 7b04 	ldr.w	r7, [sp], #4
34008bee:	4770      	bx	lr
34008bf0:	56028000 	.word	0x56028000

34008bf4 <LL_RCC_SetSAIClockSource>:
{
34008bf4:	b580      	push	{r7, lr}
34008bf6:	b082      	sub	sp, #8
34008bf8:	af00      	add	r7, sp, #0
34008bfa:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34008bfc:	6878      	ldr	r0, [r7, #4]
34008bfe:	f7ff fe5d 	bl	340088bc <LL_RCC_SetClockSource>
}
34008c02:	bf00      	nop
34008c04:	3708      	adds	r7, #8
34008c06:	46bd      	mov	sp, r7
34008c08:	bd80      	pop	{r7, pc}

34008c0a <LL_RCC_SetSDMMCClockSource>:
{
34008c0a:	b580      	push	{r7, lr}
34008c0c:	b082      	sub	sp, #8
34008c0e:	af00      	add	r7, sp, #0
34008c10:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34008c12:	6878      	ldr	r0, [r7, #4]
34008c14:	f7ff fe52 	bl	340088bc <LL_RCC_SetClockSource>
}
34008c18:	bf00      	nop
34008c1a:	3708      	adds	r7, #8
34008c1c:	46bd      	mov	sp, r7
34008c1e:	bd80      	pop	{r7, pc}

34008c20 <LL_RCC_SetSPDIFRXClockSource>:
{
34008c20:	b480      	push	{r7}
34008c22:	b083      	sub	sp, #12
34008c24:	af00      	add	r7, sp, #0
34008c26:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL, ClkSource);
34008c28:	4b07      	ldr	r3, [pc, #28]	@ (34008c48 <LL_RCC_SetSPDIFRXClockSource+0x28>)
34008c2a:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
34008c2e:	f023 0207 	bic.w	r2, r3, #7
34008c32:	4905      	ldr	r1, [pc, #20]	@ (34008c48 <LL_RCC_SetSPDIFRXClockSource+0x28>)
34008c34:	687b      	ldr	r3, [r7, #4]
34008c36:	4313      	orrs	r3, r2
34008c38:	f8c1 3164 	str.w	r3, [r1, #356]	@ 0x164
}
34008c3c:	bf00      	nop
34008c3e:	370c      	adds	r7, #12
34008c40:	46bd      	mov	sp, r7
34008c42:	f85d 7b04 	ldr.w	r7, [sp], #4
34008c46:	4770      	bx	lr
34008c48:	56028000 	.word	0x56028000

34008c4c <LL_RCC_SetSPIClockSource>:
{
34008c4c:	b580      	push	{r7, lr}
34008c4e:	b082      	sub	sp, #8
34008c50:	af00      	add	r7, sp, #0
34008c52:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34008c54:	6878      	ldr	r0, [r7, #4]
34008c56:	f7ff fe31 	bl	340088bc <LL_RCC_SetClockSource>
}
34008c5a:	bf00      	nop
34008c5c:	3708      	adds	r7, #8
34008c5e:	46bd      	mov	sp, r7
34008c60:	bd80      	pop	{r7, pc}

34008c62 <LL_RCC_SetUSARTClockSource>:
{
34008c62:	b580      	push	{r7, lr}
34008c64:	b082      	sub	sp, #8
34008c66:	af00      	add	r7, sp, #0
34008c68:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34008c6a:	6878      	ldr	r0, [r7, #4]
34008c6c:	f7ff fe26 	bl	340088bc <LL_RCC_SetClockSource>
}
34008c70:	bf00      	nop
34008c72:	3708      	adds	r7, #8
34008c74:	46bd      	mov	sp, r7
34008c76:	bd80      	pop	{r7, pc}

34008c78 <LL_RCC_SetXSPIClockSource>:
{
34008c78:	b580      	push	{r7, lr}
34008c7a:	b082      	sub	sp, #8
34008c7c:	af00      	add	r7, sp, #0
34008c7e:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34008c80:	6878      	ldr	r0, [r7, #4]
34008c82:	f7ff fe1b 	bl	340088bc <LL_RCC_SetClockSource>
}
34008c86:	bf00      	nop
34008c88:	3708      	adds	r7, #8
34008c8a:	46bd      	mov	sp, r7
34008c8c:	bd80      	pop	{r7, pc}
	...

34008c90 <LL_RCC_GetClockSource>:
{
34008c90:	b480      	push	{r7}
34008c92:	b085      	sub	sp, #20
34008c94:	af00      	add	r7, sp, #0
34008c96:	6078      	str	r0, [r7, #4]
  const volatile uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&RCC->CCIPR1) + LL_CLKSOURCE_REG(Periph)));
34008c98:	687b      	ldr	r3, [r7, #4]
34008c9a:	b2da      	uxtb	r2, r3
34008c9c:	4b0e      	ldr	r3, [pc, #56]	@ (34008cd8 <LL_RCC_GetClockSource+0x48>)
34008c9e:	4413      	add	r3, r2
34008ca0:	60fb      	str	r3, [r7, #12]
  return (uint32_t)(Periph | (((READ_BIT(*pReg, LL_CLKSOURCE_MASK(Periph))) >> LL_CLKSOURCE_SHIFT(Periph)) << LL_RCC_CONFIG_SHIFT));
34008ca2:	68fb      	ldr	r3, [r7, #12]
34008ca4:	681a      	ldr	r2, [r3, #0]
34008ca6:	687b      	ldr	r3, [r7, #4]
34008ca8:	0e19      	lsrs	r1, r3, #24
34008caa:	687b      	ldr	r3, [r7, #4]
34008cac:	0a1b      	lsrs	r3, r3, #8
34008cae:	f003 031f 	and.w	r3, r3, #31
34008cb2:	fa01 f303 	lsl.w	r3, r1, r3
34008cb6:	401a      	ands	r2, r3
34008cb8:	687b      	ldr	r3, [r7, #4]
34008cba:	0a1b      	lsrs	r3, r3, #8
34008cbc:	f003 031f 	and.w	r3, r3, #31
34008cc0:	fa22 f303 	lsr.w	r3, r2, r3
34008cc4:	041a      	lsls	r2, r3, #16
34008cc6:	687b      	ldr	r3, [r7, #4]
34008cc8:	4313      	orrs	r3, r2
}
34008cca:	4618      	mov	r0, r3
34008ccc:	3714      	adds	r7, #20
34008cce:	46bd      	mov	sp, r7
34008cd0:	f85d 7b04 	ldr.w	r7, [sp], #4
34008cd4:	4770      	bx	lr
34008cd6:	bf00      	nop
34008cd8:	56028144 	.word	0x56028144

34008cdc <LL_RCC_GetADCClockSource>:
{
34008cdc:	b480      	push	{r7}
34008cde:	b083      	sub	sp, #12
34008ce0:	af00      	add	r7, sp, #0
34008ce2:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADC12SEL));
34008ce4:	4b05      	ldr	r3, [pc, #20]	@ (34008cfc <LL_RCC_GetADCClockSource+0x20>)
34008ce6:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34008cea:	f003 0370 	and.w	r3, r3, #112	@ 0x70
}
34008cee:	4618      	mov	r0, r3
34008cf0:	370c      	adds	r7, #12
34008cf2:	46bd      	mov	sp, r7
34008cf4:	f85d 7b04 	ldr.w	r7, [sp], #4
34008cf8:	4770      	bx	lr
34008cfa:	bf00      	nop
34008cfc:	56028000 	.word	0x56028000

34008d00 <LL_RCC_GetADFClockSource>:
{
34008d00:	b480      	push	{r7}
34008d02:	b083      	sub	sp, #12
34008d04:	af00      	add	r7, sp, #0
34008d06:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL));
34008d08:	4b05      	ldr	r3, [pc, #20]	@ (34008d20 <LL_RCC_GetADFClockSource+0x20>)
34008d0a:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34008d0e:	f003 0307 	and.w	r3, r3, #7
}
34008d12:	4618      	mov	r0, r3
34008d14:	370c      	adds	r7, #12
34008d16:	46bd      	mov	sp, r7
34008d18:	f85d 7b04 	ldr.w	r7, [sp], #4
34008d1c:	4770      	bx	lr
34008d1e:	bf00      	nop
34008d20:	56028000 	.word	0x56028000

34008d24 <LL_RCC_GetCLKPClockSource>:
{
34008d24:	b480      	push	{r7}
34008d26:	b083      	sub	sp, #12
34008d28:	af00      	add	r7, sp, #0
34008d2a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PERSEL));
34008d2c:	4b05      	ldr	r3, [pc, #20]	@ (34008d44 <LL_RCC_GetCLKPClockSource+0x20>)
34008d2e:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34008d32:	f003 0307 	and.w	r3, r3, #7
}
34008d36:	4618      	mov	r0, r3
34008d38:	370c      	adds	r7, #12
34008d3a:	46bd      	mov	sp, r7
34008d3c:	f85d 7b04 	ldr.w	r7, [sp], #4
34008d40:	4770      	bx	lr
34008d42:	bf00      	nop
34008d44:	56028000 	.word	0x56028000

34008d48 <LL_RCC_GetDCMIPPClockSource>:
{
34008d48:	b480      	push	{r7}
34008d4a:	b083      	sub	sp, #12
34008d4c:	af00      	add	r7, sp, #0
34008d4e:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL));
34008d50:	4b05      	ldr	r3, [pc, #20]	@ (34008d68 <LL_RCC_GetDCMIPPClockSource+0x20>)
34008d52:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34008d56:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
}
34008d5a:	4618      	mov	r0, r3
34008d5c:	370c      	adds	r7, #12
34008d5e:	46bd      	mov	sp, r7
34008d60:	f85d 7b04 	ldr.w	r7, [sp], #4
34008d64:	4770      	bx	lr
34008d66:	bf00      	nop
34008d68:	56028000 	.word	0x56028000

34008d6c <LL_RCC_GetETHClockSource>:
{
34008d6c:	b480      	push	{r7}
34008d6e:	b083      	sub	sp, #12
34008d70:	af00      	add	r7, sp, #0
34008d72:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL));
34008d74:	4b05      	ldr	r3, [pc, #20]	@ (34008d8c <LL_RCC_GetETHClockSource+0x20>)
34008d76:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34008d7a:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
}
34008d7e:	4618      	mov	r0, r3
34008d80:	370c      	adds	r7, #12
34008d82:	46bd      	mov	sp, r7
34008d84:	f85d 7b04 	ldr.w	r7, [sp], #4
34008d88:	4770      	bx	lr
34008d8a:	bf00      	nop
34008d8c:	56028000 	.word	0x56028000

34008d90 <LL_RCC_GetETHPTPClockSource>:
{
34008d90:	b480      	push	{r7}
34008d92:	b083      	sub	sp, #12
34008d94:	af00      	add	r7, sp, #0
34008d96:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPSEL));
34008d98:	4b05      	ldr	r3, [pc, #20]	@ (34008db0 <LL_RCC_GetETHPTPClockSource+0x20>)
34008d9a:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34008d9e:	f003 0303 	and.w	r3, r3, #3
}
34008da2:	4618      	mov	r0, r3
34008da4:	370c      	adds	r7, #12
34008da6:	46bd      	mov	sp, r7
34008da8:	f85d 7b04 	ldr.w	r7, [sp], #4
34008dac:	4770      	bx	lr
34008dae:	bf00      	nop
34008db0:	56028000 	.word	0x56028000

34008db4 <LL_RCC_GetFDCANClockSource>:
{
34008db4:	b480      	push	{r7}
34008db6:	b083      	sub	sp, #12
34008db8:	af00      	add	r7, sp, #0
34008dba:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL));
34008dbc:	4b05      	ldr	r3, [pc, #20]	@ (34008dd4 <LL_RCC_GetFDCANClockSource+0x20>)
34008dbe:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34008dc2:	f003 0303 	and.w	r3, r3, #3
}
34008dc6:	4618      	mov	r0, r3
34008dc8:	370c      	adds	r7, #12
34008dca:	46bd      	mov	sp, r7
34008dcc:	f85d 7b04 	ldr.w	r7, [sp], #4
34008dd0:	4770      	bx	lr
34008dd2:	bf00      	nop
34008dd4:	56028000 	.word	0x56028000

34008dd8 <LL_RCC_GetFMCClockSource>:
{
34008dd8:	b480      	push	{r7}
34008dda:	b083      	sub	sp, #12
34008ddc:	af00      	add	r7, sp, #0
34008dde:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FMCSEL));
34008de0:	4b05      	ldr	r3, [pc, #20]	@ (34008df8 <LL_RCC_GetFMCClockSource+0x20>)
34008de2:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34008de6:	f003 0330 	and.w	r3, r3, #48	@ 0x30
}
34008dea:	4618      	mov	r0, r3
34008dec:	370c      	adds	r7, #12
34008dee:	46bd      	mov	sp, r7
34008df0:	f85d 7b04 	ldr.w	r7, [sp], #4
34008df4:	4770      	bx	lr
34008df6:	bf00      	nop
34008df8:	56028000 	.word	0x56028000

34008dfc <LL_RCC_GetI2CClockSource>:
{
34008dfc:	b580      	push	{r7, lr}
34008dfe:	b082      	sub	sp, #8
34008e00:	af00      	add	r7, sp, #0
34008e02:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34008e04:	6878      	ldr	r0, [r7, #4]
34008e06:	f7ff ff43 	bl	34008c90 <LL_RCC_GetClockSource>
34008e0a:	4603      	mov	r3, r0
}
34008e0c:	4618      	mov	r0, r3
34008e0e:	3708      	adds	r7, #8
34008e10:	46bd      	mov	sp, r7
34008e12:	bd80      	pop	{r7, pc}

34008e14 <LL_RCC_GetI3CClockSource>:
{
34008e14:	b580      	push	{r7, lr}
34008e16:	b082      	sub	sp, #8
34008e18:	af00      	add	r7, sp, #0
34008e1a:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34008e1c:	6878      	ldr	r0, [r7, #4]
34008e1e:	f7ff ff37 	bl	34008c90 <LL_RCC_GetClockSource>
34008e22:	4603      	mov	r3, r0
}
34008e24:	4618      	mov	r0, r3
34008e26:	3708      	adds	r7, #8
34008e28:	46bd      	mov	sp, r7
34008e2a:	bd80      	pop	{r7, pc}

34008e2c <LL_RCC_GetLPTIMClockSource>:
{
34008e2c:	b580      	push	{r7, lr}
34008e2e:	b082      	sub	sp, #8
34008e30:	af00      	add	r7, sp, #0
34008e32:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34008e34:	6878      	ldr	r0, [r7, #4]
34008e36:	f7ff ff2b 	bl	34008c90 <LL_RCC_GetClockSource>
34008e3a:	4603      	mov	r3, r0
}
34008e3c:	4618      	mov	r0, r3
34008e3e:	3708      	adds	r7, #8
34008e40:	46bd      	mov	sp, r7
34008e42:	bd80      	pop	{r7, pc}

34008e44 <LL_RCC_GetLPUARTClockSource>:
{
34008e44:	b480      	push	{r7}
34008e46:	b083      	sub	sp, #12
34008e48:	af00      	add	r7, sp, #0
34008e4a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL));
34008e4c:	4b05      	ldr	r3, [pc, #20]	@ (34008e64 <LL_RCC_GetLPUARTClockSource+0x20>)
34008e4e:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34008e52:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
}
34008e56:	4618      	mov	r0, r3
34008e58:	370c      	adds	r7, #12
34008e5a:	46bd      	mov	sp, r7
34008e5c:	f85d 7b04 	ldr.w	r7, [sp], #4
34008e60:	4770      	bx	lr
34008e62:	bf00      	nop
34008e64:	56028000 	.word	0x56028000

34008e68 <LL_RCC_GetLTDCClockSource>:
{
34008e68:	b480      	push	{r7}
34008e6a:	b083      	sub	sp, #12
34008e6c:	af00      	add	r7, sp, #0
34008e6e:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL));
34008e70:	4b05      	ldr	r3, [pc, #20]	@ (34008e88 <LL_RCC_GetLTDCClockSource+0x20>)
34008e72:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
34008e76:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
}
34008e7a:	4618      	mov	r0, r3
34008e7c:	370c      	adds	r7, #12
34008e7e:	46bd      	mov	sp, r7
34008e80:	f85d 7b04 	ldr.w	r7, [sp], #4
34008e84:	4770      	bx	lr
34008e86:	bf00      	nop
34008e88:	56028000 	.word	0x56028000

34008e8c <LL_RCC_GetMDFClockSource>:
{
34008e8c:	b480      	push	{r7}
34008e8e:	b083      	sub	sp, #12
34008e90:	af00      	add	r7, sp, #0
34008e92:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL));
34008e94:	4b05      	ldr	r3, [pc, #20]	@ (34008eac <LL_RCC_GetMDFClockSource+0x20>)
34008e96:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
34008e9a:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
}
34008e9e:	4618      	mov	r0, r3
34008ea0:	370c      	adds	r7, #12
34008ea2:	46bd      	mov	sp, r7
34008ea4:	f85d 7b04 	ldr.w	r7, [sp], #4
34008ea8:	4770      	bx	lr
34008eaa:	bf00      	nop
34008eac:	56028000 	.word	0x56028000

34008eb0 <LL_RCC_GetPSSIClockSource>:
{
34008eb0:	b480      	push	{r7}
34008eb2:	b083      	sub	sp, #12
34008eb4:	af00      	add	r7, sp, #0
34008eb6:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PSSISEL));
34008eb8:	4b05      	ldr	r3, [pc, #20]	@ (34008ed0 <LL_RCC_GetPSSIClockSource+0x20>)
34008eba:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34008ebe:	f003 0330 	and.w	r3, r3, #48	@ 0x30
}
34008ec2:	4618      	mov	r0, r3
34008ec4:	370c      	adds	r7, #12
34008ec6:	46bd      	mov	sp, r7
34008ec8:	f85d 7b04 	ldr.w	r7, [sp], #4
34008ecc:	4770      	bx	lr
34008ece:	bf00      	nop
34008ed0:	56028000 	.word	0x56028000

34008ed4 <LL_RCC_GetSAIClockSource>:
{
34008ed4:	b580      	push	{r7, lr}
34008ed6:	b082      	sub	sp, #8
34008ed8:	af00      	add	r7, sp, #0
34008eda:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34008edc:	6878      	ldr	r0, [r7, #4]
34008ede:	f7ff fed7 	bl	34008c90 <LL_RCC_GetClockSource>
34008ee2:	4603      	mov	r3, r0
}
34008ee4:	4618      	mov	r0, r3
34008ee6:	3708      	adds	r7, #8
34008ee8:	46bd      	mov	sp, r7
34008eea:	bd80      	pop	{r7, pc}

34008eec <LL_RCC_GetSDMMCClockSource>:
{
34008eec:	b580      	push	{r7, lr}
34008eee:	b082      	sub	sp, #8
34008ef0:	af00      	add	r7, sp, #0
34008ef2:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34008ef4:	6878      	ldr	r0, [r7, #4]
34008ef6:	f7ff fecb 	bl	34008c90 <LL_RCC_GetClockSource>
34008efa:	4603      	mov	r3, r0
}
34008efc:	4618      	mov	r0, r3
34008efe:	3708      	adds	r7, #8
34008f00:	46bd      	mov	sp, r7
34008f02:	bd80      	pop	{r7, pc}

34008f04 <LL_RCC_GetSPDIFRXClockSource>:
{
34008f04:	b480      	push	{r7}
34008f06:	b083      	sub	sp, #12
34008f08:	af00      	add	r7, sp, #0
34008f0a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL));
34008f0c:	4b05      	ldr	r3, [pc, #20]	@ (34008f24 <LL_RCC_GetSPDIFRXClockSource+0x20>)
34008f0e:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
34008f12:	f003 0307 	and.w	r3, r3, #7
}
34008f16:	4618      	mov	r0, r3
34008f18:	370c      	adds	r7, #12
34008f1a:	46bd      	mov	sp, r7
34008f1c:	f85d 7b04 	ldr.w	r7, [sp], #4
34008f20:	4770      	bx	lr
34008f22:	bf00      	nop
34008f24:	56028000 	.word	0x56028000

34008f28 <LL_RCC_GetSPIClockSource>:
{
34008f28:	b580      	push	{r7, lr}
34008f2a:	b082      	sub	sp, #8
34008f2c:	af00      	add	r7, sp, #0
34008f2e:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34008f30:	6878      	ldr	r0, [r7, #4]
34008f32:	f7ff fead 	bl	34008c90 <LL_RCC_GetClockSource>
34008f36:	4603      	mov	r3, r0
}
34008f38:	4618      	mov	r0, r3
34008f3a:	3708      	adds	r7, #8
34008f3c:	46bd      	mov	sp, r7
34008f3e:	bd80      	pop	{r7, pc}

34008f40 <LL_RCC_GetUSARTClockSource>:
{
34008f40:	b580      	push	{r7, lr}
34008f42:	b082      	sub	sp, #8
34008f44:	af00      	add	r7, sp, #0
34008f46:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34008f48:	6878      	ldr	r0, [r7, #4]
34008f4a:	f7ff fea1 	bl	34008c90 <LL_RCC_GetClockSource>
34008f4e:	4603      	mov	r3, r0
}
34008f50:	4618      	mov	r0, r3
34008f52:	3708      	adds	r7, #8
34008f54:	46bd      	mov	sp, r7
34008f56:	bd80      	pop	{r7, pc}

34008f58 <LL_RCC_GetUARTClockSource>:
{
34008f58:	b580      	push	{r7, lr}
34008f5a:	b082      	sub	sp, #8
34008f5c:	af00      	add	r7, sp, #0
34008f5e:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34008f60:	6878      	ldr	r0, [r7, #4]
34008f62:	f7ff fe95 	bl	34008c90 <LL_RCC_GetClockSource>
34008f66:	4603      	mov	r3, r0
}
34008f68:	4618      	mov	r0, r3
34008f6a:	3708      	adds	r7, #8
34008f6c:	46bd      	mov	sp, r7
34008f6e:	bd80      	pop	{r7, pc}

34008f70 <LL_RCC_GetUSBClockSource>:
{
34008f70:	b580      	push	{r7, lr}
34008f72:	b082      	sub	sp, #8
34008f74:	af00      	add	r7, sp, #0
34008f76:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34008f78:	6878      	ldr	r0, [r7, #4]
34008f7a:	f7ff fe89 	bl	34008c90 <LL_RCC_GetClockSource>
34008f7e:	4603      	mov	r3, r0
}
34008f80:	4618      	mov	r0, r3
34008f82:	3708      	adds	r7, #8
34008f84:	46bd      	mov	sp, r7
34008f86:	bd80      	pop	{r7, pc}

34008f88 <LL_RCC_GetXSPIClockSource>:
{
34008f88:	b580      	push	{r7, lr}
34008f8a:	b082      	sub	sp, #8
34008f8c:	af00      	add	r7, sp, #0
34008f8e:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34008f90:	6878      	ldr	r0, [r7, #4]
34008f92:	f7ff fe7d 	bl	34008c90 <LL_RCC_GetClockSource>
34008f96:	4603      	mov	r3, r0
}
34008f98:	4618      	mov	r0, r3
34008f9a:	3708      	adds	r7, #8
34008f9c:	46bd      	mov	sp, r7
34008f9e:	bd80      	pop	{r7, pc}

34008fa0 <LL_RCC_SetRTCClockSource>:
{
34008fa0:	b480      	push	{r7}
34008fa2:	b083      	sub	sp, #12
34008fa4:	af00      	add	r7, sp, #0
34008fa6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCSEL, Source);
34008fa8:	4b07      	ldr	r3, [pc, #28]	@ (34008fc8 <LL_RCC_SetRTCClockSource+0x28>)
34008faa:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34008fae:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
34008fb2:	4905      	ldr	r1, [pc, #20]	@ (34008fc8 <LL_RCC_SetRTCClockSource+0x28>)
34008fb4:	687b      	ldr	r3, [r7, #4]
34008fb6:	4313      	orrs	r3, r2
34008fb8:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
34008fbc:	bf00      	nop
34008fbe:	370c      	adds	r7, #12
34008fc0:	46bd      	mov	sp, r7
34008fc2:	f85d 7b04 	ldr.w	r7, [sp], #4
34008fc6:	4770      	bx	lr
34008fc8:	56028000 	.word	0x56028000

34008fcc <LL_RCC_GetRTCClockSource>:
{
34008fcc:	b480      	push	{r7}
34008fce:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
34008fd0:	4b04      	ldr	r3, [pc, #16]	@ (34008fe4 <LL_RCC_GetRTCClockSource+0x18>)
34008fd2:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34008fd6:	f403 7340 	and.w	r3, r3, #768	@ 0x300
}
34008fda:	4618      	mov	r0, r3
34008fdc:	46bd      	mov	sp, r7
34008fde:	f85d 7b04 	ldr.w	r7, [sp], #4
34008fe2:	4770      	bx	lr
34008fe4:	56028000 	.word	0x56028000

34008fe8 <LL_RCC_SetRTC_HSEPrescaler>:
{
34008fe8:	b480      	push	{r7}
34008fea:	b083      	sub	sp, #12
34008fec:	af00      	add	r7, sp, #0
34008fee:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCPRE, Prescaler);
34008ff0:	4b07      	ldr	r3, [pc, #28]	@ (34009010 <LL_RCC_SetRTC_HSEPrescaler+0x28>)
34008ff2:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34008ff6:	f423 327c 	bic.w	r2, r3, #258048	@ 0x3f000
34008ffa:	4905      	ldr	r1, [pc, #20]	@ (34009010 <LL_RCC_SetRTC_HSEPrescaler+0x28>)
34008ffc:	687b      	ldr	r3, [r7, #4]
34008ffe:	4313      	orrs	r3, r2
34009000:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
34009004:	bf00      	nop
34009006:	370c      	adds	r7, #12
34009008:	46bd      	mov	sp, r7
3400900a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400900e:	4770      	bx	lr
34009010:	56028000 	.word	0x56028000

34009014 <LL_RCC_SetTIMPrescaler>:
{
34009014:	b480      	push	{r7}
34009016:	b083      	sub	sp, #12
34009018:	af00      	add	r7, sp, #0
3400901a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_TIMPRE, Prescaler << RCC_CFGR2_TIMPRE_Pos);
3400901c:	4b07      	ldr	r3, [pc, #28]	@ (3400903c <LL_RCC_SetTIMPrescaler+0x28>)
3400901e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34009020:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
34009024:	687b      	ldr	r3, [r7, #4]
34009026:	061b      	lsls	r3, r3, #24
34009028:	4904      	ldr	r1, [pc, #16]	@ (3400903c <LL_RCC_SetTIMPrescaler+0x28>)
3400902a:	4313      	orrs	r3, r2
3400902c:	624b      	str	r3, [r1, #36]	@ 0x24
}
3400902e:	bf00      	nop
34009030:	370c      	adds	r7, #12
34009032:	46bd      	mov	sp, r7
34009034:	f85d 7b04 	ldr.w	r7, [sp], #4
34009038:	4770      	bx	lr
3400903a:	bf00      	nop
3400903c:	56028000 	.word	0x56028000

34009040 <LL_RCC_GetTIMPrescaler>:
{
34009040:	b480      	push	{r7}
34009042:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
34009044:	4b04      	ldr	r3, [pc, #16]	@ (34009058 <LL_RCC_GetTIMPrescaler+0x18>)
34009046:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34009048:	0e1b      	lsrs	r3, r3, #24
3400904a:	f003 0303 	and.w	r3, r3, #3
}
3400904e:	4618      	mov	r0, r3
34009050:	46bd      	mov	sp, r7
34009052:	f85d 7b04 	ldr.w	r7, [sp], #4
34009056:	4770      	bx	lr
34009058:	56028000 	.word	0x56028000

3400905c <LL_RCC_PLL1_GetSource>:
{
3400905c:	b480      	push	{r7}
3400905e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
34009060:	4b04      	ldr	r3, [pc, #16]	@ (34009074 <LL_RCC_PLL1_GetSource+0x18>)
34009062:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34009066:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400906a:	4618      	mov	r0, r3
3400906c:	46bd      	mov	sp, r7
3400906e:	f85d 7b04 	ldr.w	r7, [sp], #4
34009072:	4770      	bx	lr
34009074:	56028000 	.word	0x56028000

34009078 <LL_RCC_PLL1_IsReady>:
{
34009078:	b480      	push	{r7}
3400907a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
3400907c:	4b07      	ldr	r3, [pc, #28]	@ (3400909c <LL_RCC_PLL1_IsReady+0x24>)
3400907e:	685b      	ldr	r3, [r3, #4]
34009080:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34009084:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34009088:	d101      	bne.n	3400908e <LL_RCC_PLL1_IsReady+0x16>
3400908a:	2301      	movs	r3, #1
3400908c:	e000      	b.n	34009090 <LL_RCC_PLL1_IsReady+0x18>
3400908e:	2300      	movs	r3, #0
}
34009090:	4618      	mov	r0, r3
34009092:	46bd      	mov	sp, r7
34009094:	f85d 7b04 	ldr.w	r7, [sp], #4
34009098:	4770      	bx	lr
3400909a:	bf00      	nop
3400909c:	56028000 	.word	0x56028000

340090a0 <LL_RCC_PLL1_IsEnabledBypass>:
{
340090a0:	b480      	push	{r7}
340090a2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
340090a4:	4b07      	ldr	r3, [pc, #28]	@ (340090c4 <LL_RCC_PLL1_IsEnabledBypass+0x24>)
340090a6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340090aa:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
340090ae:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
340090b2:	d101      	bne.n	340090b8 <LL_RCC_PLL1_IsEnabledBypass+0x18>
340090b4:	2301      	movs	r3, #1
340090b6:	e000      	b.n	340090ba <LL_RCC_PLL1_IsEnabledBypass+0x1a>
340090b8:	2300      	movs	r3, #0
}
340090ba:	4618      	mov	r0, r3
340090bc:	46bd      	mov	sp, r7
340090be:	f85d 7b04 	ldr.w	r7, [sp], #4
340090c2:	4770      	bx	lr
340090c4:	56028000 	.word	0x56028000

340090c8 <LL_RCC_PLL1_GetN>:
{
340090c8:	b480      	push	{r7}
340090ca:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVN) >> RCC_PLL1CFGR1_PLL1DIVN_Pos));
340090cc:	4b05      	ldr	r3, [pc, #20]	@ (340090e4 <LL_RCC_PLL1_GetN+0x1c>)
340090ce:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340090d2:	0a1b      	lsrs	r3, r3, #8
340090d4:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
340090d8:	4618      	mov	r0, r3
340090da:	46bd      	mov	sp, r7
340090dc:	f85d 7b04 	ldr.w	r7, [sp], #4
340090e0:	4770      	bx	lr
340090e2:	bf00      	nop
340090e4:	56028000 	.word	0x56028000

340090e8 <LL_RCC_PLL1_GetM>:
{
340090e8:	b480      	push	{r7}
340090ea:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVM) >> RCC_PLL1CFGR1_PLL1DIVM_Pos);
340090ec:	4b05      	ldr	r3, [pc, #20]	@ (34009104 <LL_RCC_PLL1_GetM+0x1c>)
340090ee:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340090f2:	0d1b      	lsrs	r3, r3, #20
340090f4:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
340090f8:	4618      	mov	r0, r3
340090fa:	46bd      	mov	sp, r7
340090fc:	f85d 7b04 	ldr.w	r7, [sp], #4
34009100:	4770      	bx	lr
34009102:	bf00      	nop
34009104:	56028000 	.word	0x56028000

34009108 <LL_RCC_PLL1_GetP1>:
{
34009108:	b480      	push	{r7}
3400910a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
3400910c:	4b05      	ldr	r3, [pc, #20]	@ (34009124 <LL_RCC_PLL1_GetP1+0x1c>)
3400910e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34009112:	0edb      	lsrs	r3, r3, #27
34009114:	f003 0307 	and.w	r3, r3, #7
}
34009118:	4618      	mov	r0, r3
3400911a:	46bd      	mov	sp, r7
3400911c:	f85d 7b04 	ldr.w	r7, [sp], #4
34009120:	4770      	bx	lr
34009122:	bf00      	nop
34009124:	56028000 	.word	0x56028000

34009128 <LL_RCC_PLL1_GetP2>:
{
34009128:	b480      	push	{r7}
3400912a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
3400912c:	4b05      	ldr	r3, [pc, #20]	@ (34009144 <LL_RCC_PLL1_GetP2+0x1c>)
3400912e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34009132:	0e1b      	lsrs	r3, r3, #24
34009134:	f003 0307 	and.w	r3, r3, #7
}
34009138:	4618      	mov	r0, r3
3400913a:	46bd      	mov	sp, r7
3400913c:	f85d 7b04 	ldr.w	r7, [sp], #4
34009140:	4770      	bx	lr
34009142:	bf00      	nop
34009144:	56028000 	.word	0x56028000

34009148 <LL_RCC_PLL1P_IsEnabled>:
{
34009148:	b480      	push	{r7}
3400914a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIVEN) == RCC_PLL1CFGR3_PLL1PDIVEN) ? 1UL : 0UL);
3400914c:	4b07      	ldr	r3, [pc, #28]	@ (3400916c <LL_RCC_PLL1P_IsEnabled+0x24>)
3400914e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34009152:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34009156:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3400915a:	d101      	bne.n	34009160 <LL_RCC_PLL1P_IsEnabled+0x18>
3400915c:	2301      	movs	r3, #1
3400915e:	e000      	b.n	34009162 <LL_RCC_PLL1P_IsEnabled+0x1a>
34009160:	2300      	movs	r3, #0
}
34009162:	4618      	mov	r0, r3
34009164:	46bd      	mov	sp, r7
34009166:	f85d 7b04 	ldr.w	r7, [sp], #4
3400916a:	4770      	bx	lr
3400916c:	56028000 	.word	0x56028000

34009170 <LL_RCC_PLL1_GetFRACN>:
{
34009170:	b480      	push	{r7}
34009172:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >> RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);
34009174:	4b04      	ldr	r3, [pc, #16]	@ (34009188 <LL_RCC_PLL1_GetFRACN+0x18>)
34009176:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3400917a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3400917e:	4618      	mov	r0, r3
34009180:	46bd      	mov	sp, r7
34009182:	f85d 7b04 	ldr.w	r7, [sp], #4
34009186:	4770      	bx	lr
34009188:	56028000 	.word	0x56028000

3400918c <LL_RCC_PLL2_GetSource>:
{
3400918c:	b480      	push	{r7}
3400918e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
34009190:	4b04      	ldr	r3, [pc, #16]	@ (340091a4 <LL_RCC_PLL2_GetSource+0x18>)
34009192:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34009196:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400919a:	4618      	mov	r0, r3
3400919c:	46bd      	mov	sp, r7
3400919e:	f85d 7b04 	ldr.w	r7, [sp], #4
340091a2:	4770      	bx	lr
340091a4:	56028000 	.word	0x56028000

340091a8 <LL_RCC_PLL2_IsReady>:
{
340091a8:	b480      	push	{r7}
340091aa:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
340091ac:	4b07      	ldr	r3, [pc, #28]	@ (340091cc <LL_RCC_PLL2_IsReady+0x24>)
340091ae:	685b      	ldr	r3, [r3, #4]
340091b0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
340091b4:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
340091b8:	d101      	bne.n	340091be <LL_RCC_PLL2_IsReady+0x16>
340091ba:	2301      	movs	r3, #1
340091bc:	e000      	b.n	340091c0 <LL_RCC_PLL2_IsReady+0x18>
340091be:	2300      	movs	r3, #0
}
340091c0:	4618      	mov	r0, r3
340091c2:	46bd      	mov	sp, r7
340091c4:	f85d 7b04 	ldr.w	r7, [sp], #4
340091c8:	4770      	bx	lr
340091ca:	bf00      	nop
340091cc:	56028000 	.word	0x56028000

340091d0 <LL_RCC_PLL2_IsEnabledBypass>:
{
340091d0:	b480      	push	{r7}
340091d2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
340091d4:	4b07      	ldr	r3, [pc, #28]	@ (340091f4 <LL_RCC_PLL2_IsEnabledBypass+0x24>)
340091d6:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
340091da:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
340091de:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
340091e2:	d101      	bne.n	340091e8 <LL_RCC_PLL2_IsEnabledBypass+0x18>
340091e4:	2301      	movs	r3, #1
340091e6:	e000      	b.n	340091ea <LL_RCC_PLL2_IsEnabledBypass+0x1a>
340091e8:	2300      	movs	r3, #0
}
340091ea:	4618      	mov	r0, r3
340091ec:	46bd      	mov	sp, r7
340091ee:	f85d 7b04 	ldr.w	r7, [sp], #4
340091f2:	4770      	bx	lr
340091f4:	56028000 	.word	0x56028000

340091f8 <LL_RCC_PLL2_GetN>:
{
340091f8:	b480      	push	{r7}
340091fa:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVN) >> RCC_PLL2CFGR1_PLL2DIVN_Pos));
340091fc:	4b05      	ldr	r3, [pc, #20]	@ (34009214 <LL_RCC_PLL2_GetN+0x1c>)
340091fe:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34009202:	0a1b      	lsrs	r3, r3, #8
34009204:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
34009208:	4618      	mov	r0, r3
3400920a:	46bd      	mov	sp, r7
3400920c:	f85d 7b04 	ldr.w	r7, [sp], #4
34009210:	4770      	bx	lr
34009212:	bf00      	nop
34009214:	56028000 	.word	0x56028000

34009218 <LL_RCC_PLL2_GetM>:
{
34009218:	b480      	push	{r7}
3400921a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVM) >> RCC_PLL2CFGR1_PLL2DIVM_Pos);
3400921c:	4b05      	ldr	r3, [pc, #20]	@ (34009234 <LL_RCC_PLL2_GetM+0x1c>)
3400921e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34009222:	0d1b      	lsrs	r3, r3, #20
34009224:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
34009228:	4618      	mov	r0, r3
3400922a:	46bd      	mov	sp, r7
3400922c:	f85d 7b04 	ldr.w	r7, [sp], #4
34009230:	4770      	bx	lr
34009232:	bf00      	nop
34009234:	56028000 	.word	0x56028000

34009238 <LL_RCC_PLL2_GetP1>:
{
34009238:	b480      	push	{r7}
3400923a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
3400923c:	4b05      	ldr	r3, [pc, #20]	@ (34009254 <LL_RCC_PLL2_GetP1+0x1c>)
3400923e:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34009242:	0edb      	lsrs	r3, r3, #27
34009244:	f003 0307 	and.w	r3, r3, #7
}
34009248:	4618      	mov	r0, r3
3400924a:	46bd      	mov	sp, r7
3400924c:	f85d 7b04 	ldr.w	r7, [sp], #4
34009250:	4770      	bx	lr
34009252:	bf00      	nop
34009254:	56028000 	.word	0x56028000

34009258 <LL_RCC_PLL2_GetP2>:
{
34009258:	b480      	push	{r7}
3400925a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
3400925c:	4b05      	ldr	r3, [pc, #20]	@ (34009274 <LL_RCC_PLL2_GetP2+0x1c>)
3400925e:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34009262:	0e1b      	lsrs	r3, r3, #24
34009264:	f003 0307 	and.w	r3, r3, #7
}
34009268:	4618      	mov	r0, r3
3400926a:	46bd      	mov	sp, r7
3400926c:	f85d 7b04 	ldr.w	r7, [sp], #4
34009270:	4770      	bx	lr
34009272:	bf00      	nop
34009274:	56028000 	.word	0x56028000

34009278 <LL_RCC_PLL2P_IsEnabled>:
{
34009278:	b480      	push	{r7}
3400927a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIVEN) == RCC_PLL2CFGR3_PLL2PDIVEN) ? 1UL : 0UL);
3400927c:	4b07      	ldr	r3, [pc, #28]	@ (3400929c <LL_RCC_PLL2P_IsEnabled+0x24>)
3400927e:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34009282:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34009286:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3400928a:	d101      	bne.n	34009290 <LL_RCC_PLL2P_IsEnabled+0x18>
3400928c:	2301      	movs	r3, #1
3400928e:	e000      	b.n	34009292 <LL_RCC_PLL2P_IsEnabled+0x1a>
34009290:	2300      	movs	r3, #0
}
34009292:	4618      	mov	r0, r3
34009294:	46bd      	mov	sp, r7
34009296:	f85d 7b04 	ldr.w	r7, [sp], #4
3400929a:	4770      	bx	lr
3400929c:	56028000 	.word	0x56028000

340092a0 <LL_RCC_PLL2_GetFRACN>:
{
340092a0:	b480      	push	{r7}
340092a2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >> RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos);
340092a4:	4b04      	ldr	r3, [pc, #16]	@ (340092b8 <LL_RCC_PLL2_GetFRACN+0x18>)
340092a6:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
340092aa:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
340092ae:	4618      	mov	r0, r3
340092b0:	46bd      	mov	sp, r7
340092b2:	f85d 7b04 	ldr.w	r7, [sp], #4
340092b6:	4770      	bx	lr
340092b8:	56028000 	.word	0x56028000

340092bc <LL_RCC_PLL3_GetSource>:
{
340092bc:	b480      	push	{r7}
340092be:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
340092c0:	4b04      	ldr	r3, [pc, #16]	@ (340092d4 <LL_RCC_PLL3_GetSource+0x18>)
340092c2:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
340092c6:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
340092ca:	4618      	mov	r0, r3
340092cc:	46bd      	mov	sp, r7
340092ce:	f85d 7b04 	ldr.w	r7, [sp], #4
340092d2:	4770      	bx	lr
340092d4:	56028000 	.word	0x56028000

340092d8 <LL_RCC_PLL3_IsReady>:
{
340092d8:	b480      	push	{r7}
340092da:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
340092dc:	4b07      	ldr	r3, [pc, #28]	@ (340092fc <LL_RCC_PLL3_IsReady+0x24>)
340092de:	685b      	ldr	r3, [r3, #4]
340092e0:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
340092e4:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
340092e8:	d101      	bne.n	340092ee <LL_RCC_PLL3_IsReady+0x16>
340092ea:	2301      	movs	r3, #1
340092ec:	e000      	b.n	340092f0 <LL_RCC_PLL3_IsReady+0x18>
340092ee:	2300      	movs	r3, #0
}
340092f0:	4618      	mov	r0, r3
340092f2:	46bd      	mov	sp, r7
340092f4:	f85d 7b04 	ldr.w	r7, [sp], #4
340092f8:	4770      	bx	lr
340092fa:	bf00      	nop
340092fc:	56028000 	.word	0x56028000

34009300 <LL_RCC_PLL3_IsEnabledBypass>:
{
34009300:	b480      	push	{r7}
34009302:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
34009304:	4b07      	ldr	r3, [pc, #28]	@ (34009324 <LL_RCC_PLL3_IsEnabledBypass+0x24>)
34009306:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400930a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400930e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34009312:	d101      	bne.n	34009318 <LL_RCC_PLL3_IsEnabledBypass+0x18>
34009314:	2301      	movs	r3, #1
34009316:	e000      	b.n	3400931a <LL_RCC_PLL3_IsEnabledBypass+0x1a>
34009318:	2300      	movs	r3, #0
}
3400931a:	4618      	mov	r0, r3
3400931c:	46bd      	mov	sp, r7
3400931e:	f85d 7b04 	ldr.w	r7, [sp], #4
34009322:	4770      	bx	lr
34009324:	56028000 	.word	0x56028000

34009328 <LL_RCC_PLL3_GetN>:
{
34009328:	b480      	push	{r7}
3400932a:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVN) >> RCC_PLL3CFGR1_PLL3DIVN_Pos));
3400932c:	4b05      	ldr	r3, [pc, #20]	@ (34009344 <LL_RCC_PLL3_GetN+0x1c>)
3400932e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34009332:	0a1b      	lsrs	r3, r3, #8
34009334:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
34009338:	4618      	mov	r0, r3
3400933a:	46bd      	mov	sp, r7
3400933c:	f85d 7b04 	ldr.w	r7, [sp], #4
34009340:	4770      	bx	lr
34009342:	bf00      	nop
34009344:	56028000 	.word	0x56028000

34009348 <LL_RCC_PLL3_GetM>:
{
34009348:	b480      	push	{r7}
3400934a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVM) >> RCC_PLL3CFGR1_PLL3DIVM_Pos);
3400934c:	4b05      	ldr	r3, [pc, #20]	@ (34009364 <LL_RCC_PLL3_GetM+0x1c>)
3400934e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34009352:	0d1b      	lsrs	r3, r3, #20
34009354:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
34009358:	4618      	mov	r0, r3
3400935a:	46bd      	mov	sp, r7
3400935c:	f85d 7b04 	ldr.w	r7, [sp], #4
34009360:	4770      	bx	lr
34009362:	bf00      	nop
34009364:	56028000 	.word	0x56028000

34009368 <LL_RCC_PLL3_GetP1>:
{
34009368:	b480      	push	{r7}
3400936a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
3400936c:	4b05      	ldr	r3, [pc, #20]	@ (34009384 <LL_RCC_PLL3_GetP1+0x1c>)
3400936e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34009372:	0edb      	lsrs	r3, r3, #27
34009374:	f003 0307 	and.w	r3, r3, #7
}
34009378:	4618      	mov	r0, r3
3400937a:	46bd      	mov	sp, r7
3400937c:	f85d 7b04 	ldr.w	r7, [sp], #4
34009380:	4770      	bx	lr
34009382:	bf00      	nop
34009384:	56028000 	.word	0x56028000

34009388 <LL_RCC_PLL3_GetP2>:
{
34009388:	b480      	push	{r7}
3400938a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
3400938c:	4b05      	ldr	r3, [pc, #20]	@ (340093a4 <LL_RCC_PLL3_GetP2+0x1c>)
3400938e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34009392:	0e1b      	lsrs	r3, r3, #24
34009394:	f003 0307 	and.w	r3, r3, #7
}
34009398:	4618      	mov	r0, r3
3400939a:	46bd      	mov	sp, r7
3400939c:	f85d 7b04 	ldr.w	r7, [sp], #4
340093a0:	4770      	bx	lr
340093a2:	bf00      	nop
340093a4:	56028000 	.word	0x56028000

340093a8 <LL_RCC_PLL3P_IsEnabled>:
{
340093a8:	b480      	push	{r7}
340093aa:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIVEN) == RCC_PLL3CFGR3_PLL3PDIVEN) ? 1UL : 0UL);
340093ac:	4b07      	ldr	r3, [pc, #28]	@ (340093cc <LL_RCC_PLL3P_IsEnabled+0x24>)
340093ae:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
340093b2:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
340093b6:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
340093ba:	d101      	bne.n	340093c0 <LL_RCC_PLL3P_IsEnabled+0x18>
340093bc:	2301      	movs	r3, #1
340093be:	e000      	b.n	340093c2 <LL_RCC_PLL3P_IsEnabled+0x1a>
340093c0:	2300      	movs	r3, #0
}
340093c2:	4618      	mov	r0, r3
340093c4:	46bd      	mov	sp, r7
340093c6:	f85d 7b04 	ldr.w	r7, [sp], #4
340093ca:	4770      	bx	lr
340093cc:	56028000 	.word	0x56028000

340093d0 <LL_RCC_PLL3_GetFRACN>:
{
340093d0:	b480      	push	{r7}
340093d2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >> RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos);
340093d4:	4b04      	ldr	r3, [pc, #16]	@ (340093e8 <LL_RCC_PLL3_GetFRACN+0x18>)
340093d6:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
340093da:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
340093de:	4618      	mov	r0, r3
340093e0:	46bd      	mov	sp, r7
340093e2:	f85d 7b04 	ldr.w	r7, [sp], #4
340093e6:	4770      	bx	lr
340093e8:	56028000 	.word	0x56028000

340093ec <LL_RCC_PLL4_GetSource>:
{
340093ec:	b480      	push	{r7}
340093ee:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
340093f0:	4b04      	ldr	r3, [pc, #16]	@ (34009404 <LL_RCC_PLL4_GetSource+0x18>)
340093f2:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
340093f6:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
340093fa:	4618      	mov	r0, r3
340093fc:	46bd      	mov	sp, r7
340093fe:	f85d 7b04 	ldr.w	r7, [sp], #4
34009402:	4770      	bx	lr
34009404:	56028000 	.word	0x56028000

34009408 <LL_RCC_PLL4_IsReady>:
{
34009408:	b480      	push	{r7}
3400940a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
3400940c:	4b07      	ldr	r3, [pc, #28]	@ (3400942c <LL_RCC_PLL4_IsReady+0x24>)
3400940e:	685b      	ldr	r3, [r3, #4]
34009410:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34009414:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34009418:	d101      	bne.n	3400941e <LL_RCC_PLL4_IsReady+0x16>
3400941a:	2301      	movs	r3, #1
3400941c:	e000      	b.n	34009420 <LL_RCC_PLL4_IsReady+0x18>
3400941e:	2300      	movs	r3, #0
}
34009420:	4618      	mov	r0, r3
34009422:	46bd      	mov	sp, r7
34009424:	f85d 7b04 	ldr.w	r7, [sp], #4
34009428:	4770      	bx	lr
3400942a:	bf00      	nop
3400942c:	56028000 	.word	0x56028000

34009430 <LL_RCC_PLL4_IsEnabledBypass>:
{
34009430:	b480      	push	{r7}
34009432:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
34009434:	4b07      	ldr	r3, [pc, #28]	@ (34009454 <LL_RCC_PLL4_IsEnabledBypass+0x24>)
34009436:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3400943a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400943e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34009442:	d101      	bne.n	34009448 <LL_RCC_PLL4_IsEnabledBypass+0x18>
34009444:	2301      	movs	r3, #1
34009446:	e000      	b.n	3400944a <LL_RCC_PLL4_IsEnabledBypass+0x1a>
34009448:	2300      	movs	r3, #0
}
3400944a:	4618      	mov	r0, r3
3400944c:	46bd      	mov	sp, r7
3400944e:	f85d 7b04 	ldr.w	r7, [sp], #4
34009452:	4770      	bx	lr
34009454:	56028000 	.word	0x56028000

34009458 <LL_RCC_PLL4_GetN>:
{
34009458:	b480      	push	{r7}
3400945a:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVN) >> RCC_PLL4CFGR1_PLL4DIVN_Pos));
3400945c:	4b05      	ldr	r3, [pc, #20]	@ (34009474 <LL_RCC_PLL4_GetN+0x1c>)
3400945e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34009462:	0a1b      	lsrs	r3, r3, #8
34009464:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
34009468:	4618      	mov	r0, r3
3400946a:	46bd      	mov	sp, r7
3400946c:	f85d 7b04 	ldr.w	r7, [sp], #4
34009470:	4770      	bx	lr
34009472:	bf00      	nop
34009474:	56028000 	.word	0x56028000

34009478 <LL_RCC_PLL4_GetM>:
{
34009478:	b480      	push	{r7}
3400947a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVM) >> RCC_PLL4CFGR1_PLL4DIVM_Pos);
3400947c:	4b05      	ldr	r3, [pc, #20]	@ (34009494 <LL_RCC_PLL4_GetM+0x1c>)
3400947e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34009482:	0d1b      	lsrs	r3, r3, #20
34009484:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
34009488:	4618      	mov	r0, r3
3400948a:	46bd      	mov	sp, r7
3400948c:	f85d 7b04 	ldr.w	r7, [sp], #4
34009490:	4770      	bx	lr
34009492:	bf00      	nop
34009494:	56028000 	.word	0x56028000

34009498 <LL_RCC_PLL4_GetP1>:
{
34009498:	b480      	push	{r7}
3400949a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
3400949c:	4b05      	ldr	r3, [pc, #20]	@ (340094b4 <LL_RCC_PLL4_GetP1+0x1c>)
3400949e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
340094a2:	0edb      	lsrs	r3, r3, #27
340094a4:	f003 0307 	and.w	r3, r3, #7
}
340094a8:	4618      	mov	r0, r3
340094aa:	46bd      	mov	sp, r7
340094ac:	f85d 7b04 	ldr.w	r7, [sp], #4
340094b0:	4770      	bx	lr
340094b2:	bf00      	nop
340094b4:	56028000 	.word	0x56028000

340094b8 <LL_RCC_PLL4_GetP2>:
{
340094b8:	b480      	push	{r7}
340094ba:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
340094bc:	4b05      	ldr	r3, [pc, #20]	@ (340094d4 <LL_RCC_PLL4_GetP2+0x1c>)
340094be:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
340094c2:	0e1b      	lsrs	r3, r3, #24
340094c4:	f003 0307 	and.w	r3, r3, #7
}
340094c8:	4618      	mov	r0, r3
340094ca:	46bd      	mov	sp, r7
340094cc:	f85d 7b04 	ldr.w	r7, [sp], #4
340094d0:	4770      	bx	lr
340094d2:	bf00      	nop
340094d4:	56028000 	.word	0x56028000

340094d8 <LL_RCC_PLL4P_IsEnabled>:
{
340094d8:	b480      	push	{r7}
340094da:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIVEN) == RCC_PLL4CFGR3_PLL4PDIVEN) ? 1UL : 0UL);
340094dc:	4b07      	ldr	r3, [pc, #28]	@ (340094fc <LL_RCC_PLL4P_IsEnabled+0x24>)
340094de:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
340094e2:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
340094e6:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
340094ea:	d101      	bne.n	340094f0 <LL_RCC_PLL4P_IsEnabled+0x18>
340094ec:	2301      	movs	r3, #1
340094ee:	e000      	b.n	340094f2 <LL_RCC_PLL4P_IsEnabled+0x1a>
340094f0:	2300      	movs	r3, #0
}
340094f2:	4618      	mov	r0, r3
340094f4:	46bd      	mov	sp, r7
340094f6:	f85d 7b04 	ldr.w	r7, [sp], #4
340094fa:	4770      	bx	lr
340094fc:	56028000 	.word	0x56028000

34009500 <LL_RCC_PLL4_GetFRACN>:
{
34009500:	b480      	push	{r7}
34009502:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >> RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos);
34009504:	4b04      	ldr	r3, [pc, #16]	@ (34009518 <LL_RCC_PLL4_GetFRACN+0x18>)
34009506:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
3400950a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3400950e:	4618      	mov	r0, r3
34009510:	46bd      	mov	sp, r7
34009512:	f85d 7b04 	ldr.w	r7, [sp], #4
34009516:	4770      	bx	lr
34009518:	56028000 	.word	0x56028000

3400951c <LL_RCC_IC3_Enable>:
{
3400951c:	b480      	push	{r7}
3400951e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
34009520:	4b04      	ldr	r3, [pc, #16]	@ (34009534 <LL_RCC_IC3_Enable+0x18>)
34009522:	2204      	movs	r2, #4
34009524:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34009528:	bf00      	nop
3400952a:	46bd      	mov	sp, r7
3400952c:	f85d 7b04 	ldr.w	r7, [sp], #4
34009530:	4770      	bx	lr
34009532:	bf00      	nop
34009534:	56028000 	.word	0x56028000

34009538 <LL_RCC_IC3_IsEnabled>:
{
34009538:	b480      	push	{r7}
3400953a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC3EN) == RCC_DIVENR_IC3EN) ? 1UL : 0UL);
3400953c:	4b07      	ldr	r3, [pc, #28]	@ (3400955c <LL_RCC_IC3_IsEnabled+0x24>)
3400953e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34009542:	f003 0304 	and.w	r3, r3, #4
34009546:	2b04      	cmp	r3, #4
34009548:	d101      	bne.n	3400954e <LL_RCC_IC3_IsEnabled+0x16>
3400954a:	2301      	movs	r3, #1
3400954c:	e000      	b.n	34009550 <LL_RCC_IC3_IsEnabled+0x18>
3400954e:	2300      	movs	r3, #0
}
34009550:	4618      	mov	r0, r3
34009552:	46bd      	mov	sp, r7
34009554:	f85d 7b04 	ldr.w	r7, [sp], #4
34009558:	4770      	bx	lr
3400955a:	bf00      	nop
3400955c:	56028000 	.word	0x56028000

34009560 <LL_RCC_IC3_GetSource>:
{
34009560:	b480      	push	{r7}
34009562:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
34009564:	4b04      	ldr	r3, [pc, #16]	@ (34009578 <LL_RCC_IC3_GetSource+0x18>)
34009566:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400956a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400956e:	4618      	mov	r0, r3
34009570:	46bd      	mov	sp, r7
34009572:	f85d 7b04 	ldr.w	r7, [sp], #4
34009576:	4770      	bx	lr
34009578:	56028000 	.word	0x56028000

3400957c <LL_RCC_IC3_GetDivider>:
{
3400957c:	b480      	push	{r7}
3400957e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
34009580:	4b05      	ldr	r3, [pc, #20]	@ (34009598 <LL_RCC_IC3_GetDivider+0x1c>)
34009582:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34009586:	0c1b      	lsrs	r3, r3, #16
34009588:	b2db      	uxtb	r3, r3
3400958a:	3301      	adds	r3, #1
}
3400958c:	4618      	mov	r0, r3
3400958e:	46bd      	mov	sp, r7
34009590:	f85d 7b04 	ldr.w	r7, [sp], #4
34009594:	4770      	bx	lr
34009596:	bf00      	nop
34009598:	56028000 	.word	0x56028000

3400959c <LL_RCC_IC4_Enable>:
{
3400959c:	b480      	push	{r7}
3400959e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
340095a0:	4b04      	ldr	r3, [pc, #16]	@ (340095b4 <LL_RCC_IC4_Enable+0x18>)
340095a2:	2208      	movs	r2, #8
340095a4:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340095a8:	bf00      	nop
340095aa:	46bd      	mov	sp, r7
340095ac:	f85d 7b04 	ldr.w	r7, [sp], #4
340095b0:	4770      	bx	lr
340095b2:	bf00      	nop
340095b4:	56028000 	.word	0x56028000

340095b8 <LL_RCC_IC4_IsEnabled>:
{
340095b8:	b480      	push	{r7}
340095ba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
340095bc:	4b07      	ldr	r3, [pc, #28]	@ (340095dc <LL_RCC_IC4_IsEnabled+0x24>)
340095be:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
340095c2:	f003 0308 	and.w	r3, r3, #8
340095c6:	2b08      	cmp	r3, #8
340095c8:	d101      	bne.n	340095ce <LL_RCC_IC4_IsEnabled+0x16>
340095ca:	2301      	movs	r3, #1
340095cc:	e000      	b.n	340095d0 <LL_RCC_IC4_IsEnabled+0x18>
340095ce:	2300      	movs	r3, #0
}
340095d0:	4618      	mov	r0, r3
340095d2:	46bd      	mov	sp, r7
340095d4:	f85d 7b04 	ldr.w	r7, [sp], #4
340095d8:	4770      	bx	lr
340095da:	bf00      	nop
340095dc:	56028000 	.word	0x56028000

340095e0 <LL_RCC_IC4_GetSource>:
{
340095e0:	b480      	push	{r7}
340095e2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
340095e4:	4b04      	ldr	r3, [pc, #16]	@ (340095f8 <LL_RCC_IC4_GetSource+0x18>)
340095e6:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
340095ea:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
340095ee:	4618      	mov	r0, r3
340095f0:	46bd      	mov	sp, r7
340095f2:	f85d 7b04 	ldr.w	r7, [sp], #4
340095f6:	4770      	bx	lr
340095f8:	56028000 	.word	0x56028000

340095fc <LL_RCC_IC4_GetDivider>:
{
340095fc:	b480      	push	{r7}
340095fe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
34009600:	4b05      	ldr	r3, [pc, #20]	@ (34009618 <LL_RCC_IC4_GetDivider+0x1c>)
34009602:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34009606:	0c1b      	lsrs	r3, r3, #16
34009608:	b2db      	uxtb	r3, r3
3400960a:	3301      	adds	r3, #1
}
3400960c:	4618      	mov	r0, r3
3400960e:	46bd      	mov	sp, r7
34009610:	f85d 7b04 	ldr.w	r7, [sp], #4
34009614:	4770      	bx	lr
34009616:	bf00      	nop
34009618:	56028000 	.word	0x56028000

3400961c <LL_RCC_IC5_Enable>:
{
3400961c:	b480      	push	{r7}
3400961e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
34009620:	4b04      	ldr	r3, [pc, #16]	@ (34009634 <LL_RCC_IC5_Enable+0x18>)
34009622:	2210      	movs	r2, #16
34009624:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34009628:	bf00      	nop
3400962a:	46bd      	mov	sp, r7
3400962c:	f85d 7b04 	ldr.w	r7, [sp], #4
34009630:	4770      	bx	lr
34009632:	bf00      	nop
34009634:	56028000 	.word	0x56028000

34009638 <LL_RCC_IC5_IsEnabled>:
{
34009638:	b480      	push	{r7}
3400963a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC5EN) == RCC_DIVENR_IC5EN) ? 1UL : 0UL);
3400963c:	4b07      	ldr	r3, [pc, #28]	@ (3400965c <LL_RCC_IC5_IsEnabled+0x24>)
3400963e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34009642:	f003 0310 	and.w	r3, r3, #16
34009646:	2b10      	cmp	r3, #16
34009648:	d101      	bne.n	3400964e <LL_RCC_IC5_IsEnabled+0x16>
3400964a:	2301      	movs	r3, #1
3400964c:	e000      	b.n	34009650 <LL_RCC_IC5_IsEnabled+0x18>
3400964e:	2300      	movs	r3, #0
}
34009650:	4618      	mov	r0, r3
34009652:	46bd      	mov	sp, r7
34009654:	f85d 7b04 	ldr.w	r7, [sp], #4
34009658:	4770      	bx	lr
3400965a:	bf00      	nop
3400965c:	56028000 	.word	0x56028000

34009660 <LL_RCC_IC5_GetSource>:
{
34009660:	b480      	push	{r7}
34009662:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
34009664:	4b04      	ldr	r3, [pc, #16]	@ (34009678 <LL_RCC_IC5_GetSource+0x18>)
34009666:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3400966a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400966e:	4618      	mov	r0, r3
34009670:	46bd      	mov	sp, r7
34009672:	f85d 7b04 	ldr.w	r7, [sp], #4
34009676:	4770      	bx	lr
34009678:	56028000 	.word	0x56028000

3400967c <LL_RCC_IC5_GetDivider>:
{
3400967c:	b480      	push	{r7}
3400967e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
34009680:	4b05      	ldr	r3, [pc, #20]	@ (34009698 <LL_RCC_IC5_GetDivider+0x1c>)
34009682:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34009686:	0c1b      	lsrs	r3, r3, #16
34009688:	b2db      	uxtb	r3, r3
3400968a:	3301      	adds	r3, #1
}
3400968c:	4618      	mov	r0, r3
3400968e:	46bd      	mov	sp, r7
34009690:	f85d 7b04 	ldr.w	r7, [sp], #4
34009694:	4770      	bx	lr
34009696:	bf00      	nop
34009698:	56028000 	.word	0x56028000

3400969c <LL_RCC_IC7_Enable>:
{
3400969c:	b480      	push	{r7}
3400969e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
340096a0:	4b04      	ldr	r3, [pc, #16]	@ (340096b4 <LL_RCC_IC7_Enable+0x18>)
340096a2:	2240      	movs	r2, #64	@ 0x40
340096a4:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340096a8:	bf00      	nop
340096aa:	46bd      	mov	sp, r7
340096ac:	f85d 7b04 	ldr.w	r7, [sp], #4
340096b0:	4770      	bx	lr
340096b2:	bf00      	nop
340096b4:	56028000 	.word	0x56028000

340096b8 <LL_RCC_IC7_IsEnabled>:
{
340096b8:	b480      	push	{r7}
340096ba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC7EN) == RCC_DIVENR_IC7EN) ? 1UL : 0UL);
340096bc:	4b07      	ldr	r3, [pc, #28]	@ (340096dc <LL_RCC_IC7_IsEnabled+0x24>)
340096be:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
340096c2:	f003 0340 	and.w	r3, r3, #64	@ 0x40
340096c6:	2b40      	cmp	r3, #64	@ 0x40
340096c8:	d101      	bne.n	340096ce <LL_RCC_IC7_IsEnabled+0x16>
340096ca:	2301      	movs	r3, #1
340096cc:	e000      	b.n	340096d0 <LL_RCC_IC7_IsEnabled+0x18>
340096ce:	2300      	movs	r3, #0
}
340096d0:	4618      	mov	r0, r3
340096d2:	46bd      	mov	sp, r7
340096d4:	f85d 7b04 	ldr.w	r7, [sp], #4
340096d8:	4770      	bx	lr
340096da:	bf00      	nop
340096dc:	56028000 	.word	0x56028000

340096e0 <LL_RCC_IC7_GetSource>:
{
340096e0:	b480      	push	{r7}
340096e2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
340096e4:	4b04      	ldr	r3, [pc, #16]	@ (340096f8 <LL_RCC_IC7_GetSource+0x18>)
340096e6:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
340096ea:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
340096ee:	4618      	mov	r0, r3
340096f0:	46bd      	mov	sp, r7
340096f2:	f85d 7b04 	ldr.w	r7, [sp], #4
340096f6:	4770      	bx	lr
340096f8:	56028000 	.word	0x56028000

340096fc <LL_RCC_IC7_GetDivider>:
{
340096fc:	b480      	push	{r7}
340096fe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7INT) >> RCC_IC7CFGR_IC7INT_Pos) + 1UL);
34009700:	4b05      	ldr	r3, [pc, #20]	@ (34009718 <LL_RCC_IC7_GetDivider+0x1c>)
34009702:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34009706:	0c1b      	lsrs	r3, r3, #16
34009708:	b2db      	uxtb	r3, r3
3400970a:	3301      	adds	r3, #1
}
3400970c:	4618      	mov	r0, r3
3400970e:	46bd      	mov	sp, r7
34009710:	f85d 7b04 	ldr.w	r7, [sp], #4
34009714:	4770      	bx	lr
34009716:	bf00      	nop
34009718:	56028000 	.word	0x56028000

3400971c <LL_RCC_IC8_Enable>:
{
3400971c:	b480      	push	{r7}
3400971e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
34009720:	4b04      	ldr	r3, [pc, #16]	@ (34009734 <LL_RCC_IC8_Enable+0x18>)
34009722:	2280      	movs	r2, #128	@ 0x80
34009724:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34009728:	bf00      	nop
3400972a:	46bd      	mov	sp, r7
3400972c:	f85d 7b04 	ldr.w	r7, [sp], #4
34009730:	4770      	bx	lr
34009732:	bf00      	nop
34009734:	56028000 	.word	0x56028000

34009738 <LL_RCC_IC8_IsEnabled>:
{
34009738:	b480      	push	{r7}
3400973a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC8EN) == RCC_DIVENR_IC8EN) ? 1UL : 0UL);
3400973c:	4b07      	ldr	r3, [pc, #28]	@ (3400975c <LL_RCC_IC8_IsEnabled+0x24>)
3400973e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34009742:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34009746:	2b80      	cmp	r3, #128	@ 0x80
34009748:	d101      	bne.n	3400974e <LL_RCC_IC8_IsEnabled+0x16>
3400974a:	2301      	movs	r3, #1
3400974c:	e000      	b.n	34009750 <LL_RCC_IC8_IsEnabled+0x18>
3400974e:	2300      	movs	r3, #0
}
34009750:	4618      	mov	r0, r3
34009752:	46bd      	mov	sp, r7
34009754:	f85d 7b04 	ldr.w	r7, [sp], #4
34009758:	4770      	bx	lr
3400975a:	bf00      	nop
3400975c:	56028000 	.word	0x56028000

34009760 <LL_RCC_IC8_GetSource>:
{
34009760:	b480      	push	{r7}
34009762:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
34009764:	4b04      	ldr	r3, [pc, #16]	@ (34009778 <LL_RCC_IC8_GetSource+0x18>)
34009766:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400976a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400976e:	4618      	mov	r0, r3
34009770:	46bd      	mov	sp, r7
34009772:	f85d 7b04 	ldr.w	r7, [sp], #4
34009776:	4770      	bx	lr
34009778:	56028000 	.word	0x56028000

3400977c <LL_RCC_IC8_GetDivider>:
{
3400977c:	b480      	push	{r7}
3400977e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8INT) >> RCC_IC8CFGR_IC8INT_Pos) + 1UL);
34009780:	4b05      	ldr	r3, [pc, #20]	@ (34009798 <LL_RCC_IC8_GetDivider+0x1c>)
34009782:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34009786:	0c1b      	lsrs	r3, r3, #16
34009788:	b2db      	uxtb	r3, r3
3400978a:	3301      	adds	r3, #1
}
3400978c:	4618      	mov	r0, r3
3400978e:	46bd      	mov	sp, r7
34009790:	f85d 7b04 	ldr.w	r7, [sp], #4
34009794:	4770      	bx	lr
34009796:	bf00      	nop
34009798:	56028000 	.word	0x56028000

3400979c <LL_RCC_IC9_Enable>:
{
3400979c:	b480      	push	{r7}
3400979e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
340097a0:	4b04      	ldr	r3, [pc, #16]	@ (340097b4 <LL_RCC_IC9_Enable+0x18>)
340097a2:	f44f 7280 	mov.w	r2, #256	@ 0x100
340097a6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340097aa:	bf00      	nop
340097ac:	46bd      	mov	sp, r7
340097ae:	f85d 7b04 	ldr.w	r7, [sp], #4
340097b2:	4770      	bx	lr
340097b4:	56028000 	.word	0x56028000

340097b8 <LL_RCC_IC9_IsEnabled>:
{
340097b8:	b480      	push	{r7}
340097ba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC9EN) == RCC_DIVENR_IC9EN) ? 1UL : 0UL);
340097bc:	4b07      	ldr	r3, [pc, #28]	@ (340097dc <LL_RCC_IC9_IsEnabled+0x24>)
340097be:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
340097c2:	f403 7380 	and.w	r3, r3, #256	@ 0x100
340097c6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340097ca:	d101      	bne.n	340097d0 <LL_RCC_IC9_IsEnabled+0x18>
340097cc:	2301      	movs	r3, #1
340097ce:	e000      	b.n	340097d2 <LL_RCC_IC9_IsEnabled+0x1a>
340097d0:	2300      	movs	r3, #0
}
340097d2:	4618      	mov	r0, r3
340097d4:	46bd      	mov	sp, r7
340097d6:	f85d 7b04 	ldr.w	r7, [sp], #4
340097da:	4770      	bx	lr
340097dc:	56028000 	.word	0x56028000

340097e0 <LL_RCC_IC9_GetSource>:
{
340097e0:	b480      	push	{r7}
340097e2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
340097e4:	4b04      	ldr	r3, [pc, #16]	@ (340097f8 <LL_RCC_IC9_GetSource+0x18>)
340097e6:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340097ea:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
340097ee:	4618      	mov	r0, r3
340097f0:	46bd      	mov	sp, r7
340097f2:	f85d 7b04 	ldr.w	r7, [sp], #4
340097f6:	4770      	bx	lr
340097f8:	56028000 	.word	0x56028000

340097fc <LL_RCC_IC9_GetDivider>:
{
340097fc:	b480      	push	{r7}
340097fe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9INT) >> RCC_IC9CFGR_IC9INT_Pos) + 1UL);
34009800:	4b05      	ldr	r3, [pc, #20]	@ (34009818 <LL_RCC_IC9_GetDivider+0x1c>)
34009802:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34009806:	0c1b      	lsrs	r3, r3, #16
34009808:	b2db      	uxtb	r3, r3
3400980a:	3301      	adds	r3, #1
}
3400980c:	4618      	mov	r0, r3
3400980e:	46bd      	mov	sp, r7
34009810:	f85d 7b04 	ldr.w	r7, [sp], #4
34009814:	4770      	bx	lr
34009816:	bf00      	nop
34009818:	56028000 	.word	0x56028000

3400981c <LL_RCC_IC10_Enable>:
{
3400981c:	b480      	push	{r7}
3400981e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
34009820:	4b04      	ldr	r3, [pc, #16]	@ (34009834 <LL_RCC_IC10_Enable+0x18>)
34009822:	f44f 7200 	mov.w	r2, #512	@ 0x200
34009826:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400982a:	bf00      	nop
3400982c:	46bd      	mov	sp, r7
3400982e:	f85d 7b04 	ldr.w	r7, [sp], #4
34009832:	4770      	bx	lr
34009834:	56028000 	.word	0x56028000

34009838 <LL_RCC_IC10_IsEnabled>:
{
34009838:	b480      	push	{r7}
3400983a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
3400983c:	4b07      	ldr	r3, [pc, #28]	@ (3400985c <LL_RCC_IC10_IsEnabled+0x24>)
3400983e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34009842:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34009846:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400984a:	d101      	bne.n	34009850 <LL_RCC_IC10_IsEnabled+0x18>
3400984c:	2301      	movs	r3, #1
3400984e:	e000      	b.n	34009852 <LL_RCC_IC10_IsEnabled+0x1a>
34009850:	2300      	movs	r3, #0
}
34009852:	4618      	mov	r0, r3
34009854:	46bd      	mov	sp, r7
34009856:	f85d 7b04 	ldr.w	r7, [sp], #4
3400985a:	4770      	bx	lr
3400985c:	56028000 	.word	0x56028000

34009860 <LL_RCC_IC10_GetSource>:
{
34009860:	b480      	push	{r7}
34009862:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
34009864:	4b04      	ldr	r3, [pc, #16]	@ (34009878 <LL_RCC_IC10_GetSource+0x18>)
34009866:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3400986a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400986e:	4618      	mov	r0, r3
34009870:	46bd      	mov	sp, r7
34009872:	f85d 7b04 	ldr.w	r7, [sp], #4
34009876:	4770      	bx	lr
34009878:	56028000 	.word	0x56028000

3400987c <LL_RCC_IC10_GetDivider>:
{
3400987c:	b480      	push	{r7}
3400987e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
34009880:	4b05      	ldr	r3, [pc, #20]	@ (34009898 <LL_RCC_IC10_GetDivider+0x1c>)
34009882:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34009886:	0c1b      	lsrs	r3, r3, #16
34009888:	b2db      	uxtb	r3, r3
3400988a:	3301      	adds	r3, #1
}
3400988c:	4618      	mov	r0, r3
3400988e:	46bd      	mov	sp, r7
34009890:	f85d 7b04 	ldr.w	r7, [sp], #4
34009894:	4770      	bx	lr
34009896:	bf00      	nop
34009898:	56028000 	.word	0x56028000

3400989c <LL_RCC_IC12_Enable>:
  * @brief  Enable IC12
  * @rmtoll DIVENSR       IC12ENS        LL_RCC_IC12_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC12_Enable(void)
{
3400989c:	b480      	push	{r7}
3400989e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC12ENS);
340098a0:	4b04      	ldr	r3, [pc, #16]	@ (340098b4 <LL_RCC_IC12_Enable+0x18>)
340098a2:	f44f 6200 	mov.w	r2, #2048	@ 0x800
340098a6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340098aa:	bf00      	nop
340098ac:	46bd      	mov	sp, r7
340098ae:	f85d 7b04 	ldr.w	r7, [sp], #4
340098b2:	4770      	bx	lr
340098b4:	56028000 	.word	0x56028000

340098b8 <LL_RCC_IC12_IsEnabled>:
  * @brief  Check if IC12 is enabled
  * @rmtoll DIVENR       IC12EN         LL_RCC_IC12_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC12_IsEnabled(void)
{
340098b8:	b480      	push	{r7}
340098ba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC12EN) == RCC_DIVENR_IC12EN) ? 1UL : 0UL);
340098bc:	4b07      	ldr	r3, [pc, #28]	@ (340098dc <LL_RCC_IC12_IsEnabled+0x24>)
340098be:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
340098c2:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
340098c6:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
340098ca:	d101      	bne.n	340098d0 <LL_RCC_IC12_IsEnabled+0x18>
340098cc:	2301      	movs	r3, #1
340098ce:	e000      	b.n	340098d2 <LL_RCC_IC12_IsEnabled+0x1a>
340098d0:	2300      	movs	r3, #0
}
340098d2:	4618      	mov	r0, r3
340098d4:	46bd      	mov	sp, r7
340098d6:	f85d 7b04 	ldr.w	r7, [sp], #4
340098da:	4770      	bx	lr
340098dc:	56028000 	.word	0x56028000

340098e0 <LL_RCC_IC12_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC12_GetSource(void)
{
340098e0:	b480      	push	{r7}
340098e2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL));
340098e4:	4b04      	ldr	r3, [pc, #16]	@ (340098f8 <LL_RCC_IC12_GetSource+0x18>)
340098e6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
340098ea:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
340098ee:	4618      	mov	r0, r3
340098f0:	46bd      	mov	sp, r7
340098f2:	f85d 7b04 	ldr.w	r7, [sp], #4
340098f6:	4770      	bx	lr
340098f8:	56028000 	.word	0x56028000

340098fc <LL_RCC_IC12_GetDivider>:
  * @brief  Get IC12 divider
  * @rmtoll IC12CFGR      IC12INT        LL_RCC_IC12_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC12_GetDivider(void)
{
340098fc:	b480      	push	{r7}
340098fe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12INT) >> RCC_IC12CFGR_IC12INT_Pos) + 1UL);
34009900:	4b05      	ldr	r3, [pc, #20]	@ (34009918 <LL_RCC_IC12_GetDivider+0x1c>)
34009902:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
34009906:	0c1b      	lsrs	r3, r3, #16
34009908:	b2db      	uxtb	r3, r3
3400990a:	3301      	adds	r3, #1
}
3400990c:	4618      	mov	r0, r3
3400990e:	46bd      	mov	sp, r7
34009910:	f85d 7b04 	ldr.w	r7, [sp], #4
34009914:	4770      	bx	lr
34009916:	bf00      	nop
34009918:	56028000 	.word	0x56028000

3400991c <LL_RCC_IC13_Enable>:
  * @brief  Enable IC13
  * @rmtoll DIVENSR       IC13ENS        LL_RCC_IC13_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC13_Enable(void)
{
3400991c:	b480      	push	{r7}
3400991e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC13ENS);
34009920:	4b04      	ldr	r3, [pc, #16]	@ (34009934 <LL_RCC_IC13_Enable+0x18>)
34009922:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34009926:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400992a:	bf00      	nop
3400992c:	46bd      	mov	sp, r7
3400992e:	f85d 7b04 	ldr.w	r7, [sp], #4
34009932:	4770      	bx	lr
34009934:	56028000 	.word	0x56028000

34009938 <LL_RCC_IC13_IsEnabled>:
  * @brief  Check if IC13 is enabled
  * @rmtoll DIVENR       IC13EN         LL_RCC_IC13_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC13_IsEnabled(void)
{
34009938:	b480      	push	{r7}
3400993a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC13EN) == RCC_DIVENR_IC13EN) ? 1UL : 0UL);
3400993c:	4b07      	ldr	r3, [pc, #28]	@ (3400995c <LL_RCC_IC13_IsEnabled+0x24>)
3400993e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34009942:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34009946:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3400994a:	d101      	bne.n	34009950 <LL_RCC_IC13_IsEnabled+0x18>
3400994c:	2301      	movs	r3, #1
3400994e:	e000      	b.n	34009952 <LL_RCC_IC13_IsEnabled+0x1a>
34009950:	2300      	movs	r3, #0
}
34009952:	4618      	mov	r0, r3
34009954:	46bd      	mov	sp, r7
34009956:	f85d 7b04 	ldr.w	r7, [sp], #4
3400995a:	4770      	bx	lr
3400995c:	56028000 	.word	0x56028000

34009960 <LL_RCC_IC13_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC13_GetSource(void)
{
34009960:	b480      	push	{r7}
34009962:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL));
34009964:	4b04      	ldr	r3, [pc, #16]	@ (34009978 <LL_RCC_IC13_GetSource+0x18>)
34009966:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
3400996a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400996e:	4618      	mov	r0, r3
34009970:	46bd      	mov	sp, r7
34009972:	f85d 7b04 	ldr.w	r7, [sp], #4
34009976:	4770      	bx	lr
34009978:	56028000 	.word	0x56028000

3400997c <LL_RCC_IC13_GetDivider>:
  * @brief  Get IC13 divider
  * @rmtoll IC13CFGR      IC13INT        LL_RCC_IC13_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC13_GetDivider(void)
{
3400997c:	b480      	push	{r7}
3400997e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
34009980:	4b05      	ldr	r3, [pc, #20]	@ (34009998 <LL_RCC_IC13_GetDivider+0x1c>)
34009982:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
34009986:	0c1b      	lsrs	r3, r3, #16
34009988:	b2db      	uxtb	r3, r3
3400998a:	3301      	adds	r3, #1
}
3400998c:	4618      	mov	r0, r3
3400998e:	46bd      	mov	sp, r7
34009990:	f85d 7b04 	ldr.w	r7, [sp], #4
34009994:	4770      	bx	lr
34009996:	bf00      	nop
34009998:	56028000 	.word	0x56028000

3400999c <LL_RCC_IC14_Enable>:
  * @brief  Enable IC14
  * @rmtoll DIVENSR       IC14ENS        LL_RCC_IC14_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC14_Enable(void)
{
3400999c:	b480      	push	{r7}
3400999e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
340099a0:	4b04      	ldr	r3, [pc, #16]	@ (340099b4 <LL_RCC_IC14_Enable+0x18>)
340099a2:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
340099a6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340099aa:	bf00      	nop
340099ac:	46bd      	mov	sp, r7
340099ae:	f85d 7b04 	ldr.w	r7, [sp], #4
340099b2:	4770      	bx	lr
340099b4:	56028000 	.word	0x56028000

340099b8 <LL_RCC_IC14_IsEnabled>:
  * @brief  Check if IC14 is enabled
  * @rmtoll DIVENR       IC14EN         LL_RCC_IC14_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_IsEnabled(void)
{
340099b8:	b480      	push	{r7}
340099ba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC14EN) == RCC_DIVENR_IC14EN) ? 1UL : 0UL);
340099bc:	4b07      	ldr	r3, [pc, #28]	@ (340099dc <LL_RCC_IC14_IsEnabled+0x24>)
340099be:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
340099c2:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
340099c6:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
340099ca:	d101      	bne.n	340099d0 <LL_RCC_IC14_IsEnabled+0x18>
340099cc:	2301      	movs	r3, #1
340099ce:	e000      	b.n	340099d2 <LL_RCC_IC14_IsEnabled+0x1a>
340099d0:	2300      	movs	r3, #0
}
340099d2:	4618      	mov	r0, r3
340099d4:	46bd      	mov	sp, r7
340099d6:	f85d 7b04 	ldr.w	r7, [sp], #4
340099da:	4770      	bx	lr
340099dc:	56028000 	.word	0x56028000

340099e0 <LL_RCC_IC14_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_GetSource(void)
{
340099e0:	b480      	push	{r7}
340099e2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
340099e4:	4b04      	ldr	r3, [pc, #16]	@ (340099f8 <LL_RCC_IC14_GetSource+0x18>)
340099e6:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
340099ea:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
340099ee:	4618      	mov	r0, r3
340099f0:	46bd      	mov	sp, r7
340099f2:	f85d 7b04 	ldr.w	r7, [sp], #4
340099f6:	4770      	bx	lr
340099f8:	56028000 	.word	0x56028000

340099fc <LL_RCC_IC14_GetDivider>:
  * @brief  Get IC14 divider
  * @rmtoll IC14CFGR      IC14INT        LL_RCC_IC14_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_GetDivider(void)
{
340099fc:	b480      	push	{r7}
340099fe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14INT) >> RCC_IC14CFGR_IC14INT_Pos) + 1UL);
34009a00:	4b05      	ldr	r3, [pc, #20]	@ (34009a18 <LL_RCC_IC14_GetDivider+0x1c>)
34009a02:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34009a06:	0c1b      	lsrs	r3, r3, #16
34009a08:	b2db      	uxtb	r3, r3
34009a0a:	3301      	adds	r3, #1
}
34009a0c:	4618      	mov	r0, r3
34009a0e:	46bd      	mov	sp, r7
34009a10:	f85d 7b04 	ldr.w	r7, [sp], #4
34009a14:	4770      	bx	lr
34009a16:	bf00      	nop
34009a18:	56028000 	.word	0x56028000

34009a1c <LL_RCC_IC15_Enable>:
  * @brief  Enable IC15
  * @rmtoll DIVENSR       IC15ENS        LL_RCC_IC15_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC15_Enable(void)
{
34009a1c:	b480      	push	{r7}
34009a1e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
34009a20:	4b04      	ldr	r3, [pc, #16]	@ (34009a34 <LL_RCC_IC15_Enable+0x18>)
34009a22:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34009a26:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34009a2a:	bf00      	nop
34009a2c:	46bd      	mov	sp, r7
34009a2e:	f85d 7b04 	ldr.w	r7, [sp], #4
34009a32:	4770      	bx	lr
34009a34:	56028000 	.word	0x56028000

34009a38 <LL_RCC_IC15_IsEnabled>:
  * @brief  Check if IC15 is enabled
  * @rmtoll DIVENR       IC15EN         LL_RCC_IC15_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_IsEnabled(void)
{
34009a38:	b480      	push	{r7}
34009a3a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC15EN) == RCC_DIVENR_IC15EN) ? 1UL : 0UL);
34009a3c:	4b07      	ldr	r3, [pc, #28]	@ (34009a5c <LL_RCC_IC15_IsEnabled+0x24>)
34009a3e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34009a42:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34009a46:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34009a4a:	d101      	bne.n	34009a50 <LL_RCC_IC15_IsEnabled+0x18>
34009a4c:	2301      	movs	r3, #1
34009a4e:	e000      	b.n	34009a52 <LL_RCC_IC15_IsEnabled+0x1a>
34009a50:	2300      	movs	r3, #0
}
34009a52:	4618      	mov	r0, r3
34009a54:	46bd      	mov	sp, r7
34009a56:	f85d 7b04 	ldr.w	r7, [sp], #4
34009a5a:	4770      	bx	lr
34009a5c:	56028000 	.word	0x56028000

34009a60 <LL_RCC_IC15_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_GetSource(void)
{
34009a60:	b480      	push	{r7}
34009a62:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
34009a64:	4b04      	ldr	r3, [pc, #16]	@ (34009a78 <LL_RCC_IC15_GetSource+0x18>)
34009a66:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34009a6a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34009a6e:	4618      	mov	r0, r3
34009a70:	46bd      	mov	sp, r7
34009a72:	f85d 7b04 	ldr.w	r7, [sp], #4
34009a76:	4770      	bx	lr
34009a78:	56028000 	.word	0x56028000

34009a7c <LL_RCC_IC15_GetDivider>:
  * @brief  Get IC15 divider
  * @rmtoll IC15CFGR      IC15INT        LL_RCC_IC15_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_GetDivider(void)
{
34009a7c:	b480      	push	{r7}
34009a7e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15INT) >> RCC_IC15CFGR_IC15INT_Pos) + 1UL);
34009a80:	4b05      	ldr	r3, [pc, #20]	@ (34009a98 <LL_RCC_IC15_GetDivider+0x1c>)
34009a82:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34009a86:	0c1b      	lsrs	r3, r3, #16
34009a88:	b2db      	uxtb	r3, r3
34009a8a:	3301      	adds	r3, #1
}
34009a8c:	4618      	mov	r0, r3
34009a8e:	46bd      	mov	sp, r7
34009a90:	f85d 7b04 	ldr.w	r7, [sp], #4
34009a94:	4770      	bx	lr
34009a96:	bf00      	nop
34009a98:	56028000 	.word	0x56028000

34009a9c <LL_RCC_IC16_Enable>:
  * @brief  Enable IC16
  * @rmtoll DIVENSR       IC16ENS        LL_RCC_IC16_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC16_Enable(void)
{
34009a9c:	b480      	push	{r7}
34009a9e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC16ENS);
34009aa0:	4b04      	ldr	r3, [pc, #16]	@ (34009ab4 <LL_RCC_IC16_Enable+0x18>)
34009aa2:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34009aa6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34009aaa:	bf00      	nop
34009aac:	46bd      	mov	sp, r7
34009aae:	f85d 7b04 	ldr.w	r7, [sp], #4
34009ab2:	4770      	bx	lr
34009ab4:	56028000 	.word	0x56028000

34009ab8 <LL_RCC_IC16_IsEnabled>:
  * @brief  Check if IC16 is enabled
  * @rmtoll DIVENR       IC16EN         LL_RCC_IC16_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC16_IsEnabled(void)
{
34009ab8:	b480      	push	{r7}
34009aba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC16EN) == RCC_DIVENR_IC16EN) ? 1UL : 0UL);
34009abc:	4b07      	ldr	r3, [pc, #28]	@ (34009adc <LL_RCC_IC16_IsEnabled+0x24>)
34009abe:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34009ac2:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34009ac6:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
34009aca:	d101      	bne.n	34009ad0 <LL_RCC_IC16_IsEnabled+0x18>
34009acc:	2301      	movs	r3, #1
34009ace:	e000      	b.n	34009ad2 <LL_RCC_IC16_IsEnabled+0x1a>
34009ad0:	2300      	movs	r3, #0
}
34009ad2:	4618      	mov	r0, r3
34009ad4:	46bd      	mov	sp, r7
34009ad6:	f85d 7b04 	ldr.w	r7, [sp], #4
34009ada:	4770      	bx	lr
34009adc:	56028000 	.word	0x56028000

34009ae0 <LL_RCC_IC16_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC16_GetSource(void)
{
34009ae0:	b480      	push	{r7}
34009ae2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL));
34009ae4:	4b04      	ldr	r3, [pc, #16]	@ (34009af8 <LL_RCC_IC16_GetSource+0x18>)
34009ae6:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
34009aea:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34009aee:	4618      	mov	r0, r3
34009af0:	46bd      	mov	sp, r7
34009af2:	f85d 7b04 	ldr.w	r7, [sp], #4
34009af6:	4770      	bx	lr
34009af8:	56028000 	.word	0x56028000

34009afc <LL_RCC_IC16_GetDivider>:
  * @brief  Get IC16 divider
  * @rmtoll IC16CFGR      IC16INT        LL_RCC_IC16_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC16_GetDivider(void)
{
34009afc:	b480      	push	{r7}
34009afe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16INT) >> RCC_IC16CFGR_IC16INT_Pos) + 1UL);
34009b00:	4b05      	ldr	r3, [pc, #20]	@ (34009b18 <LL_RCC_IC16_GetDivider+0x1c>)
34009b02:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
34009b06:	0c1b      	lsrs	r3, r3, #16
34009b08:	b2db      	uxtb	r3, r3
34009b0a:	3301      	adds	r3, #1
}
34009b0c:	4618      	mov	r0, r3
34009b0e:	46bd      	mov	sp, r7
34009b10:	f85d 7b04 	ldr.w	r7, [sp], #4
34009b14:	4770      	bx	lr
34009b16:	bf00      	nop
34009b18:	56028000 	.word	0x56028000

34009b1c <LL_RCC_IC17_Enable>:
  * @brief  Enable IC17
  * @rmtoll DIVENSR       IC17ENS        LL_RCC_IC17_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC17_Enable(void)
{
34009b1c:	b480      	push	{r7}
34009b1e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC17ENS);
34009b20:	4b04      	ldr	r3, [pc, #16]	@ (34009b34 <LL_RCC_IC17_Enable+0x18>)
34009b22:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34009b26:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34009b2a:	bf00      	nop
34009b2c:	46bd      	mov	sp, r7
34009b2e:	f85d 7b04 	ldr.w	r7, [sp], #4
34009b32:	4770      	bx	lr
34009b34:	56028000 	.word	0x56028000

34009b38 <LL_RCC_IC17_IsEnabled>:
  * @brief  Check if IC17 is enabled
  * @rmtoll DIVENR       IC17EN         LL_RCC_IC17_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC17_IsEnabled(void)
{
34009b38:	b480      	push	{r7}
34009b3a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC17EN) == RCC_DIVENR_IC17EN) ? 1UL : 0UL);
34009b3c:	4b07      	ldr	r3, [pc, #28]	@ (34009b5c <LL_RCC_IC17_IsEnabled+0x24>)
34009b3e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34009b42:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34009b46:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34009b4a:	d101      	bne.n	34009b50 <LL_RCC_IC17_IsEnabled+0x18>
34009b4c:	2301      	movs	r3, #1
34009b4e:	e000      	b.n	34009b52 <LL_RCC_IC17_IsEnabled+0x1a>
34009b50:	2300      	movs	r3, #0
}
34009b52:	4618      	mov	r0, r3
34009b54:	46bd      	mov	sp, r7
34009b56:	f85d 7b04 	ldr.w	r7, [sp], #4
34009b5a:	4770      	bx	lr
34009b5c:	56028000 	.word	0x56028000

34009b60 <LL_RCC_IC17_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC17_GetSource(void)
{
34009b60:	b480      	push	{r7}
34009b62:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL));
34009b64:	4b04      	ldr	r3, [pc, #16]	@ (34009b78 <LL_RCC_IC17_GetSource+0x18>)
34009b66:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34009b6a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34009b6e:	4618      	mov	r0, r3
34009b70:	46bd      	mov	sp, r7
34009b72:	f85d 7b04 	ldr.w	r7, [sp], #4
34009b76:	4770      	bx	lr
34009b78:	56028000 	.word	0x56028000

34009b7c <LL_RCC_IC17_GetDivider>:
  * @brief  Get IC17 divider
  * @rmtoll IC17CFGR      IC17INT        LL_RCC_IC17_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC17_GetDivider(void)
{
34009b7c:	b480      	push	{r7}
34009b7e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17INT) >> RCC_IC17CFGR_IC17INT_Pos) + 1UL);
34009b80:	4b05      	ldr	r3, [pc, #20]	@ (34009b98 <LL_RCC_IC17_GetDivider+0x1c>)
34009b82:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34009b86:	0c1b      	lsrs	r3, r3, #16
34009b88:	b2db      	uxtb	r3, r3
34009b8a:	3301      	adds	r3, #1
}
34009b8c:	4618      	mov	r0, r3
34009b8e:	46bd      	mov	sp, r7
34009b90:	f85d 7b04 	ldr.w	r7, [sp], #4
34009b94:	4770      	bx	lr
34009b96:	bf00      	nop
34009b98:	56028000 	.word	0x56028000

34009b9c <LL_RCC_IC18_Enable>:
  * @brief  Enable IC18
  * @rmtoll DIVENSR       IC18ENS        LL_RCC_IC18_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC18_Enable(void)
{
34009b9c:	b480      	push	{r7}
34009b9e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC18ENS);
34009ba0:	4b04      	ldr	r3, [pc, #16]	@ (34009bb4 <LL_RCC_IC18_Enable+0x18>)
34009ba2:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
34009ba6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34009baa:	bf00      	nop
34009bac:	46bd      	mov	sp, r7
34009bae:	f85d 7b04 	ldr.w	r7, [sp], #4
34009bb2:	4770      	bx	lr
34009bb4:	56028000 	.word	0x56028000

34009bb8 <LL_RCC_IC18_IsEnabled>:
  * @brief  Check if IC18 is enabled
  * @rmtoll DIVENR       IC18EN         LL_RCC_IC18_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC18_IsEnabled(void)
{
34009bb8:	b480      	push	{r7}
34009bba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC18EN) == RCC_DIVENR_IC18EN) ? 1UL : 0UL);
34009bbc:	4b07      	ldr	r3, [pc, #28]	@ (34009bdc <LL_RCC_IC18_IsEnabled+0x24>)
34009bbe:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34009bc2:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34009bc6:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34009bca:	d101      	bne.n	34009bd0 <LL_RCC_IC18_IsEnabled+0x18>
34009bcc:	2301      	movs	r3, #1
34009bce:	e000      	b.n	34009bd2 <LL_RCC_IC18_IsEnabled+0x1a>
34009bd0:	2300      	movs	r3, #0
}
34009bd2:	4618      	mov	r0, r3
34009bd4:	46bd      	mov	sp, r7
34009bd6:	f85d 7b04 	ldr.w	r7, [sp], #4
34009bda:	4770      	bx	lr
34009bdc:	56028000 	.word	0x56028000

34009be0 <LL_RCC_IC18_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC18_GetSource(void)
{
34009be0:	b480      	push	{r7}
34009be2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL));
34009be4:	4b04      	ldr	r3, [pc, #16]	@ (34009bf8 <LL_RCC_IC18_GetSource+0x18>)
34009be6:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34009bea:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34009bee:	4618      	mov	r0, r3
34009bf0:	46bd      	mov	sp, r7
34009bf2:	f85d 7b04 	ldr.w	r7, [sp], #4
34009bf6:	4770      	bx	lr
34009bf8:	56028000 	.word	0x56028000

34009bfc <LL_RCC_IC18_GetDivider>:
  * @brief  Get IC18 divider
  * @rmtoll IC18CFGR      IC18INT        LL_RCC_IC18_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC18_GetDivider(void)
{
34009bfc:	b480      	push	{r7}
34009bfe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18INT) >> RCC_IC18CFGR_IC18INT_Pos) + 1UL);
34009c00:	4b05      	ldr	r3, [pc, #20]	@ (34009c18 <LL_RCC_IC18_GetDivider+0x1c>)
34009c02:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34009c06:	0c1b      	lsrs	r3, r3, #16
34009c08:	b2db      	uxtb	r3, r3
34009c0a:	3301      	adds	r3, #1
}
34009c0c:	4618      	mov	r0, r3
34009c0e:	46bd      	mov	sp, r7
34009c10:	f85d 7b04 	ldr.w	r7, [sp], #4
34009c14:	4770      	bx	lr
34009c16:	bf00      	nop
34009c18:	56028000 	.word	0x56028000

34009c1c <LL_RCC_IC19_Enable>:
  * @brief  Enable IC19
  * @rmtoll DIVENSR       IC19ENS        LL_RCC_IC19_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC19_Enable(void)
{
34009c1c:	b480      	push	{r7}
34009c1e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
34009c20:	4b04      	ldr	r3, [pc, #16]	@ (34009c34 <LL_RCC_IC19_Enable+0x18>)
34009c22:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
34009c26:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34009c2a:	bf00      	nop
34009c2c:	46bd      	mov	sp, r7
34009c2e:	f85d 7b04 	ldr.w	r7, [sp], #4
34009c32:	4770      	bx	lr
34009c34:	56028000 	.word	0x56028000

34009c38 <LL_RCC_IC19_IsEnabled>:
  * @brief  Check if IC19 is enabled
  * @rmtoll DIVENR       IC19EN         LL_RCC_IC19_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC19_IsEnabled(void)
{
34009c38:	b480      	push	{r7}
34009c3a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC19EN) == RCC_DIVENR_IC19EN) ? 1UL : 0UL);
34009c3c:	4b07      	ldr	r3, [pc, #28]	@ (34009c5c <LL_RCC_IC19_IsEnabled+0x24>)
34009c3e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34009c42:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34009c46:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34009c4a:	d101      	bne.n	34009c50 <LL_RCC_IC19_IsEnabled+0x18>
34009c4c:	2301      	movs	r3, #1
34009c4e:	e000      	b.n	34009c52 <LL_RCC_IC19_IsEnabled+0x1a>
34009c50:	2300      	movs	r3, #0
}
34009c52:	4618      	mov	r0, r3
34009c54:	46bd      	mov	sp, r7
34009c56:	f85d 7b04 	ldr.w	r7, [sp], #4
34009c5a:	4770      	bx	lr
34009c5c:	56028000 	.word	0x56028000

34009c60 <LL_RCC_IC19_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC19_GetSource(void)
{
34009c60:	b480      	push	{r7}
34009c62:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
34009c64:	4b04      	ldr	r3, [pc, #16]	@ (34009c78 <LL_RCC_IC19_GetSource+0x18>)
34009c66:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
34009c6a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34009c6e:	4618      	mov	r0, r3
34009c70:	46bd      	mov	sp, r7
34009c72:	f85d 7b04 	ldr.w	r7, [sp], #4
34009c76:	4770      	bx	lr
34009c78:	56028000 	.word	0x56028000

34009c7c <LL_RCC_IC19_GetDivider>:
  * @brief  Get IC19 divider
  * @rmtoll IC19CFGR      IC19INT        LL_RCC_IC19_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC19_GetDivider(void)
{
34009c7c:	b480      	push	{r7}
34009c7e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
34009c80:	4b05      	ldr	r3, [pc, #20]	@ (34009c98 <LL_RCC_IC19_GetDivider+0x1c>)
34009c82:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
34009c86:	0c1b      	lsrs	r3, r3, #16
34009c88:	b2db      	uxtb	r3, r3
34009c8a:	3301      	adds	r3, #1
}
34009c8c:	4618      	mov	r0, r3
34009c8e:	46bd      	mov	sp, r7
34009c90:	f85d 7b04 	ldr.w	r7, [sp], #4
34009c94:	4770      	bx	lr
34009c96:	bf00      	nop
34009c98:	56028000 	.word	0x56028000

34009c9c <LL_RCC_IC20_Enable>:
  * @brief  Enable IC20
  * @rmtoll DIVENSR       IC20ENS        LL_RCC_IC20_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC20_Enable(void)
{
34009c9c:	b480      	push	{r7}
34009c9e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
34009ca0:	4b04      	ldr	r3, [pc, #16]	@ (34009cb4 <LL_RCC_IC20_Enable+0x18>)
34009ca2:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
34009ca6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34009caa:	bf00      	nop
34009cac:	46bd      	mov	sp, r7
34009cae:	f85d 7b04 	ldr.w	r7, [sp], #4
34009cb2:	4770      	bx	lr
34009cb4:	56028000 	.word	0x56028000

34009cb8 <LL_RCC_IC20_IsEnabled>:
  * @brief  Check if IC20 is enabled
  * @rmtoll DIVENR       IC20EN         LL_RCC_IC20_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC20_IsEnabled(void)
{
34009cb8:	b480      	push	{r7}
34009cba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC20EN) == RCC_DIVENR_IC20EN) ? 1UL : 0UL);
34009cbc:	4b07      	ldr	r3, [pc, #28]	@ (34009cdc <LL_RCC_IC20_IsEnabled+0x24>)
34009cbe:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34009cc2:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
34009cc6:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
34009cca:	d101      	bne.n	34009cd0 <LL_RCC_IC20_IsEnabled+0x18>
34009ccc:	2301      	movs	r3, #1
34009cce:	e000      	b.n	34009cd2 <LL_RCC_IC20_IsEnabled+0x1a>
34009cd0:	2300      	movs	r3, #0
}
34009cd2:	4618      	mov	r0, r3
34009cd4:	46bd      	mov	sp, r7
34009cd6:	f85d 7b04 	ldr.w	r7, [sp], #4
34009cda:	4770      	bx	lr
34009cdc:	56028000 	.word	0x56028000

34009ce0 <LL_RCC_IC20_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC20_GetSource(void)
{
34009ce0:	b480      	push	{r7}
34009ce2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
34009ce4:	4b04      	ldr	r3, [pc, #16]	@ (34009cf8 <LL_RCC_IC20_GetSource+0x18>)
34009ce6:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34009cea:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34009cee:	4618      	mov	r0, r3
34009cf0:	46bd      	mov	sp, r7
34009cf2:	f85d 7b04 	ldr.w	r7, [sp], #4
34009cf6:	4770      	bx	lr
34009cf8:	56028000 	.word	0x56028000

34009cfc <LL_RCC_IC20_GetDivider>:
  * @brief  Get IC20 divider
  * @rmtoll IC20CFGR      IC20INT        LL_RCC_IC20_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC20_GetDivider(void)
{
34009cfc:	b480      	push	{r7}
34009cfe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
34009d00:	4b05      	ldr	r3, [pc, #20]	@ (34009d18 <LL_RCC_IC20_GetDivider+0x1c>)
34009d02:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34009d06:	0c1b      	lsrs	r3, r3, #16
34009d08:	b2db      	uxtb	r3, r3
34009d0a:	3301      	adds	r3, #1
}
34009d0c:	4618      	mov	r0, r3
34009d0e:	46bd      	mov	sp, r7
34009d10:	f85d 7b04 	ldr.w	r7, [sp], #4
34009d14:	4770      	bx	lr
34009d16:	bf00      	nop
34009d18:	56028000 	.word	0x56028000

34009d1c <LL_RCC_CLKP_Enable>:
  * @brief  Enable CLKP
  * @rmtoll MISCENSR      PERENS        LL_RCC_CLKP_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_CLKP_Enable(void)
{
34009d1c:	b480      	push	{r7}
34009d1e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34009d20:	4b04      	ldr	r3, [pc, #16]	@ (34009d34 <LL_RCC_CLKP_Enable+0x18>)
34009d22:	2240      	movs	r2, #64	@ 0x40
34009d24:	f8c3 2a48 	str.w	r2, [r3, #2632]	@ 0xa48
}
34009d28:	bf00      	nop
34009d2a:	46bd      	mov	sp, r7
34009d2c:	f85d 7b04 	ldr.w	r7, [sp], #4
34009d30:	4770      	bx	lr
34009d32:	bf00      	nop
34009d34:	56028000 	.word	0x56028000

34009d38 <LL_RCC_CLKP_IsEnabled>:
  * @brief  Check if CLKP is enabled
  * @rmtoll MISCENR       PEREN         LL_RCC_CLKP_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_CLKP_IsEnabled(void)
{
34009d38:	b480      	push	{r7}
34009d3a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->MISCENR, RCC_MISCENR_PEREN) == RCC_MISCENR_PEREN) ? 1UL : 0UL);
34009d3c:	4b07      	ldr	r3, [pc, #28]	@ (34009d5c <LL_RCC_CLKP_IsEnabled+0x24>)
34009d3e:	f8d3 3248 	ldr.w	r3, [r3, #584]	@ 0x248
34009d42:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34009d46:	2b40      	cmp	r3, #64	@ 0x40
34009d48:	d101      	bne.n	34009d4e <LL_RCC_CLKP_IsEnabled+0x16>
34009d4a:	2301      	movs	r3, #1
34009d4c:	e000      	b.n	34009d50 <LL_RCC_CLKP_IsEnabled+0x18>
34009d4e:	2300      	movs	r3, #0
}
34009d50:	4618      	mov	r0, r3
34009d52:	46bd      	mov	sp, r7
34009d54:	f85d 7b04 	ldr.w	r7, [sp], #4
34009d58:	4770      	bx	lr
34009d5a:	bf00      	nop
34009d5c:	56028000 	.word	0x56028000

34009d60 <HAL_RCCEx_PeriphCLKConfig>:
  *         modification indeed impacts all peripherals using this ICx as clock source.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(const RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
34009d60:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
34009d64:	f5ad 7d64 	sub.w	sp, sp, #912	@ 0x390
34009d68:	af00      	add	r7, sp, #0
34009d6a:	f8c7 037c 	str.w	r0, [r7, #892]	@ 0x37c
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
34009d6e:	2300      	movs	r3, #0
34009d70:	f887 338f 	strb.w	r3, [r7, #911]	@ 0x38f
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
34009d74:	2300      	movs	r3, #0
34009d76:	f887 338e 	strb.w	r3, [r7, #910]	@ 0x38e

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
34009d7a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009d7e:	e9d3 2300 	ldrd	r2, r3, [r3]
34009d82:	f402 6400 	and.w	r4, r2, #2048	@ 0x800
34009d86:	2500      	movs	r5, #0
34009d88:	ea54 0305 	orrs.w	r3, r4, r5
34009d8c:	f040 83e0 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
34009d90:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009d94:	e9d3 2300 	ldrd	r2, r3, [r3]
34009d98:	f04f 0800 	mov.w	r8, #0
34009d9c:	f403 0980 	and.w	r9, r3, #4194304	@ 0x400000
34009da0:	ea58 0309 	orrs.w	r3, r8, r9
34009da4:	f040 83d4 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
34009da8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009dac:	e9d3 2300 	ldrd	r2, r3, [r3]
34009db0:	f04f 0a00 	mov.w	sl, #0
34009db4:	f403 0b00 	and.w	fp, r3, #8388608	@ 0x800000
34009db8:	ea5a 030b 	orrs.w	r3, sl, fp
34009dbc:	f040 83c8 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
34009dc0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009dc4:	e9d3 2300 	ldrd	r2, r3, [r3]
34009dc8:	2100      	movs	r1, #0
34009dca:	f8c7 1370 	str.w	r1, [r7, #880]	@ 0x370
34009dce:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34009dd2:	f8c7 3374 	str.w	r3, [r7, #884]	@ 0x374
34009dd6:	e9d7 01dc 	ldrd	r0, r1, [r7, #880]	@ 0x370
34009dda:	4603      	mov	r3, r0
34009ddc:	460a      	mov	r2, r1
34009dde:	4313      	orrs	r3, r2
34009de0:	f040 83b6 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
34009de4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009de8:	e9d3 2300 	ldrd	r2, r3, [r3]
34009dec:	f002 0304 	and.w	r3, r2, #4
34009df0:	f8c7 3368 	str.w	r3, [r7, #872]	@ 0x368
34009df4:	2300      	movs	r3, #0
34009df6:	f8c7 336c 	str.w	r3, [r7, #876]	@ 0x36c
34009dfa:	e9d7 01da 	ldrd	r0, r1, [r7, #872]	@ 0x368
34009dfe:	4603      	mov	r3, r0
34009e00:	460a      	mov	r2, r1
34009e02:	4313      	orrs	r3, r2
34009e04:	f040 83a4 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
34009e08:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009e0c:	e9d3 2300 	ldrd	r2, r3, [r3]
34009e10:	f002 0301 	and.w	r3, r2, #1
34009e14:	f8c7 3360 	str.w	r3, [r7, #864]	@ 0x360
34009e18:	2300      	movs	r3, #0
34009e1a:	f8c7 3364 	str.w	r3, [r7, #868]	@ 0x364
34009e1e:	e9d7 01d8 	ldrd	r0, r1, [r7, #864]	@ 0x360
34009e22:	4603      	mov	r3, r0
34009e24:	460a      	mov	r2, r1
34009e26:	4313      	orrs	r3, r2
34009e28:	f040 8392 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
34009e2c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009e30:	e9d3 2300 	ldrd	r2, r3, [r3]
34009e34:	f002 0302 	and.w	r3, r2, #2
34009e38:	f8c7 3358 	str.w	r3, [r7, #856]	@ 0x358
34009e3c:	2300      	movs	r3, #0
34009e3e:	f8c7 335c 	str.w	r3, [r7, #860]	@ 0x35c
34009e42:	e9d7 01d6 	ldrd	r0, r1, [r7, #856]	@ 0x358
34009e46:	4603      	mov	r3, r0
34009e48:	460a      	mov	r2, r1
34009e4a:	4313      	orrs	r3, r2
34009e4c:	f040 8380 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
34009e50:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009e54:	e9d3 2300 	ldrd	r2, r3, [r3]
34009e58:	f002 0308 	and.w	r3, r2, #8
34009e5c:	f8c7 3350 	str.w	r3, [r7, #848]	@ 0x350
34009e60:	2300      	movs	r3, #0
34009e62:	f8c7 3354 	str.w	r3, [r7, #852]	@ 0x354
34009e66:	e9d7 01d4 	ldrd	r0, r1, [r7, #848]	@ 0x350
34009e6a:	4603      	mov	r3, r0
34009e6c:	460a      	mov	r2, r1
34009e6e:	4313      	orrs	r3, r2
34009e70:	f040 836e 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
34009e74:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009e78:	e9d3 2300 	ldrd	r2, r3, [r3]
34009e7c:	f002 0310 	and.w	r3, r2, #16
34009e80:	f8c7 3348 	str.w	r3, [r7, #840]	@ 0x348
34009e84:	2300      	movs	r3, #0
34009e86:	f8c7 334c 	str.w	r3, [r7, #844]	@ 0x34c
34009e8a:	e9d7 01d2 	ldrd	r0, r1, [r7, #840]	@ 0x348
34009e8e:	4603      	mov	r3, r0
34009e90:	460a      	mov	r2, r1
34009e92:	4313      	orrs	r3, r2
34009e94:	f040 835c 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
34009e98:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009e9c:	e9d3 2300 	ldrd	r2, r3, [r3]
34009ea0:	f002 0320 	and.w	r3, r2, #32
34009ea4:	f8c7 3340 	str.w	r3, [r7, #832]	@ 0x340
34009ea8:	2300      	movs	r3, #0
34009eaa:	f8c7 3344 	str.w	r3, [r7, #836]	@ 0x344
34009eae:	e9d7 01d0 	ldrd	r0, r1, [r7, #832]	@ 0x340
34009eb2:	4603      	mov	r3, r0
34009eb4:	460a      	mov	r2, r1
34009eb6:	4313      	orrs	r3, r2
34009eb8:	f040 834a 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
34009ebc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009ec0:	e9d3 2300 	ldrd	r2, r3, [r3]
34009ec4:	f002 0340 	and.w	r3, r2, #64	@ 0x40
34009ec8:	f8c7 3338 	str.w	r3, [r7, #824]	@ 0x338
34009ecc:	2300      	movs	r3, #0
34009ece:	f8c7 333c 	str.w	r3, [r7, #828]	@ 0x33c
34009ed2:	e9d7 01ce 	ldrd	r0, r1, [r7, #824]	@ 0x338
34009ed6:	4603      	mov	r3, r0
34009ed8:	460a      	mov	r2, r1
34009eda:	4313      	orrs	r3, r2
34009edc:	f040 8338 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
34009ee0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009ee4:	e9d3 2300 	ldrd	r2, r3, [r3]
34009ee8:	f002 0380 	and.w	r3, r2, #128	@ 0x80
34009eec:	f8c7 3330 	str.w	r3, [r7, #816]	@ 0x330
34009ef0:	2300      	movs	r3, #0
34009ef2:	f8c7 3334 	str.w	r3, [r7, #820]	@ 0x334
34009ef6:	e9d7 01cc 	ldrd	r0, r1, [r7, #816]	@ 0x330
34009efa:	4603      	mov	r3, r0
34009efc:	460a      	mov	r2, r1
34009efe:	4313      	orrs	r3, r2
34009f00:	f040 8326 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
34009f04:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009f08:	e9d3 2300 	ldrd	r2, r3, [r3]
34009f0c:	f402 7380 	and.w	r3, r2, #256	@ 0x100
34009f10:	f8c7 3328 	str.w	r3, [r7, #808]	@ 0x328
34009f14:	2300      	movs	r3, #0
34009f16:	f8c7 332c 	str.w	r3, [r7, #812]	@ 0x32c
34009f1a:	e9d7 01ca 	ldrd	r0, r1, [r7, #808]	@ 0x328
34009f1e:	4603      	mov	r3, r0
34009f20:	460a      	mov	r2, r1
34009f22:	4313      	orrs	r3, r2
34009f24:	f040 8314 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
34009f28:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009f2c:	e9d3 2300 	ldrd	r2, r3, [r3]
34009f30:	f402 7300 	and.w	r3, r2, #512	@ 0x200
34009f34:	f8c7 3320 	str.w	r3, [r7, #800]	@ 0x320
34009f38:	2300      	movs	r3, #0
34009f3a:	f8c7 3324 	str.w	r3, [r7, #804]	@ 0x324
34009f3e:	e9d7 01c8 	ldrd	r0, r1, [r7, #800]	@ 0x320
34009f42:	4603      	mov	r3, r0
34009f44:	460a      	mov	r2, r1
34009f46:	4313      	orrs	r3, r2
34009f48:	f040 8302 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
34009f4c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009f50:	e9d3 2300 	ldrd	r2, r3, [r3]
34009f54:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
34009f58:	f8c7 3318 	str.w	r3, [r7, #792]	@ 0x318
34009f5c:	2300      	movs	r3, #0
34009f5e:	f8c7 331c 	str.w	r3, [r7, #796]	@ 0x31c
34009f62:	e9d7 01c6 	ldrd	r0, r1, [r7, #792]	@ 0x318
34009f66:	4603      	mov	r3, r0
34009f68:	460a      	mov	r2, r1
34009f6a:	4313      	orrs	r3, r2
34009f6c:	f040 82f0 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
34009f70:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009f74:	e9d3 2300 	ldrd	r2, r3, [r3]
34009f78:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
34009f7c:	f8c7 3310 	str.w	r3, [r7, #784]	@ 0x310
34009f80:	2300      	movs	r3, #0
34009f82:	f8c7 3314 	str.w	r3, [r7, #788]	@ 0x314
34009f86:	e9d7 01c4 	ldrd	r0, r1, [r7, #784]	@ 0x310
34009f8a:	4603      	mov	r3, r0
34009f8c:	460a      	mov	r2, r1
34009f8e:	4313      	orrs	r3, r2
34009f90:	f040 82de 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
34009f94:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009f98:	e9d3 2300 	ldrd	r2, r3, [r3]
34009f9c:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
34009fa0:	f8c7 3308 	str.w	r3, [r7, #776]	@ 0x308
34009fa4:	2300      	movs	r3, #0
34009fa6:	f8c7 330c 	str.w	r3, [r7, #780]	@ 0x30c
34009faa:	e9d7 01c2 	ldrd	r0, r1, [r7, #776]	@ 0x308
34009fae:	4603      	mov	r3, r0
34009fb0:	460a      	mov	r2, r1
34009fb2:	4313      	orrs	r3, r2
34009fb4:	f040 82cc 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
34009fb8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009fbc:	e9d3 2300 	ldrd	r2, r3, [r3]
34009fc0:	f402 4380 	and.w	r3, r2, #16384	@ 0x4000
34009fc4:	f8c7 3300 	str.w	r3, [r7, #768]	@ 0x300
34009fc8:	2300      	movs	r3, #0
34009fca:	f8c7 3304 	str.w	r3, [r7, #772]	@ 0x304
34009fce:	e9d7 01c0 	ldrd	r0, r1, [r7, #768]	@ 0x300
34009fd2:	4603      	mov	r3, r0
34009fd4:	460a      	mov	r2, r1
34009fd6:	4313      	orrs	r3, r2
34009fd8:	f040 82ba 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
34009fdc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34009fe0:	e9d3 2300 	ldrd	r2, r3, [r3]
34009fe4:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
34009fe8:	f8c7 32f8 	str.w	r3, [r7, #760]	@ 0x2f8
34009fec:	2300      	movs	r3, #0
34009fee:	f8c7 32fc 	str.w	r3, [r7, #764]	@ 0x2fc
34009ff2:	e9d7 01be 	ldrd	r0, r1, [r7, #760]	@ 0x2f8
34009ff6:	4603      	mov	r3, r0
34009ff8:	460a      	mov	r2, r1
34009ffa:	4313      	orrs	r3, r2
34009ffc:	f040 82a8 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a000:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a004:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a008:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
3400a00c:	f8c7 32f0 	str.w	r3, [r7, #752]	@ 0x2f0
3400a010:	2300      	movs	r3, #0
3400a012:	f8c7 32f4 	str.w	r3, [r7, #756]	@ 0x2f4
3400a016:	e9d7 01bc 	ldrd	r0, r1, [r7, #752]	@ 0x2f0
3400a01a:	4603      	mov	r3, r0
3400a01c:	460a      	mov	r2, r1
3400a01e:	4313      	orrs	r3, r2
3400a020:	f040 8296 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a024:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a028:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a02c:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
3400a030:	f8c7 32e8 	str.w	r3, [r7, #744]	@ 0x2e8
3400a034:	2300      	movs	r3, #0
3400a036:	f8c7 32ec 	str.w	r3, [r7, #748]	@ 0x2ec
3400a03a:	e9d7 01ba 	ldrd	r0, r1, [r7, #744]	@ 0x2e8
3400a03e:	4603      	mov	r3, r0
3400a040:	460a      	mov	r2, r1
3400a042:	4313      	orrs	r3, r2
3400a044:	f040 8284 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a048:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a04c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a050:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
3400a054:	f8c7 32e0 	str.w	r3, [r7, #736]	@ 0x2e0
3400a058:	2300      	movs	r3, #0
3400a05a:	f8c7 32e4 	str.w	r3, [r7, #740]	@ 0x2e4
3400a05e:	e9d7 01b8 	ldrd	r0, r1, [r7, #736]	@ 0x2e0
3400a062:	4603      	mov	r3, r0
3400a064:	460a      	mov	r2, r1
3400a066:	4313      	orrs	r3, r2
3400a068:	f040 8272 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a06c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a070:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a074:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
3400a078:	f8c7 32d8 	str.w	r3, [r7, #728]	@ 0x2d8
3400a07c:	2300      	movs	r3, #0
3400a07e:	f8c7 32dc 	str.w	r3, [r7, #732]	@ 0x2dc
3400a082:	e9d7 01b6 	ldrd	r0, r1, [r7, #728]	@ 0x2d8
3400a086:	4603      	mov	r3, r0
3400a088:	460a      	mov	r2, r1
3400a08a:	4313      	orrs	r3, r2
3400a08c:	f040 8260 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a090:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a094:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a098:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
3400a09c:	f8c7 32d0 	str.w	r3, [r7, #720]	@ 0x2d0
3400a0a0:	2300      	movs	r3, #0
3400a0a2:	f8c7 32d4 	str.w	r3, [r7, #724]	@ 0x2d4
3400a0a6:	e9d7 01b4 	ldrd	r0, r1, [r7, #720]	@ 0x2d0
3400a0aa:	4603      	mov	r3, r0
3400a0ac:	460a      	mov	r2, r1
3400a0ae:	4313      	orrs	r3, r2
3400a0b0:	f040 824e 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a0b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a0b8:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a0bc:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
3400a0c0:	f8c7 32c8 	str.w	r3, [r7, #712]	@ 0x2c8
3400a0c4:	2300      	movs	r3, #0
3400a0c6:	f8c7 32cc 	str.w	r3, [r7, #716]	@ 0x2cc
3400a0ca:	e9d7 01b2 	ldrd	r0, r1, [r7, #712]	@ 0x2c8
3400a0ce:	4603      	mov	r3, r0
3400a0d0:	460a      	mov	r2, r1
3400a0d2:	4313      	orrs	r3, r2
3400a0d4:	f040 823c 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a0d8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a0dc:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a0e0:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
3400a0e4:	f8c7 32c0 	str.w	r3, [r7, #704]	@ 0x2c0
3400a0e8:	2300      	movs	r3, #0
3400a0ea:	f8c7 32c4 	str.w	r3, [r7, #708]	@ 0x2c4
3400a0ee:	e9d7 01b0 	ldrd	r0, r1, [r7, #704]	@ 0x2c0
3400a0f2:	4603      	mov	r3, r0
3400a0f4:	460a      	mov	r2, r1
3400a0f6:	4313      	orrs	r3, r2
3400a0f8:	f040 822a 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a0fc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a100:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a104:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
3400a108:	f8c7 32b8 	str.w	r3, [r7, #696]	@ 0x2b8
3400a10c:	2300      	movs	r3, #0
3400a10e:	f8c7 32bc 	str.w	r3, [r7, #700]	@ 0x2bc
3400a112:	e9d7 01ae 	ldrd	r0, r1, [r7, #696]	@ 0x2b8
3400a116:	4603      	mov	r3, r0
3400a118:	460a      	mov	r2, r1
3400a11a:	4313      	orrs	r3, r2
3400a11c:	f040 8218 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a120:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a124:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a128:	f002 7380 	and.w	r3, r2, #16777216	@ 0x1000000
3400a12c:	f8c7 32b0 	str.w	r3, [r7, #688]	@ 0x2b0
3400a130:	2300      	movs	r3, #0
3400a132:	f8c7 32b4 	str.w	r3, [r7, #692]	@ 0x2b4
3400a136:	e9d7 01ac 	ldrd	r0, r1, [r7, #688]	@ 0x2b0
3400a13a:	4603      	mov	r3, r0
3400a13c:	460a      	mov	r2, r1
3400a13e:	4313      	orrs	r3, r2
3400a140:	f040 8206 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a144:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a148:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a14c:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
3400a150:	f8c7 32a8 	str.w	r3, [r7, #680]	@ 0x2a8
3400a154:	2300      	movs	r3, #0
3400a156:	f8c7 32ac 	str.w	r3, [r7, #684]	@ 0x2ac
3400a15a:	e9d7 01aa 	ldrd	r0, r1, [r7, #680]	@ 0x2a8
3400a15e:	4603      	mov	r3, r0
3400a160:	460a      	mov	r2, r1
3400a162:	4313      	orrs	r3, r2
3400a164:	f040 81f4 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a168:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a16c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a170:	f002 6380 	and.w	r3, r2, #67108864	@ 0x4000000
3400a174:	f8c7 32a0 	str.w	r3, [r7, #672]	@ 0x2a0
3400a178:	2300      	movs	r3, #0
3400a17a:	f8c7 32a4 	str.w	r3, [r7, #676]	@ 0x2a4
3400a17e:	e9d7 01a8 	ldrd	r0, r1, [r7, #672]	@ 0x2a0
3400a182:	4603      	mov	r3, r0
3400a184:	460a      	mov	r2, r1
3400a186:	4313      	orrs	r3, r2
3400a188:	f040 81e2 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a18c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a190:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a194:	f002 6300 	and.w	r3, r2, #134217728	@ 0x8000000
3400a198:	f8c7 3298 	str.w	r3, [r7, #664]	@ 0x298
3400a19c:	2300      	movs	r3, #0
3400a19e:	f8c7 329c 	str.w	r3, [r7, #668]	@ 0x29c
3400a1a2:	e9d7 01a6 	ldrd	r0, r1, [r7, #664]	@ 0x298
3400a1a6:	4603      	mov	r3, r0
3400a1a8:	460a      	mov	r2, r1
3400a1aa:	4313      	orrs	r3, r2
3400a1ac:	f040 81d0 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a1b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a1b4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a1b8:	f002 5380 	and.w	r3, r2, #268435456	@ 0x10000000
3400a1bc:	f8c7 3290 	str.w	r3, [r7, #656]	@ 0x290
3400a1c0:	2300      	movs	r3, #0
3400a1c2:	f8c7 3294 	str.w	r3, [r7, #660]	@ 0x294
3400a1c6:	e9d7 01a4 	ldrd	r0, r1, [r7, #656]	@ 0x290
3400a1ca:	4603      	mov	r3, r0
3400a1cc:	460a      	mov	r2, r1
3400a1ce:	4313      	orrs	r3, r2
3400a1d0:	f040 81be 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a1d4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a1d8:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a1dc:	f002 5300 	and.w	r3, r2, #536870912	@ 0x20000000
3400a1e0:	f8c7 3288 	str.w	r3, [r7, #648]	@ 0x288
3400a1e4:	2300      	movs	r3, #0
3400a1e6:	f8c7 328c 	str.w	r3, [r7, #652]	@ 0x28c
3400a1ea:	e9d7 01a2 	ldrd	r0, r1, [r7, #648]	@ 0x288
3400a1ee:	4603      	mov	r3, r0
3400a1f0:	460a      	mov	r2, r1
3400a1f2:	4313      	orrs	r3, r2
3400a1f4:	f040 81ac 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a1f8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a1fc:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a200:	f002 4380 	and.w	r3, r2, #1073741824	@ 0x40000000
3400a204:	f8c7 3280 	str.w	r3, [r7, #640]	@ 0x280
3400a208:	2300      	movs	r3, #0
3400a20a:	f8c7 3284 	str.w	r3, [r7, #644]	@ 0x284
3400a20e:	e9d7 01a0 	ldrd	r0, r1, [r7, #640]	@ 0x280
3400a212:	4603      	mov	r3, r0
3400a214:	460a      	mov	r2, r1
3400a216:	4313      	orrs	r3, r2
3400a218:	f040 819a 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a21c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a220:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a224:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
3400a228:	f8c7 3278 	str.w	r3, [r7, #632]	@ 0x278
3400a22c:	2300      	movs	r3, #0
3400a22e:	f8c7 327c 	str.w	r3, [r7, #636]	@ 0x27c
3400a232:	e9d7 019e 	ldrd	r0, r1, [r7, #632]	@ 0x278
3400a236:	4603      	mov	r3, r0
3400a238:	460a      	mov	r2, r1
3400a23a:	4313      	orrs	r3, r2
3400a23c:	f040 8188 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a240:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a244:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a248:	2100      	movs	r1, #0
3400a24a:	f8c7 1270 	str.w	r1, [r7, #624]	@ 0x270
3400a24e:	f003 0301 	and.w	r3, r3, #1
3400a252:	f8c7 3274 	str.w	r3, [r7, #628]	@ 0x274
3400a256:	e9d7 019c 	ldrd	r0, r1, [r7, #624]	@ 0x270
3400a25a:	4603      	mov	r3, r0
3400a25c:	460a      	mov	r2, r1
3400a25e:	4313      	orrs	r3, r2
3400a260:	f040 8176 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a264:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a268:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a26c:	2100      	movs	r1, #0
3400a26e:	f8c7 1268 	str.w	r1, [r7, #616]	@ 0x268
3400a272:	f003 0302 	and.w	r3, r3, #2
3400a276:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
3400a27a:	e9d7 019a 	ldrd	r0, r1, [r7, #616]	@ 0x268
3400a27e:	4603      	mov	r3, r0
3400a280:	460a      	mov	r2, r1
3400a282:	4313      	orrs	r3, r2
3400a284:	f040 8164 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a288:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a28c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a290:	2100      	movs	r1, #0
3400a292:	f8c7 1260 	str.w	r1, [r7, #608]	@ 0x260
3400a296:	f003 0304 	and.w	r3, r3, #4
3400a29a:	f8c7 3264 	str.w	r3, [r7, #612]	@ 0x264
3400a29e:	e9d7 0198 	ldrd	r0, r1, [r7, #608]	@ 0x260
3400a2a2:	4603      	mov	r3, r0
3400a2a4:	460a      	mov	r2, r1
3400a2a6:	4313      	orrs	r3, r2
3400a2a8:	f040 8152 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a2ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a2b0:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a2b4:	2100      	movs	r1, #0
3400a2b6:	f8c7 1258 	str.w	r1, [r7, #600]	@ 0x258
3400a2ba:	f003 0308 	and.w	r3, r3, #8
3400a2be:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
3400a2c2:	e9d7 0196 	ldrd	r0, r1, [r7, #600]	@ 0x258
3400a2c6:	4603      	mov	r3, r0
3400a2c8:	460a      	mov	r2, r1
3400a2ca:	4313      	orrs	r3, r2
3400a2cc:	f040 8140 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a2d0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a2d4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a2d8:	2100      	movs	r1, #0
3400a2da:	f8c7 1250 	str.w	r1, [r7, #592]	@ 0x250
3400a2de:	f003 0310 	and.w	r3, r3, #16
3400a2e2:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
3400a2e6:	e9d7 0194 	ldrd	r0, r1, [r7, #592]	@ 0x250
3400a2ea:	4603      	mov	r3, r0
3400a2ec:	460a      	mov	r2, r1
3400a2ee:	4313      	orrs	r3, r2
3400a2f0:	f040 812e 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a2f4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a2f8:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a2fc:	2100      	movs	r1, #0
3400a2fe:	f8c7 1248 	str.w	r1, [r7, #584]	@ 0x248
3400a302:	f003 0320 	and.w	r3, r3, #32
3400a306:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
3400a30a:	e9d7 0192 	ldrd	r0, r1, [r7, #584]	@ 0x248
3400a30e:	4603      	mov	r3, r0
3400a310:	460a      	mov	r2, r1
3400a312:	4313      	orrs	r3, r2
3400a314:	f040 811c 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a318:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a31c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a320:	2100      	movs	r1, #0
3400a322:	f8c7 1240 	str.w	r1, [r7, #576]	@ 0x240
3400a326:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400a32a:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
3400a32e:	e9d7 0190 	ldrd	r0, r1, [r7, #576]	@ 0x240
3400a332:	4603      	mov	r3, r0
3400a334:	460a      	mov	r2, r1
3400a336:	4313      	orrs	r3, r2
3400a338:	f040 810a 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a33c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a340:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a344:	2100      	movs	r1, #0
3400a346:	f8c7 1238 	str.w	r1, [r7, #568]	@ 0x238
3400a34a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3400a34e:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
3400a352:	e9d7 018e 	ldrd	r0, r1, [r7, #568]	@ 0x238
3400a356:	4603      	mov	r3, r0
3400a358:	460a      	mov	r2, r1
3400a35a:	4313      	orrs	r3, r2
3400a35c:	f040 80f8 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a360:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a364:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a368:	2100      	movs	r1, #0
3400a36a:	f8c7 1230 	str.w	r1, [r7, #560]	@ 0x230
3400a36e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400a372:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
3400a376:	e9d7 018c 	ldrd	r0, r1, [r7, #560]	@ 0x230
3400a37a:	4603      	mov	r3, r0
3400a37c:	460a      	mov	r2, r1
3400a37e:	4313      	orrs	r3, r2
3400a380:	f040 80e6 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a384:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a388:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a38c:	2100      	movs	r1, #0
3400a38e:	f8c7 1228 	str.w	r1, [r7, #552]	@ 0x228
3400a392:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400a396:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
3400a39a:	e9d7 018a 	ldrd	r0, r1, [r7, #552]	@ 0x228
3400a39e:	4603      	mov	r3, r0
3400a3a0:	460a      	mov	r2, r1
3400a3a2:	4313      	orrs	r3, r2
3400a3a4:	f040 80d4 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a3a8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a3ac:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a3b0:	2100      	movs	r1, #0
3400a3b2:	f8c7 1220 	str.w	r1, [r7, #544]	@ 0x220
3400a3b6:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3400a3ba:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
3400a3be:	e9d7 0188 	ldrd	r0, r1, [r7, #544]	@ 0x220
3400a3c2:	4603      	mov	r3, r0
3400a3c4:	460a      	mov	r2, r1
3400a3c6:	4313      	orrs	r3, r2
3400a3c8:	f040 80c2 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a3cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a3d0:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a3d4:	2100      	movs	r1, #0
3400a3d6:	f8c7 1218 	str.w	r1, [r7, #536]	@ 0x218
3400a3da:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3400a3de:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
3400a3e2:	e9d7 0186 	ldrd	r0, r1, [r7, #536]	@ 0x218
3400a3e6:	4603      	mov	r3, r0
3400a3e8:	460a      	mov	r2, r1
3400a3ea:	4313      	orrs	r3, r2
3400a3ec:	f040 80b0 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a3f0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a3f4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a3f8:	2100      	movs	r1, #0
3400a3fa:	f8c7 1210 	str.w	r1, [r7, #528]	@ 0x210
3400a3fe:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3400a402:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
3400a406:	e9d7 0184 	ldrd	r0, r1, [r7, #528]	@ 0x210
3400a40a:	4603      	mov	r3, r0
3400a40c:	460a      	mov	r2, r1
3400a40e:	4313      	orrs	r3, r2
3400a410:	f040 809e 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a414:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a418:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a41c:	2100      	movs	r1, #0
3400a41e:	f8c7 1208 	str.w	r1, [r7, #520]	@ 0x208
3400a422:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
3400a426:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
3400a42a:	e9d7 0182 	ldrd	r0, r1, [r7, #520]	@ 0x208
3400a42e:	4603      	mov	r3, r0
3400a430:	460a      	mov	r2, r1
3400a432:	4313      	orrs	r3, r2
3400a434:	f040 808c 	bne.w	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a438:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a43c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a440:	2100      	movs	r1, #0
3400a442:	f8c7 1200 	str.w	r1, [r7, #512]	@ 0x200
3400a446:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3400a44a:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
3400a44e:	e9d7 0180 	ldrd	r0, r1, [r7, #512]	@ 0x200
3400a452:	4603      	mov	r3, r0
3400a454:	460a      	mov	r2, r1
3400a456:	4313      	orrs	r3, r2
3400a458:	d17a      	bne.n	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a45a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a45e:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a462:	2100      	movs	r1, #0
3400a464:	f8c7 11f8 	str.w	r1, [r7, #504]	@ 0x1f8
3400a468:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
3400a46c:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
3400a470:	e9d7 017e 	ldrd	r0, r1, [r7, #504]	@ 0x1f8
3400a474:	4603      	mov	r3, r0
3400a476:	460a      	mov	r2, r1
3400a478:	4313      	orrs	r3, r2
3400a47a:	d169      	bne.n	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a47c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a480:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a484:	2100      	movs	r1, #0
3400a486:	f8c7 11f0 	str.w	r1, [r7, #496]	@ 0x1f0
3400a48a:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3400a48e:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
3400a492:	e9d7 017c 	ldrd	r0, r1, [r7, #496]	@ 0x1f0
3400a496:	4603      	mov	r3, r0
3400a498:	460a      	mov	r2, r1
3400a49a:	4313      	orrs	r3, r2
3400a49c:	d158      	bne.n	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a49e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a4a2:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a4a6:	2100      	movs	r1, #0
3400a4a8:	f8c7 11e8 	str.w	r1, [r7, #488]	@ 0x1e8
3400a4ac:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
3400a4b0:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
3400a4b4:	e9d7 017a 	ldrd	r0, r1, [r7, #488]	@ 0x1e8
3400a4b8:	4603      	mov	r3, r0
3400a4ba:	460a      	mov	r2, r1
3400a4bc:	4313      	orrs	r3, r2
3400a4be:	d147      	bne.n	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a4c0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a4c4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a4c8:	2100      	movs	r1, #0
3400a4ca:	f8c7 11e0 	str.w	r1, [r7, #480]	@ 0x1e0
3400a4ce:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
3400a4d2:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
3400a4d6:	e9d7 0178 	ldrd	r0, r1, [r7, #480]	@ 0x1e0
3400a4da:	4603      	mov	r3, r0
3400a4dc:	460a      	mov	r2, r1
3400a4de:	4313      	orrs	r3, r2
3400a4e0:	d136      	bne.n	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a4e2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a4e6:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a4ea:	2100      	movs	r1, #0
3400a4ec:	f8c7 11d8 	str.w	r1, [r7, #472]	@ 0x1d8
3400a4f0:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
3400a4f4:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
3400a4f8:	e9d7 0176 	ldrd	r0, r1, [r7, #472]	@ 0x1d8
3400a4fc:	4603      	mov	r3, r0
3400a4fe:	460a      	mov	r2, r1
3400a500:	4313      	orrs	r3, r2
3400a502:	d125      	bne.n	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a504:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a508:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a50c:	2100      	movs	r1, #0
3400a50e:	f8c7 11d0 	str.w	r1, [r7, #464]	@ 0x1d0
3400a512:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
3400a516:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
3400a51a:	e9d7 0174 	ldrd	r0, r1, [r7, #464]	@ 0x1d0
3400a51e:	4603      	mov	r3, r0
3400a520:	460a      	mov	r2, r1
3400a522:	4313      	orrs	r3, r2
3400a524:	d114      	bne.n	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a526:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a52a:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a52e:	2100      	movs	r1, #0
3400a530:	f8c7 11c8 	str.w	r1, [r7, #456]	@ 0x1c8
3400a534:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
3400a538:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
3400a53c:	e9d7 0172 	ldrd	r0, r1, [r7, #456]	@ 0x1c8
3400a540:	4603      	mov	r3, r0
3400a542:	460a      	mov	r2, r1
3400a544:	4313      	orrs	r3, r2
3400a546:	d103      	bne.n	3400a550 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400a548:	2188      	movs	r1, #136	@ 0x88
3400a54a:	48d3      	ldr	r0, [pc, #844]	@ (3400a898 <HAL_RCCEx_PeriphCLKConfig+0xb38>)
3400a54c:	f7f7 fd60 	bl	34002010 <assert_failed>

  /*---------------------------- RTC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
3400a550:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a554:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a558:	f002 6300 	and.w	r3, r2, #134217728	@ 0x8000000
3400a55c:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
3400a560:	2300      	movs	r3, #0
3400a562:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
3400a566:	e9d7 0170 	ldrd	r0, r1, [r7, #448]	@ 0x1c0
3400a56a:	4603      	mov	r3, r0
3400a56c:	460a      	mov	r2, r1
3400a56e:	4313      	orrs	r3, r2
3400a570:	f000 82b5 	beq.w	3400aade <HAL_RCCEx_PeriphCLKConfig+0xd7e>
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
3400a574:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a578:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400a57c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400a580:	f000 8240 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a584:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a588:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400a58c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400a590:	f000 8238 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a594:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a598:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400a59c:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3400a5a0:	f000 8230 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a5a4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a5a8:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400a5ac:	f5b3 5f98 	cmp.w	r3, #4864	@ 0x1300
3400a5b0:	f000 8228 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a5b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a5b8:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400a5bc:	f5b3 5f0c 	cmp.w	r3, #8960	@ 0x2300
3400a5c0:	f000 8220 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a5c4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a5c8:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400a5cc:	f5b3 5f4c 	cmp.w	r3, #13056	@ 0x3300
3400a5d0:	f000 8218 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a5d4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a5d8:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400a5dc:	f5b3 4f86 	cmp.w	r3, #17152	@ 0x4300
3400a5e0:	f000 8210 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a5e4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a5e8:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400a5ec:	f5b3 4fa6 	cmp.w	r3, #21248	@ 0x5300
3400a5f0:	f000 8208 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a5f4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a5f8:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400a5fc:	f5b3 4fc6 	cmp.w	r3, #25344	@ 0x6300
3400a600:	f000 8200 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a604:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a608:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400a60c:	f5b3 4fe6 	cmp.w	r3, #29440	@ 0x7300
3400a610:	f000 81f8 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a614:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a618:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400a61c:	f5b3 4f03 	cmp.w	r3, #33536	@ 0x8300
3400a620:	f000 81f0 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a624:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a628:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400a62c:	f5b3 4f13 	cmp.w	r3, #37632	@ 0x9300
3400a630:	f000 81e8 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a634:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a638:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400a63c:	f5b3 4f23 	cmp.w	r3, #41728	@ 0xa300
3400a640:	f000 81e0 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a644:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a648:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400a64c:	f5b3 4f33 	cmp.w	r3, #45824	@ 0xb300
3400a650:	f000 81d8 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a654:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a658:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400a65c:	f5b3 4f43 	cmp.w	r3, #49920	@ 0xc300
3400a660:	f000 81d0 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a664:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a668:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400a66c:	f5b3 4f53 	cmp.w	r3, #54016	@ 0xd300
3400a670:	f000 81c8 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a674:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a678:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400a67c:	f5b3 4f63 	cmp.w	r3, #58112	@ 0xe300
3400a680:	f000 81c0 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a684:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a688:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400a68c:	f5b3 4f73 	cmp.w	r3, #62208	@ 0xf300
3400a690:	f000 81b8 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a694:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a698:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a69c:	4b7f      	ldr	r3, [pc, #508]	@ (3400a89c <HAL_RCCEx_PeriphCLKConfig+0xb3c>)
3400a69e:	429a      	cmp	r2, r3
3400a6a0:	f000 81b0 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a6a4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a6a8:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a6ac:	4b7c      	ldr	r3, [pc, #496]	@ (3400a8a0 <HAL_RCCEx_PeriphCLKConfig+0xb40>)
3400a6ae:	429a      	cmp	r2, r3
3400a6b0:	f000 81a8 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a6b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a6b8:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a6bc:	4b79      	ldr	r3, [pc, #484]	@ (3400a8a4 <HAL_RCCEx_PeriphCLKConfig+0xb44>)
3400a6be:	429a      	cmp	r2, r3
3400a6c0:	f000 81a0 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a6c4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a6c8:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a6cc:	4b76      	ldr	r3, [pc, #472]	@ (3400a8a8 <HAL_RCCEx_PeriphCLKConfig+0xb48>)
3400a6ce:	429a      	cmp	r2, r3
3400a6d0:	f000 8198 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a6d4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a6d8:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a6dc:	4b73      	ldr	r3, [pc, #460]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0xb4c>)
3400a6de:	429a      	cmp	r2, r3
3400a6e0:	f000 8190 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a6e4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a6e8:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a6ec:	4b70      	ldr	r3, [pc, #448]	@ (3400a8b0 <HAL_RCCEx_PeriphCLKConfig+0xb50>)
3400a6ee:	429a      	cmp	r2, r3
3400a6f0:	f000 8188 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a6f4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a6f8:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a6fc:	4b6d      	ldr	r3, [pc, #436]	@ (3400a8b4 <HAL_RCCEx_PeriphCLKConfig+0xb54>)
3400a6fe:	429a      	cmp	r2, r3
3400a700:	f000 8180 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a704:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a708:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a70c:	4b6a      	ldr	r3, [pc, #424]	@ (3400a8b8 <HAL_RCCEx_PeriphCLKConfig+0xb58>)
3400a70e:	429a      	cmp	r2, r3
3400a710:	f000 8178 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a714:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a718:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a71c:	4b67      	ldr	r3, [pc, #412]	@ (3400a8bc <HAL_RCCEx_PeriphCLKConfig+0xb5c>)
3400a71e:	429a      	cmp	r2, r3
3400a720:	f000 8170 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a724:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a728:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a72c:	4b64      	ldr	r3, [pc, #400]	@ (3400a8c0 <HAL_RCCEx_PeriphCLKConfig+0xb60>)
3400a72e:	429a      	cmp	r2, r3
3400a730:	f000 8168 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a734:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a738:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a73c:	4b61      	ldr	r3, [pc, #388]	@ (3400a8c4 <HAL_RCCEx_PeriphCLKConfig+0xb64>)
3400a73e:	429a      	cmp	r2, r3
3400a740:	f000 8160 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a744:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a748:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a74c:	4b5e      	ldr	r3, [pc, #376]	@ (3400a8c8 <HAL_RCCEx_PeriphCLKConfig+0xb68>)
3400a74e:	429a      	cmp	r2, r3
3400a750:	f000 8158 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a754:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a758:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a75c:	4b5b      	ldr	r3, [pc, #364]	@ (3400a8cc <HAL_RCCEx_PeriphCLKConfig+0xb6c>)
3400a75e:	429a      	cmp	r2, r3
3400a760:	f000 8150 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a764:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a768:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a76c:	4b58      	ldr	r3, [pc, #352]	@ (3400a8d0 <HAL_RCCEx_PeriphCLKConfig+0xb70>)
3400a76e:	429a      	cmp	r2, r3
3400a770:	f000 8148 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a774:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a778:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a77c:	4b55      	ldr	r3, [pc, #340]	@ (3400a8d4 <HAL_RCCEx_PeriphCLKConfig+0xb74>)
3400a77e:	429a      	cmp	r2, r3
3400a780:	f000 8140 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a784:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a788:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a78c:	4b52      	ldr	r3, [pc, #328]	@ (3400a8d8 <HAL_RCCEx_PeriphCLKConfig+0xb78>)
3400a78e:	429a      	cmp	r2, r3
3400a790:	f000 8138 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a794:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a798:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a79c:	4b4f      	ldr	r3, [pc, #316]	@ (3400a8dc <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
3400a79e:	429a      	cmp	r2, r3
3400a7a0:	f000 8130 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a7a4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a7a8:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a7ac:	4b4c      	ldr	r3, [pc, #304]	@ (3400a8e0 <HAL_RCCEx_PeriphCLKConfig+0xb80>)
3400a7ae:	429a      	cmp	r2, r3
3400a7b0:	f000 8128 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a7b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a7b8:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a7bc:	4b49      	ldr	r3, [pc, #292]	@ (3400a8e4 <HAL_RCCEx_PeriphCLKConfig+0xb84>)
3400a7be:	429a      	cmp	r2, r3
3400a7c0:	f000 8120 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a7c4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a7c8:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a7cc:	4b46      	ldr	r3, [pc, #280]	@ (3400a8e8 <HAL_RCCEx_PeriphCLKConfig+0xb88>)
3400a7ce:	429a      	cmp	r2, r3
3400a7d0:	f000 8118 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a7d4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a7d8:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a7dc:	4b43      	ldr	r3, [pc, #268]	@ (3400a8ec <HAL_RCCEx_PeriphCLKConfig+0xb8c>)
3400a7de:	429a      	cmp	r2, r3
3400a7e0:	f000 8110 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a7e4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a7e8:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a7ec:	4b40      	ldr	r3, [pc, #256]	@ (3400a8f0 <HAL_RCCEx_PeriphCLKConfig+0xb90>)
3400a7ee:	429a      	cmp	r2, r3
3400a7f0:	f000 8108 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a7f4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a7f8:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a7fc:	4b3d      	ldr	r3, [pc, #244]	@ (3400a8f4 <HAL_RCCEx_PeriphCLKConfig+0xb94>)
3400a7fe:	429a      	cmp	r2, r3
3400a800:	f000 8100 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a804:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a808:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a80c:	4b3a      	ldr	r3, [pc, #232]	@ (3400a8f8 <HAL_RCCEx_PeriphCLKConfig+0xb98>)
3400a80e:	429a      	cmp	r2, r3
3400a810:	f000 80f8 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a814:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a818:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a81c:	4b37      	ldr	r3, [pc, #220]	@ (3400a8fc <HAL_RCCEx_PeriphCLKConfig+0xb9c>)
3400a81e:	429a      	cmp	r2, r3
3400a820:	f000 80f0 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a824:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a828:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a82c:	4b34      	ldr	r3, [pc, #208]	@ (3400a900 <HAL_RCCEx_PeriphCLKConfig+0xba0>)
3400a82e:	429a      	cmp	r2, r3
3400a830:	f000 80e8 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a834:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a838:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a83c:	4b31      	ldr	r3, [pc, #196]	@ (3400a904 <HAL_RCCEx_PeriphCLKConfig+0xba4>)
3400a83e:	429a      	cmp	r2, r3
3400a840:	f000 80e0 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a844:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a848:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a84c:	4b2e      	ldr	r3, [pc, #184]	@ (3400a908 <HAL_RCCEx_PeriphCLKConfig+0xba8>)
3400a84e:	429a      	cmp	r2, r3
3400a850:	f000 80d8 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a854:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a858:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a85c:	4b2b      	ldr	r3, [pc, #172]	@ (3400a90c <HAL_RCCEx_PeriphCLKConfig+0xbac>)
3400a85e:	429a      	cmp	r2, r3
3400a860:	f000 80d0 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a864:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a868:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a86c:	4b28      	ldr	r3, [pc, #160]	@ (3400a910 <HAL_RCCEx_PeriphCLKConfig+0xbb0>)
3400a86e:	429a      	cmp	r2, r3
3400a870:	f000 80c8 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a874:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a878:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a87c:	4b25      	ldr	r3, [pc, #148]	@ (3400a914 <HAL_RCCEx_PeriphCLKConfig+0xbb4>)
3400a87e:	429a      	cmp	r2, r3
3400a880:	f000 80c0 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a884:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a888:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a88c:	4b22      	ldr	r3, [pc, #136]	@ (3400a918 <HAL_RCCEx_PeriphCLKConfig+0xbb8>)
3400a88e:	429a      	cmp	r2, r3
3400a890:	f000 80b8 	beq.w	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a894:	e042      	b.n	3400a91c <HAL_RCCEx_PeriphCLKConfig+0xbbc>
3400a896:	bf00      	nop
3400a898:	3401ee60 	.word	0x3401ee60
3400a89c:	00010300 	.word	0x00010300
3400a8a0:	00011300 	.word	0x00011300
3400a8a4:	00012300 	.word	0x00012300
3400a8a8:	00013300 	.word	0x00013300
3400a8ac:	00014300 	.word	0x00014300
3400a8b0:	00015300 	.word	0x00015300
3400a8b4:	00016300 	.word	0x00016300
3400a8b8:	00017300 	.word	0x00017300
3400a8bc:	00018300 	.word	0x00018300
3400a8c0:	00019300 	.word	0x00019300
3400a8c4:	0001a300 	.word	0x0001a300
3400a8c8:	0001b300 	.word	0x0001b300
3400a8cc:	0001c300 	.word	0x0001c300
3400a8d0:	0001d300 	.word	0x0001d300
3400a8d4:	0001e300 	.word	0x0001e300
3400a8d8:	0001f300 	.word	0x0001f300
3400a8dc:	00020300 	.word	0x00020300
3400a8e0:	00021300 	.word	0x00021300
3400a8e4:	00022300 	.word	0x00022300
3400a8e8:	00023300 	.word	0x00023300
3400a8ec:	00024300 	.word	0x00024300
3400a8f0:	00025300 	.word	0x00025300
3400a8f4:	00026300 	.word	0x00026300
3400a8f8:	00027300 	.word	0x00027300
3400a8fc:	00028300 	.word	0x00028300
3400a900:	00029300 	.word	0x00029300
3400a904:	0002a300 	.word	0x0002a300
3400a908:	0002b300 	.word	0x0002b300
3400a90c:	0002c300 	.word	0x0002c300
3400a910:	0002d300 	.word	0x0002d300
3400a914:	0002e300 	.word	0x0002e300
3400a918:	0002f300 	.word	0x0002f300
3400a91c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a920:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a924:	4bb4      	ldr	r3, [pc, #720]	@ (3400abf8 <HAL_RCCEx_PeriphCLKConfig+0xe98>)
3400a926:	429a      	cmp	r2, r3
3400a928:	d06c      	beq.n	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a92a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a92e:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a932:	4bb2      	ldr	r3, [pc, #712]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0xe9c>)
3400a934:	429a      	cmp	r2, r3
3400a936:	d065      	beq.n	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a938:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a93c:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a940:	4baf      	ldr	r3, [pc, #700]	@ (3400ac00 <HAL_RCCEx_PeriphCLKConfig+0xea0>)
3400a942:	429a      	cmp	r2, r3
3400a944:	d05e      	beq.n	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a946:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a94a:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a94e:	4bad      	ldr	r3, [pc, #692]	@ (3400ac04 <HAL_RCCEx_PeriphCLKConfig+0xea4>)
3400a950:	429a      	cmp	r2, r3
3400a952:	d057      	beq.n	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a954:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a958:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a95c:	4baa      	ldr	r3, [pc, #680]	@ (3400ac08 <HAL_RCCEx_PeriphCLKConfig+0xea8>)
3400a95e:	429a      	cmp	r2, r3
3400a960:	d050      	beq.n	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a962:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a966:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a96a:	4ba8      	ldr	r3, [pc, #672]	@ (3400ac0c <HAL_RCCEx_PeriphCLKConfig+0xeac>)
3400a96c:	429a      	cmp	r2, r3
3400a96e:	d049      	beq.n	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a970:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a974:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a978:	4ba5      	ldr	r3, [pc, #660]	@ (3400ac10 <HAL_RCCEx_PeriphCLKConfig+0xeb0>)
3400a97a:	429a      	cmp	r2, r3
3400a97c:	d042      	beq.n	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a97e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a982:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a986:	4ba3      	ldr	r3, [pc, #652]	@ (3400ac14 <HAL_RCCEx_PeriphCLKConfig+0xeb4>)
3400a988:	429a      	cmp	r2, r3
3400a98a:	d03b      	beq.n	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a98c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a990:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a994:	4ba0      	ldr	r3, [pc, #640]	@ (3400ac18 <HAL_RCCEx_PeriphCLKConfig+0xeb8>)
3400a996:	429a      	cmp	r2, r3
3400a998:	d034      	beq.n	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a99a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a99e:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a9a2:	4b9e      	ldr	r3, [pc, #632]	@ (3400ac1c <HAL_RCCEx_PeriphCLKConfig+0xebc>)
3400a9a4:	429a      	cmp	r2, r3
3400a9a6:	d02d      	beq.n	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a9a8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a9ac:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a9b0:	4b9b      	ldr	r3, [pc, #620]	@ (3400ac20 <HAL_RCCEx_PeriphCLKConfig+0xec0>)
3400a9b2:	429a      	cmp	r2, r3
3400a9b4:	d026      	beq.n	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a9b6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a9ba:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a9be:	4b99      	ldr	r3, [pc, #612]	@ (3400ac24 <HAL_RCCEx_PeriphCLKConfig+0xec4>)
3400a9c0:	429a      	cmp	r2, r3
3400a9c2:	d01f      	beq.n	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a9c4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a9c8:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a9cc:	4b96      	ldr	r3, [pc, #600]	@ (3400ac28 <HAL_RCCEx_PeriphCLKConfig+0xec8>)
3400a9ce:	429a      	cmp	r2, r3
3400a9d0:	d018      	beq.n	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a9d2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a9d6:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a9da:	4b94      	ldr	r3, [pc, #592]	@ (3400ac2c <HAL_RCCEx_PeriphCLKConfig+0xecc>)
3400a9dc:	429a      	cmp	r2, r3
3400a9de:	d011      	beq.n	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a9e0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a9e4:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a9e8:	4b91      	ldr	r3, [pc, #580]	@ (3400ac30 <HAL_RCCEx_PeriphCLKConfig+0xed0>)
3400a9ea:	429a      	cmp	r2, r3
3400a9ec:	d00a      	beq.n	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a9ee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400a9f2:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400a9f6:	4b8f      	ldr	r3, [pc, #572]	@ (3400ac34 <HAL_RCCEx_PeriphCLKConfig+0xed4>)
3400a9f8:	429a      	cmp	r2, r3
3400a9fa:	d003      	beq.n	3400aa04 <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400a9fc:	218e      	movs	r1, #142	@ 0x8e
3400a9fe:	488e      	ldr	r0, [pc, #568]	@ (3400ac38 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
3400aa00:	f7f7 fb06 	bl	34002010 <assert_failed>

    /* As the RTC clock source selection can be changed only if the Backup Domain is reset */
    /* reset the Backup domain only if the RTC Clock source selection is modified from default reset value */
    tmpreg = LL_RCC_GetRTCClockSource();
3400aa04:	f7fe fae2 	bl	34008fcc <LL_RCC_GetRTCClockSource>
3400aa08:	f8c7 0388 	str.w	r0, [r7, #904]	@ 0x388

    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
3400aa0c:	f8d7 3388 	ldr.w	r3, [r7, #904]	@ 0x388
3400aa10:	2b00      	cmp	r3, #0
3400aa12:	d018      	beq.n	3400aa46 <HAL_RCCEx_PeriphCLKConfig+0xce6>
3400aa14:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400aa18:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400aa1c:	f403 7240 	and.w	r2, r3, #768	@ 0x300
3400aa20:	f8d7 3388 	ldr.w	r3, [r7, #904]	@ 0x388
3400aa24:	4293      	cmp	r3, r2
3400aa26:	d00e      	beq.n	3400aa46 <HAL_RCCEx_PeriphCLKConfig+0xce6>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
3400aa28:	4b84      	ldr	r3, [pc, #528]	@ (3400ac3c <HAL_RCCEx_PeriphCLKConfig+0xedc>)
3400aa2a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400aa2c:	4a83      	ldr	r2, [pc, #524]	@ (3400ac3c <HAL_RCCEx_PeriphCLKConfig+0xedc>)
3400aa2e:	f043 0301 	orr.w	r3, r3, #1
3400aa32:	62d3      	str	r3, [r2, #44]	@ 0x2c

      /* Read back to check Backup domain enabled */
      if (READ_BIT(PWR->DBPCR, PWR_DBPCR_DBP) == 0U)
3400aa34:	4b81      	ldr	r3, [pc, #516]	@ (3400ac3c <HAL_RCCEx_PeriphCLKConfig+0xedc>)
3400aa36:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400aa38:	f003 0301 	and.w	r3, r3, #1
3400aa3c:	2b00      	cmp	r3, #0
3400aa3e:	d102      	bne.n	3400aa46 <HAL_RCCEx_PeriphCLKConfig+0xce6>
      {
        ret = HAL_ERROR;
3400aa40:	2301      	movs	r3, #1
3400aa42:	f887 338f 	strb.w	r3, [r7, #911]	@ 0x38f
        WRITE_REG(RCC->BDCR, tmpreg);
#endif /* #if 0  TO DO */
      }
    }

    if (ret == HAL_OK)
3400aa46:	f897 338f 	ldrb.w	r3, [r7, #911]	@ 0x38f
3400aa4a:	2b00      	cmp	r3, #0
3400aa4c:	d143      	bne.n	3400aad6 <HAL_RCCEx_PeriphCLKConfig+0xd76>
    {
      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
3400aa4e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400aa52:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400aa56:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400aa5a:	d117      	bne.n	3400aa8c <HAL_RCCEx_PeriphCLKConfig+0xd2c>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3400aa5c:	f7f9 fafa 	bl	34004054 <HAL_GetTick>
3400aa60:	f8c7 0384 	str.w	r0, [r7, #900]	@ 0x384

        /* Wait till LSE is ready */
        while (LL_RCC_LSE_IsReady() == 0U)
3400aa64:	e00d      	b.n	3400aa82 <HAL_RCCEx_PeriphCLKConfig+0xd22>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400aa66:	f7f9 faf5 	bl	34004054 <HAL_GetTick>
3400aa6a:	4602      	mov	r2, r0
3400aa6c:	f8d7 3384 	ldr.w	r3, [r7, #900]	@ 0x384
3400aa70:	1ad2      	subs	r2, r2, r3
3400aa72:	f241 3388 	movw	r3, #5000	@ 0x1388
3400aa76:	429a      	cmp	r2, r3
3400aa78:	d903      	bls.n	3400aa82 <HAL_RCCEx_PeriphCLKConfig+0xd22>
          {
            ret = HAL_TIMEOUT;
3400aa7a:	2303      	movs	r3, #3
3400aa7c:	f887 338f 	strb.w	r3, [r7, #911]	@ 0x38f
            break;
3400aa80:	e004      	b.n	3400aa8c <HAL_RCCEx_PeriphCLKConfig+0xd2c>
        while (LL_RCC_LSE_IsReady() == 0U)
3400aa82:	f7fd feb5 	bl	340087f0 <LL_RCC_LSE_IsReady>
3400aa86:	4603      	mov	r3, r0
3400aa88:	2b00      	cmp	r3, #0
3400aa8a:	d0ec      	beq.n	3400aa66 <HAL_RCCEx_PeriphCLKConfig+0xd06>
          }
        }
      }

      if (ret == HAL_OK)
3400aa8c:	f897 338f 	ldrb.w	r3, [r7, #911]	@ 0x38f
3400aa90:	2b00      	cmp	r3, #0
3400aa92:	d11b      	bne.n	3400aacc <HAL_RCCEx_PeriphCLKConfig+0xd6c>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
3400aa94:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400aa98:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400aa9c:	f403 7340 	and.w	r3, r3, #768	@ 0x300
3400aaa0:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3400aaa4:	d108      	bne.n	3400aab8 <HAL_RCCEx_PeriphCLKConfig+0xd58>
3400aaa6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400aaaa:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400aaae:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
3400aab2:	4618      	mov	r0, r3
3400aab4:	f7fe fa98 	bl	34008fe8 <LL_RCC_SetRTC_HSEPrescaler>
3400aab8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400aabc:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400aac0:	f403 7340 	and.w	r3, r3, #768	@ 0x300
3400aac4:	4618      	mov	r0, r3
3400aac6:	f7fe fa6b 	bl	34008fa0 <LL_RCC_SetRTCClockSource>
3400aaca:	e008      	b.n	3400aade <HAL_RCCEx_PeriphCLKConfig+0xd7e>
      }
      else
      {
        /* set overall return value */
        status = ret;
3400aacc:	f897 338f 	ldrb.w	r3, [r7, #911]	@ 0x38f
3400aad0:	f887 338e 	strb.w	r3, [r7, #910]	@ 0x38e
3400aad4:	e003      	b.n	3400aade <HAL_RCCEx_PeriphCLKConfig+0xd7e>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
3400aad6:	f897 338f 	ldrb.w	r3, [r7, #911]	@ 0x38f
3400aada:	f887 338e 	strb.w	r3, [r7, #910]	@ 0x38e
    }
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
3400aade:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400aae2:	e9d3 2300 	ldrd	r2, r3, [r3]
3400aae6:	f002 0304 	and.w	r3, r2, #4
3400aaea:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
3400aaee:	2300      	movs	r3, #0
3400aaf0:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
3400aaf4:	e9d7 016e 	ldrd	r0, r1, [r7, #440]	@ 0x1b8
3400aaf8:	4603      	mov	r3, r0
3400aafa:	460a      	mov	r2, r1
3400aafc:	4313      	orrs	r3, r2
3400aafe:	f000 81dc 	beq.w	3400aeba <HAL_RCCEx_PeriphCLKConfig+0x115a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CKPERCLKSOURCE(PeriphClkInit->CkperClockSelection));
3400ab02:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ab06:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400ab0a:	2b00      	cmp	r3, #0
3400ab0c:	d02d      	beq.n	3400ab6a <HAL_RCCEx_PeriphCLKConfig+0xe0a>
3400ab0e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ab12:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400ab16:	2b01      	cmp	r3, #1
3400ab18:	d027      	beq.n	3400ab6a <HAL_RCCEx_PeriphCLKConfig+0xe0a>
3400ab1a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ab1e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400ab22:	2b02      	cmp	r3, #2
3400ab24:	d021      	beq.n	3400ab6a <HAL_RCCEx_PeriphCLKConfig+0xe0a>
3400ab26:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ab2a:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400ab2e:	2b03      	cmp	r3, #3
3400ab30:	d01b      	beq.n	3400ab6a <HAL_RCCEx_PeriphCLKConfig+0xe0a>
3400ab32:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ab36:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400ab3a:	2b04      	cmp	r3, #4
3400ab3c:	d015      	beq.n	3400ab6a <HAL_RCCEx_PeriphCLKConfig+0xe0a>
3400ab3e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ab42:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400ab46:	2b05      	cmp	r3, #5
3400ab48:	d00f      	beq.n	3400ab6a <HAL_RCCEx_PeriphCLKConfig+0xe0a>
3400ab4a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ab4e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400ab52:	2b06      	cmp	r3, #6
3400ab54:	d009      	beq.n	3400ab6a <HAL_RCCEx_PeriphCLKConfig+0xe0a>
3400ab56:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ab5a:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400ab5e:	2b07      	cmp	r3, #7
3400ab60:	d003      	beq.n	3400ab6a <HAL_RCCEx_PeriphCLKConfig+0xe0a>
3400ab62:	21d4      	movs	r1, #212	@ 0xd4
3400ab64:	4834      	ldr	r0, [pc, #208]	@ (3400ac38 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
3400ab66:	f7f7 fa53 	bl	34002010 <assert_failed>

    if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC5)
3400ab6a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ab6e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400ab72:	2b04      	cmp	r3, #4
3400ab74:	d166      	bne.n	3400ac44 <HAL_RCCEx_PeriphCLKConfig+0xee4>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
3400ab76:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ab7a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400ab7c:	2b00      	cmp	r3, #0
3400ab7e:	d015      	beq.n	3400abac <HAL_RCCEx_PeriphCLKConfig+0xe4c>
3400ab80:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ab84:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400ab86:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ab8a:	d00f      	beq.n	3400abac <HAL_RCCEx_PeriphCLKConfig+0xe4c>
3400ab8c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ab90:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400ab92:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ab96:	d009      	beq.n	3400abac <HAL_RCCEx_PeriphCLKConfig+0xe4c>
3400ab98:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ab9c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400ab9e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400aba2:	d003      	beq.n	3400abac <HAL_RCCEx_PeriphCLKConfig+0xe4c>
3400aba4:	21d9      	movs	r1, #217	@ 0xd9
3400aba6:	4824      	ldr	r0, [pc, #144]	@ (3400ac38 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
3400aba8:	f7f7 fa32 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));
3400abac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400abb0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400abb2:	2b00      	cmp	r3, #0
3400abb4:	d005      	beq.n	3400abc2 <HAL_RCCEx_PeriphCLKConfig+0xe62>
3400abb6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400abba:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400abbc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400abc0:	d903      	bls.n	3400abca <HAL_RCCEx_PeriphCLKConfig+0xe6a>
3400abc2:	21da      	movs	r1, #218	@ 0xda
3400abc4:	481c      	ldr	r0, [pc, #112]	@ (3400ac38 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
3400abc6:	f7f7 fa23 	bl	34002010 <assert_failed>

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3400abca:	4b1d      	ldr	r3, [pc, #116]	@ (3400ac40 <HAL_RCCEx_PeriphCLKConfig+0xee0>)
3400abcc:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3400abd0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400abd4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400abd8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400abdc:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3400abde:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400abe2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400abe4:	3b01      	subs	r3, #1
3400abe6:	041b      	lsls	r3, r3, #16
3400abe8:	4313      	orrs	r3, r2
3400abea:	4a15      	ldr	r2, [pc, #84]	@ (3400ac40 <HAL_RCCEx_PeriphCLKConfig+0xee0>)
3400abec:	430b      	orrs	r3, r1
3400abee:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
3400abf2:	f7fe fd13 	bl	3400961c <LL_RCC_IC5_Enable>
3400abf6:	e159      	b.n	3400aeac <HAL_RCCEx_PeriphCLKConfig+0x114c>
3400abf8:	00030300 	.word	0x00030300
3400abfc:	00031300 	.word	0x00031300
3400ac00:	00032300 	.word	0x00032300
3400ac04:	00033300 	.word	0x00033300
3400ac08:	00034300 	.word	0x00034300
3400ac0c:	00035300 	.word	0x00035300
3400ac10:	00036300 	.word	0x00036300
3400ac14:	00037300 	.word	0x00037300
3400ac18:	00038300 	.word	0x00038300
3400ac1c:	00039300 	.word	0x00039300
3400ac20:	0003a300 	.word	0x0003a300
3400ac24:	0003b300 	.word	0x0003b300
3400ac28:	0003c300 	.word	0x0003c300
3400ac2c:	0003d300 	.word	0x0003d300
3400ac30:	0003e300 	.word	0x0003e300
3400ac34:	0003f300 	.word	0x0003f300
3400ac38:	3401ee60 	.word	0x3401ee60
3400ac3c:	56024800 	.word	0x56024800
3400ac40:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC10)
3400ac44:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ac48:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400ac4c:	2b05      	cmp	r3, #5
3400ac4e:	d140      	bne.n	3400acd2 <HAL_RCCEx_PeriphCLKConfig+0xf72>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400ac50:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ac54:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400ac56:	2b00      	cmp	r3, #0
3400ac58:	d015      	beq.n	3400ac86 <HAL_RCCEx_PeriphCLKConfig+0xf26>
3400ac5a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ac5e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400ac60:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ac64:	d00f      	beq.n	3400ac86 <HAL_RCCEx_PeriphCLKConfig+0xf26>
3400ac66:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ac6a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400ac6c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ac70:	d009      	beq.n	3400ac86 <HAL_RCCEx_PeriphCLKConfig+0xf26>
3400ac72:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ac76:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400ac78:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ac7c:	d003      	beq.n	3400ac86 <HAL_RCCEx_PeriphCLKConfig+0xf26>
3400ac7e:	21e6      	movs	r1, #230	@ 0xe6
3400ac80:	4860      	ldr	r0, [pc, #384]	@ (3400ae04 <HAL_RCCEx_PeriphCLKConfig+0x10a4>)
3400ac82:	f7f7 f9c5 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400ac86:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ac8a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400ac8c:	2b00      	cmp	r3, #0
3400ac8e:	d005      	beq.n	3400ac9c <HAL_RCCEx_PeriphCLKConfig+0xf3c>
3400ac90:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ac94:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400ac96:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400ac9a:	d903      	bls.n	3400aca4 <HAL_RCCEx_PeriphCLKConfig+0xf44>
3400ac9c:	21e7      	movs	r1, #231	@ 0xe7
3400ac9e:	4859      	ldr	r0, [pc, #356]	@ (3400ae04 <HAL_RCCEx_PeriphCLKConfig+0x10a4>)
3400aca0:	f7f7 f9b6 	bl	34002010 <assert_failed>

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400aca4:	4b58      	ldr	r3, [pc, #352]	@ (3400ae08 <HAL_RCCEx_PeriphCLKConfig+0x10a8>)
3400aca6:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3400acaa:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400acae:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400acb2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400acb6:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3400acb8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400acbc:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400acbe:	3b01      	subs	r3, #1
3400acc0:	041b      	lsls	r3, r3, #16
3400acc2:	4313      	orrs	r3, r2
3400acc4:	4a50      	ldr	r2, [pc, #320]	@ (3400ae08 <HAL_RCCEx_PeriphCLKConfig+0x10a8>)
3400acc6:	430b      	orrs	r3, r1
3400acc8:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3400accc:	f7fe fda6 	bl	3400981c <LL_RCC_IC10_Enable>
3400acd0:	e0ec      	b.n	3400aeac <HAL_RCCEx_PeriphCLKConfig+0x114c>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC15)
3400acd2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400acd6:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400acda:	2b06      	cmp	r3, #6
3400acdc:	d140      	bne.n	3400ad60 <HAL_RCCEx_PeriphCLKConfig+0x1000>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400acde:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ace2:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400ace4:	2b00      	cmp	r3, #0
3400ace6:	d015      	beq.n	3400ad14 <HAL_RCCEx_PeriphCLKConfig+0xfb4>
3400ace8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400acec:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400acee:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400acf2:	d00f      	beq.n	3400ad14 <HAL_RCCEx_PeriphCLKConfig+0xfb4>
3400acf4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400acf8:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400acfa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400acfe:	d009      	beq.n	3400ad14 <HAL_RCCEx_PeriphCLKConfig+0xfb4>
3400ad00:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ad04:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400ad06:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ad0a:	d003      	beq.n	3400ad14 <HAL_RCCEx_PeriphCLKConfig+0xfb4>
3400ad0c:	21f3      	movs	r1, #243	@ 0xf3
3400ad0e:	483d      	ldr	r0, [pc, #244]	@ (3400ae04 <HAL_RCCEx_PeriphCLKConfig+0x10a4>)
3400ad10:	f7f7 f97e 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400ad14:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ad18:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400ad1a:	2b00      	cmp	r3, #0
3400ad1c:	d005      	beq.n	3400ad2a <HAL_RCCEx_PeriphCLKConfig+0xfca>
3400ad1e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ad22:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400ad24:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400ad28:	d903      	bls.n	3400ad32 <HAL_RCCEx_PeriphCLKConfig+0xfd2>
3400ad2a:	21f4      	movs	r1, #244	@ 0xf4
3400ad2c:	4835      	ldr	r0, [pc, #212]	@ (3400ae04 <HAL_RCCEx_PeriphCLKConfig+0x10a4>)
3400ad2e:	f7f7 f96f 	bl	34002010 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400ad32:	4b35      	ldr	r3, [pc, #212]	@ (3400ae08 <HAL_RCCEx_PeriphCLKConfig+0x10a8>)
3400ad34:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400ad38:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400ad3c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400ad40:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ad44:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3400ad46:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ad4a:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400ad4c:	3b01      	subs	r3, #1
3400ad4e:	041b      	lsls	r3, r3, #16
3400ad50:	4313      	orrs	r3, r2
3400ad52:	4a2d      	ldr	r2, [pc, #180]	@ (3400ae08 <HAL_RCCEx_PeriphCLKConfig+0x10a8>)
3400ad54:	430b      	orrs	r3, r1
3400ad56:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400ad5a:	f7fe fe5f 	bl	34009a1c <LL_RCC_IC15_Enable>
3400ad5e:	e0a5      	b.n	3400aeac <HAL_RCCEx_PeriphCLKConfig+0x114c>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC19)
3400ad60:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ad64:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400ad68:	2b03      	cmp	r3, #3
3400ad6a:	d14f      	bne.n	3400ae0c <HAL_RCCEx_PeriphCLKConfig+0x10ac>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
3400ad6c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ad70:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400ad74:	2b00      	cmp	r3, #0
3400ad76:	d019      	beq.n	3400adac <HAL_RCCEx_PeriphCLKConfig+0x104c>
3400ad78:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ad7c:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400ad80:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ad84:	d012      	beq.n	3400adac <HAL_RCCEx_PeriphCLKConfig+0x104c>
3400ad86:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ad8a:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400ad8e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ad92:	d00b      	beq.n	3400adac <HAL_RCCEx_PeriphCLKConfig+0x104c>
3400ad94:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ad98:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400ad9c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ada0:	d004      	beq.n	3400adac <HAL_RCCEx_PeriphCLKConfig+0x104c>
3400ada2:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400ada6:	4817      	ldr	r0, [pc, #92]	@ (3400ae04 <HAL_RCCEx_PeriphCLKConfig+0x10a4>)
3400ada8:	f7f7 f932 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));
3400adac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400adb0:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
3400adb4:	2b00      	cmp	r3, #0
3400adb6:	d006      	beq.n	3400adc6 <HAL_RCCEx_PeriphCLKConfig+0x1066>
3400adb8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400adbc:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
3400adc0:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400adc4:	d904      	bls.n	3400add0 <HAL_RCCEx_PeriphCLKConfig+0x1070>
3400adc6:	f240 1101 	movw	r1, #257	@ 0x101
3400adca:	480e      	ldr	r0, [pc, #56]	@ (3400ae04 <HAL_RCCEx_PeriphCLKConfig+0x10a4>)
3400adcc:	f7f7 f920 	bl	34002010 <assert_failed>

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
3400add0:	4b0d      	ldr	r3, [pc, #52]	@ (3400ae08 <HAL_RCCEx_PeriphCLKConfig+0x10a8>)
3400add2:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3400add6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400adda:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400adde:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ade2:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
3400ade6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400adea:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
3400adee:	3b01      	subs	r3, #1
3400adf0:	041b      	lsls	r3, r3, #16
3400adf2:	4313      	orrs	r3, r2
3400adf4:	4a04      	ldr	r2, [pc, #16]	@ (3400ae08 <HAL_RCCEx_PeriphCLKConfig+0x10a8>)
3400adf6:	430b      	orrs	r3, r1
3400adf8:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
3400adfc:	f7fe ff0e 	bl	34009c1c <LL_RCC_IC19_Enable>
3400ae00:	e054      	b.n	3400aeac <HAL_RCCEx_PeriphCLKConfig+0x114c>
3400ae02:	bf00      	nop
3400ae04:	3401ee60 	.word	0x3401ee60
3400ae08:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC20)
3400ae0c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ae10:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400ae14:	2b07      	cmp	r3, #7
3400ae16:	d149      	bne.n	3400aeac <HAL_RCCEx_PeriphCLKConfig+0x114c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
3400ae18:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ae1c:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400ae20:	2b00      	cmp	r3, #0
3400ae22:	d019      	beq.n	3400ae58 <HAL_RCCEx_PeriphCLKConfig+0x10f8>
3400ae24:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ae28:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400ae2c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ae30:	d012      	beq.n	3400ae58 <HAL_RCCEx_PeriphCLKConfig+0x10f8>
3400ae32:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ae36:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400ae3a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ae3e:	d00b      	beq.n	3400ae58 <HAL_RCCEx_PeriphCLKConfig+0x10f8>
3400ae40:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ae44:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400ae48:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ae4c:	d004      	beq.n	3400ae58 <HAL_RCCEx_PeriphCLKConfig+0x10f8>
3400ae4e:	f240 110d 	movw	r1, #269	@ 0x10d
3400ae52:	487d      	ldr	r0, [pc, #500]	@ (3400b048 <HAL_RCCEx_PeriphCLKConfig+0x12e8>)
3400ae54:	f7f7 f8dc 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));
3400ae58:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ae5c:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3400ae60:	2b00      	cmp	r3, #0
3400ae62:	d006      	beq.n	3400ae72 <HAL_RCCEx_PeriphCLKConfig+0x1112>
3400ae64:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ae68:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3400ae6c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400ae70:	d904      	bls.n	3400ae7c <HAL_RCCEx_PeriphCLKConfig+0x111c>
3400ae72:	f44f 7187 	mov.w	r1, #270	@ 0x10e
3400ae76:	4874      	ldr	r0, [pc, #464]	@ (3400b048 <HAL_RCCEx_PeriphCLKConfig+0x12e8>)
3400ae78:	f7f7 f8ca 	bl	34002010 <assert_failed>

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
3400ae7c:	4b73      	ldr	r3, [pc, #460]	@ (3400b04c <HAL_RCCEx_PeriphCLKConfig+0x12ec>)
3400ae7e:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3400ae82:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400ae86:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400ae8a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ae8e:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
3400ae92:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ae96:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3400ae9a:	3b01      	subs	r3, #1
3400ae9c:	041b      	lsls	r3, r3, #16
3400ae9e:	4313      	orrs	r3, r2
3400aea0:	4a6a      	ldr	r2, [pc, #424]	@ (3400b04c <HAL_RCCEx_PeriphCLKConfig+0x12ec>)
3400aea2:	430b      	orrs	r3, r1
3400aea4:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
3400aea8:	f7fe fef8 	bl	34009c9c <LL_RCC_IC20_Enable>
    {
      /* No ICx selected as source */
    }

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
3400aeac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400aeb0:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400aeb4:	4618      	mov	r0, r3
3400aeb6:	f7fd fd4f 	bl	34008958 <LL_RCC_SetCLKPClockSource>
  }

  /*-------------------------- XSPI1 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI1) == RCC_PERIPHCLK_XSPI1)
3400aeba:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400aebe:	e9d3 2300 	ldrd	r2, r3, [r3]
3400aec2:	2100      	movs	r1, #0
3400aec4:	f8c7 11b0 	str.w	r1, [r7, #432]	@ 0x1b0
3400aec8:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
3400aecc:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
3400aed0:	e9d7 016c 	ldrd	r0, r1, [r7, #432]	@ 0x1b0
3400aed4:	4603      	mov	r3, r0
3400aed6:	460a      	mov	r2, r1
3400aed8:	4313      	orrs	r3, r2
3400aeda:	f000 80d1 	beq.w	3400b080 <HAL_RCCEx_PeriphCLKConfig+0x1320>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI1CLKSOURCE(PeriphClkInit->Xspi1ClockSelection));
3400aede:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400aee2:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3400aee6:	4b5a      	ldr	r3, [pc, #360]	@ (3400b050 <HAL_RCCEx_PeriphCLKConfig+0x12f0>)
3400aee8:	429a      	cmp	r2, r3
3400aeea:	d019      	beq.n	3400af20 <HAL_RCCEx_PeriphCLKConfig+0x11c0>
3400aeec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400aef0:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3400aef4:	4b57      	ldr	r3, [pc, #348]	@ (3400b054 <HAL_RCCEx_PeriphCLKConfig+0x12f4>)
3400aef6:	429a      	cmp	r2, r3
3400aef8:	d012      	beq.n	3400af20 <HAL_RCCEx_PeriphCLKConfig+0x11c0>
3400aefa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400aefe:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3400af02:	4b55      	ldr	r3, [pc, #340]	@ (3400b058 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
3400af04:	429a      	cmp	r2, r3
3400af06:	d00b      	beq.n	3400af20 <HAL_RCCEx_PeriphCLKConfig+0x11c0>
3400af08:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400af0c:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3400af10:	4b52      	ldr	r3, [pc, #328]	@ (3400b05c <HAL_RCCEx_PeriphCLKConfig+0x12fc>)
3400af12:	429a      	cmp	r2, r3
3400af14:	d004      	beq.n	3400af20 <HAL_RCCEx_PeriphCLKConfig+0x11c0>
3400af16:	f44f 7192 	mov.w	r1, #292	@ 0x124
3400af1a:	484b      	ldr	r0, [pc, #300]	@ (3400b048 <HAL_RCCEx_PeriphCLKConfig+0x12e8>)
3400af1c:	f7f7 f878 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC3)
3400af20:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400af24:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3400af28:	4b4b      	ldr	r3, [pc, #300]	@ (3400b058 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
3400af2a:	429a      	cmp	r2, r3
3400af2c:	d142      	bne.n	3400afb4 <HAL_RCCEx_PeriphCLKConfig+0x1254>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400af2e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400af32:	699b      	ldr	r3, [r3, #24]
3400af34:	2b00      	cmp	r3, #0
3400af36:	d016      	beq.n	3400af66 <HAL_RCCEx_PeriphCLKConfig+0x1206>
3400af38:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400af3c:	699b      	ldr	r3, [r3, #24]
3400af3e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400af42:	d010      	beq.n	3400af66 <HAL_RCCEx_PeriphCLKConfig+0x1206>
3400af44:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400af48:	699b      	ldr	r3, [r3, #24]
3400af4a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400af4e:	d00a      	beq.n	3400af66 <HAL_RCCEx_PeriphCLKConfig+0x1206>
3400af50:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400af54:	699b      	ldr	r3, [r3, #24]
3400af56:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400af5a:	d004      	beq.n	3400af66 <HAL_RCCEx_PeriphCLKConfig+0x1206>
3400af5c:	f240 1129 	movw	r1, #297	@ 0x129
3400af60:	4839      	ldr	r0, [pc, #228]	@ (3400b048 <HAL_RCCEx_PeriphCLKConfig+0x12e8>)
3400af62:	f7f7 f855 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400af66:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400af6a:	69db      	ldr	r3, [r3, #28]
3400af6c:	2b00      	cmp	r3, #0
3400af6e:	d005      	beq.n	3400af7c <HAL_RCCEx_PeriphCLKConfig+0x121c>
3400af70:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400af74:	69db      	ldr	r3, [r3, #28]
3400af76:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400af7a:	d904      	bls.n	3400af86 <HAL_RCCEx_PeriphCLKConfig+0x1226>
3400af7c:	f44f 7195 	mov.w	r1, #298	@ 0x12a
3400af80:	4831      	ldr	r0, [pc, #196]	@ (3400b048 <HAL_RCCEx_PeriphCLKConfig+0x12e8>)
3400af82:	f7f7 f845 	bl	34002010 <assert_failed>

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400af86:	4b31      	ldr	r3, [pc, #196]	@ (3400b04c <HAL_RCCEx_PeriphCLKConfig+0x12ec>)
3400af88:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400af8c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400af90:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400af94:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400af98:	699a      	ldr	r2, [r3, #24]
3400af9a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400af9e:	69db      	ldr	r3, [r3, #28]
3400afa0:	3b01      	subs	r3, #1
3400afa2:	041b      	lsls	r3, r3, #16
3400afa4:	4313      	orrs	r3, r2
3400afa6:	4a29      	ldr	r2, [pc, #164]	@ (3400b04c <HAL_RCCEx_PeriphCLKConfig+0x12ec>)
3400afa8:	430b      	orrs	r3, r1
3400afaa:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3400afae:	f7fe fab5 	bl	3400951c <LL_RCC_IC3_Enable>
3400afb2:	e05e      	b.n	3400b072 <HAL_RCCEx_PeriphCLKConfig+0x1312>
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC4)
3400afb4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400afb8:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3400afbc:	4b27      	ldr	r3, [pc, #156]	@ (3400b05c <HAL_RCCEx_PeriphCLKConfig+0x12fc>)
3400afbe:	429a      	cmp	r2, r3
3400afc0:	d14e      	bne.n	3400b060 <HAL_RCCEx_PeriphCLKConfig+0x1300>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400afc2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400afc6:	6a1b      	ldr	r3, [r3, #32]
3400afc8:	2b00      	cmp	r3, #0
3400afca:	d016      	beq.n	3400affa <HAL_RCCEx_PeriphCLKConfig+0x129a>
3400afcc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400afd0:	6a1b      	ldr	r3, [r3, #32]
3400afd2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400afd6:	d010      	beq.n	3400affa <HAL_RCCEx_PeriphCLKConfig+0x129a>
3400afd8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400afdc:	6a1b      	ldr	r3, [r3, #32]
3400afde:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400afe2:	d00a      	beq.n	3400affa <HAL_RCCEx_PeriphCLKConfig+0x129a>
3400afe4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400afe8:	6a1b      	ldr	r3, [r3, #32]
3400afea:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400afee:	d004      	beq.n	3400affa <HAL_RCCEx_PeriphCLKConfig+0x129a>
3400aff0:	f44f 719b 	mov.w	r1, #310	@ 0x136
3400aff4:	4814      	ldr	r0, [pc, #80]	@ (3400b048 <HAL_RCCEx_PeriphCLKConfig+0x12e8>)
3400aff6:	f7f7 f80b 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400affa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400affe:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b000:	2b00      	cmp	r3, #0
3400b002:	d005      	beq.n	3400b010 <HAL_RCCEx_PeriphCLKConfig+0x12b0>
3400b004:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b008:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b00a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400b00e:	d904      	bls.n	3400b01a <HAL_RCCEx_PeriphCLKConfig+0x12ba>
3400b010:	f240 1137 	movw	r1, #311	@ 0x137
3400b014:	480c      	ldr	r0, [pc, #48]	@ (3400b048 <HAL_RCCEx_PeriphCLKConfig+0x12e8>)
3400b016:	f7f6 fffb 	bl	34002010 <assert_failed>

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400b01a:	4b0c      	ldr	r3, [pc, #48]	@ (3400b04c <HAL_RCCEx_PeriphCLKConfig+0x12ec>)
3400b01c:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400b020:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400b024:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400b028:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b02c:	6a1a      	ldr	r2, [r3, #32]
3400b02e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b032:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b034:	3b01      	subs	r3, #1
3400b036:	041b      	lsls	r3, r3, #16
3400b038:	4313      	orrs	r3, r2
3400b03a:	4a04      	ldr	r2, [pc, #16]	@ (3400b04c <HAL_RCCEx_PeriphCLKConfig+0x12ec>)
3400b03c:	430b      	orrs	r3, r1
3400b03e:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3400b042:	f7fe faab 	bl	3400959c <LL_RCC_IC4_Enable>
3400b046:	e014      	b.n	3400b072 <HAL_RCCEx_PeriphCLKConfig+0x1312>
3400b048:	3401ee60 	.word	0x3401ee60
3400b04c:	56028000 	.word	0x56028000
3400b050:	03000014 	.word	0x03000014
3400b054:	03010014 	.word	0x03010014
3400b058:	03020014 	.word	0x03020014
3400b05c:	03030014 	.word	0x03030014
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_CLKP)
3400b060:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b064:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3400b068:	4baf      	ldr	r3, [pc, #700]	@ (3400b328 <HAL_RCCEx_PeriphCLKConfig+0x15c8>)
3400b06a:	429a      	cmp	r2, r3
3400b06c:	d101      	bne.n	3400b072 <HAL_RCCEx_PeriphCLKConfig+0x1312>
    {
      LL_RCC_CLKP_Enable();
3400b06e:	f7fe fe55 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI1 clock source */
    __HAL_RCC_XSPI1_CONFIG(PeriphClkInit->Xspi1ClockSelection);
3400b072:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b076:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
3400b07a:	4618      	mov	r0, r3
3400b07c:	f7fd fdfc 	bl	34008c78 <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI2 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI2) == RCC_PERIPHCLK_XSPI2)
3400b080:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b084:	e9d3 2300 	ldrd	r2, r3, [r3]
3400b088:	2100      	movs	r1, #0
3400b08a:	f8c7 11a8 	str.w	r1, [r7, #424]	@ 0x1a8
3400b08e:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
3400b092:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
3400b096:	e9d7 016a 	ldrd	r0, r1, [r7, #424]	@ 0x1a8
3400b09a:	4603      	mov	r3, r0
3400b09c:	460a      	mov	r2, r1
3400b09e:	4313      	orrs	r3, r2
3400b0a0:	f000 80c5 	beq.w	3400b22e <HAL_RCCEx_PeriphCLKConfig+0x14ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI2CLKSOURCE(PeriphClkInit->Xspi2ClockSelection));
3400b0a4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b0a8:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3400b0ac:	4b9f      	ldr	r3, [pc, #636]	@ (3400b32c <HAL_RCCEx_PeriphCLKConfig+0x15cc>)
3400b0ae:	429a      	cmp	r2, r3
3400b0b0:	d019      	beq.n	3400b0e6 <HAL_RCCEx_PeriphCLKConfig+0x1386>
3400b0b2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b0b6:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3400b0ba:	4b9d      	ldr	r3, [pc, #628]	@ (3400b330 <HAL_RCCEx_PeriphCLKConfig+0x15d0>)
3400b0bc:	429a      	cmp	r2, r3
3400b0be:	d012      	beq.n	3400b0e6 <HAL_RCCEx_PeriphCLKConfig+0x1386>
3400b0c0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b0c4:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3400b0c8:	4b9a      	ldr	r3, [pc, #616]	@ (3400b334 <HAL_RCCEx_PeriphCLKConfig+0x15d4>)
3400b0ca:	429a      	cmp	r2, r3
3400b0cc:	d00b      	beq.n	3400b0e6 <HAL_RCCEx_PeriphCLKConfig+0x1386>
3400b0ce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b0d2:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3400b0d6:	4b98      	ldr	r3, [pc, #608]	@ (3400b338 <HAL_RCCEx_PeriphCLKConfig+0x15d8>)
3400b0d8:	429a      	cmp	r2, r3
3400b0da:	d004      	beq.n	3400b0e6 <HAL_RCCEx_PeriphCLKConfig+0x1386>
3400b0dc:	f240 1151 	movw	r1, #337	@ 0x151
3400b0e0:	4896      	ldr	r0, [pc, #600]	@ (3400b33c <HAL_RCCEx_PeriphCLKConfig+0x15dc>)
3400b0e2:	f7f6 ff95 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC3)
3400b0e6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b0ea:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3400b0ee:	4b91      	ldr	r3, [pc, #580]	@ (3400b334 <HAL_RCCEx_PeriphCLKConfig+0x15d4>)
3400b0f0:	429a      	cmp	r2, r3
3400b0f2:	d142      	bne.n	3400b17a <HAL_RCCEx_PeriphCLKConfig+0x141a>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400b0f4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b0f8:	699b      	ldr	r3, [r3, #24]
3400b0fa:	2b00      	cmp	r3, #0
3400b0fc:	d016      	beq.n	3400b12c <HAL_RCCEx_PeriphCLKConfig+0x13cc>
3400b0fe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b102:	699b      	ldr	r3, [r3, #24]
3400b104:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400b108:	d010      	beq.n	3400b12c <HAL_RCCEx_PeriphCLKConfig+0x13cc>
3400b10a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b10e:	699b      	ldr	r3, [r3, #24]
3400b110:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b114:	d00a      	beq.n	3400b12c <HAL_RCCEx_PeriphCLKConfig+0x13cc>
3400b116:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b11a:	699b      	ldr	r3, [r3, #24]
3400b11c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b120:	d004      	beq.n	3400b12c <HAL_RCCEx_PeriphCLKConfig+0x13cc>
3400b122:	f44f 71ab 	mov.w	r1, #342	@ 0x156
3400b126:	4885      	ldr	r0, [pc, #532]	@ (3400b33c <HAL_RCCEx_PeriphCLKConfig+0x15dc>)
3400b128:	f7f6 ff72 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400b12c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b130:	69db      	ldr	r3, [r3, #28]
3400b132:	2b00      	cmp	r3, #0
3400b134:	d005      	beq.n	3400b142 <HAL_RCCEx_PeriphCLKConfig+0x13e2>
3400b136:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b13a:	69db      	ldr	r3, [r3, #28]
3400b13c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400b140:	d904      	bls.n	3400b14c <HAL_RCCEx_PeriphCLKConfig+0x13ec>
3400b142:	f240 1157 	movw	r1, #343	@ 0x157
3400b146:	487d      	ldr	r0, [pc, #500]	@ (3400b33c <HAL_RCCEx_PeriphCLKConfig+0x15dc>)
3400b148:	f7f6 ff62 	bl	34002010 <assert_failed>

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400b14c:	4b7c      	ldr	r3, [pc, #496]	@ (3400b340 <HAL_RCCEx_PeriphCLKConfig+0x15e0>)
3400b14e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400b152:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400b156:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400b15a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b15e:	699a      	ldr	r2, [r3, #24]
3400b160:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b164:	69db      	ldr	r3, [r3, #28]
3400b166:	3b01      	subs	r3, #1
3400b168:	041b      	lsls	r3, r3, #16
3400b16a:	4313      	orrs	r3, r2
3400b16c:	4a74      	ldr	r2, [pc, #464]	@ (3400b340 <HAL_RCCEx_PeriphCLKConfig+0x15e0>)
3400b16e:	430b      	orrs	r3, r1
3400b170:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3400b174:	f7fe f9d2 	bl	3400951c <LL_RCC_IC3_Enable>
3400b178:	e052      	b.n	3400b220 <HAL_RCCEx_PeriphCLKConfig+0x14c0>
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC4)
3400b17a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b17e:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3400b182:	4b6d      	ldr	r3, [pc, #436]	@ (3400b338 <HAL_RCCEx_PeriphCLKConfig+0x15d8>)
3400b184:	429a      	cmp	r2, r3
3400b186:	d142      	bne.n	3400b20e <HAL_RCCEx_PeriphCLKConfig+0x14ae>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400b188:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b18c:	6a1b      	ldr	r3, [r3, #32]
3400b18e:	2b00      	cmp	r3, #0
3400b190:	d016      	beq.n	3400b1c0 <HAL_RCCEx_PeriphCLKConfig+0x1460>
3400b192:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b196:	6a1b      	ldr	r3, [r3, #32]
3400b198:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400b19c:	d010      	beq.n	3400b1c0 <HAL_RCCEx_PeriphCLKConfig+0x1460>
3400b19e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b1a2:	6a1b      	ldr	r3, [r3, #32]
3400b1a4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b1a8:	d00a      	beq.n	3400b1c0 <HAL_RCCEx_PeriphCLKConfig+0x1460>
3400b1aa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b1ae:	6a1b      	ldr	r3, [r3, #32]
3400b1b0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b1b4:	d004      	beq.n	3400b1c0 <HAL_RCCEx_PeriphCLKConfig+0x1460>
3400b1b6:	f240 1163 	movw	r1, #355	@ 0x163
3400b1ba:	4860      	ldr	r0, [pc, #384]	@ (3400b33c <HAL_RCCEx_PeriphCLKConfig+0x15dc>)
3400b1bc:	f7f6 ff28 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400b1c0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b1c4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b1c6:	2b00      	cmp	r3, #0
3400b1c8:	d005      	beq.n	3400b1d6 <HAL_RCCEx_PeriphCLKConfig+0x1476>
3400b1ca:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b1ce:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b1d0:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400b1d4:	d904      	bls.n	3400b1e0 <HAL_RCCEx_PeriphCLKConfig+0x1480>
3400b1d6:	f44f 71b2 	mov.w	r1, #356	@ 0x164
3400b1da:	4858      	ldr	r0, [pc, #352]	@ (3400b33c <HAL_RCCEx_PeriphCLKConfig+0x15dc>)
3400b1dc:	f7f6 ff18 	bl	34002010 <assert_failed>

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400b1e0:	4b57      	ldr	r3, [pc, #348]	@ (3400b340 <HAL_RCCEx_PeriphCLKConfig+0x15e0>)
3400b1e2:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400b1e6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400b1ea:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400b1ee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b1f2:	6a1a      	ldr	r2, [r3, #32]
3400b1f4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b1f8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b1fa:	3b01      	subs	r3, #1
3400b1fc:	041b      	lsls	r3, r3, #16
3400b1fe:	4313      	orrs	r3, r2
3400b200:	4a4f      	ldr	r2, [pc, #316]	@ (3400b340 <HAL_RCCEx_PeriphCLKConfig+0x15e0>)
3400b202:	430b      	orrs	r3, r1
3400b204:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3400b208:	f7fe f9c8 	bl	3400959c <LL_RCC_IC4_Enable>
3400b20c:	e008      	b.n	3400b220 <HAL_RCCEx_PeriphCLKConfig+0x14c0>
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_CLKP)
3400b20e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b212:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3400b216:	4b46      	ldr	r3, [pc, #280]	@ (3400b330 <HAL_RCCEx_PeriphCLKConfig+0x15d0>)
3400b218:	429a      	cmp	r2, r3
3400b21a:	d101      	bne.n	3400b220 <HAL_RCCEx_PeriphCLKConfig+0x14c0>
    {
      LL_RCC_CLKP_Enable();
3400b21c:	f7fe fd7e 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI2 clock source */
    __HAL_RCC_XSPI2_CONFIG(PeriphClkInit->Xspi2ClockSelection);
3400b220:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b224:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3400b228:	4618      	mov	r0, r3
3400b22a:	f7fd fd25 	bl	34008c78 <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI3 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI3) == RCC_PERIPHCLK_XSPI3)
3400b22e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b232:	e9d3 2300 	ldrd	r2, r3, [r3]
3400b236:	2100      	movs	r1, #0
3400b238:	f8c7 11a0 	str.w	r1, [r7, #416]	@ 0x1a0
3400b23c:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
3400b240:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
3400b244:	e9d7 0168 	ldrd	r0, r1, [r7, #416]	@ 0x1a0
3400b248:	4603      	mov	r3, r0
3400b24a:	460a      	mov	r2, r1
3400b24c:	4313      	orrs	r3, r2
3400b24e:	f000 80db 	beq.w	3400b408 <HAL_RCCEx_PeriphCLKConfig+0x16a8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI3CLKSOURCE(PeriphClkInit->Xspi3ClockSelection));
3400b252:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b256:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3400b25a:	4b3a      	ldr	r3, [pc, #232]	@ (3400b344 <HAL_RCCEx_PeriphCLKConfig+0x15e4>)
3400b25c:	429a      	cmp	r2, r3
3400b25e:	d019      	beq.n	3400b294 <HAL_RCCEx_PeriphCLKConfig+0x1534>
3400b260:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b264:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3400b268:	4b37      	ldr	r3, [pc, #220]	@ (3400b348 <HAL_RCCEx_PeriphCLKConfig+0x15e8>)
3400b26a:	429a      	cmp	r2, r3
3400b26c:	d012      	beq.n	3400b294 <HAL_RCCEx_PeriphCLKConfig+0x1534>
3400b26e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b272:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3400b276:	4b35      	ldr	r3, [pc, #212]	@ (3400b34c <HAL_RCCEx_PeriphCLKConfig+0x15ec>)
3400b278:	429a      	cmp	r2, r3
3400b27a:	d00b      	beq.n	3400b294 <HAL_RCCEx_PeriphCLKConfig+0x1534>
3400b27c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b280:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3400b284:	4b32      	ldr	r3, [pc, #200]	@ (3400b350 <HAL_RCCEx_PeriphCLKConfig+0x15f0>)
3400b286:	429a      	cmp	r2, r3
3400b288:	d004      	beq.n	3400b294 <HAL_RCCEx_PeriphCLKConfig+0x1534>
3400b28a:	f44f 71bf 	mov.w	r1, #382	@ 0x17e
3400b28e:	482b      	ldr	r0, [pc, #172]	@ (3400b33c <HAL_RCCEx_PeriphCLKConfig+0x15dc>)
3400b290:	f7f6 febe 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC3)
3400b294:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b298:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3400b29c:	4b2b      	ldr	r3, [pc, #172]	@ (3400b34c <HAL_RCCEx_PeriphCLKConfig+0x15ec>)
3400b29e:	429a      	cmp	r2, r3
3400b2a0:	d158      	bne.n	3400b354 <HAL_RCCEx_PeriphCLKConfig+0x15f4>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400b2a2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b2a6:	699b      	ldr	r3, [r3, #24]
3400b2a8:	2b00      	cmp	r3, #0
3400b2aa:	d016      	beq.n	3400b2da <HAL_RCCEx_PeriphCLKConfig+0x157a>
3400b2ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b2b0:	699b      	ldr	r3, [r3, #24]
3400b2b2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400b2b6:	d010      	beq.n	3400b2da <HAL_RCCEx_PeriphCLKConfig+0x157a>
3400b2b8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b2bc:	699b      	ldr	r3, [r3, #24]
3400b2be:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b2c2:	d00a      	beq.n	3400b2da <HAL_RCCEx_PeriphCLKConfig+0x157a>
3400b2c4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b2c8:	699b      	ldr	r3, [r3, #24]
3400b2ca:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b2ce:	d004      	beq.n	3400b2da <HAL_RCCEx_PeriphCLKConfig+0x157a>
3400b2d0:	f240 1183 	movw	r1, #387	@ 0x183
3400b2d4:	4819      	ldr	r0, [pc, #100]	@ (3400b33c <HAL_RCCEx_PeriphCLKConfig+0x15dc>)
3400b2d6:	f7f6 fe9b 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400b2da:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b2de:	69db      	ldr	r3, [r3, #28]
3400b2e0:	2b00      	cmp	r3, #0
3400b2e2:	d005      	beq.n	3400b2f0 <HAL_RCCEx_PeriphCLKConfig+0x1590>
3400b2e4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b2e8:	69db      	ldr	r3, [r3, #28]
3400b2ea:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400b2ee:	d904      	bls.n	3400b2fa <HAL_RCCEx_PeriphCLKConfig+0x159a>
3400b2f0:	f44f 71c2 	mov.w	r1, #388	@ 0x184
3400b2f4:	4811      	ldr	r0, [pc, #68]	@ (3400b33c <HAL_RCCEx_PeriphCLKConfig+0x15dc>)
3400b2f6:	f7f6 fe8b 	bl	34002010 <assert_failed>

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400b2fa:	4b11      	ldr	r3, [pc, #68]	@ (3400b340 <HAL_RCCEx_PeriphCLKConfig+0x15e0>)
3400b2fc:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400b300:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400b304:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400b308:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b30c:	699a      	ldr	r2, [r3, #24]
3400b30e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b312:	69db      	ldr	r3, [r3, #28]
3400b314:	3b01      	subs	r3, #1
3400b316:	041b      	lsls	r3, r3, #16
3400b318:	4313      	orrs	r3, r2
3400b31a:	4a09      	ldr	r2, [pc, #36]	@ (3400b340 <HAL_RCCEx_PeriphCLKConfig+0x15e0>)
3400b31c:	430b      	orrs	r3, r1
3400b31e:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3400b322:	f7fe f8fb 	bl	3400951c <LL_RCC_IC3_Enable>
3400b326:	e068      	b.n	3400b3fa <HAL_RCCEx_PeriphCLKConfig+0x169a>
3400b328:	03010014 	.word	0x03010014
3400b32c:	03000414 	.word	0x03000414
3400b330:	03010414 	.word	0x03010414
3400b334:	03020414 	.word	0x03020414
3400b338:	03030414 	.word	0x03030414
3400b33c:	3401ee60 	.word	0x3401ee60
3400b340:	56028000 	.word	0x56028000
3400b344:	03000814 	.word	0x03000814
3400b348:	03010814 	.word	0x03010814
3400b34c:	03020814 	.word	0x03020814
3400b350:	03030814 	.word	0x03030814
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC4)
3400b354:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b358:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3400b35c:	4b8b      	ldr	r3, [pc, #556]	@ (3400b58c <HAL_RCCEx_PeriphCLKConfig+0x182c>)
3400b35e:	429a      	cmp	r2, r3
3400b360:	d142      	bne.n	3400b3e8 <HAL_RCCEx_PeriphCLKConfig+0x1688>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400b362:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b366:	6a1b      	ldr	r3, [r3, #32]
3400b368:	2b00      	cmp	r3, #0
3400b36a:	d016      	beq.n	3400b39a <HAL_RCCEx_PeriphCLKConfig+0x163a>
3400b36c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b370:	6a1b      	ldr	r3, [r3, #32]
3400b372:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400b376:	d010      	beq.n	3400b39a <HAL_RCCEx_PeriphCLKConfig+0x163a>
3400b378:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b37c:	6a1b      	ldr	r3, [r3, #32]
3400b37e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b382:	d00a      	beq.n	3400b39a <HAL_RCCEx_PeriphCLKConfig+0x163a>
3400b384:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b388:	6a1b      	ldr	r3, [r3, #32]
3400b38a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b38e:	d004      	beq.n	3400b39a <HAL_RCCEx_PeriphCLKConfig+0x163a>
3400b390:	f44f 71c8 	mov.w	r1, #400	@ 0x190
3400b394:	487e      	ldr	r0, [pc, #504]	@ (3400b590 <HAL_RCCEx_PeriphCLKConfig+0x1830>)
3400b396:	f7f6 fe3b 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400b39a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b39e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b3a0:	2b00      	cmp	r3, #0
3400b3a2:	d005      	beq.n	3400b3b0 <HAL_RCCEx_PeriphCLKConfig+0x1650>
3400b3a4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b3a8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b3aa:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400b3ae:	d904      	bls.n	3400b3ba <HAL_RCCEx_PeriphCLKConfig+0x165a>
3400b3b0:	f240 1191 	movw	r1, #401	@ 0x191
3400b3b4:	4876      	ldr	r0, [pc, #472]	@ (3400b590 <HAL_RCCEx_PeriphCLKConfig+0x1830>)
3400b3b6:	f7f6 fe2b 	bl	34002010 <assert_failed>

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400b3ba:	4b76      	ldr	r3, [pc, #472]	@ (3400b594 <HAL_RCCEx_PeriphCLKConfig+0x1834>)
3400b3bc:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400b3c0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400b3c4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400b3c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b3cc:	6a1a      	ldr	r2, [r3, #32]
3400b3ce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b3d2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b3d4:	3b01      	subs	r3, #1
3400b3d6:	041b      	lsls	r3, r3, #16
3400b3d8:	4313      	orrs	r3, r2
3400b3da:	4a6e      	ldr	r2, [pc, #440]	@ (3400b594 <HAL_RCCEx_PeriphCLKConfig+0x1834>)
3400b3dc:	430b      	orrs	r3, r1
3400b3de:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3400b3e2:	f7fe f8db 	bl	3400959c <LL_RCC_IC4_Enable>
3400b3e6:	e008      	b.n	3400b3fa <HAL_RCCEx_PeriphCLKConfig+0x169a>
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_CLKP)
3400b3e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b3ec:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3400b3f0:	4b69      	ldr	r3, [pc, #420]	@ (3400b598 <HAL_RCCEx_PeriphCLKConfig+0x1838>)
3400b3f2:	429a      	cmp	r2, r3
3400b3f4:	d101      	bne.n	3400b3fa <HAL_RCCEx_PeriphCLKConfig+0x169a>
    {
      LL_RCC_CLKP_Enable();
3400b3f6:	f7fe fc91 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI3 clock source */
    __HAL_RCC_XSPI3_CONFIG(PeriphClkInit->Xspi3ClockSelection);
3400b3fa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b3fe:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
3400b402:	4618      	mov	r0, r3
3400b404:	f7fd fc38 	bl	34008c78 <LL_RCC_SetXSPIClockSource>
  }

  /*---------------------------- FMC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
3400b408:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b40c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400b410:	f402 6300 	and.w	r3, r2, #2048	@ 0x800
3400b414:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
3400b418:	2300      	movs	r3, #0
3400b41a:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
3400b41e:	e9d7 0166 	ldrd	r0, r1, [r7, #408]	@ 0x198
3400b422:	4603      	mov	r3, r0
3400b424:	460a      	mov	r2, r1
3400b426:	4313      	orrs	r3, r2
3400b428:	f000 80c7 	beq.w	3400b5ba <HAL_RCCEx_PeriphCLKConfig+0x185a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FMCCLKSOURCE(PeriphClkInit->FmcClockSelection));
3400b42c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b430:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400b434:	2b00      	cmp	r3, #0
3400b436:	d016      	beq.n	3400b466 <HAL_RCCEx_PeriphCLKConfig+0x1706>
3400b438:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b43c:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400b440:	2b10      	cmp	r3, #16
3400b442:	d010      	beq.n	3400b466 <HAL_RCCEx_PeriphCLKConfig+0x1706>
3400b444:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b448:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400b44c:	2b20      	cmp	r3, #32
3400b44e:	d00a      	beq.n	3400b466 <HAL_RCCEx_PeriphCLKConfig+0x1706>
3400b450:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b454:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400b458:	2b30      	cmp	r3, #48	@ 0x30
3400b45a:	d004      	beq.n	3400b466 <HAL_RCCEx_PeriphCLKConfig+0x1706>
3400b45c:	f240 11ab 	movw	r1, #427	@ 0x1ab
3400b460:	484b      	ldr	r0, [pc, #300]	@ (3400b590 <HAL_RCCEx_PeriphCLKConfig+0x1830>)
3400b462:	f7f6 fdd5 	bl	34002010 <assert_failed>

    if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC3)
3400b466:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b46a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400b46e:	2b20      	cmp	r3, #32
3400b470:	d142      	bne.n	3400b4f8 <HAL_RCCEx_PeriphCLKConfig+0x1798>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400b472:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b476:	699b      	ldr	r3, [r3, #24]
3400b478:	2b00      	cmp	r3, #0
3400b47a:	d016      	beq.n	3400b4aa <HAL_RCCEx_PeriphCLKConfig+0x174a>
3400b47c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b480:	699b      	ldr	r3, [r3, #24]
3400b482:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400b486:	d010      	beq.n	3400b4aa <HAL_RCCEx_PeriphCLKConfig+0x174a>
3400b488:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b48c:	699b      	ldr	r3, [r3, #24]
3400b48e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b492:	d00a      	beq.n	3400b4aa <HAL_RCCEx_PeriphCLKConfig+0x174a>
3400b494:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b498:	699b      	ldr	r3, [r3, #24]
3400b49a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b49e:	d004      	beq.n	3400b4aa <HAL_RCCEx_PeriphCLKConfig+0x174a>
3400b4a0:	f44f 71d8 	mov.w	r1, #432	@ 0x1b0
3400b4a4:	483a      	ldr	r0, [pc, #232]	@ (3400b590 <HAL_RCCEx_PeriphCLKConfig+0x1830>)
3400b4a6:	f7f6 fdb3 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400b4aa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b4ae:	69db      	ldr	r3, [r3, #28]
3400b4b0:	2b00      	cmp	r3, #0
3400b4b2:	d005      	beq.n	3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x1760>
3400b4b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b4b8:	69db      	ldr	r3, [r3, #28]
3400b4ba:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400b4be:	d904      	bls.n	3400b4ca <HAL_RCCEx_PeriphCLKConfig+0x176a>
3400b4c0:	f240 11b1 	movw	r1, #433	@ 0x1b1
3400b4c4:	4832      	ldr	r0, [pc, #200]	@ (3400b590 <HAL_RCCEx_PeriphCLKConfig+0x1830>)
3400b4c6:	f7f6 fda3 	bl	34002010 <assert_failed>

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400b4ca:	4b32      	ldr	r3, [pc, #200]	@ (3400b594 <HAL_RCCEx_PeriphCLKConfig+0x1834>)
3400b4cc:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400b4d0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400b4d4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400b4d8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b4dc:	699a      	ldr	r2, [r3, #24]
3400b4de:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b4e2:	69db      	ldr	r3, [r3, #28]
3400b4e4:	3b01      	subs	r3, #1
3400b4e6:	041b      	lsls	r3, r3, #16
3400b4e8:	4313      	orrs	r3, r2
3400b4ea:	4a2a      	ldr	r2, [pc, #168]	@ (3400b594 <HAL_RCCEx_PeriphCLKConfig+0x1834>)
3400b4ec:	430b      	orrs	r3, r1
3400b4ee:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3400b4f2:	f7fe f813 	bl	3400951c <LL_RCC_IC3_Enable>
3400b4f6:	e059      	b.n	3400b5ac <HAL_RCCEx_PeriphCLKConfig+0x184c>
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC4)
3400b4f8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b4fc:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400b500:	2b30      	cmp	r3, #48	@ 0x30
3400b502:	d14b      	bne.n	3400b59c <HAL_RCCEx_PeriphCLKConfig+0x183c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400b504:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b508:	6a1b      	ldr	r3, [r3, #32]
3400b50a:	2b00      	cmp	r3, #0
3400b50c:	d016      	beq.n	3400b53c <HAL_RCCEx_PeriphCLKConfig+0x17dc>
3400b50e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b512:	6a1b      	ldr	r3, [r3, #32]
3400b514:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400b518:	d010      	beq.n	3400b53c <HAL_RCCEx_PeriphCLKConfig+0x17dc>
3400b51a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b51e:	6a1b      	ldr	r3, [r3, #32]
3400b520:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b524:	d00a      	beq.n	3400b53c <HAL_RCCEx_PeriphCLKConfig+0x17dc>
3400b526:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b52a:	6a1b      	ldr	r3, [r3, #32]
3400b52c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b530:	d004      	beq.n	3400b53c <HAL_RCCEx_PeriphCLKConfig+0x17dc>
3400b532:	f240 11bd 	movw	r1, #445	@ 0x1bd
3400b536:	4816      	ldr	r0, [pc, #88]	@ (3400b590 <HAL_RCCEx_PeriphCLKConfig+0x1830>)
3400b538:	f7f6 fd6a 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400b53c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b540:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b542:	2b00      	cmp	r3, #0
3400b544:	d005      	beq.n	3400b552 <HAL_RCCEx_PeriphCLKConfig+0x17f2>
3400b546:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b54a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b54c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400b550:	d904      	bls.n	3400b55c <HAL_RCCEx_PeriphCLKConfig+0x17fc>
3400b552:	f44f 71df 	mov.w	r1, #446	@ 0x1be
3400b556:	480e      	ldr	r0, [pc, #56]	@ (3400b590 <HAL_RCCEx_PeriphCLKConfig+0x1830>)
3400b558:	f7f6 fd5a 	bl	34002010 <assert_failed>

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400b55c:	4b0d      	ldr	r3, [pc, #52]	@ (3400b594 <HAL_RCCEx_PeriphCLKConfig+0x1834>)
3400b55e:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400b562:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400b566:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400b56a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b56e:	6a1a      	ldr	r2, [r3, #32]
3400b570:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b574:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b576:	3b01      	subs	r3, #1
3400b578:	041b      	lsls	r3, r3, #16
3400b57a:	4313      	orrs	r3, r2
3400b57c:	4a05      	ldr	r2, [pc, #20]	@ (3400b594 <HAL_RCCEx_PeriphCLKConfig+0x1834>)
3400b57e:	430b      	orrs	r3, r1
3400b580:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3400b584:	f7fe f80a 	bl	3400959c <LL_RCC_IC4_Enable>
3400b588:	e010      	b.n	3400b5ac <HAL_RCCEx_PeriphCLKConfig+0x184c>
3400b58a:	bf00      	nop
3400b58c:	03030814 	.word	0x03030814
3400b590:	3401ee60 	.word	0x3401ee60
3400b594:	56028000 	.word	0x56028000
3400b598:	03010814 	.word	0x03010814
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_CLKP)
3400b59c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b5a0:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400b5a4:	2b10      	cmp	r3, #16
3400b5a6:	d101      	bne.n	3400b5ac <HAL_RCCEx_PeriphCLKConfig+0x184c>
    {
      LL_RCC_CLKP_Enable();
3400b5a8:	f7fe fbb8 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FMC kernel clock*/
    __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
3400b5ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b5b0:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400b5b4:	4618      	mov	r0, r3
3400b5b6:	f7fd fa77 	bl	34008aa8 <LL_RCC_SetFMCClockSource>
  }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
3400b5ba:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b5be:	e9d3 2300 	ldrd	r2, r3, [r3]
3400b5c2:	f002 4380 	and.w	r3, r2, #1073741824	@ 0x40000000
3400b5c6:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
3400b5ca:	2300      	movs	r3, #0
3400b5cc:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
3400b5d0:	e9d7 0164 	ldrd	r0, r1, [r7, #400]	@ 0x190
3400b5d4:	4603      	mov	r3, r0
3400b5d6:	460a      	mov	r2, r1
3400b5d8:	4313      	orrs	r3, r2
3400b5da:	f000 80c5 	beq.w	3400b768 <HAL_RCCEx_PeriphCLKConfig+0x1a08>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
3400b5de:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b5e2:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
3400b5e6:	4b9f      	ldr	r3, [pc, #636]	@ (3400b864 <HAL_RCCEx_PeriphCLKConfig+0x1b04>)
3400b5e8:	429a      	cmp	r2, r3
3400b5ea:	d019      	beq.n	3400b620 <HAL_RCCEx_PeriphCLKConfig+0x18c0>
3400b5ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b5f0:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
3400b5f4:	4b9c      	ldr	r3, [pc, #624]	@ (3400b868 <HAL_RCCEx_PeriphCLKConfig+0x1b08>)
3400b5f6:	429a      	cmp	r2, r3
3400b5f8:	d012      	beq.n	3400b620 <HAL_RCCEx_PeriphCLKConfig+0x18c0>
3400b5fa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b5fe:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
3400b602:	4b9a      	ldr	r3, [pc, #616]	@ (3400b86c <HAL_RCCEx_PeriphCLKConfig+0x1b0c>)
3400b604:	429a      	cmp	r2, r3
3400b606:	d00b      	beq.n	3400b620 <HAL_RCCEx_PeriphCLKConfig+0x18c0>
3400b608:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b60c:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
3400b610:	4b97      	ldr	r3, [pc, #604]	@ (3400b870 <HAL_RCCEx_PeriphCLKConfig+0x1b10>)
3400b612:	429a      	cmp	r2, r3
3400b614:	d004      	beq.n	3400b620 <HAL_RCCEx_PeriphCLKConfig+0x18c0>
3400b616:	f44f 71ec 	mov.w	r1, #472	@ 0x1d8
3400b61a:	4896      	ldr	r0, [pc, #600]	@ (3400b874 <HAL_RCCEx_PeriphCLKConfig+0x1b14>)
3400b61c:	f7f6 fcf8 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC4)
3400b620:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b624:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
3400b628:	4b90      	ldr	r3, [pc, #576]	@ (3400b86c <HAL_RCCEx_PeriphCLKConfig+0x1b0c>)
3400b62a:	429a      	cmp	r2, r3
3400b62c:	d142      	bne.n	3400b6b4 <HAL_RCCEx_PeriphCLKConfig+0x1954>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400b62e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b632:	6a1b      	ldr	r3, [r3, #32]
3400b634:	2b00      	cmp	r3, #0
3400b636:	d016      	beq.n	3400b666 <HAL_RCCEx_PeriphCLKConfig+0x1906>
3400b638:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b63c:	6a1b      	ldr	r3, [r3, #32]
3400b63e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400b642:	d010      	beq.n	3400b666 <HAL_RCCEx_PeriphCLKConfig+0x1906>
3400b644:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b648:	6a1b      	ldr	r3, [r3, #32]
3400b64a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b64e:	d00a      	beq.n	3400b666 <HAL_RCCEx_PeriphCLKConfig+0x1906>
3400b650:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b654:	6a1b      	ldr	r3, [r3, #32]
3400b656:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b65a:	d004      	beq.n	3400b666 <HAL_RCCEx_PeriphCLKConfig+0x1906>
3400b65c:	f240 11dd 	movw	r1, #477	@ 0x1dd
3400b660:	4884      	ldr	r0, [pc, #528]	@ (3400b874 <HAL_RCCEx_PeriphCLKConfig+0x1b14>)
3400b662:	f7f6 fcd5 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400b666:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b66a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b66c:	2b00      	cmp	r3, #0
3400b66e:	d005      	beq.n	3400b67c <HAL_RCCEx_PeriphCLKConfig+0x191c>
3400b670:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b674:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b676:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400b67a:	d904      	bls.n	3400b686 <HAL_RCCEx_PeriphCLKConfig+0x1926>
3400b67c:	f44f 71ef 	mov.w	r1, #478	@ 0x1de
3400b680:	487c      	ldr	r0, [pc, #496]	@ (3400b874 <HAL_RCCEx_PeriphCLKConfig+0x1b14>)
3400b682:	f7f6 fcc5 	bl	34002010 <assert_failed>

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400b686:	4b7c      	ldr	r3, [pc, #496]	@ (3400b878 <HAL_RCCEx_PeriphCLKConfig+0x1b18>)
3400b688:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400b68c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400b690:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400b694:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b698:	6a1a      	ldr	r2, [r3, #32]
3400b69a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b69e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b6a0:	3b01      	subs	r3, #1
3400b6a2:	041b      	lsls	r3, r3, #16
3400b6a4:	4313      	orrs	r3, r2
3400b6a6:	4a74      	ldr	r2, [pc, #464]	@ (3400b878 <HAL_RCCEx_PeriphCLKConfig+0x1b18>)
3400b6a8:	430b      	orrs	r3, r1
3400b6aa:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3400b6ae:	f7fd ff75 	bl	3400959c <LL_RCC_IC4_Enable>
3400b6b2:	e052      	b.n	3400b75a <HAL_RCCEx_PeriphCLKConfig+0x19fa>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC5)
3400b6b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b6b8:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
3400b6bc:	4b6c      	ldr	r3, [pc, #432]	@ (3400b870 <HAL_RCCEx_PeriphCLKConfig+0x1b10>)
3400b6be:	429a      	cmp	r2, r3
3400b6c0:	d142      	bne.n	3400b748 <HAL_RCCEx_PeriphCLKConfig+0x19e8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
3400b6c2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b6c6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400b6c8:	2b00      	cmp	r3, #0
3400b6ca:	d016      	beq.n	3400b6fa <HAL_RCCEx_PeriphCLKConfig+0x199a>
3400b6cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b6d0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400b6d2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400b6d6:	d010      	beq.n	3400b6fa <HAL_RCCEx_PeriphCLKConfig+0x199a>
3400b6d8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b6dc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400b6de:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b6e2:	d00a      	beq.n	3400b6fa <HAL_RCCEx_PeriphCLKConfig+0x199a>
3400b6e4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b6e8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400b6ea:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b6ee:	d004      	beq.n	3400b6fa <HAL_RCCEx_PeriphCLKConfig+0x199a>
3400b6f0:	f44f 71f5 	mov.w	r1, #490	@ 0x1ea
3400b6f4:	485f      	ldr	r0, [pc, #380]	@ (3400b874 <HAL_RCCEx_PeriphCLKConfig+0x1b14>)
3400b6f6:	f7f6 fc8b 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));
3400b6fa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b6fe:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400b700:	2b00      	cmp	r3, #0
3400b702:	d005      	beq.n	3400b710 <HAL_RCCEx_PeriphCLKConfig+0x19b0>
3400b704:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b708:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400b70a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400b70e:	d904      	bls.n	3400b71a <HAL_RCCEx_PeriphCLKConfig+0x19ba>
3400b710:	f240 11eb 	movw	r1, #491	@ 0x1eb
3400b714:	4857      	ldr	r0, [pc, #348]	@ (3400b874 <HAL_RCCEx_PeriphCLKConfig+0x1b14>)
3400b716:	f7f6 fc7b 	bl	34002010 <assert_failed>

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3400b71a:	4b57      	ldr	r3, [pc, #348]	@ (3400b878 <HAL_RCCEx_PeriphCLKConfig+0x1b18>)
3400b71c:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3400b720:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400b724:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400b728:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b72c:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3400b72e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b732:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400b734:	3b01      	subs	r3, #1
3400b736:	041b      	lsls	r3, r3, #16
3400b738:	4313      	orrs	r3, r2
3400b73a:	4a4f      	ldr	r2, [pc, #316]	@ (3400b878 <HAL_RCCEx_PeriphCLKConfig+0x1b18>)
3400b73c:	430b      	orrs	r3, r1
3400b73e:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
3400b742:	f7fd ff6b 	bl	3400961c <LL_RCC_IC5_Enable>
3400b746:	e008      	b.n	3400b75a <HAL_RCCEx_PeriphCLKConfig+0x19fa>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_CLKP)
3400b748:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b74c:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
3400b750:	4b45      	ldr	r3, [pc, #276]	@ (3400b868 <HAL_RCCEx_PeriphCLKConfig+0x1b08>)
3400b752:	429a      	cmp	r2, r3
3400b754:	d101      	bne.n	3400b75a <HAL_RCCEx_PeriphCLKConfig+0x19fa>
    {
      LL_RCC_CLKP_Enable();
3400b756:	f7fe fae1 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC1 clock*/
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
3400b75a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b75e:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
3400b762:	4618      	mov	r0, r3
3400b764:	f7fd fa51 	bl	34008c0a <LL_RCC_SetSDMMCClockSource>
  }

  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
3400b768:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b76c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400b770:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
3400b774:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
3400b778:	2300      	movs	r3, #0
3400b77a:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
3400b77e:	e9d7 0162 	ldrd	r0, r1, [r7, #392]	@ 0x188
3400b782:	4603      	mov	r3, r0
3400b784:	460a      	mov	r2, r1
3400b786:	4313      	orrs	r3, r2
3400b788:	f000 80da 	beq.w	3400b940 <HAL_RCCEx_PeriphCLKConfig+0x1be0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));
3400b78c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b790:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3400b794:	4b39      	ldr	r3, [pc, #228]	@ (3400b87c <HAL_RCCEx_PeriphCLKConfig+0x1b1c>)
3400b796:	429a      	cmp	r2, r3
3400b798:	d019      	beq.n	3400b7ce <HAL_RCCEx_PeriphCLKConfig+0x1a6e>
3400b79a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b79e:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3400b7a2:	4b37      	ldr	r3, [pc, #220]	@ (3400b880 <HAL_RCCEx_PeriphCLKConfig+0x1b20>)
3400b7a4:	429a      	cmp	r2, r3
3400b7a6:	d012      	beq.n	3400b7ce <HAL_RCCEx_PeriphCLKConfig+0x1a6e>
3400b7a8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b7ac:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3400b7b0:	4b34      	ldr	r3, [pc, #208]	@ (3400b884 <HAL_RCCEx_PeriphCLKConfig+0x1b24>)
3400b7b2:	429a      	cmp	r2, r3
3400b7b4:	d00b      	beq.n	3400b7ce <HAL_RCCEx_PeriphCLKConfig+0x1a6e>
3400b7b6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b7ba:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3400b7be:	4b32      	ldr	r3, [pc, #200]	@ (3400b888 <HAL_RCCEx_PeriphCLKConfig+0x1b28>)
3400b7c0:	429a      	cmp	r2, r3
3400b7c2:	d004      	beq.n	3400b7ce <HAL_RCCEx_PeriphCLKConfig+0x1a6e>
3400b7c4:	f240 2105 	movw	r1, #517	@ 0x205
3400b7c8:	482a      	ldr	r0, [pc, #168]	@ (3400b874 <HAL_RCCEx_PeriphCLKConfig+0x1b14>)
3400b7ca:	f7f6 fc21 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC4)
3400b7ce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b7d2:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3400b7d6:	4b2b      	ldr	r3, [pc, #172]	@ (3400b884 <HAL_RCCEx_PeriphCLKConfig+0x1b24>)
3400b7d8:	429a      	cmp	r2, r3
3400b7da:	d157      	bne.n	3400b88c <HAL_RCCEx_PeriphCLKConfig+0x1b2c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400b7dc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b7e0:	6a1b      	ldr	r3, [r3, #32]
3400b7e2:	2b00      	cmp	r3, #0
3400b7e4:	d016      	beq.n	3400b814 <HAL_RCCEx_PeriphCLKConfig+0x1ab4>
3400b7e6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b7ea:	6a1b      	ldr	r3, [r3, #32]
3400b7ec:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400b7f0:	d010      	beq.n	3400b814 <HAL_RCCEx_PeriphCLKConfig+0x1ab4>
3400b7f2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b7f6:	6a1b      	ldr	r3, [r3, #32]
3400b7f8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b7fc:	d00a      	beq.n	3400b814 <HAL_RCCEx_PeriphCLKConfig+0x1ab4>
3400b7fe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b802:	6a1b      	ldr	r3, [r3, #32]
3400b804:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b808:	d004      	beq.n	3400b814 <HAL_RCCEx_PeriphCLKConfig+0x1ab4>
3400b80a:	f240 210a 	movw	r1, #522	@ 0x20a
3400b80e:	4819      	ldr	r0, [pc, #100]	@ (3400b874 <HAL_RCCEx_PeriphCLKConfig+0x1b14>)
3400b810:	f7f6 fbfe 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400b814:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b818:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b81a:	2b00      	cmp	r3, #0
3400b81c:	d005      	beq.n	3400b82a <HAL_RCCEx_PeriphCLKConfig+0x1aca>
3400b81e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b822:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b824:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400b828:	d904      	bls.n	3400b834 <HAL_RCCEx_PeriphCLKConfig+0x1ad4>
3400b82a:	f240 210b 	movw	r1, #523	@ 0x20b
3400b82e:	4811      	ldr	r0, [pc, #68]	@ (3400b874 <HAL_RCCEx_PeriphCLKConfig+0x1b14>)
3400b830:	f7f6 fbee 	bl	34002010 <assert_failed>

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400b834:	4b10      	ldr	r3, [pc, #64]	@ (3400b878 <HAL_RCCEx_PeriphCLKConfig+0x1b18>)
3400b836:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400b83a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400b83e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400b842:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b846:	6a1a      	ldr	r2, [r3, #32]
3400b848:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b84c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b84e:	3b01      	subs	r3, #1
3400b850:	041b      	lsls	r3, r3, #16
3400b852:	4313      	orrs	r3, r2
3400b854:	4a08      	ldr	r2, [pc, #32]	@ (3400b878 <HAL_RCCEx_PeriphCLKConfig+0x1b18>)
3400b856:	430b      	orrs	r3, r1
3400b858:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3400b85c:	f7fd fe9e 	bl	3400959c <LL_RCC_IC4_Enable>
3400b860:	e067      	b.n	3400b932 <HAL_RCCEx_PeriphCLKConfig+0x1bd2>
3400b862:	bf00      	nop
3400b864:	0300001c 	.word	0x0300001c
3400b868:	0301001c 	.word	0x0301001c
3400b86c:	0302001c 	.word	0x0302001c
3400b870:	0303001c 	.word	0x0303001c
3400b874:	3401ee60 	.word	0x3401ee60
3400b878:	56028000 	.word	0x56028000
3400b87c:	0300041c 	.word	0x0300041c
3400b880:	0301041c 	.word	0x0301041c
3400b884:	0302041c 	.word	0x0302041c
3400b888:	0303041c 	.word	0x0303041c
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC5)
3400b88c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b890:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3400b894:	4ba0      	ldr	r3, [pc, #640]	@ (3400bb18 <HAL_RCCEx_PeriphCLKConfig+0x1db8>)
3400b896:	429a      	cmp	r2, r3
3400b898:	d142      	bne.n	3400b920 <HAL_RCCEx_PeriphCLKConfig+0x1bc0>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
3400b89a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b89e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400b8a0:	2b00      	cmp	r3, #0
3400b8a2:	d016      	beq.n	3400b8d2 <HAL_RCCEx_PeriphCLKConfig+0x1b72>
3400b8a4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b8a8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400b8aa:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400b8ae:	d010      	beq.n	3400b8d2 <HAL_RCCEx_PeriphCLKConfig+0x1b72>
3400b8b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b8b4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400b8b6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b8ba:	d00a      	beq.n	3400b8d2 <HAL_RCCEx_PeriphCLKConfig+0x1b72>
3400b8bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b8c0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400b8c2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b8c6:	d004      	beq.n	3400b8d2 <HAL_RCCEx_PeriphCLKConfig+0x1b72>
3400b8c8:	f240 2117 	movw	r1, #535	@ 0x217
3400b8cc:	4893      	ldr	r0, [pc, #588]	@ (3400bb1c <HAL_RCCEx_PeriphCLKConfig+0x1dbc>)
3400b8ce:	f7f6 fb9f 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));
3400b8d2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b8d6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400b8d8:	2b00      	cmp	r3, #0
3400b8da:	d005      	beq.n	3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0x1b88>
3400b8dc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b8e0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400b8e2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400b8e6:	d904      	bls.n	3400b8f2 <HAL_RCCEx_PeriphCLKConfig+0x1b92>
3400b8e8:	f44f 7106 	mov.w	r1, #536	@ 0x218
3400b8ec:	488b      	ldr	r0, [pc, #556]	@ (3400bb1c <HAL_RCCEx_PeriphCLKConfig+0x1dbc>)
3400b8ee:	f7f6 fb8f 	bl	34002010 <assert_failed>

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3400b8f2:	4b8b      	ldr	r3, [pc, #556]	@ (3400bb20 <HAL_RCCEx_PeriphCLKConfig+0x1dc0>)
3400b8f4:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3400b8f8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400b8fc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400b900:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b904:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3400b906:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b90a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400b90c:	3b01      	subs	r3, #1
3400b90e:	041b      	lsls	r3, r3, #16
3400b910:	4313      	orrs	r3, r2
3400b912:	4a83      	ldr	r2, [pc, #524]	@ (3400bb20 <HAL_RCCEx_PeriphCLKConfig+0x1dc0>)
3400b914:	430b      	orrs	r3, r1
3400b916:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
3400b91a:	f7fd fe7f 	bl	3400961c <LL_RCC_IC5_Enable>
3400b91e:	e008      	b.n	3400b932 <HAL_RCCEx_PeriphCLKConfig+0x1bd2>
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_CLKP)
3400b920:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b924:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3400b928:	4b7e      	ldr	r3, [pc, #504]	@ (3400bb24 <HAL_RCCEx_PeriphCLKConfig+0x1dc4>)
3400b92a:	429a      	cmp	r2, r3
3400b92c:	d101      	bne.n	3400b932 <HAL_RCCEx_PeriphCLKConfig+0x1bd2>
    {
      LL_RCC_CLKP_Enable();
3400b92e:	f7fe f9f5 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC2 clock*/
    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);
3400b932:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b936:	f8d3 3130 	ldr.w	r3, [r3, #304]	@ 0x130
3400b93a:	4618      	mov	r0, r3
3400b93c:	f7fd f965 	bl	34008c0a <LL_RCC_SetSDMMCClockSource>
  }

  /*---------------------------- ADC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
3400b940:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b944:	e9d3 2300 	ldrd	r2, r3, [r3]
3400b948:	f002 0301 	and.w	r3, r2, #1
3400b94c:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
3400b950:	2300      	movs	r3, #0
3400b952:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
3400b956:	e9d7 0160 	ldrd	r0, r1, [r7, #384]	@ 0x180
3400b95a:	4603      	mov	r3, r0
3400b95c:	460a      	mov	r2, r1
3400b95e:	4313      	orrs	r3, r2
3400b960:	f000 8100 	beq.w	3400bb64 <HAL_RCCEx_PeriphCLKConfig+0x1e04>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));
3400b964:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b968:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3400b96c:	2b00      	cmp	r3, #0
3400b96e:	d02e      	beq.n	3400b9ce <HAL_RCCEx_PeriphCLKConfig+0x1c6e>
3400b970:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b974:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3400b978:	2b10      	cmp	r3, #16
3400b97a:	d028      	beq.n	3400b9ce <HAL_RCCEx_PeriphCLKConfig+0x1c6e>
3400b97c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b980:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3400b984:	2b20      	cmp	r3, #32
3400b986:	d022      	beq.n	3400b9ce <HAL_RCCEx_PeriphCLKConfig+0x1c6e>
3400b988:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b98c:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3400b990:	2b30      	cmp	r3, #48	@ 0x30
3400b992:	d01c      	beq.n	3400b9ce <HAL_RCCEx_PeriphCLKConfig+0x1c6e>
3400b994:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b998:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3400b99c:	2b40      	cmp	r3, #64	@ 0x40
3400b99e:	d016      	beq.n	3400b9ce <HAL_RCCEx_PeriphCLKConfig+0x1c6e>
3400b9a0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b9a4:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3400b9a8:	2b50      	cmp	r3, #80	@ 0x50
3400b9aa:	d010      	beq.n	3400b9ce <HAL_RCCEx_PeriphCLKConfig+0x1c6e>
3400b9ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b9b0:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3400b9b4:	2b60      	cmp	r3, #96	@ 0x60
3400b9b6:	d00a      	beq.n	3400b9ce <HAL_RCCEx_PeriphCLKConfig+0x1c6e>
3400b9b8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b9bc:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3400b9c0:	2b70      	cmp	r3, #112	@ 0x70
3400b9c2:	d004      	beq.n	3400b9ce <HAL_RCCEx_PeriphCLKConfig+0x1c6e>
3400b9c4:	f240 2132 	movw	r1, #562	@ 0x232
3400b9c8:	4854      	ldr	r0, [pc, #336]	@ (3400bb1c <HAL_RCCEx_PeriphCLKConfig+0x1dbc>)
3400b9ca:	f7f6 fb21 	bl	34002010 <assert_failed>
    assert_param(IS_RCC_ADCDIVIDER(PeriphClkInit->AdcDivider));
3400b9ce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b9d2:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
3400b9d6:	2b00      	cmp	r3, #0
3400b9d8:	d006      	beq.n	3400b9e8 <HAL_RCCEx_PeriphCLKConfig+0x1c88>
3400b9da:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b9de:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
3400b9e2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400b9e6:	d904      	bls.n	3400b9f2 <HAL_RCCEx_PeriphCLKConfig+0x1c92>
3400b9e8:	f240 2133 	movw	r1, #563	@ 0x233
3400b9ec:	484b      	ldr	r0, [pc, #300]	@ (3400bb1c <HAL_RCCEx_PeriphCLKConfig+0x1dbc>)
3400b9ee:	f7f6 fb0f 	bl	34002010 <assert_failed>

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC7)
3400b9f2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400b9f6:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3400b9fa:	2b20      	cmp	r3, #32
3400b9fc:	d142      	bne.n	3400ba84 <HAL_RCCEx_PeriphCLKConfig+0x1d24>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400b9fe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ba02:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400ba04:	2b00      	cmp	r3, #0
3400ba06:	d016      	beq.n	3400ba36 <HAL_RCCEx_PeriphCLKConfig+0x1cd6>
3400ba08:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ba0c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400ba0e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ba12:	d010      	beq.n	3400ba36 <HAL_RCCEx_PeriphCLKConfig+0x1cd6>
3400ba14:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ba18:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400ba1a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ba1e:	d00a      	beq.n	3400ba36 <HAL_RCCEx_PeriphCLKConfig+0x1cd6>
3400ba20:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ba24:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400ba26:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ba2a:	d004      	beq.n	3400ba36 <HAL_RCCEx_PeriphCLKConfig+0x1cd6>
3400ba2c:	f44f 710e 	mov.w	r1, #568	@ 0x238
3400ba30:	483a      	ldr	r0, [pc, #232]	@ (3400bb1c <HAL_RCCEx_PeriphCLKConfig+0x1dbc>)
3400ba32:	f7f6 faed 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400ba36:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ba3a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400ba3c:	2b00      	cmp	r3, #0
3400ba3e:	d005      	beq.n	3400ba4c <HAL_RCCEx_PeriphCLKConfig+0x1cec>
3400ba40:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ba44:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400ba46:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400ba4a:	d904      	bls.n	3400ba56 <HAL_RCCEx_PeriphCLKConfig+0x1cf6>
3400ba4c:	f240 2139 	movw	r1, #569	@ 0x239
3400ba50:	4832      	ldr	r0, [pc, #200]	@ (3400bb1c <HAL_RCCEx_PeriphCLKConfig+0x1dbc>)
3400ba52:	f7f6 fadd 	bl	34002010 <assert_failed>

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400ba56:	4b32      	ldr	r3, [pc, #200]	@ (3400bb20 <HAL_RCCEx_PeriphCLKConfig+0x1dc0>)
3400ba58:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400ba5c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400ba60:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400ba64:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ba68:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3400ba6a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ba6e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400ba70:	3b01      	subs	r3, #1
3400ba72:	041b      	lsls	r3, r3, #16
3400ba74:	4313      	orrs	r3, r2
3400ba76:	4a2a      	ldr	r2, [pc, #168]	@ (3400bb20 <HAL_RCCEx_PeriphCLKConfig+0x1dc0>)
3400ba78:	430b      	orrs	r3, r1
3400ba7a:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
3400ba7e:	f7fd fe0d 	bl	3400969c <LL_RCC_IC7_Enable>
3400ba82:	e059      	b.n	3400bb38 <HAL_RCCEx_PeriphCLKConfig+0x1dd8>
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC8)
3400ba84:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ba88:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3400ba8c:	2b30      	cmp	r3, #48	@ 0x30
3400ba8e:	d14b      	bne.n	3400bb28 <HAL_RCCEx_PeriphCLKConfig+0x1dc8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400ba90:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ba94:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400ba96:	2b00      	cmp	r3, #0
3400ba98:	d016      	beq.n	3400bac8 <HAL_RCCEx_PeriphCLKConfig+0x1d68>
3400ba9a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ba9e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400baa0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400baa4:	d010      	beq.n	3400bac8 <HAL_RCCEx_PeriphCLKConfig+0x1d68>
3400baa6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400baaa:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400baac:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400bab0:	d00a      	beq.n	3400bac8 <HAL_RCCEx_PeriphCLKConfig+0x1d68>
3400bab2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bab6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400bab8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400babc:	d004      	beq.n	3400bac8 <HAL_RCCEx_PeriphCLKConfig+0x1d68>
3400babe:	f240 2145 	movw	r1, #581	@ 0x245
3400bac2:	4816      	ldr	r0, [pc, #88]	@ (3400bb1c <HAL_RCCEx_PeriphCLKConfig+0x1dbc>)
3400bac4:	f7f6 faa4 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400bac8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bacc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400bace:	2b00      	cmp	r3, #0
3400bad0:	d005      	beq.n	3400bade <HAL_RCCEx_PeriphCLKConfig+0x1d7e>
3400bad2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bad6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400bad8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400badc:	d904      	bls.n	3400bae8 <HAL_RCCEx_PeriphCLKConfig+0x1d88>
3400bade:	f240 2146 	movw	r1, #582	@ 0x246
3400bae2:	480e      	ldr	r0, [pc, #56]	@ (3400bb1c <HAL_RCCEx_PeriphCLKConfig+0x1dbc>)
3400bae4:	f7f6 fa94 	bl	34002010 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400bae8:	4b0d      	ldr	r3, [pc, #52]	@ (3400bb20 <HAL_RCCEx_PeriphCLKConfig+0x1dc0>)
3400baea:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400baee:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400baf2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400baf6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bafa:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3400bafc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bb00:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400bb02:	3b01      	subs	r3, #1
3400bb04:	041b      	lsls	r3, r3, #16
3400bb06:	4313      	orrs	r3, r2
3400bb08:	4a05      	ldr	r2, [pc, #20]	@ (3400bb20 <HAL_RCCEx_PeriphCLKConfig+0x1dc0>)
3400bb0a:	430b      	orrs	r3, r1
3400bb0c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3400bb10:	f7fd fe04 	bl	3400971c <LL_RCC_IC8_Enable>
3400bb14:	e010      	b.n	3400bb38 <HAL_RCCEx_PeriphCLKConfig+0x1dd8>
3400bb16:	bf00      	nop
3400bb18:	0303041c 	.word	0x0303041c
3400bb1c:	3401ee60 	.word	0x3401ee60
3400bb20:	56028000 	.word	0x56028000
3400bb24:	0301041c 	.word	0x0301041c
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_CLKP)
3400bb28:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bb2c:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3400bb30:	2b10      	cmp	r3, #16
3400bb32:	d101      	bne.n	3400bb38 <HAL_RCCEx_PeriphCLKConfig+0x1dd8>
    {
      LL_RCC_CLKP_Enable();
3400bb34:	f7fe f8f2 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ADC clock source and divider */
    MODIFY_REG(RCC->CCIPR1, (RCC_CCIPR1_ADCPRE | RCC_CCIPR1_ADC12SEL), \
3400bb38:	4b77      	ldr	r3, [pc, #476]	@ (3400bd18 <HAL_RCCEx_PeriphCLKConfig+0x1fb8>)
3400bb3a:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400bb3e:	f423 417f 	bic.w	r1, r3, #65280	@ 0xff00
3400bb42:	f021 0170 	bic.w	r1, r1, #112	@ 0x70
3400bb46:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bb4a:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
3400bb4e:	3b01      	subs	r3, #1
3400bb50:	021a      	lsls	r2, r3, #8
3400bb52:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bb56:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3400bb5a:	4313      	orrs	r3, r2
3400bb5c:	4a6e      	ldr	r2, [pc, #440]	@ (3400bd18 <HAL_RCCEx_PeriphCLKConfig+0x1fb8>)
3400bb5e:	430b      	orrs	r3, r1
3400bb60:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
               (((PeriphClkInit->AdcDivider - 1U) << RCC_CCIPR1_ADCPRE_Pos) | (PeriphClkInit->AdcClockSelection)));
  }

  /*---------------------------- ADF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
3400bb64:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bb68:	e9d3 2300 	ldrd	r2, r3, [r3]
3400bb6c:	f002 0302 	and.w	r3, r2, #2
3400bb70:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
3400bb74:	2300      	movs	r3, #0
3400bb76:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
3400bb7a:	e9d7 015e 	ldrd	r0, r1, [r7, #376]	@ 0x178
3400bb7e:	4603      	mov	r3, r0
3400bb80:	460a      	mov	r2, r1
3400bb82:	4313      	orrs	r3, r2
3400bb84:	f000 80db 	beq.w	3400bd3e <HAL_RCCEx_PeriphCLKConfig+0x1fde>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADF1CLKSOURCE(PeriphClkInit->Adf1ClockSelection));
3400bb88:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bb8c:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400bb90:	2b00      	cmp	r3, #0
3400bb92:	d02e      	beq.n	3400bbf2 <HAL_RCCEx_PeriphCLKConfig+0x1e92>
3400bb94:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bb98:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400bb9c:	2b01      	cmp	r3, #1
3400bb9e:	d028      	beq.n	3400bbf2 <HAL_RCCEx_PeriphCLKConfig+0x1e92>
3400bba0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bba4:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400bba8:	2b02      	cmp	r3, #2
3400bbaa:	d022      	beq.n	3400bbf2 <HAL_RCCEx_PeriphCLKConfig+0x1e92>
3400bbac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bbb0:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400bbb4:	2b03      	cmp	r3, #3
3400bbb6:	d01c      	beq.n	3400bbf2 <HAL_RCCEx_PeriphCLKConfig+0x1e92>
3400bbb8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bbbc:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400bbc0:	2b04      	cmp	r3, #4
3400bbc2:	d016      	beq.n	3400bbf2 <HAL_RCCEx_PeriphCLKConfig+0x1e92>
3400bbc4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bbc8:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400bbcc:	2b05      	cmp	r3, #5
3400bbce:	d010      	beq.n	3400bbf2 <HAL_RCCEx_PeriphCLKConfig+0x1e92>
3400bbd0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bbd4:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400bbd8:	2b06      	cmp	r3, #6
3400bbda:	d00a      	beq.n	3400bbf2 <HAL_RCCEx_PeriphCLKConfig+0x1e92>
3400bbdc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bbe0:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400bbe4:	2b07      	cmp	r3, #7
3400bbe6:	d004      	beq.n	3400bbf2 <HAL_RCCEx_PeriphCLKConfig+0x1e92>
3400bbe8:	f240 2161 	movw	r1, #609	@ 0x261
3400bbec:	484b      	ldr	r0, [pc, #300]	@ (3400bd1c <HAL_RCCEx_PeriphCLKConfig+0x1fbc>)
3400bbee:	f7f6 fa0f 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC7)
3400bbf2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bbf6:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400bbfa:	2b02      	cmp	r3, #2
3400bbfc:	d142      	bne.n	3400bc84 <HAL_RCCEx_PeriphCLKConfig+0x1f24>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400bbfe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bc02:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400bc04:	2b00      	cmp	r3, #0
3400bc06:	d016      	beq.n	3400bc36 <HAL_RCCEx_PeriphCLKConfig+0x1ed6>
3400bc08:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bc0c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400bc0e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400bc12:	d010      	beq.n	3400bc36 <HAL_RCCEx_PeriphCLKConfig+0x1ed6>
3400bc14:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bc18:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400bc1a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400bc1e:	d00a      	beq.n	3400bc36 <HAL_RCCEx_PeriphCLKConfig+0x1ed6>
3400bc20:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bc24:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400bc26:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400bc2a:	d004      	beq.n	3400bc36 <HAL_RCCEx_PeriphCLKConfig+0x1ed6>
3400bc2c:	f240 2166 	movw	r1, #614	@ 0x266
3400bc30:	483a      	ldr	r0, [pc, #232]	@ (3400bd1c <HAL_RCCEx_PeriphCLKConfig+0x1fbc>)
3400bc32:	f7f6 f9ed 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400bc36:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bc3a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400bc3c:	2b00      	cmp	r3, #0
3400bc3e:	d005      	beq.n	3400bc4c <HAL_RCCEx_PeriphCLKConfig+0x1eec>
3400bc40:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bc44:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400bc46:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400bc4a:	d904      	bls.n	3400bc56 <HAL_RCCEx_PeriphCLKConfig+0x1ef6>
3400bc4c:	f240 2167 	movw	r1, #615	@ 0x267
3400bc50:	4832      	ldr	r0, [pc, #200]	@ (3400bd1c <HAL_RCCEx_PeriphCLKConfig+0x1fbc>)
3400bc52:	f7f6 f9dd 	bl	34002010 <assert_failed>

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400bc56:	4b30      	ldr	r3, [pc, #192]	@ (3400bd18 <HAL_RCCEx_PeriphCLKConfig+0x1fb8>)
3400bc58:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400bc5c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400bc60:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400bc64:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bc68:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3400bc6a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bc6e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400bc70:	3b01      	subs	r3, #1
3400bc72:	041b      	lsls	r3, r3, #16
3400bc74:	4313      	orrs	r3, r2
3400bc76:	4a28      	ldr	r2, [pc, #160]	@ (3400bd18 <HAL_RCCEx_PeriphCLKConfig+0x1fb8>)
3400bc78:	430b      	orrs	r3, r1
3400bc7a:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
3400bc7e:	f7fd fd0d 	bl	3400969c <LL_RCC_IC7_Enable>
3400bc82:	e055      	b.n	3400bd30 <HAL_RCCEx_PeriphCLKConfig+0x1fd0>
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC8)
3400bc84:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bc88:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400bc8c:	2b03      	cmp	r3, #3
3400bc8e:	d147      	bne.n	3400bd20 <HAL_RCCEx_PeriphCLKConfig+0x1fc0>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400bc90:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bc94:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400bc96:	2b00      	cmp	r3, #0
3400bc98:	d016      	beq.n	3400bcc8 <HAL_RCCEx_PeriphCLKConfig+0x1f68>
3400bc9a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bc9e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400bca0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400bca4:	d010      	beq.n	3400bcc8 <HAL_RCCEx_PeriphCLKConfig+0x1f68>
3400bca6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bcaa:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400bcac:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400bcb0:	d00a      	beq.n	3400bcc8 <HAL_RCCEx_PeriphCLKConfig+0x1f68>
3400bcb2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bcb6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400bcb8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400bcbc:	d004      	beq.n	3400bcc8 <HAL_RCCEx_PeriphCLKConfig+0x1f68>
3400bcbe:	f240 2173 	movw	r1, #627	@ 0x273
3400bcc2:	4816      	ldr	r0, [pc, #88]	@ (3400bd1c <HAL_RCCEx_PeriphCLKConfig+0x1fbc>)
3400bcc4:	f7f6 f9a4 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400bcc8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bccc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400bcce:	2b00      	cmp	r3, #0
3400bcd0:	d005      	beq.n	3400bcde <HAL_RCCEx_PeriphCLKConfig+0x1f7e>
3400bcd2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bcd6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400bcd8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400bcdc:	d904      	bls.n	3400bce8 <HAL_RCCEx_PeriphCLKConfig+0x1f88>
3400bcde:	f44f 711d 	mov.w	r1, #628	@ 0x274
3400bce2:	480e      	ldr	r0, [pc, #56]	@ (3400bd1c <HAL_RCCEx_PeriphCLKConfig+0x1fbc>)
3400bce4:	f7f6 f994 	bl	34002010 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400bce8:	4b0b      	ldr	r3, [pc, #44]	@ (3400bd18 <HAL_RCCEx_PeriphCLKConfig+0x1fb8>)
3400bcea:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400bcee:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400bcf2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400bcf6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bcfa:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3400bcfc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bd00:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400bd02:	3b01      	subs	r3, #1
3400bd04:	041b      	lsls	r3, r3, #16
3400bd06:	4313      	orrs	r3, r2
3400bd08:	4a03      	ldr	r2, [pc, #12]	@ (3400bd18 <HAL_RCCEx_PeriphCLKConfig+0x1fb8>)
3400bd0a:	430b      	orrs	r3, r1
3400bd0c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3400bd10:	f7fd fd04 	bl	3400971c <LL_RCC_IC8_Enable>
3400bd14:	e00c      	b.n	3400bd30 <HAL_RCCEx_PeriphCLKConfig+0x1fd0>
3400bd16:	bf00      	nop
3400bd18:	56028000 	.word	0x56028000
3400bd1c:	3401ee60 	.word	0x3401ee60
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_CLKP)
3400bd20:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bd24:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400bd28:	2b01      	cmp	r3, #1
3400bd2a:	d101      	bne.n	3400bd30 <HAL_RCCEx_PeriphCLKConfig+0x1fd0>
    {
      LL_RCC_CLKP_Enable();
3400bd2c:	f7fd fff6 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of ADF1 clock*/
    __HAL_RCC_ADF1_CONFIG(PeriphClkInit->Adf1ClockSelection);
3400bd30:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bd34:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400bd38:	4618      	mov	r0, r3
3400bd3a:	f7fc fdf7 	bl	3400892c <LL_RCC_SetADFClockSource>
  }

  /*------------------------------------ CSI configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CSI) == RCC_PERIPHCLK_CSI)
3400bd3e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bd42:	e9d3 2300 	ldrd	r2, r3, [r3]
3400bd46:	f002 0308 	and.w	r3, r2, #8
3400bd4a:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
3400bd4e:	2300      	movs	r3, #0
3400bd50:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
3400bd54:	e9d7 015c 	ldrd	r0, r1, [r7, #368]	@ 0x170
3400bd58:	4603      	mov	r3, r0
3400bd5a:	460a      	mov	r2, r1
3400bd5c:	4313      	orrs	r3, r2
3400bd5e:	d049      	beq.n	3400bdf4 <HAL_RCCEx_PeriphCLKConfig+0x2094>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC18].ClockSelection));
3400bd60:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bd64:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400bd68:	2b00      	cmp	r3, #0
3400bd6a:	d019      	beq.n	3400bda0 <HAL_RCCEx_PeriphCLKConfig+0x2040>
3400bd6c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bd70:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400bd74:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400bd78:	d012      	beq.n	3400bda0 <HAL_RCCEx_PeriphCLKConfig+0x2040>
3400bd7a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bd7e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400bd82:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400bd86:	d00b      	beq.n	3400bda0 <HAL_RCCEx_PeriphCLKConfig+0x2040>
3400bd88:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bd8c:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400bd90:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400bd94:	d004      	beq.n	3400bda0 <HAL_RCCEx_PeriphCLKConfig+0x2040>
3400bd96:	f240 218e 	movw	r1, #654	@ 0x28e
3400bd9a:	489e      	ldr	r0, [pc, #632]	@ (3400c014 <HAL_RCCEx_PeriphCLKConfig+0x22b4>)
3400bd9c:	f7f6 f938 	bl	34002010 <assert_failed>
    assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC18].ClockDivider));
3400bda0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bda4:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
3400bda8:	2b00      	cmp	r3, #0
3400bdaa:	d006      	beq.n	3400bdba <HAL_RCCEx_PeriphCLKConfig+0x205a>
3400bdac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bdb0:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
3400bdb4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400bdb8:	d904      	bls.n	3400bdc4 <HAL_RCCEx_PeriphCLKConfig+0x2064>
3400bdba:	f240 218f 	movw	r1, #655	@ 0x28f
3400bdbe:	4895      	ldr	r0, [pc, #596]	@ (3400c014 <HAL_RCCEx_PeriphCLKConfig+0x22b4>)
3400bdc0:	f7f6 f926 	bl	34002010 <assert_failed>

    /* Set IC18 configuration */
    MODIFY_REG(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL | RCC_IC18CFGR_IC18INT,
3400bdc4:	4b94      	ldr	r3, [pc, #592]	@ (3400c018 <HAL_RCCEx_PeriphCLKConfig+0x22b8>)
3400bdc6:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
3400bdca:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400bdce:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400bdd2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bdd6:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
3400bdda:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bdde:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
3400bde2:	3b01      	subs	r3, #1
3400bde4:	041b      	lsls	r3, r3, #16
3400bde6:	4313      	orrs	r3, r2
3400bde8:	4a8b      	ldr	r2, [pc, #556]	@ (3400c018 <HAL_RCCEx_PeriphCLKConfig+0x22b8>)
3400bdea:	430b      	orrs	r3, r1
3400bdec:	f8c2 3108 	str.w	r3, [r2, #264]	@ 0x108
               PeriphClkInit->ICSelection[RCC_IC18].ClockSelection | \
               ((PeriphClkInit->ICSelection[RCC_IC18].ClockDivider - 1U) << RCC_IC18CFGR_IC18INT_Pos));

    LL_RCC_IC18_Enable();
3400bdf0:	f7fd fed4 	bl	34009b9c <LL_RCC_IC18_Enable>
  }

  /*---------------------- DCMIPP configuration ------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_DCMIPP) == RCC_PERIPHCLK_DCMIPP)
3400bdf4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bdf8:	e9d3 2300 	ldrd	r2, r3, [r3]
3400bdfc:	f002 0310 	and.w	r3, r2, #16
3400be00:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
3400be04:	2300      	movs	r3, #0
3400be06:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
3400be0a:	e9d7 015a 	ldrd	r0, r1, [r7, #360]	@ 0x168
3400be0e:	4603      	mov	r3, r0
3400be10:	460a      	mov	r2, r1
3400be12:	4313      	orrs	r3, r2
3400be14:	f000 8082 	beq.w	3400bf1c <HAL_RCCEx_PeriphCLKConfig+0x21bc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DCMIPPCLKSOURCE(PeriphClkInit->DcmippClockSelection));
3400be18:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400be1c:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3400be20:	2b00      	cmp	r3, #0
3400be22:	d019      	beq.n	3400be58 <HAL_RCCEx_PeriphCLKConfig+0x20f8>
3400be24:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400be28:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3400be2c:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3400be30:	d012      	beq.n	3400be58 <HAL_RCCEx_PeriphCLKConfig+0x20f8>
3400be32:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400be36:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3400be3a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400be3e:	d00b      	beq.n	3400be58 <HAL_RCCEx_PeriphCLKConfig+0x20f8>
3400be40:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400be44:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3400be48:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400be4c:	d004      	beq.n	3400be58 <HAL_RCCEx_PeriphCLKConfig+0x20f8>
3400be4e:	f240 219d 	movw	r1, #669	@ 0x29d
3400be52:	4870      	ldr	r0, [pc, #448]	@ (3400c014 <HAL_RCCEx_PeriphCLKConfig+0x22b4>)
3400be54:	f7f6 f8dc 	bl	34002010 <assert_failed>

    if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_IC17)
3400be58:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400be5c:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3400be60:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400be64:	d14a      	bne.n	3400befc <HAL_RCCEx_PeriphCLKConfig+0x219c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC17].ClockSelection));
3400be66:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400be6a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3400be6e:	2b00      	cmp	r3, #0
3400be70:	d019      	beq.n	3400bea6 <HAL_RCCEx_PeriphCLKConfig+0x2146>
3400be72:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400be76:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3400be7a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400be7e:	d012      	beq.n	3400bea6 <HAL_RCCEx_PeriphCLKConfig+0x2146>
3400be80:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400be84:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3400be88:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400be8c:	d00b      	beq.n	3400bea6 <HAL_RCCEx_PeriphCLKConfig+0x2146>
3400be8e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400be92:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3400be96:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400be9a:	d004      	beq.n	3400bea6 <HAL_RCCEx_PeriphCLKConfig+0x2146>
3400be9c:	f240 21a2 	movw	r1, #674	@ 0x2a2
3400bea0:	485c      	ldr	r0, [pc, #368]	@ (3400c014 <HAL_RCCEx_PeriphCLKConfig+0x22b4>)
3400bea2:	f7f6 f8b5 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC17].ClockDivider));
3400bea6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400beaa:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
3400beae:	2b00      	cmp	r3, #0
3400beb0:	d006      	beq.n	3400bec0 <HAL_RCCEx_PeriphCLKConfig+0x2160>
3400beb2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400beb6:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
3400beba:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400bebe:	d904      	bls.n	3400beca <HAL_RCCEx_PeriphCLKConfig+0x216a>
3400bec0:	f240 21a3 	movw	r1, #675	@ 0x2a3
3400bec4:	4853      	ldr	r0, [pc, #332]	@ (3400c014 <HAL_RCCEx_PeriphCLKConfig+0x22b4>)
3400bec6:	f7f6 f8a3 	bl	34002010 <assert_failed>

      /* Set IC17 configuration */
      MODIFY_REG(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL | RCC_IC17CFGR_IC17INT,
3400beca:	4b53      	ldr	r3, [pc, #332]	@ (3400c018 <HAL_RCCEx_PeriphCLKConfig+0x22b8>)
3400becc:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3400bed0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400bed4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400bed8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bedc:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
3400bee0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bee4:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
3400bee8:	3b01      	subs	r3, #1
3400beea:	041b      	lsls	r3, r3, #16
3400beec:	4313      	orrs	r3, r2
3400beee:	4a4a      	ldr	r2, [pc, #296]	@ (3400c018 <HAL_RCCEx_PeriphCLKConfig+0x22b8>)
3400bef0:	430b      	orrs	r3, r1
3400bef2:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
                 PeriphClkInit->ICSelection[RCC_IC17].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC17].ClockDivider - 1U) << RCC_IC17CFGR_IC17INT_Pos));

      LL_RCC_IC17_Enable();
3400bef6:	f7fd fe11 	bl	34009b1c <LL_RCC_IC17_Enable>
3400befa:	e008      	b.n	3400bf0e <HAL_RCCEx_PeriphCLKConfig+0x21ae>
    }
    else if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_CLKP)
3400befc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bf00:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3400bf04:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3400bf08:	d101      	bne.n	3400bf0e <HAL_RCCEx_PeriphCLKConfig+0x21ae>
    {
      LL_RCC_CLKP_Enable();
3400bf0a:	f7fd ff07 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the CEC clock source */
    __HAL_RCC_DCMIPP_CONFIG(PeriphClkInit->DcmippClockSelection);
3400bf0e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bf12:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3400bf16:	4618      	mov	r0, r3
3400bf18:	f7fc fd34 	bl	34008984 <LL_RCC_SetDCMIPPClockSource>
  }

  /*---------------------- ETH1 configuration --------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1) == RCC_PERIPHCLK_ETH1)
3400bf1c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bf20:	e9d3 2300 	ldrd	r2, r3, [r3]
3400bf24:	f002 0320 	and.w	r3, r2, #32
3400bf28:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
3400bf2c:	2300      	movs	r3, #0
3400bf2e:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
3400bf32:	e9d7 0158 	ldrd	r0, r1, [r7, #352]	@ 0x160
3400bf36:	4603      	mov	r3, r0
3400bf38:	460a      	mov	r2, r1
3400bf3a:	4313      	orrs	r3, r2
3400bf3c:	d07e      	beq.n	3400c03c <HAL_RCCEx_PeriphCLKConfig+0x22dc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1CLKSOURCE(PeriphClkInit->Eth1ClockSelection));
3400bf3e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bf42:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400bf46:	2b00      	cmp	r3, #0
3400bf48:	d019      	beq.n	3400bf7e <HAL_RCCEx_PeriphCLKConfig+0x221e>
3400bf4a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bf4e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400bf52:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3400bf56:	d012      	beq.n	3400bf7e <HAL_RCCEx_PeriphCLKConfig+0x221e>
3400bf58:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bf5c:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400bf60:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3400bf64:	d00b      	beq.n	3400bf7e <HAL_RCCEx_PeriphCLKConfig+0x221e>
3400bf66:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bf6a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400bf6e:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
3400bf72:	d004      	beq.n	3400bf7e <HAL_RCCEx_PeriphCLKConfig+0x221e>
3400bf74:	f240 21bd 	movw	r1, #701	@ 0x2bd
3400bf78:	4826      	ldr	r0, [pc, #152]	@ (3400c014 <HAL_RCCEx_PeriphCLKConfig+0x22b4>)
3400bf7a:	f7f6 f849 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_IC12)
3400bf7e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bf82:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400bf86:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3400bf8a:	d147      	bne.n	3400c01c <HAL_RCCEx_PeriphCLKConfig+0x22bc>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC12].ClockSelection));
3400bf8c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bf90:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3400bf92:	2b00      	cmp	r3, #0
3400bf94:	d016      	beq.n	3400bfc4 <HAL_RCCEx_PeriphCLKConfig+0x2264>
3400bf96:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bf9a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3400bf9c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400bfa0:	d010      	beq.n	3400bfc4 <HAL_RCCEx_PeriphCLKConfig+0x2264>
3400bfa2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bfa6:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3400bfa8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400bfac:	d00a      	beq.n	3400bfc4 <HAL_RCCEx_PeriphCLKConfig+0x2264>
3400bfae:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bfb2:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3400bfb4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400bfb8:	d004      	beq.n	3400bfc4 <HAL_RCCEx_PeriphCLKConfig+0x2264>
3400bfba:	f240 21c2 	movw	r1, #706	@ 0x2c2
3400bfbe:	4815      	ldr	r0, [pc, #84]	@ (3400c014 <HAL_RCCEx_PeriphCLKConfig+0x22b4>)
3400bfc0:	f7f6 f826 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC12].ClockDivider));
3400bfc4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bfc8:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3400bfca:	2b00      	cmp	r3, #0
3400bfcc:	d005      	beq.n	3400bfda <HAL_RCCEx_PeriphCLKConfig+0x227a>
3400bfce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bfd2:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3400bfd4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400bfd8:	d904      	bls.n	3400bfe4 <HAL_RCCEx_PeriphCLKConfig+0x2284>
3400bfda:	f240 21c3 	movw	r1, #707	@ 0x2c3
3400bfde:	480d      	ldr	r0, [pc, #52]	@ (3400c014 <HAL_RCCEx_PeriphCLKConfig+0x22b4>)
3400bfe0:	f7f6 f816 	bl	34002010 <assert_failed>

      /* Set IC12 configuration */
      MODIFY_REG(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL | RCC_IC12CFGR_IC12INT,
3400bfe4:	4b0c      	ldr	r3, [pc, #48]	@ (3400c018 <HAL_RCCEx_PeriphCLKConfig+0x22b8>)
3400bfe6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
3400bfea:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400bfee:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400bff2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bff6:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
3400bff8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400bffc:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3400bffe:	3b01      	subs	r3, #1
3400c000:	041b      	lsls	r3, r3, #16
3400c002:	4313      	orrs	r3, r2
3400c004:	4a04      	ldr	r2, [pc, #16]	@ (3400c018 <HAL_RCCEx_PeriphCLKConfig+0x22b8>)
3400c006:	430b      	orrs	r3, r1
3400c008:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
                 PeriphClkInit->ICSelection[RCC_IC12].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC12].ClockDivider - 1U) << RCC_IC12CFGR_IC12INT_Pos));

      LL_RCC_IC12_Enable();
3400c00c:	f7fd fc46 	bl	3400989c <LL_RCC_IC12_Enable>
3400c010:	e00d      	b.n	3400c02e <HAL_RCCEx_PeriphCLKConfig+0x22ce>
3400c012:	bf00      	nop
3400c014:	3401ee60 	.word	0x3401ee60
3400c018:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_CLKP)
3400c01c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c020:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400c024:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3400c028:	d101      	bne.n	3400c02e <HAL_RCCEx_PeriphCLKConfig+0x22ce>
    {
      LL_RCC_CLKP_Enable();
3400c02a:	f7fd fe77 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 clock source */
    __HAL_RCC_ETH1_CONFIG(PeriphClkInit->Eth1ClockSelection);
3400c02e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c032:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400c036:	4618      	mov	r0, r3
3400c038:	f7fc fcba 	bl	340089b0 <LL_RCC_SetETHClockSource>
  }

  /*---------------------- ETH1PHY configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PHY) == RCC_PERIPHCLK_ETH1PHY)
3400c03c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c040:	e9d3 2300 	ldrd	r2, r3, [r3]
3400c044:	f002 0340 	and.w	r3, r2, #64	@ 0x40
3400c048:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
3400c04c:	2300      	movs	r3, #0
3400c04e:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
3400c052:	e9d7 0156 	ldrd	r0, r1, [r7, #344]	@ 0x158
3400c056:	4603      	mov	r3, r0
3400c058:	460a      	mov	r2, r1
3400c05a:	4313      	orrs	r3, r2
3400c05c:	d01f      	beq.n	3400c09e <HAL_RCCEx_PeriphCLKConfig+0x233e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PHYIF(PeriphClkInit->Eth1PhyInterfaceSelection));
3400c05e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c062:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400c066:	2b00      	cmp	r3, #0
3400c068:	d012      	beq.n	3400c090 <HAL_RCCEx_PeriphCLKConfig+0x2330>
3400c06a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c06e:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400c072:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3400c076:	d00b      	beq.n	3400c090 <HAL_RCCEx_PeriphCLKConfig+0x2330>
3400c078:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c07c:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400c080:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400c084:	d004      	beq.n	3400c090 <HAL_RCCEx_PeriphCLKConfig+0x2330>
3400c086:	f240 21dd 	movw	r1, #733	@ 0x2dd
3400c08a:	48c1      	ldr	r0, [pc, #772]	@ (3400c390 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
3400c08c:	f7f5 ffc0 	bl	34002010 <assert_failed>

    /* Configure the source of ETH1 PHY interface */
    __HAL_RCC_ETH1PHY_CONFIG(PeriphClkInit->Eth1PhyInterfaceSelection);
3400c090:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c094:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400c098:	4618      	mov	r0, r3
3400c09a:	f7fc fc9f 	bl	340089dc <LL_RCC_SetETHPHYInterface>
  }

  /*---------------------- ETH1 RX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1RX) == RCC_PERIPHCLK_ETH1RX)
3400c09e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c0a2:	e9d3 2300 	ldrd	r2, r3, [r3]
3400c0a6:	f002 0380 	and.w	r3, r2, #128	@ 0x80
3400c0aa:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
3400c0ae:	2300      	movs	r3, #0
3400c0b0:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
3400c0b4:	e9d7 0154 	ldrd	r0, r1, [r7, #336]	@ 0x150
3400c0b8:	4603      	mov	r3, r0
3400c0ba:	460a      	mov	r2, r1
3400c0bc:	4313      	orrs	r3, r2
3400c0be:	d018      	beq.n	3400c0f2 <HAL_RCCEx_PeriphCLKConfig+0x2392>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1RXCLKSOURCE(PeriphClkInit->Eth1RxClockSelection));
3400c0c0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c0c4:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3400c0c8:	2b00      	cmp	r3, #0
3400c0ca:	d00b      	beq.n	3400c0e4 <HAL_RCCEx_PeriphCLKConfig+0x2384>
3400c0cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c0d0:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3400c0d4:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3400c0d8:	d004      	beq.n	3400c0e4 <HAL_RCCEx_PeriphCLKConfig+0x2384>
3400c0da:	f240 21e7 	movw	r1, #743	@ 0x2e7
3400c0de:	48ac      	ldr	r0, [pc, #688]	@ (3400c390 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
3400c0e0:	f7f5 ff96 	bl	34002010 <assert_failed>

    /* Configure the ETH1 RX clock source */
    __HAL_RCC_ETH1RX_CONFIG(PeriphClkInit->Eth1RxClockSelection);
3400c0e4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c0e8:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3400c0ec:	4618      	mov	r0, r3
3400c0ee:	f7fc fc99 	bl	34008a24 <LL_RCC_SetETHREFRXClockSource>
  }

  /*---------------------- ETH1 TX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1TX) == RCC_PERIPHCLK_ETH1TX)
3400c0f2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c0f6:	e9d3 2300 	ldrd	r2, r3, [r3]
3400c0fa:	f402 7380 	and.w	r3, r2, #256	@ 0x100
3400c0fe:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
3400c102:	2300      	movs	r3, #0
3400c104:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
3400c108:	e9d7 0152 	ldrd	r0, r1, [r7, #328]	@ 0x148
3400c10c:	4603      	mov	r3, r0
3400c10e:	460a      	mov	r2, r1
3400c110:	4313      	orrs	r3, r2
3400c112:	d018      	beq.n	3400c146 <HAL_RCCEx_PeriphCLKConfig+0x23e6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1TXCLKSOURCE(PeriphClkInit->Eth1TxClockSelection));
3400c114:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c118:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
3400c11c:	2b00      	cmp	r3, #0
3400c11e:	d00b      	beq.n	3400c138 <HAL_RCCEx_PeriphCLKConfig+0x23d8>
3400c120:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c124:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
3400c128:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
3400c12c:	d004      	beq.n	3400c138 <HAL_RCCEx_PeriphCLKConfig+0x23d8>
3400c12e:	f240 21f1 	movw	r1, #753	@ 0x2f1
3400c132:	4897      	ldr	r0, [pc, #604]	@ (3400c390 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
3400c134:	f7f5 ff6c 	bl	34002010 <assert_failed>

    /* Configure the ETH1 TX clock source */
    __HAL_RCC_ETH1TX_CONFIG(PeriphClkInit->Eth1TxClockSelection);
3400c138:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c13c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
3400c140:	4618      	mov	r0, r3
3400c142:	f7fc fc85 	bl	34008a50 <LL_RCC_SetETHREFTXClockSource>
  }

  /*---------------------- ETH1 PTP configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PTP) == RCC_PERIPHCLK_ETH1PTP)
3400c146:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c14a:	e9d3 2300 	ldrd	r2, r3, [r3]
3400c14e:	f402 7300 	and.w	r3, r2, #512	@ 0x200
3400c152:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
3400c156:	2300      	movs	r3, #0
3400c158:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
3400c15c:	e9d7 0150 	ldrd	r0, r1, [r7, #320]	@ 0x140
3400c160:	4603      	mov	r3, r0
3400c162:	460a      	mov	r2, r1
3400c164:	4313      	orrs	r3, r2
3400c166:	f000 8093 	beq.w	3400c290 <HAL_RCCEx_PeriphCLKConfig+0x2530>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PTPCLKSOURCE(PeriphClkInit->Eth1PtpClockSelection));
3400c16a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c16e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400c172:	2b00      	cmp	r3, #0
3400c174:	d016      	beq.n	3400c1a4 <HAL_RCCEx_PeriphCLKConfig+0x2444>
3400c176:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c17a:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400c17e:	2b01      	cmp	r3, #1
3400c180:	d010      	beq.n	3400c1a4 <HAL_RCCEx_PeriphCLKConfig+0x2444>
3400c182:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c186:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400c18a:	2b02      	cmp	r3, #2
3400c18c:	d00a      	beq.n	3400c1a4 <HAL_RCCEx_PeriphCLKConfig+0x2444>
3400c18e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c192:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400c196:	2b03      	cmp	r3, #3
3400c198:	d004      	beq.n	3400c1a4 <HAL_RCCEx_PeriphCLKConfig+0x2444>
3400c19a:	f240 21fb 	movw	r1, #763	@ 0x2fb
3400c19e:	487c      	ldr	r0, [pc, #496]	@ (3400c390 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
3400c1a0:	f7f5 ff36 	bl	34002010 <assert_failed>
    assert_param(IS_RCC_ETH1PTPDIVIDER(PeriphClkInit->Eth1PtpDivider));
3400c1a4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c1a8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400c1ac:	2b00      	cmp	r3, #0
3400c1ae:	d005      	beq.n	3400c1bc <HAL_RCCEx_PeriphCLKConfig+0x245c>
3400c1b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c1b4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400c1b8:	2b10      	cmp	r3, #16
3400c1ba:	d904      	bls.n	3400c1c6 <HAL_RCCEx_PeriphCLKConfig+0x2466>
3400c1bc:	f44f 713f 	mov.w	r1, #764	@ 0x2fc
3400c1c0:	4873      	ldr	r0, [pc, #460]	@ (3400c390 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
3400c1c2:	f7f5 ff25 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_IC13)
3400c1c6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c1ca:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400c1ce:	2b02      	cmp	r3, #2
3400c1d0:	d142      	bne.n	3400c258 <HAL_RCCEx_PeriphCLKConfig+0x24f8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC13].ClockSelection));
3400c1d2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c1d6:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3400c1d8:	2b00      	cmp	r3, #0
3400c1da:	d016      	beq.n	3400c20a <HAL_RCCEx_PeriphCLKConfig+0x24aa>
3400c1dc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c1e0:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3400c1e2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400c1e6:	d010      	beq.n	3400c20a <HAL_RCCEx_PeriphCLKConfig+0x24aa>
3400c1e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c1ec:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3400c1ee:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400c1f2:	d00a      	beq.n	3400c20a <HAL_RCCEx_PeriphCLKConfig+0x24aa>
3400c1f4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c1f8:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3400c1fa:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400c1fe:	d004      	beq.n	3400c20a <HAL_RCCEx_PeriphCLKConfig+0x24aa>
3400c200:	f240 3101 	movw	r1, #769	@ 0x301
3400c204:	4862      	ldr	r0, [pc, #392]	@ (3400c390 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
3400c206:	f7f5 ff03 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC13].ClockDivider));
3400c20a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c20e:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
3400c210:	2b00      	cmp	r3, #0
3400c212:	d005      	beq.n	3400c220 <HAL_RCCEx_PeriphCLKConfig+0x24c0>
3400c214:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c218:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
3400c21a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400c21e:	d904      	bls.n	3400c22a <HAL_RCCEx_PeriphCLKConfig+0x24ca>
3400c220:	f240 3102 	movw	r1, #770	@ 0x302
3400c224:	485a      	ldr	r0, [pc, #360]	@ (3400c390 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
3400c226:	f7f5 fef3 	bl	34002010 <assert_failed>

      /* Set IC13 configuration */
      MODIFY_REG(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL | RCC_IC13CFGR_IC13INT,
3400c22a:	4b5a      	ldr	r3, [pc, #360]	@ (3400c394 <HAL_RCCEx_PeriphCLKConfig+0x2634>)
3400c22c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
3400c230:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400c234:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400c238:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c23c:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
3400c23e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c242:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
3400c244:	3b01      	subs	r3, #1
3400c246:	041b      	lsls	r3, r3, #16
3400c248:	4313      	orrs	r3, r2
3400c24a:	4a52      	ldr	r2, [pc, #328]	@ (3400c394 <HAL_RCCEx_PeriphCLKConfig+0x2634>)
3400c24c:	430b      	orrs	r3, r1
3400c24e:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
                 PeriphClkInit->ICSelection[RCC_IC13].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC13].ClockDivider - 1U) << RCC_IC13CFGR_IC13INT_Pos));

      LL_RCC_IC13_Enable();
3400c252:	f7fd fb63 	bl	3400991c <LL_RCC_IC13_Enable>
3400c256:	e007      	b.n	3400c268 <HAL_RCCEx_PeriphCLKConfig+0x2508>
    }
    else if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_CLKP)
3400c258:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c25c:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400c260:	2b01      	cmp	r3, #1
3400c262:	d101      	bne.n	3400c268 <HAL_RCCEx_PeriphCLKConfig+0x2508>
    {
      LL_RCC_CLKP_Enable();
3400c264:	f7fd fd5a 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 PTP clock source and divider */
    MODIFY_REG(RCC->CCIPR2, (RCC_CCIPR2_ETH1PTPDIV | RCC_CCIPR2_ETH1PTPSEL), \
3400c268:	4b4a      	ldr	r3, [pc, #296]	@ (3400c394 <HAL_RCCEx_PeriphCLKConfig+0x2634>)
3400c26a:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3400c26e:	f023 01f3 	bic.w	r1, r3, #243	@ 0xf3
3400c272:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c276:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400c27a:	3b01      	subs	r3, #1
3400c27c:	011a      	lsls	r2, r3, #4
3400c27e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c282:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400c286:	4313      	orrs	r3, r2
3400c288:	4a42      	ldr	r2, [pc, #264]	@ (3400c394 <HAL_RCCEx_PeriphCLKConfig+0x2634>)
3400c28a:	430b      	orrs	r3, r1
3400c28c:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
               (((PeriphClkInit->Eth1PtpDivider - 1U) << RCC_CCIPR2_ETH1PTPDIV_Pos) | PeriphClkInit->Eth1PtpClockSelection));
  }

  /*---------------------- FDCAN configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
3400c290:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c294:	e9d3 2300 	ldrd	r2, r3, [r3]
3400c298:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
3400c29c:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
3400c2a0:	2300      	movs	r3, #0
3400c2a2:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
3400c2a6:	e9d7 014e 	ldrd	r0, r1, [r7, #312]	@ 0x138
3400c2aa:	4603      	mov	r3, r0
3400c2ac:	460a      	mov	r2, r1
3400c2ae:	4313      	orrs	r3, r2
3400c2b0:	f000 8081 	beq.w	3400c3b6 <HAL_RCCEx_PeriphCLKConfig+0x2656>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));
3400c2b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c2b8:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400c2bc:	2b00      	cmp	r3, #0
3400c2be:	d016      	beq.n	3400c2ee <HAL_RCCEx_PeriphCLKConfig+0x258e>
3400c2c0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c2c4:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400c2c8:	2b01      	cmp	r3, #1
3400c2ca:	d010      	beq.n	3400c2ee <HAL_RCCEx_PeriphCLKConfig+0x258e>
3400c2cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c2d0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400c2d4:	2b02      	cmp	r3, #2
3400c2d6:	d00a      	beq.n	3400c2ee <HAL_RCCEx_PeriphCLKConfig+0x258e>
3400c2d8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c2dc:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400c2e0:	2b03      	cmp	r3, #3
3400c2e2:	d004      	beq.n	3400c2ee <HAL_RCCEx_PeriphCLKConfig+0x258e>
3400c2e4:	f240 311d 	movw	r1, #797	@ 0x31d
3400c2e8:	4829      	ldr	r0, [pc, #164]	@ (3400c390 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
3400c2ea:	f7f5 fe91 	bl	34002010 <assert_failed>

    if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_IC19)
3400c2ee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c2f2:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400c2f6:	2b02      	cmp	r3, #2
3400c2f8:	d14e      	bne.n	3400c398 <HAL_RCCEx_PeriphCLKConfig+0x2638>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
3400c2fa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c2fe:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400c302:	2b00      	cmp	r3, #0
3400c304:	d019      	beq.n	3400c33a <HAL_RCCEx_PeriphCLKConfig+0x25da>
3400c306:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c30a:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400c30e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400c312:	d012      	beq.n	3400c33a <HAL_RCCEx_PeriphCLKConfig+0x25da>
3400c314:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c318:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400c31c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400c320:	d00b      	beq.n	3400c33a <HAL_RCCEx_PeriphCLKConfig+0x25da>
3400c322:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c326:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400c32a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400c32e:	d004      	beq.n	3400c33a <HAL_RCCEx_PeriphCLKConfig+0x25da>
3400c330:	f240 3122 	movw	r1, #802	@ 0x322
3400c334:	4816      	ldr	r0, [pc, #88]	@ (3400c390 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
3400c336:	f7f5 fe6b 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));
3400c33a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c33e:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
3400c342:	2b00      	cmp	r3, #0
3400c344:	d006      	beq.n	3400c354 <HAL_RCCEx_PeriphCLKConfig+0x25f4>
3400c346:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c34a:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
3400c34e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400c352:	d904      	bls.n	3400c35e <HAL_RCCEx_PeriphCLKConfig+0x25fe>
3400c354:	f240 3123 	movw	r1, #803	@ 0x323
3400c358:	480d      	ldr	r0, [pc, #52]	@ (3400c390 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
3400c35a:	f7f5 fe59 	bl	34002010 <assert_failed>

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
3400c35e:	4b0d      	ldr	r3, [pc, #52]	@ (3400c394 <HAL_RCCEx_PeriphCLKConfig+0x2634>)
3400c360:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3400c364:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400c368:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400c36c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c370:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
3400c374:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c378:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
3400c37c:	3b01      	subs	r3, #1
3400c37e:	041b      	lsls	r3, r3, #16
3400c380:	4313      	orrs	r3, r2
3400c382:	4a04      	ldr	r2, [pc, #16]	@ (3400c394 <HAL_RCCEx_PeriphCLKConfig+0x2634>)
3400c384:	430b      	orrs	r3, r1
3400c386:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
3400c38a:	f7fd fc47 	bl	34009c1c <LL_RCC_IC19_Enable>
3400c38e:	e00b      	b.n	3400c3a8 <HAL_RCCEx_PeriphCLKConfig+0x2648>
3400c390:	3401ee60 	.word	0x3401ee60
3400c394:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_CLKP)
3400c398:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c39c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400c3a0:	2b01      	cmp	r3, #1
3400c3a2:	d101      	bne.n	3400c3a8 <HAL_RCCEx_PeriphCLKConfig+0x2648>
    {
      LL_RCC_CLKP_Enable();
3400c3a4:	f7fd fcba 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FDCAN clock*/
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
3400c3a8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c3ac:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400c3b0:	4618      	mov	r0, r3
3400c3b2:	f7fc fb63 	bl	34008a7c <LL_RCC_SetFDCANClockSource>
  }

  /*------------------------------ I2C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
3400c3b6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c3ba:	e9d3 2300 	ldrd	r2, r3, [r3]
3400c3be:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
3400c3c2:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
3400c3c6:	2300      	movs	r3, #0
3400c3c8:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
3400c3cc:	e9d7 014c 	ldrd	r0, r1, [r7, #304]	@ 0x130
3400c3d0:	4603      	mov	r3, r0
3400c3d2:	460a      	mov	r2, r1
3400c3d4:	4313      	orrs	r3, r2
3400c3d6:	f000 80d3 	beq.w	3400c580 <HAL_RCCEx_PeriphCLKConfig+0x2820>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
3400c3da:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c3de:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3400c3e2:	4bad      	ldr	r3, [pc, #692]	@ (3400c698 <HAL_RCCEx_PeriphCLKConfig+0x2938>)
3400c3e4:	429a      	cmp	r2, r3
3400c3e6:	d027      	beq.n	3400c438 <HAL_RCCEx_PeriphCLKConfig+0x26d8>
3400c3e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c3ec:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3400c3f0:	4baa      	ldr	r3, [pc, #680]	@ (3400c69c <HAL_RCCEx_PeriphCLKConfig+0x293c>)
3400c3f2:	429a      	cmp	r2, r3
3400c3f4:	d020      	beq.n	3400c438 <HAL_RCCEx_PeriphCLKConfig+0x26d8>
3400c3f6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c3fa:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3400c3fe:	4ba8      	ldr	r3, [pc, #672]	@ (3400c6a0 <HAL_RCCEx_PeriphCLKConfig+0x2940>)
3400c400:	429a      	cmp	r2, r3
3400c402:	d019      	beq.n	3400c438 <HAL_RCCEx_PeriphCLKConfig+0x26d8>
3400c404:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c408:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3400c40c:	4ba5      	ldr	r3, [pc, #660]	@ (3400c6a4 <HAL_RCCEx_PeriphCLKConfig+0x2944>)
3400c40e:	429a      	cmp	r2, r3
3400c410:	d012      	beq.n	3400c438 <HAL_RCCEx_PeriphCLKConfig+0x26d8>
3400c412:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c416:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3400c41a:	4ba3      	ldr	r3, [pc, #652]	@ (3400c6a8 <HAL_RCCEx_PeriphCLKConfig+0x2948>)
3400c41c:	429a      	cmp	r2, r3
3400c41e:	d00b      	beq.n	3400c438 <HAL_RCCEx_PeriphCLKConfig+0x26d8>
3400c420:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c424:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3400c428:	4ba0      	ldr	r3, [pc, #640]	@ (3400c6ac <HAL_RCCEx_PeriphCLKConfig+0x294c>)
3400c42a:	429a      	cmp	r2, r3
3400c42c:	d004      	beq.n	3400c438 <HAL_RCCEx_PeriphCLKConfig+0x26d8>
3400c42e:	f240 313d 	movw	r1, #829	@ 0x33d
3400c432:	489f      	ldr	r0, [pc, #636]	@ (3400c6b0 <HAL_RCCEx_PeriphCLKConfig+0x2950>)
3400c434:	f7f5 fdec 	bl	34002010 <assert_failed>

    if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC10)
3400c438:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c43c:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3400c440:	4b97      	ldr	r3, [pc, #604]	@ (3400c6a0 <HAL_RCCEx_PeriphCLKConfig+0x2940>)
3400c442:	429a      	cmp	r2, r3
3400c444:	d142      	bne.n	3400c4cc <HAL_RCCEx_PeriphCLKConfig+0x276c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400c446:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c44a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400c44c:	2b00      	cmp	r3, #0
3400c44e:	d016      	beq.n	3400c47e <HAL_RCCEx_PeriphCLKConfig+0x271e>
3400c450:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c454:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400c456:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400c45a:	d010      	beq.n	3400c47e <HAL_RCCEx_PeriphCLKConfig+0x271e>
3400c45c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c460:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400c462:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400c466:	d00a      	beq.n	3400c47e <HAL_RCCEx_PeriphCLKConfig+0x271e>
3400c468:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c46c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400c46e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400c472:	d004      	beq.n	3400c47e <HAL_RCCEx_PeriphCLKConfig+0x271e>
3400c474:	f240 3142 	movw	r1, #834	@ 0x342
3400c478:	488d      	ldr	r0, [pc, #564]	@ (3400c6b0 <HAL_RCCEx_PeriphCLKConfig+0x2950>)
3400c47a:	f7f5 fdc9 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400c47e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c482:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400c484:	2b00      	cmp	r3, #0
3400c486:	d005      	beq.n	3400c494 <HAL_RCCEx_PeriphCLKConfig+0x2734>
3400c488:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c48c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400c48e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400c492:	d904      	bls.n	3400c49e <HAL_RCCEx_PeriphCLKConfig+0x273e>
3400c494:	f240 3143 	movw	r1, #835	@ 0x343
3400c498:	4885      	ldr	r0, [pc, #532]	@ (3400c6b0 <HAL_RCCEx_PeriphCLKConfig+0x2950>)
3400c49a:	f7f5 fdb9 	bl	34002010 <assert_failed>

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400c49e:	4b85      	ldr	r3, [pc, #532]	@ (3400c6b4 <HAL_RCCEx_PeriphCLKConfig+0x2954>)
3400c4a0:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3400c4a4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400c4a8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400c4ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c4b0:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3400c4b2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c4b6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400c4b8:	3b01      	subs	r3, #1
3400c4ba:	041b      	lsls	r3, r3, #16
3400c4bc:	4313      	orrs	r3, r2
3400c4be:	4a7d      	ldr	r2, [pc, #500]	@ (3400c6b4 <HAL_RCCEx_PeriphCLKConfig+0x2954>)
3400c4c0:	430b      	orrs	r3, r1
3400c4c2:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3400c4c6:	f7fd f9a9 	bl	3400981c <LL_RCC_IC10_Enable>
3400c4ca:	e052      	b.n	3400c572 <HAL_RCCEx_PeriphCLKConfig+0x2812>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC15)
3400c4cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c4d0:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3400c4d4:	4b73      	ldr	r3, [pc, #460]	@ (3400c6a4 <HAL_RCCEx_PeriphCLKConfig+0x2944>)
3400c4d6:	429a      	cmp	r2, r3
3400c4d8:	d142      	bne.n	3400c560 <HAL_RCCEx_PeriphCLKConfig+0x2800>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c4da:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c4de:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400c4e0:	2b00      	cmp	r3, #0
3400c4e2:	d016      	beq.n	3400c512 <HAL_RCCEx_PeriphCLKConfig+0x27b2>
3400c4e4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c4e8:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400c4ea:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400c4ee:	d010      	beq.n	3400c512 <HAL_RCCEx_PeriphCLKConfig+0x27b2>
3400c4f0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c4f4:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400c4f6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400c4fa:	d00a      	beq.n	3400c512 <HAL_RCCEx_PeriphCLKConfig+0x27b2>
3400c4fc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c500:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400c502:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400c506:	d004      	beq.n	3400c512 <HAL_RCCEx_PeriphCLKConfig+0x27b2>
3400c508:	f240 314f 	movw	r1, #847	@ 0x34f
3400c50c:	4868      	ldr	r0, [pc, #416]	@ (3400c6b0 <HAL_RCCEx_PeriphCLKConfig+0x2950>)
3400c50e:	f7f5 fd7f 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c512:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c516:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400c518:	2b00      	cmp	r3, #0
3400c51a:	d005      	beq.n	3400c528 <HAL_RCCEx_PeriphCLKConfig+0x27c8>
3400c51c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c520:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400c522:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400c526:	d904      	bls.n	3400c532 <HAL_RCCEx_PeriphCLKConfig+0x27d2>
3400c528:	f44f 7154 	mov.w	r1, #848	@ 0x350
3400c52c:	4860      	ldr	r0, [pc, #384]	@ (3400c6b0 <HAL_RCCEx_PeriphCLKConfig+0x2950>)
3400c52e:	f7f5 fd6f 	bl	34002010 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c532:	4b60      	ldr	r3, [pc, #384]	@ (3400c6b4 <HAL_RCCEx_PeriphCLKConfig+0x2954>)
3400c534:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400c538:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400c53c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400c540:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c544:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3400c546:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c54a:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400c54c:	3b01      	subs	r3, #1
3400c54e:	041b      	lsls	r3, r3, #16
3400c550:	4313      	orrs	r3, r2
3400c552:	4a58      	ldr	r2, [pc, #352]	@ (3400c6b4 <HAL_RCCEx_PeriphCLKConfig+0x2954>)
3400c554:	430b      	orrs	r3, r1
3400c556:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400c55a:	f7fd fa5f 	bl	34009a1c <LL_RCC_IC15_Enable>
3400c55e:	e008      	b.n	3400c572 <HAL_RCCEx_PeriphCLKConfig+0x2812>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_CLKP)
3400c560:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c564:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3400c568:	4b4c      	ldr	r3, [pc, #304]	@ (3400c69c <HAL_RCCEx_PeriphCLKConfig+0x293c>)
3400c56a:	429a      	cmp	r2, r3
3400c56c:	d101      	bne.n	3400c572 <HAL_RCCEx_PeriphCLKConfig+0x2812>
    {
      LL_RCC_CLKP_Enable();
3400c56e:	f7fd fbd5 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C1 clock*/
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
3400c572:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c576:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3400c57a:	4618      	mov	r0, r3
3400c57c:	f7fc faaa 	bl	34008ad4 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
3400c580:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c584:	e9d3 2300 	ldrd	r2, r3, [r3]
3400c588:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
3400c58c:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
3400c590:	2300      	movs	r3, #0
3400c592:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
3400c596:	e9d7 014a 	ldrd	r0, r1, [r7, #296]	@ 0x128
3400c59a:	4603      	mov	r3, r0
3400c59c:	460a      	mov	r2, r1
3400c59e:	4313      	orrs	r3, r2
3400c5a0:	f000 80f0 	beq.w	3400c784 <HAL_RCCEx_PeriphCLKConfig+0x2a24>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));
3400c5a4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c5a8:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3400c5ac:	4b42      	ldr	r3, [pc, #264]	@ (3400c6b8 <HAL_RCCEx_PeriphCLKConfig+0x2958>)
3400c5ae:	429a      	cmp	r2, r3
3400c5b0:	d027      	beq.n	3400c602 <HAL_RCCEx_PeriphCLKConfig+0x28a2>
3400c5b2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c5b6:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3400c5ba:	4b40      	ldr	r3, [pc, #256]	@ (3400c6bc <HAL_RCCEx_PeriphCLKConfig+0x295c>)
3400c5bc:	429a      	cmp	r2, r3
3400c5be:	d020      	beq.n	3400c602 <HAL_RCCEx_PeriphCLKConfig+0x28a2>
3400c5c0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c5c4:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3400c5c8:	4b3d      	ldr	r3, [pc, #244]	@ (3400c6c0 <HAL_RCCEx_PeriphCLKConfig+0x2960>)
3400c5ca:	429a      	cmp	r2, r3
3400c5cc:	d019      	beq.n	3400c602 <HAL_RCCEx_PeriphCLKConfig+0x28a2>
3400c5ce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c5d2:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3400c5d6:	4b3b      	ldr	r3, [pc, #236]	@ (3400c6c4 <HAL_RCCEx_PeriphCLKConfig+0x2964>)
3400c5d8:	429a      	cmp	r2, r3
3400c5da:	d012      	beq.n	3400c602 <HAL_RCCEx_PeriphCLKConfig+0x28a2>
3400c5dc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c5e0:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3400c5e4:	4b38      	ldr	r3, [pc, #224]	@ (3400c6c8 <HAL_RCCEx_PeriphCLKConfig+0x2968>)
3400c5e6:	429a      	cmp	r2, r3
3400c5e8:	d00b      	beq.n	3400c602 <HAL_RCCEx_PeriphCLKConfig+0x28a2>
3400c5ea:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c5ee:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3400c5f2:	4b36      	ldr	r3, [pc, #216]	@ (3400c6cc <HAL_RCCEx_PeriphCLKConfig+0x296c>)
3400c5f4:	429a      	cmp	r2, r3
3400c5f6:	d004      	beq.n	3400c602 <HAL_RCCEx_PeriphCLKConfig+0x28a2>
3400c5f8:	f240 316a 	movw	r1, #874	@ 0x36a
3400c5fc:	482c      	ldr	r0, [pc, #176]	@ (3400c6b0 <HAL_RCCEx_PeriphCLKConfig+0x2950>)
3400c5fe:	f7f5 fd07 	bl	34002010 <assert_failed>

    if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC10)
3400c602:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c606:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3400c60a:	4b2d      	ldr	r3, [pc, #180]	@ (3400c6c0 <HAL_RCCEx_PeriphCLKConfig+0x2960>)
3400c60c:	429a      	cmp	r2, r3
3400c60e:	d15f      	bne.n	3400c6d0 <HAL_RCCEx_PeriphCLKConfig+0x2970>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400c610:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c614:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400c616:	2b00      	cmp	r3, #0
3400c618:	d016      	beq.n	3400c648 <HAL_RCCEx_PeriphCLKConfig+0x28e8>
3400c61a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c61e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400c620:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400c624:	d010      	beq.n	3400c648 <HAL_RCCEx_PeriphCLKConfig+0x28e8>
3400c626:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c62a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400c62c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400c630:	d00a      	beq.n	3400c648 <HAL_RCCEx_PeriphCLKConfig+0x28e8>
3400c632:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c636:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400c638:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400c63c:	d004      	beq.n	3400c648 <HAL_RCCEx_PeriphCLKConfig+0x28e8>
3400c63e:	f240 316f 	movw	r1, #879	@ 0x36f
3400c642:	481b      	ldr	r0, [pc, #108]	@ (3400c6b0 <HAL_RCCEx_PeriphCLKConfig+0x2950>)
3400c644:	f7f5 fce4 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400c648:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c64c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400c64e:	2b00      	cmp	r3, #0
3400c650:	d005      	beq.n	3400c65e <HAL_RCCEx_PeriphCLKConfig+0x28fe>
3400c652:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c656:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400c658:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400c65c:	d904      	bls.n	3400c668 <HAL_RCCEx_PeriphCLKConfig+0x2908>
3400c65e:	f44f 715c 	mov.w	r1, #880	@ 0x370
3400c662:	4813      	ldr	r0, [pc, #76]	@ (3400c6b0 <HAL_RCCEx_PeriphCLKConfig+0x2950>)
3400c664:	f7f5 fcd4 	bl	34002010 <assert_failed>

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400c668:	4b12      	ldr	r3, [pc, #72]	@ (3400c6b4 <HAL_RCCEx_PeriphCLKConfig+0x2954>)
3400c66a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3400c66e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400c672:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400c676:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c67a:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3400c67c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c680:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400c682:	3b01      	subs	r3, #1
3400c684:	041b      	lsls	r3, r3, #16
3400c686:	4313      	orrs	r3, r2
3400c688:	4a0a      	ldr	r2, [pc, #40]	@ (3400c6b4 <HAL_RCCEx_PeriphCLKConfig+0x2954>)
3400c68a:	430b      	orrs	r3, r1
3400c68c:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3400c690:	f7fd f8c4 	bl	3400981c <LL_RCC_IC10_Enable>
3400c694:	e06f      	b.n	3400c776 <HAL_RCCEx_PeriphCLKConfig+0x2a16>
3400c696:	bf00      	nop
3400c698:	0700000c 	.word	0x0700000c
3400c69c:	0701000c 	.word	0x0701000c
3400c6a0:	0702000c 	.word	0x0702000c
3400c6a4:	0703000c 	.word	0x0703000c
3400c6a8:	0704000c 	.word	0x0704000c
3400c6ac:	0705000c 	.word	0x0705000c
3400c6b0:	3401ee60 	.word	0x3401ee60
3400c6b4:	56028000 	.word	0x56028000
3400c6b8:	0700040c 	.word	0x0700040c
3400c6bc:	0701040c 	.word	0x0701040c
3400c6c0:	0702040c 	.word	0x0702040c
3400c6c4:	0703040c 	.word	0x0703040c
3400c6c8:	0704040c 	.word	0x0704040c
3400c6cc:	0705040c 	.word	0x0705040c
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC15)
3400c6d0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c6d4:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3400c6d8:	4b95      	ldr	r3, [pc, #596]	@ (3400c930 <HAL_RCCEx_PeriphCLKConfig+0x2bd0>)
3400c6da:	429a      	cmp	r2, r3
3400c6dc:	d142      	bne.n	3400c764 <HAL_RCCEx_PeriphCLKConfig+0x2a04>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c6de:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c6e2:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400c6e4:	2b00      	cmp	r3, #0
3400c6e6:	d016      	beq.n	3400c716 <HAL_RCCEx_PeriphCLKConfig+0x29b6>
3400c6e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c6ec:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400c6ee:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400c6f2:	d010      	beq.n	3400c716 <HAL_RCCEx_PeriphCLKConfig+0x29b6>
3400c6f4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c6f8:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400c6fa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400c6fe:	d00a      	beq.n	3400c716 <HAL_RCCEx_PeriphCLKConfig+0x29b6>
3400c700:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c704:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400c706:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400c70a:	d004      	beq.n	3400c716 <HAL_RCCEx_PeriphCLKConfig+0x29b6>
3400c70c:	f44f 715f 	mov.w	r1, #892	@ 0x37c
3400c710:	4888      	ldr	r0, [pc, #544]	@ (3400c934 <HAL_RCCEx_PeriphCLKConfig+0x2bd4>)
3400c712:	f7f5 fc7d 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c716:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c71a:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400c71c:	2b00      	cmp	r3, #0
3400c71e:	d005      	beq.n	3400c72c <HAL_RCCEx_PeriphCLKConfig+0x29cc>
3400c720:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c724:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400c726:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400c72a:	d904      	bls.n	3400c736 <HAL_RCCEx_PeriphCLKConfig+0x29d6>
3400c72c:	f240 317d 	movw	r1, #893	@ 0x37d
3400c730:	4880      	ldr	r0, [pc, #512]	@ (3400c934 <HAL_RCCEx_PeriphCLKConfig+0x2bd4>)
3400c732:	f7f5 fc6d 	bl	34002010 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c736:	4b80      	ldr	r3, [pc, #512]	@ (3400c938 <HAL_RCCEx_PeriphCLKConfig+0x2bd8>)
3400c738:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400c73c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400c740:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400c744:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c748:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3400c74a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c74e:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400c750:	3b01      	subs	r3, #1
3400c752:	041b      	lsls	r3, r3, #16
3400c754:	4313      	orrs	r3, r2
3400c756:	4a78      	ldr	r2, [pc, #480]	@ (3400c938 <HAL_RCCEx_PeriphCLKConfig+0x2bd8>)
3400c758:	430b      	orrs	r3, r1
3400c75a:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400c75e:	f7fd f95d 	bl	34009a1c <LL_RCC_IC15_Enable>
3400c762:	e008      	b.n	3400c776 <HAL_RCCEx_PeriphCLKConfig+0x2a16>
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_CLKP)
3400c764:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c768:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3400c76c:	4b73      	ldr	r3, [pc, #460]	@ (3400c93c <HAL_RCCEx_PeriphCLKConfig+0x2bdc>)
3400c76e:	429a      	cmp	r2, r3
3400c770:	d101      	bne.n	3400c776 <HAL_RCCEx_PeriphCLKConfig+0x2a16>
    {
      LL_RCC_CLKP_Enable();
3400c772:	f7fd fad3 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C2 clock*/
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
3400c776:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c77a:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
3400c77e:	4618      	mov	r0, r3
3400c780:	f7fc f9a8 	bl	34008ad4 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C3 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
3400c784:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c788:	e9d3 2300 	ldrd	r2, r3, [r3]
3400c78c:	f402 4380 	and.w	r3, r2, #16384	@ 0x4000
3400c790:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
3400c794:	2300      	movs	r3, #0
3400c796:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
3400c79a:	e9d7 0148 	ldrd	r0, r1, [r7, #288]	@ 0x120
3400c79e:	4603      	mov	r3, r0
3400c7a0:	460a      	mov	r2, r1
3400c7a2:	4313      	orrs	r3, r2
3400c7a4:	f000 80e8 	beq.w	3400c978 <HAL_RCCEx_PeriphCLKConfig+0x2c18>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
3400c7a8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c7ac:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3400c7b0:	4b63      	ldr	r3, [pc, #396]	@ (3400c940 <HAL_RCCEx_PeriphCLKConfig+0x2be0>)
3400c7b2:	429a      	cmp	r2, r3
3400c7b4:	d027      	beq.n	3400c806 <HAL_RCCEx_PeriphCLKConfig+0x2aa6>
3400c7b6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c7ba:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3400c7be:	4b61      	ldr	r3, [pc, #388]	@ (3400c944 <HAL_RCCEx_PeriphCLKConfig+0x2be4>)
3400c7c0:	429a      	cmp	r2, r3
3400c7c2:	d020      	beq.n	3400c806 <HAL_RCCEx_PeriphCLKConfig+0x2aa6>
3400c7c4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c7c8:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3400c7cc:	4b5e      	ldr	r3, [pc, #376]	@ (3400c948 <HAL_RCCEx_PeriphCLKConfig+0x2be8>)
3400c7ce:	429a      	cmp	r2, r3
3400c7d0:	d019      	beq.n	3400c806 <HAL_RCCEx_PeriphCLKConfig+0x2aa6>
3400c7d2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c7d6:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3400c7da:	4b5c      	ldr	r3, [pc, #368]	@ (3400c94c <HAL_RCCEx_PeriphCLKConfig+0x2bec>)
3400c7dc:	429a      	cmp	r2, r3
3400c7de:	d012      	beq.n	3400c806 <HAL_RCCEx_PeriphCLKConfig+0x2aa6>
3400c7e0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c7e4:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3400c7e8:	4b59      	ldr	r3, [pc, #356]	@ (3400c950 <HAL_RCCEx_PeriphCLKConfig+0x2bf0>)
3400c7ea:	429a      	cmp	r2, r3
3400c7ec:	d00b      	beq.n	3400c806 <HAL_RCCEx_PeriphCLKConfig+0x2aa6>
3400c7ee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c7f2:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3400c7f6:	4b57      	ldr	r3, [pc, #348]	@ (3400c954 <HAL_RCCEx_PeriphCLKConfig+0x2bf4>)
3400c7f8:	429a      	cmp	r2, r3
3400c7fa:	d004      	beq.n	3400c806 <HAL_RCCEx_PeriphCLKConfig+0x2aa6>
3400c7fc:	f240 3197 	movw	r1, #919	@ 0x397
3400c800:	484c      	ldr	r0, [pc, #304]	@ (3400c934 <HAL_RCCEx_PeriphCLKConfig+0x2bd4>)
3400c802:	f7f5 fc05 	bl	34002010 <assert_failed>

    if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC10)
3400c806:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c80a:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3400c80e:	4b4e      	ldr	r3, [pc, #312]	@ (3400c948 <HAL_RCCEx_PeriphCLKConfig+0x2be8>)
3400c810:	429a      	cmp	r2, r3
3400c812:	d142      	bne.n	3400c89a <HAL_RCCEx_PeriphCLKConfig+0x2b3a>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400c814:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c818:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400c81a:	2b00      	cmp	r3, #0
3400c81c:	d016      	beq.n	3400c84c <HAL_RCCEx_PeriphCLKConfig+0x2aec>
3400c81e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c822:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400c824:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400c828:	d010      	beq.n	3400c84c <HAL_RCCEx_PeriphCLKConfig+0x2aec>
3400c82a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c82e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400c830:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400c834:	d00a      	beq.n	3400c84c <HAL_RCCEx_PeriphCLKConfig+0x2aec>
3400c836:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c83a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400c83c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400c840:	d004      	beq.n	3400c84c <HAL_RCCEx_PeriphCLKConfig+0x2aec>
3400c842:	f44f 7167 	mov.w	r1, #924	@ 0x39c
3400c846:	483b      	ldr	r0, [pc, #236]	@ (3400c934 <HAL_RCCEx_PeriphCLKConfig+0x2bd4>)
3400c848:	f7f5 fbe2 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400c84c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c850:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400c852:	2b00      	cmp	r3, #0
3400c854:	d005      	beq.n	3400c862 <HAL_RCCEx_PeriphCLKConfig+0x2b02>
3400c856:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c85a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400c85c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400c860:	d904      	bls.n	3400c86c <HAL_RCCEx_PeriphCLKConfig+0x2b0c>
3400c862:	f240 319d 	movw	r1, #925	@ 0x39d
3400c866:	4833      	ldr	r0, [pc, #204]	@ (3400c934 <HAL_RCCEx_PeriphCLKConfig+0x2bd4>)
3400c868:	f7f5 fbd2 	bl	34002010 <assert_failed>

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400c86c:	4b32      	ldr	r3, [pc, #200]	@ (3400c938 <HAL_RCCEx_PeriphCLKConfig+0x2bd8>)
3400c86e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3400c872:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400c876:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400c87a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c87e:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3400c880:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c884:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400c886:	3b01      	subs	r3, #1
3400c888:	041b      	lsls	r3, r3, #16
3400c88a:	4313      	orrs	r3, r2
3400c88c:	4a2a      	ldr	r2, [pc, #168]	@ (3400c938 <HAL_RCCEx_PeriphCLKConfig+0x2bd8>)
3400c88e:	430b      	orrs	r3, r1
3400c890:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3400c894:	f7fc ffc2 	bl	3400981c <LL_RCC_IC10_Enable>
3400c898:	e067      	b.n	3400c96a <HAL_RCCEx_PeriphCLKConfig+0x2c0a>
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC15)
3400c89a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c89e:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3400c8a2:	4b2a      	ldr	r3, [pc, #168]	@ (3400c94c <HAL_RCCEx_PeriphCLKConfig+0x2bec>)
3400c8a4:	429a      	cmp	r2, r3
3400c8a6:	d157      	bne.n	3400c958 <HAL_RCCEx_PeriphCLKConfig+0x2bf8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c8a8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c8ac:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400c8ae:	2b00      	cmp	r3, #0
3400c8b0:	d016      	beq.n	3400c8e0 <HAL_RCCEx_PeriphCLKConfig+0x2b80>
3400c8b2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c8b6:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400c8b8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400c8bc:	d010      	beq.n	3400c8e0 <HAL_RCCEx_PeriphCLKConfig+0x2b80>
3400c8be:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c8c2:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400c8c4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400c8c8:	d00a      	beq.n	3400c8e0 <HAL_RCCEx_PeriphCLKConfig+0x2b80>
3400c8ca:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c8ce:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400c8d0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400c8d4:	d004      	beq.n	3400c8e0 <HAL_RCCEx_PeriphCLKConfig+0x2b80>
3400c8d6:	f240 31a9 	movw	r1, #937	@ 0x3a9
3400c8da:	4816      	ldr	r0, [pc, #88]	@ (3400c934 <HAL_RCCEx_PeriphCLKConfig+0x2bd4>)
3400c8dc:	f7f5 fb98 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c8e0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c8e4:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400c8e6:	2b00      	cmp	r3, #0
3400c8e8:	d005      	beq.n	3400c8f6 <HAL_RCCEx_PeriphCLKConfig+0x2b96>
3400c8ea:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c8ee:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400c8f0:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400c8f4:	d904      	bls.n	3400c900 <HAL_RCCEx_PeriphCLKConfig+0x2ba0>
3400c8f6:	f240 31aa 	movw	r1, #938	@ 0x3aa
3400c8fa:	480e      	ldr	r0, [pc, #56]	@ (3400c934 <HAL_RCCEx_PeriphCLKConfig+0x2bd4>)
3400c8fc:	f7f5 fb88 	bl	34002010 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c900:	4b0d      	ldr	r3, [pc, #52]	@ (3400c938 <HAL_RCCEx_PeriphCLKConfig+0x2bd8>)
3400c902:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400c906:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400c90a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400c90e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c912:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3400c914:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c918:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400c91a:	3b01      	subs	r3, #1
3400c91c:	041b      	lsls	r3, r3, #16
3400c91e:	4313      	orrs	r3, r2
3400c920:	4a05      	ldr	r2, [pc, #20]	@ (3400c938 <HAL_RCCEx_PeriphCLKConfig+0x2bd8>)
3400c922:	430b      	orrs	r3, r1
3400c924:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400c928:	f7fd f878 	bl	34009a1c <LL_RCC_IC15_Enable>
3400c92c:	e01d      	b.n	3400c96a <HAL_RCCEx_PeriphCLKConfig+0x2c0a>
3400c92e:	bf00      	nop
3400c930:	0703040c 	.word	0x0703040c
3400c934:	3401ee60 	.word	0x3401ee60
3400c938:	56028000 	.word	0x56028000
3400c93c:	0701040c 	.word	0x0701040c
3400c940:	0700080c 	.word	0x0700080c
3400c944:	0701080c 	.word	0x0701080c
3400c948:	0702080c 	.word	0x0702080c
3400c94c:	0703080c 	.word	0x0703080c
3400c950:	0704080c 	.word	0x0704080c
3400c954:	0705080c 	.word	0x0705080c
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_CLKP)
3400c958:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c95c:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3400c960:	4b70      	ldr	r3, [pc, #448]	@ (3400cb24 <HAL_RCCEx_PeriphCLKConfig+0x2dc4>)
3400c962:	429a      	cmp	r2, r3
3400c964:	d101      	bne.n	3400c96a <HAL_RCCEx_PeriphCLKConfig+0x2c0a>
    {
      LL_RCC_CLKP_Enable();
3400c966:	f7fd f9d9 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C3 clock*/
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
3400c96a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c96e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
3400c972:	4618      	mov	r0, r3
3400c974:	f7fc f8ae 	bl	34008ad4 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C4 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
3400c978:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c97c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400c980:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
3400c984:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
3400c988:	2300      	movs	r3, #0
3400c98a:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
3400c98e:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	@ 0x118
3400c992:	4603      	mov	r3, r0
3400c994:	460a      	mov	r2, r1
3400c996:	4313      	orrs	r3, r2
3400c998:	f000 80e6 	beq.w	3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2e08>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
3400c99c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c9a0:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3400c9a4:	4b60      	ldr	r3, [pc, #384]	@ (3400cb28 <HAL_RCCEx_PeriphCLKConfig+0x2dc8>)
3400c9a6:	429a      	cmp	r2, r3
3400c9a8:	d027      	beq.n	3400c9fa <HAL_RCCEx_PeriphCLKConfig+0x2c9a>
3400c9aa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c9ae:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3400c9b2:	4b5e      	ldr	r3, [pc, #376]	@ (3400cb2c <HAL_RCCEx_PeriphCLKConfig+0x2dcc>)
3400c9b4:	429a      	cmp	r2, r3
3400c9b6:	d020      	beq.n	3400c9fa <HAL_RCCEx_PeriphCLKConfig+0x2c9a>
3400c9b8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c9bc:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3400c9c0:	4b5b      	ldr	r3, [pc, #364]	@ (3400cb30 <HAL_RCCEx_PeriphCLKConfig+0x2dd0>)
3400c9c2:	429a      	cmp	r2, r3
3400c9c4:	d019      	beq.n	3400c9fa <HAL_RCCEx_PeriphCLKConfig+0x2c9a>
3400c9c6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c9ca:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3400c9ce:	4b59      	ldr	r3, [pc, #356]	@ (3400cb34 <HAL_RCCEx_PeriphCLKConfig+0x2dd4>)
3400c9d0:	429a      	cmp	r2, r3
3400c9d2:	d012      	beq.n	3400c9fa <HAL_RCCEx_PeriphCLKConfig+0x2c9a>
3400c9d4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c9d8:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3400c9dc:	4b56      	ldr	r3, [pc, #344]	@ (3400cb38 <HAL_RCCEx_PeriphCLKConfig+0x2dd8>)
3400c9de:	429a      	cmp	r2, r3
3400c9e0:	d00b      	beq.n	3400c9fa <HAL_RCCEx_PeriphCLKConfig+0x2c9a>
3400c9e2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c9e6:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3400c9ea:	4b54      	ldr	r3, [pc, #336]	@ (3400cb3c <HAL_RCCEx_PeriphCLKConfig+0x2ddc>)
3400c9ec:	429a      	cmp	r2, r3
3400c9ee:	d004      	beq.n	3400c9fa <HAL_RCCEx_PeriphCLKConfig+0x2c9a>
3400c9f0:	f44f 7171 	mov.w	r1, #964	@ 0x3c4
3400c9f4:	4852      	ldr	r0, [pc, #328]	@ (3400cb40 <HAL_RCCEx_PeriphCLKConfig+0x2de0>)
3400c9f6:	f7f5 fb0b 	bl	34002010 <assert_failed>

    if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC10)
3400c9fa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400c9fe:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3400ca02:	4b4b      	ldr	r3, [pc, #300]	@ (3400cb30 <HAL_RCCEx_PeriphCLKConfig+0x2dd0>)
3400ca04:	429a      	cmp	r2, r3
3400ca06:	d142      	bne.n	3400ca8e <HAL_RCCEx_PeriphCLKConfig+0x2d2e>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400ca08:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ca0c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400ca0e:	2b00      	cmp	r3, #0
3400ca10:	d016      	beq.n	3400ca40 <HAL_RCCEx_PeriphCLKConfig+0x2ce0>
3400ca12:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ca16:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400ca18:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ca1c:	d010      	beq.n	3400ca40 <HAL_RCCEx_PeriphCLKConfig+0x2ce0>
3400ca1e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ca22:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400ca24:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ca28:	d00a      	beq.n	3400ca40 <HAL_RCCEx_PeriphCLKConfig+0x2ce0>
3400ca2a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ca2e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400ca30:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ca34:	d004      	beq.n	3400ca40 <HAL_RCCEx_PeriphCLKConfig+0x2ce0>
3400ca36:	f240 31c9 	movw	r1, #969	@ 0x3c9
3400ca3a:	4841      	ldr	r0, [pc, #260]	@ (3400cb40 <HAL_RCCEx_PeriphCLKConfig+0x2de0>)
3400ca3c:	f7f5 fae8 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400ca40:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ca44:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400ca46:	2b00      	cmp	r3, #0
3400ca48:	d005      	beq.n	3400ca56 <HAL_RCCEx_PeriphCLKConfig+0x2cf6>
3400ca4a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ca4e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400ca50:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400ca54:	d904      	bls.n	3400ca60 <HAL_RCCEx_PeriphCLKConfig+0x2d00>
3400ca56:	f240 31ca 	movw	r1, #970	@ 0x3ca
3400ca5a:	4839      	ldr	r0, [pc, #228]	@ (3400cb40 <HAL_RCCEx_PeriphCLKConfig+0x2de0>)
3400ca5c:	f7f5 fad8 	bl	34002010 <assert_failed>

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400ca60:	4b38      	ldr	r3, [pc, #224]	@ (3400cb44 <HAL_RCCEx_PeriphCLKConfig+0x2de4>)
3400ca62:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3400ca66:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400ca6a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400ca6e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ca72:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3400ca74:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ca78:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400ca7a:	3b01      	subs	r3, #1
3400ca7c:	041b      	lsls	r3, r3, #16
3400ca7e:	4313      	orrs	r3, r2
3400ca80:	4a30      	ldr	r2, [pc, #192]	@ (3400cb44 <HAL_RCCEx_PeriphCLKConfig+0x2de4>)
3400ca82:	430b      	orrs	r3, r1
3400ca84:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3400ca88:	f7fc fec8 	bl	3400981c <LL_RCC_IC10_Enable>
3400ca8c:	e065      	b.n	3400cb5a <HAL_RCCEx_PeriphCLKConfig+0x2dfa>
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC15)
3400ca8e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ca92:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3400ca96:	4b27      	ldr	r3, [pc, #156]	@ (3400cb34 <HAL_RCCEx_PeriphCLKConfig+0x2dd4>)
3400ca98:	429a      	cmp	r2, r3
3400ca9a:	d155      	bne.n	3400cb48 <HAL_RCCEx_PeriphCLKConfig+0x2de8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400ca9c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400caa0:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400caa2:	2b00      	cmp	r3, #0
3400caa4:	d016      	beq.n	3400cad4 <HAL_RCCEx_PeriphCLKConfig+0x2d74>
3400caa6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400caaa:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400caac:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400cab0:	d010      	beq.n	3400cad4 <HAL_RCCEx_PeriphCLKConfig+0x2d74>
3400cab2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cab6:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400cab8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400cabc:	d00a      	beq.n	3400cad4 <HAL_RCCEx_PeriphCLKConfig+0x2d74>
3400cabe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cac2:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400cac4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400cac8:	d004      	beq.n	3400cad4 <HAL_RCCEx_PeriphCLKConfig+0x2d74>
3400caca:	f240 31d6 	movw	r1, #982	@ 0x3d6
3400cace:	481c      	ldr	r0, [pc, #112]	@ (3400cb40 <HAL_RCCEx_PeriphCLKConfig+0x2de0>)
3400cad0:	f7f5 fa9e 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400cad4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cad8:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400cada:	2b00      	cmp	r3, #0
3400cadc:	d005      	beq.n	3400caea <HAL_RCCEx_PeriphCLKConfig+0x2d8a>
3400cade:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cae2:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400cae4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400cae8:	d904      	bls.n	3400caf4 <HAL_RCCEx_PeriphCLKConfig+0x2d94>
3400caea:	f240 31d7 	movw	r1, #983	@ 0x3d7
3400caee:	4814      	ldr	r0, [pc, #80]	@ (3400cb40 <HAL_RCCEx_PeriphCLKConfig+0x2de0>)
3400caf0:	f7f5 fa8e 	bl	34002010 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400caf4:	4b13      	ldr	r3, [pc, #76]	@ (3400cb44 <HAL_RCCEx_PeriphCLKConfig+0x2de4>)
3400caf6:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400cafa:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400cafe:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400cb02:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cb06:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3400cb08:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cb0c:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400cb0e:	3b01      	subs	r3, #1
3400cb10:	041b      	lsls	r3, r3, #16
3400cb12:	4313      	orrs	r3, r2
3400cb14:	4a0b      	ldr	r2, [pc, #44]	@ (3400cb44 <HAL_RCCEx_PeriphCLKConfig+0x2de4>)
3400cb16:	430b      	orrs	r3, r1
3400cb18:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400cb1c:	f7fc ff7e 	bl	34009a1c <LL_RCC_IC15_Enable>
3400cb20:	e01b      	b.n	3400cb5a <HAL_RCCEx_PeriphCLKConfig+0x2dfa>
3400cb22:	bf00      	nop
3400cb24:	0701080c 	.word	0x0701080c
3400cb28:	07000c0c 	.word	0x07000c0c
3400cb2c:	07010c0c 	.word	0x07010c0c
3400cb30:	07020c0c 	.word	0x07020c0c
3400cb34:	07030c0c 	.word	0x07030c0c
3400cb38:	07040c0c 	.word	0x07040c0c
3400cb3c:	07050c0c 	.word	0x07050c0c
3400cb40:	3401ee60 	.word	0x3401ee60
3400cb44:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_CLKP)
3400cb48:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cb4c:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3400cb50:	4b70      	ldr	r3, [pc, #448]	@ (3400cd14 <HAL_RCCEx_PeriphCLKConfig+0x2fb4>)
3400cb52:	429a      	cmp	r2, r3
3400cb54:	d101      	bne.n	3400cb5a <HAL_RCCEx_PeriphCLKConfig+0x2dfa>
    {
      LL_RCC_CLKP_Enable();
3400cb56:	f7fd f8e1 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C4 clock*/
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
3400cb5a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cb5e:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
3400cb62:	4618      	mov	r0, r3
3400cb64:	f7fb ffb6 	bl	34008ad4 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I3C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C1) == RCC_PERIPHCLK_I3C1)
3400cb68:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cb6c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400cb70:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
3400cb74:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
3400cb78:	2300      	movs	r3, #0
3400cb7a:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
3400cb7e:	e9d7 0144 	ldrd	r0, r1, [r7, #272]	@ 0x110
3400cb82:	4603      	mov	r3, r0
3400cb84:	460a      	mov	r2, r1
3400cb86:	4313      	orrs	r3, r2
3400cb88:	f000 80e6 	beq.w	3400cd58 <HAL_RCCEx_PeriphCLKConfig+0x2ff8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C1CLKSOURCE(PeriphClkInit->I3c1ClockSelection));
3400cb8c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cb90:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3400cb94:	4b60      	ldr	r3, [pc, #384]	@ (3400cd18 <HAL_RCCEx_PeriphCLKConfig+0x2fb8>)
3400cb96:	429a      	cmp	r2, r3
3400cb98:	d027      	beq.n	3400cbea <HAL_RCCEx_PeriphCLKConfig+0x2e8a>
3400cb9a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cb9e:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3400cba2:	4b5e      	ldr	r3, [pc, #376]	@ (3400cd1c <HAL_RCCEx_PeriphCLKConfig+0x2fbc>)
3400cba4:	429a      	cmp	r2, r3
3400cba6:	d020      	beq.n	3400cbea <HAL_RCCEx_PeriphCLKConfig+0x2e8a>
3400cba8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cbac:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3400cbb0:	4b5b      	ldr	r3, [pc, #364]	@ (3400cd20 <HAL_RCCEx_PeriphCLKConfig+0x2fc0>)
3400cbb2:	429a      	cmp	r2, r3
3400cbb4:	d019      	beq.n	3400cbea <HAL_RCCEx_PeriphCLKConfig+0x2e8a>
3400cbb6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cbba:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3400cbbe:	4b59      	ldr	r3, [pc, #356]	@ (3400cd24 <HAL_RCCEx_PeriphCLKConfig+0x2fc4>)
3400cbc0:	429a      	cmp	r2, r3
3400cbc2:	d012      	beq.n	3400cbea <HAL_RCCEx_PeriphCLKConfig+0x2e8a>
3400cbc4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cbc8:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3400cbcc:	4b56      	ldr	r3, [pc, #344]	@ (3400cd28 <HAL_RCCEx_PeriphCLKConfig+0x2fc8>)
3400cbce:	429a      	cmp	r2, r3
3400cbd0:	d00b      	beq.n	3400cbea <HAL_RCCEx_PeriphCLKConfig+0x2e8a>
3400cbd2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cbd6:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3400cbda:	4b54      	ldr	r3, [pc, #336]	@ (3400cd2c <HAL_RCCEx_PeriphCLKConfig+0x2fcc>)
3400cbdc:	429a      	cmp	r2, r3
3400cbde:	d004      	beq.n	3400cbea <HAL_RCCEx_PeriphCLKConfig+0x2e8a>
3400cbe0:	f240 31f1 	movw	r1, #1009	@ 0x3f1
3400cbe4:	4852      	ldr	r0, [pc, #328]	@ (3400cd30 <HAL_RCCEx_PeriphCLKConfig+0x2fd0>)
3400cbe6:	f7f5 fa13 	bl	34002010 <assert_failed>

    if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC10)
3400cbea:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cbee:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3400cbf2:	4b4b      	ldr	r3, [pc, #300]	@ (3400cd20 <HAL_RCCEx_PeriphCLKConfig+0x2fc0>)
3400cbf4:	429a      	cmp	r2, r3
3400cbf6:	d142      	bne.n	3400cc7e <HAL_RCCEx_PeriphCLKConfig+0x2f1e>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400cbf8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cbfc:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400cbfe:	2b00      	cmp	r3, #0
3400cc00:	d016      	beq.n	3400cc30 <HAL_RCCEx_PeriphCLKConfig+0x2ed0>
3400cc02:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cc06:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400cc08:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400cc0c:	d010      	beq.n	3400cc30 <HAL_RCCEx_PeriphCLKConfig+0x2ed0>
3400cc0e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cc12:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400cc14:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400cc18:	d00a      	beq.n	3400cc30 <HAL_RCCEx_PeriphCLKConfig+0x2ed0>
3400cc1a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cc1e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400cc20:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400cc24:	d004      	beq.n	3400cc30 <HAL_RCCEx_PeriphCLKConfig+0x2ed0>
3400cc26:	f240 31f6 	movw	r1, #1014	@ 0x3f6
3400cc2a:	4841      	ldr	r0, [pc, #260]	@ (3400cd30 <HAL_RCCEx_PeriphCLKConfig+0x2fd0>)
3400cc2c:	f7f5 f9f0 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400cc30:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cc34:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400cc36:	2b00      	cmp	r3, #0
3400cc38:	d005      	beq.n	3400cc46 <HAL_RCCEx_PeriphCLKConfig+0x2ee6>
3400cc3a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cc3e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400cc40:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400cc44:	d904      	bls.n	3400cc50 <HAL_RCCEx_PeriphCLKConfig+0x2ef0>
3400cc46:	f240 31f7 	movw	r1, #1015	@ 0x3f7
3400cc4a:	4839      	ldr	r0, [pc, #228]	@ (3400cd30 <HAL_RCCEx_PeriphCLKConfig+0x2fd0>)
3400cc4c:	f7f5 f9e0 	bl	34002010 <assert_failed>

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400cc50:	4b38      	ldr	r3, [pc, #224]	@ (3400cd34 <HAL_RCCEx_PeriphCLKConfig+0x2fd4>)
3400cc52:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3400cc56:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400cc5a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400cc5e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cc62:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3400cc64:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cc68:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400cc6a:	3b01      	subs	r3, #1
3400cc6c:	041b      	lsls	r3, r3, #16
3400cc6e:	4313      	orrs	r3, r2
3400cc70:	4a30      	ldr	r2, [pc, #192]	@ (3400cd34 <HAL_RCCEx_PeriphCLKConfig+0x2fd4>)
3400cc72:	430b      	orrs	r3, r1
3400cc74:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3400cc78:	f7fc fdd0 	bl	3400981c <LL_RCC_IC10_Enable>
3400cc7c:	e065      	b.n	3400cd4a <HAL_RCCEx_PeriphCLKConfig+0x2fea>
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC15)
3400cc7e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cc82:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3400cc86:	4b27      	ldr	r3, [pc, #156]	@ (3400cd24 <HAL_RCCEx_PeriphCLKConfig+0x2fc4>)
3400cc88:	429a      	cmp	r2, r3
3400cc8a:	d155      	bne.n	3400cd38 <HAL_RCCEx_PeriphCLKConfig+0x2fd8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400cc8c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cc90:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400cc92:	2b00      	cmp	r3, #0
3400cc94:	d016      	beq.n	3400ccc4 <HAL_RCCEx_PeriphCLKConfig+0x2f64>
3400cc96:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cc9a:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400cc9c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400cca0:	d010      	beq.n	3400ccc4 <HAL_RCCEx_PeriphCLKConfig+0x2f64>
3400cca2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cca6:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400cca8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ccac:	d00a      	beq.n	3400ccc4 <HAL_RCCEx_PeriphCLKConfig+0x2f64>
3400ccae:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ccb2:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400ccb4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ccb8:	d004      	beq.n	3400ccc4 <HAL_RCCEx_PeriphCLKConfig+0x2f64>
3400ccba:	f240 4103 	movw	r1, #1027	@ 0x403
3400ccbe:	481c      	ldr	r0, [pc, #112]	@ (3400cd30 <HAL_RCCEx_PeriphCLKConfig+0x2fd0>)
3400ccc0:	f7f5 f9a6 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400ccc4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ccc8:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400ccca:	2b00      	cmp	r3, #0
3400cccc:	d005      	beq.n	3400ccda <HAL_RCCEx_PeriphCLKConfig+0x2f7a>
3400ccce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ccd2:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400ccd4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400ccd8:	d904      	bls.n	3400cce4 <HAL_RCCEx_PeriphCLKConfig+0x2f84>
3400ccda:	f240 4104 	movw	r1, #1028	@ 0x404
3400ccde:	4814      	ldr	r0, [pc, #80]	@ (3400cd30 <HAL_RCCEx_PeriphCLKConfig+0x2fd0>)
3400cce0:	f7f5 f996 	bl	34002010 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400cce4:	4b13      	ldr	r3, [pc, #76]	@ (3400cd34 <HAL_RCCEx_PeriphCLKConfig+0x2fd4>)
3400cce6:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400ccea:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400ccee:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400ccf2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ccf6:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3400ccf8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ccfc:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400ccfe:	3b01      	subs	r3, #1
3400cd00:	041b      	lsls	r3, r3, #16
3400cd02:	4313      	orrs	r3, r2
3400cd04:	4a0b      	ldr	r2, [pc, #44]	@ (3400cd34 <HAL_RCCEx_PeriphCLKConfig+0x2fd4>)
3400cd06:	430b      	orrs	r3, r1
3400cd08:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400cd0c:	f7fc fe86 	bl	34009a1c <LL_RCC_IC15_Enable>
3400cd10:	e01b      	b.n	3400cd4a <HAL_RCCEx_PeriphCLKConfig+0x2fea>
3400cd12:	bf00      	nop
3400cd14:	07010c0c 	.word	0x07010c0c
3400cd18:	0700100c 	.word	0x0700100c
3400cd1c:	0701100c 	.word	0x0701100c
3400cd20:	0702100c 	.word	0x0702100c
3400cd24:	0703100c 	.word	0x0703100c
3400cd28:	0704100c 	.word	0x0704100c
3400cd2c:	0705100c 	.word	0x0705100c
3400cd30:	3401ee60 	.word	0x3401ee60
3400cd34:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_CLKP)
3400cd38:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cd3c:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3400cd40:	4b70      	ldr	r3, [pc, #448]	@ (3400cf04 <HAL_RCCEx_PeriphCLKConfig+0x31a4>)
3400cd42:	429a      	cmp	r2, r3
3400cd44:	d101      	bne.n	3400cd4a <HAL_RCCEx_PeriphCLKConfig+0x2fea>
    {
      LL_RCC_CLKP_Enable();
3400cd46:	f7fc ffe9 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C1 clock*/
    __HAL_RCC_I3C1_CONFIG(PeriphClkInit->I3c1ClockSelection);
3400cd4a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cd4e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400cd52:	4618      	mov	r0, r3
3400cd54:	f7fb fec9 	bl	34008aea <LL_RCC_SetI3CClockSource>
  }

  /*------------------------------ I3C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C2) == RCC_PERIPHCLK_I3C2)
3400cd58:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cd5c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400cd60:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
3400cd64:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
3400cd68:	2300      	movs	r3, #0
3400cd6a:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
3400cd6e:	e9d7 0142 	ldrd	r0, r1, [r7, #264]	@ 0x108
3400cd72:	4603      	mov	r3, r0
3400cd74:	460a      	mov	r2, r1
3400cd76:	4313      	orrs	r3, r2
3400cd78:	f000 80e6 	beq.w	3400cf48 <HAL_RCCEx_PeriphCLKConfig+0x31e8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C2CLKSOURCE(PeriphClkInit->I3c2ClockSelection));
3400cd7c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cd80:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3400cd84:	4b60      	ldr	r3, [pc, #384]	@ (3400cf08 <HAL_RCCEx_PeriphCLKConfig+0x31a8>)
3400cd86:	429a      	cmp	r2, r3
3400cd88:	d027      	beq.n	3400cdda <HAL_RCCEx_PeriphCLKConfig+0x307a>
3400cd8a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cd8e:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3400cd92:	4b5e      	ldr	r3, [pc, #376]	@ (3400cf0c <HAL_RCCEx_PeriphCLKConfig+0x31ac>)
3400cd94:	429a      	cmp	r2, r3
3400cd96:	d020      	beq.n	3400cdda <HAL_RCCEx_PeriphCLKConfig+0x307a>
3400cd98:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cd9c:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3400cda0:	4b5b      	ldr	r3, [pc, #364]	@ (3400cf10 <HAL_RCCEx_PeriphCLKConfig+0x31b0>)
3400cda2:	429a      	cmp	r2, r3
3400cda4:	d019      	beq.n	3400cdda <HAL_RCCEx_PeriphCLKConfig+0x307a>
3400cda6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cdaa:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3400cdae:	4b59      	ldr	r3, [pc, #356]	@ (3400cf14 <HAL_RCCEx_PeriphCLKConfig+0x31b4>)
3400cdb0:	429a      	cmp	r2, r3
3400cdb2:	d012      	beq.n	3400cdda <HAL_RCCEx_PeriphCLKConfig+0x307a>
3400cdb4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cdb8:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3400cdbc:	4b56      	ldr	r3, [pc, #344]	@ (3400cf18 <HAL_RCCEx_PeriphCLKConfig+0x31b8>)
3400cdbe:	429a      	cmp	r2, r3
3400cdc0:	d00b      	beq.n	3400cdda <HAL_RCCEx_PeriphCLKConfig+0x307a>
3400cdc2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cdc6:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3400cdca:	4b54      	ldr	r3, [pc, #336]	@ (3400cf1c <HAL_RCCEx_PeriphCLKConfig+0x31bc>)
3400cdcc:	429a      	cmp	r2, r3
3400cdce:	d004      	beq.n	3400cdda <HAL_RCCEx_PeriphCLKConfig+0x307a>
3400cdd0:	f240 411e 	movw	r1, #1054	@ 0x41e
3400cdd4:	4852      	ldr	r0, [pc, #328]	@ (3400cf20 <HAL_RCCEx_PeriphCLKConfig+0x31c0>)
3400cdd6:	f7f5 f91b 	bl	34002010 <assert_failed>

    if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC10)
3400cdda:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cdde:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3400cde2:	4b4b      	ldr	r3, [pc, #300]	@ (3400cf10 <HAL_RCCEx_PeriphCLKConfig+0x31b0>)
3400cde4:	429a      	cmp	r2, r3
3400cde6:	d142      	bne.n	3400ce6e <HAL_RCCEx_PeriphCLKConfig+0x310e>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400cde8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cdec:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400cdee:	2b00      	cmp	r3, #0
3400cdf0:	d016      	beq.n	3400ce20 <HAL_RCCEx_PeriphCLKConfig+0x30c0>
3400cdf2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cdf6:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400cdf8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400cdfc:	d010      	beq.n	3400ce20 <HAL_RCCEx_PeriphCLKConfig+0x30c0>
3400cdfe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ce02:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400ce04:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ce08:	d00a      	beq.n	3400ce20 <HAL_RCCEx_PeriphCLKConfig+0x30c0>
3400ce0a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ce0e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400ce10:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ce14:	d004      	beq.n	3400ce20 <HAL_RCCEx_PeriphCLKConfig+0x30c0>
3400ce16:	f240 4123 	movw	r1, #1059	@ 0x423
3400ce1a:	4841      	ldr	r0, [pc, #260]	@ (3400cf20 <HAL_RCCEx_PeriphCLKConfig+0x31c0>)
3400ce1c:	f7f5 f8f8 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400ce20:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ce24:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400ce26:	2b00      	cmp	r3, #0
3400ce28:	d005      	beq.n	3400ce36 <HAL_RCCEx_PeriphCLKConfig+0x30d6>
3400ce2a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ce2e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400ce30:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400ce34:	d904      	bls.n	3400ce40 <HAL_RCCEx_PeriphCLKConfig+0x30e0>
3400ce36:	f240 4124 	movw	r1, #1060	@ 0x424
3400ce3a:	4839      	ldr	r0, [pc, #228]	@ (3400cf20 <HAL_RCCEx_PeriphCLKConfig+0x31c0>)
3400ce3c:	f7f5 f8e8 	bl	34002010 <assert_failed>

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400ce40:	4b38      	ldr	r3, [pc, #224]	@ (3400cf24 <HAL_RCCEx_PeriphCLKConfig+0x31c4>)
3400ce42:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3400ce46:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400ce4a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400ce4e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ce52:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3400ce54:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ce58:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400ce5a:	3b01      	subs	r3, #1
3400ce5c:	041b      	lsls	r3, r3, #16
3400ce5e:	4313      	orrs	r3, r2
3400ce60:	4a30      	ldr	r2, [pc, #192]	@ (3400cf24 <HAL_RCCEx_PeriphCLKConfig+0x31c4>)
3400ce62:	430b      	orrs	r3, r1
3400ce64:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3400ce68:	f7fc fcd8 	bl	3400981c <LL_RCC_IC10_Enable>
3400ce6c:	e065      	b.n	3400cf3a <HAL_RCCEx_PeriphCLKConfig+0x31da>
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC15)
3400ce6e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ce72:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3400ce76:	4b27      	ldr	r3, [pc, #156]	@ (3400cf14 <HAL_RCCEx_PeriphCLKConfig+0x31b4>)
3400ce78:	429a      	cmp	r2, r3
3400ce7a:	d155      	bne.n	3400cf28 <HAL_RCCEx_PeriphCLKConfig+0x31c8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400ce7c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ce80:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400ce82:	2b00      	cmp	r3, #0
3400ce84:	d016      	beq.n	3400ceb4 <HAL_RCCEx_PeriphCLKConfig+0x3154>
3400ce86:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ce8a:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400ce8c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ce90:	d010      	beq.n	3400ceb4 <HAL_RCCEx_PeriphCLKConfig+0x3154>
3400ce92:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ce96:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400ce98:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ce9c:	d00a      	beq.n	3400ceb4 <HAL_RCCEx_PeriphCLKConfig+0x3154>
3400ce9e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cea2:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400cea4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400cea8:	d004      	beq.n	3400ceb4 <HAL_RCCEx_PeriphCLKConfig+0x3154>
3400ceaa:	f44f 6186 	mov.w	r1, #1072	@ 0x430
3400ceae:	481c      	ldr	r0, [pc, #112]	@ (3400cf20 <HAL_RCCEx_PeriphCLKConfig+0x31c0>)
3400ceb0:	f7f5 f8ae 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400ceb4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ceb8:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400ceba:	2b00      	cmp	r3, #0
3400cebc:	d005      	beq.n	3400ceca <HAL_RCCEx_PeriphCLKConfig+0x316a>
3400cebe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cec2:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400cec4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400cec8:	d904      	bls.n	3400ced4 <HAL_RCCEx_PeriphCLKConfig+0x3174>
3400ceca:	f240 4131 	movw	r1, #1073	@ 0x431
3400cece:	4814      	ldr	r0, [pc, #80]	@ (3400cf20 <HAL_RCCEx_PeriphCLKConfig+0x31c0>)
3400ced0:	f7f5 f89e 	bl	34002010 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400ced4:	4b13      	ldr	r3, [pc, #76]	@ (3400cf24 <HAL_RCCEx_PeriphCLKConfig+0x31c4>)
3400ced6:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400ceda:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400cede:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400cee2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cee6:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3400cee8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ceec:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400ceee:	3b01      	subs	r3, #1
3400cef0:	041b      	lsls	r3, r3, #16
3400cef2:	4313      	orrs	r3, r2
3400cef4:	4a0b      	ldr	r2, [pc, #44]	@ (3400cf24 <HAL_RCCEx_PeriphCLKConfig+0x31c4>)
3400cef6:	430b      	orrs	r3, r1
3400cef8:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400cefc:	f7fc fd8e 	bl	34009a1c <LL_RCC_IC15_Enable>
3400cf00:	e01b      	b.n	3400cf3a <HAL_RCCEx_PeriphCLKConfig+0x31da>
3400cf02:	bf00      	nop
3400cf04:	0701100c 	.word	0x0701100c
3400cf08:	0700140c 	.word	0x0700140c
3400cf0c:	0701140c 	.word	0x0701140c
3400cf10:	0702140c 	.word	0x0702140c
3400cf14:	0703140c 	.word	0x0703140c
3400cf18:	0704140c 	.word	0x0704140c
3400cf1c:	0705140c 	.word	0x0705140c
3400cf20:	3401ee60 	.word	0x3401ee60
3400cf24:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_CLKP)
3400cf28:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cf2c:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3400cf30:	4b98      	ldr	r3, [pc, #608]	@ (3400d194 <HAL_RCCEx_PeriphCLKConfig+0x3434>)
3400cf32:	429a      	cmp	r2, r3
3400cf34:	d101      	bne.n	3400cf3a <HAL_RCCEx_PeriphCLKConfig+0x31da>
    {
      LL_RCC_CLKP_Enable();
3400cf36:	f7fc fef1 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C2 clock*/
    __HAL_RCC_I3C2_CONFIG(PeriphClkInit->I3c2ClockSelection);
3400cf3a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cf3e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400cf42:	4618      	mov	r0, r3
3400cf44:	f7fb fdd1 	bl	34008aea <LL_RCC_SetI3CClockSource>
  }

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
3400cf48:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cf4c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400cf50:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
3400cf54:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
3400cf58:	2300      	movs	r3, #0
3400cf5a:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
3400cf5e:	e9d7 0140 	ldrd	r0, r1, [r7, #256]	@ 0x100
3400cf62:	4603      	mov	r3, r0
3400cf64:	460a      	mov	r2, r1
3400cf66:	4313      	orrs	r3, r2
3400cf68:	f000 8089 	beq.w	3400d07e <HAL_RCCEx_PeriphCLKConfig+0x331e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));
3400cf6c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cf70:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
3400cf74:	4b88      	ldr	r3, [pc, #544]	@ (3400d198 <HAL_RCCEx_PeriphCLKConfig+0x3438>)
3400cf76:	429a      	cmp	r2, r3
3400cf78:	d027      	beq.n	3400cfca <HAL_RCCEx_PeriphCLKConfig+0x326a>
3400cf7a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cf7e:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
3400cf82:	4b86      	ldr	r3, [pc, #536]	@ (3400d19c <HAL_RCCEx_PeriphCLKConfig+0x343c>)
3400cf84:	429a      	cmp	r2, r3
3400cf86:	d020      	beq.n	3400cfca <HAL_RCCEx_PeriphCLKConfig+0x326a>
3400cf88:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cf8c:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
3400cf90:	4b83      	ldr	r3, [pc, #524]	@ (3400d1a0 <HAL_RCCEx_PeriphCLKConfig+0x3440>)
3400cf92:	429a      	cmp	r2, r3
3400cf94:	d019      	beq.n	3400cfca <HAL_RCCEx_PeriphCLKConfig+0x326a>
3400cf96:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cf9a:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
3400cf9e:	4b81      	ldr	r3, [pc, #516]	@ (3400d1a4 <HAL_RCCEx_PeriphCLKConfig+0x3444>)
3400cfa0:	429a      	cmp	r2, r3
3400cfa2:	d012      	beq.n	3400cfca <HAL_RCCEx_PeriphCLKConfig+0x326a>
3400cfa4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cfa8:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
3400cfac:	4b7e      	ldr	r3, [pc, #504]	@ (3400d1a8 <HAL_RCCEx_PeriphCLKConfig+0x3448>)
3400cfae:	429a      	cmp	r2, r3
3400cfb0:	d00b      	beq.n	3400cfca <HAL_RCCEx_PeriphCLKConfig+0x326a>
3400cfb2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cfb6:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
3400cfba:	4b7c      	ldr	r3, [pc, #496]	@ (3400d1ac <HAL_RCCEx_PeriphCLKConfig+0x344c>)
3400cfbc:	429a      	cmp	r2, r3
3400cfbe:	d004      	beq.n	3400cfca <HAL_RCCEx_PeriphCLKConfig+0x326a>
3400cfc0:	f240 414b 	movw	r1, #1099	@ 0x44b
3400cfc4:	487a      	ldr	r0, [pc, #488]	@ (3400d1b0 <HAL_RCCEx_PeriphCLKConfig+0x3450>)
3400cfc6:	f7f5 f823 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_IC15)
3400cfca:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cfce:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
3400cfd2:	4b73      	ldr	r3, [pc, #460]	@ (3400d1a0 <HAL_RCCEx_PeriphCLKConfig+0x3440>)
3400cfd4:	429a      	cmp	r2, r3
3400cfd6:	d142      	bne.n	3400d05e <HAL_RCCEx_PeriphCLKConfig+0x32fe>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400cfd8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cfdc:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400cfde:	2b00      	cmp	r3, #0
3400cfe0:	d016      	beq.n	3400d010 <HAL_RCCEx_PeriphCLKConfig+0x32b0>
3400cfe2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cfe6:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400cfe8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400cfec:	d010      	beq.n	3400d010 <HAL_RCCEx_PeriphCLKConfig+0x32b0>
3400cfee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cff2:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400cff4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400cff8:	d00a      	beq.n	3400d010 <HAL_RCCEx_PeriphCLKConfig+0x32b0>
3400cffa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400cffe:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400d000:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d004:	d004      	beq.n	3400d010 <HAL_RCCEx_PeriphCLKConfig+0x32b0>
3400d006:	f44f 618a 	mov.w	r1, #1104	@ 0x450
3400d00a:	4869      	ldr	r0, [pc, #420]	@ (3400d1b0 <HAL_RCCEx_PeriphCLKConfig+0x3450>)
3400d00c:	f7f5 f800 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400d010:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d014:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400d016:	2b00      	cmp	r3, #0
3400d018:	d005      	beq.n	3400d026 <HAL_RCCEx_PeriphCLKConfig+0x32c6>
3400d01a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d01e:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400d020:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400d024:	d904      	bls.n	3400d030 <HAL_RCCEx_PeriphCLKConfig+0x32d0>
3400d026:	f240 4151 	movw	r1, #1105	@ 0x451
3400d02a:	4861      	ldr	r0, [pc, #388]	@ (3400d1b0 <HAL_RCCEx_PeriphCLKConfig+0x3450>)
3400d02c:	f7f4 fff0 	bl	34002010 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400d030:	4b60      	ldr	r3, [pc, #384]	@ (3400d1b4 <HAL_RCCEx_PeriphCLKConfig+0x3454>)
3400d032:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400d036:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400d03a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400d03e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d042:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3400d044:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d048:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400d04a:	3b01      	subs	r3, #1
3400d04c:	041b      	lsls	r3, r3, #16
3400d04e:	4313      	orrs	r3, r2
3400d050:	4a58      	ldr	r2, [pc, #352]	@ (3400d1b4 <HAL_RCCEx_PeriphCLKConfig+0x3454>)
3400d052:	430b      	orrs	r3, r1
3400d054:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400d058:	f7fc fce0 	bl	34009a1c <LL_RCC_IC15_Enable>
3400d05c:	e008      	b.n	3400d070 <HAL_RCCEx_PeriphCLKConfig+0x3310>
    }
    else if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_CLKP)
3400d05e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d062:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
3400d066:	4b4d      	ldr	r3, [pc, #308]	@ (3400d19c <HAL_RCCEx_PeriphCLKConfig+0x343c>)
3400d068:	429a      	cmp	r2, r3
3400d06a:	d101      	bne.n	3400d070 <HAL_RCCEx_PeriphCLKConfig+0x3310>
    {
      LL_RCC_CLKP_Enable();
3400d06c:	f7fc fe56 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM1 clock*/
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
3400d070:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d074:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3400d078:	4618      	mov	r0, r3
3400d07a:	f7fb fd41 	bl	34008b00 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM2 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
3400d07e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d082:	e9d3 2300 	ldrd	r2, r3, [r3]
3400d086:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
3400d08a:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
3400d08e:	2300      	movs	r3, #0
3400d090:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
3400d094:	e9d7 013e 	ldrd	r0, r1, [r7, #248]	@ 0xf8
3400d098:	4603      	mov	r3, r0
3400d09a:	460a      	mov	r2, r1
3400d09c:	4313      	orrs	r3, r2
3400d09e:	f000 80a7 	beq.w	3400d1f0 <HAL_RCCEx_PeriphCLKConfig+0x3490>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));
3400d0a2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d0a6:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
3400d0aa:	4b43      	ldr	r3, [pc, #268]	@ (3400d1b8 <HAL_RCCEx_PeriphCLKConfig+0x3458>)
3400d0ac:	429a      	cmp	r2, r3
3400d0ae:	d027      	beq.n	3400d100 <HAL_RCCEx_PeriphCLKConfig+0x33a0>
3400d0b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d0b4:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
3400d0b8:	4b40      	ldr	r3, [pc, #256]	@ (3400d1bc <HAL_RCCEx_PeriphCLKConfig+0x345c>)
3400d0ba:	429a      	cmp	r2, r3
3400d0bc:	d020      	beq.n	3400d100 <HAL_RCCEx_PeriphCLKConfig+0x33a0>
3400d0be:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d0c2:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
3400d0c6:	4b3e      	ldr	r3, [pc, #248]	@ (3400d1c0 <HAL_RCCEx_PeriphCLKConfig+0x3460>)
3400d0c8:	429a      	cmp	r2, r3
3400d0ca:	d019      	beq.n	3400d100 <HAL_RCCEx_PeriphCLKConfig+0x33a0>
3400d0cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d0d0:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
3400d0d4:	4b3b      	ldr	r3, [pc, #236]	@ (3400d1c4 <HAL_RCCEx_PeriphCLKConfig+0x3464>)
3400d0d6:	429a      	cmp	r2, r3
3400d0d8:	d012      	beq.n	3400d100 <HAL_RCCEx_PeriphCLKConfig+0x33a0>
3400d0da:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d0de:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
3400d0e2:	4b39      	ldr	r3, [pc, #228]	@ (3400d1c8 <HAL_RCCEx_PeriphCLKConfig+0x3468>)
3400d0e4:	429a      	cmp	r2, r3
3400d0e6:	d00b      	beq.n	3400d100 <HAL_RCCEx_PeriphCLKConfig+0x33a0>
3400d0e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d0ec:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
3400d0f0:	4b36      	ldr	r3, [pc, #216]	@ (3400d1cc <HAL_RCCEx_PeriphCLKConfig+0x346c>)
3400d0f2:	429a      	cmp	r2, r3
3400d0f4:	d004      	beq.n	3400d100 <HAL_RCCEx_PeriphCLKConfig+0x33a0>
3400d0f6:	f240 416b 	movw	r1, #1131	@ 0x46b
3400d0fa:	482d      	ldr	r0, [pc, #180]	@ (3400d1b0 <HAL_RCCEx_PeriphCLKConfig+0x3450>)
3400d0fc:	f7f4 ff88 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_IC15)
3400d100:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d104:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
3400d108:	4b2d      	ldr	r3, [pc, #180]	@ (3400d1c0 <HAL_RCCEx_PeriphCLKConfig+0x3460>)
3400d10a:	429a      	cmp	r2, r3
3400d10c:	d160      	bne.n	3400d1d0 <HAL_RCCEx_PeriphCLKConfig+0x3470>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400d10e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d112:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400d114:	2b00      	cmp	r3, #0
3400d116:	d016      	beq.n	3400d146 <HAL_RCCEx_PeriphCLKConfig+0x33e6>
3400d118:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d11c:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400d11e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400d122:	d010      	beq.n	3400d146 <HAL_RCCEx_PeriphCLKConfig+0x33e6>
3400d124:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d128:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400d12a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d12e:	d00a      	beq.n	3400d146 <HAL_RCCEx_PeriphCLKConfig+0x33e6>
3400d130:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d134:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400d136:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d13a:	d004      	beq.n	3400d146 <HAL_RCCEx_PeriphCLKConfig+0x33e6>
3400d13c:	f44f 618e 	mov.w	r1, #1136	@ 0x470
3400d140:	481b      	ldr	r0, [pc, #108]	@ (3400d1b0 <HAL_RCCEx_PeriphCLKConfig+0x3450>)
3400d142:	f7f4 ff65 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400d146:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d14a:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400d14c:	2b00      	cmp	r3, #0
3400d14e:	d005      	beq.n	3400d15c <HAL_RCCEx_PeriphCLKConfig+0x33fc>
3400d150:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d154:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400d156:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400d15a:	d904      	bls.n	3400d166 <HAL_RCCEx_PeriphCLKConfig+0x3406>
3400d15c:	f240 4171 	movw	r1, #1137	@ 0x471
3400d160:	4813      	ldr	r0, [pc, #76]	@ (3400d1b0 <HAL_RCCEx_PeriphCLKConfig+0x3450>)
3400d162:	f7f4 ff55 	bl	34002010 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400d166:	4b13      	ldr	r3, [pc, #76]	@ (3400d1b4 <HAL_RCCEx_PeriphCLKConfig+0x3454>)
3400d168:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400d16c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400d170:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400d174:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d178:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3400d17a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d17e:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400d180:	3b01      	subs	r3, #1
3400d182:	041b      	lsls	r3, r3, #16
3400d184:	4313      	orrs	r3, r2
3400d186:	4a0b      	ldr	r2, [pc, #44]	@ (3400d1b4 <HAL_RCCEx_PeriphCLKConfig+0x3454>)
3400d188:	430b      	orrs	r3, r1
3400d18a:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400d18e:	f7fc fc45 	bl	34009a1c <LL_RCC_IC15_Enable>
3400d192:	e026      	b.n	3400d1e2 <HAL_RCCEx_PeriphCLKConfig+0x3482>
3400d194:	0701140c 	.word	0x0701140c
3400d198:	0700082c 	.word	0x0700082c
3400d19c:	0701082c 	.word	0x0701082c
3400d1a0:	0702082c 	.word	0x0702082c
3400d1a4:	0703082c 	.word	0x0703082c
3400d1a8:	0704082c 	.word	0x0704082c
3400d1ac:	0705082c 	.word	0x0705082c
3400d1b0:	3401ee60 	.word	0x3401ee60
3400d1b4:	56028000 	.word	0x56028000
3400d1b8:	07000c2c 	.word	0x07000c2c
3400d1bc:	07010c2c 	.word	0x07010c2c
3400d1c0:	07020c2c 	.word	0x07020c2c
3400d1c4:	07030c2c 	.word	0x07030c2c
3400d1c8:	07040c2c 	.word	0x07040c2c
3400d1cc:	07050c2c 	.word	0x07050c2c
    }
    else if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_CLKP)
3400d1d0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d1d4:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
3400d1d8:	4b98      	ldr	r3, [pc, #608]	@ (3400d43c <HAL_RCCEx_PeriphCLKConfig+0x36dc>)
3400d1da:	429a      	cmp	r2, r3
3400d1dc:	d101      	bne.n	3400d1e2 <HAL_RCCEx_PeriphCLKConfig+0x3482>
    {
      LL_RCC_CLKP_Enable();
3400d1de:	f7fc fd9d 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM2 clock*/
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
3400d1e2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d1e6:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3400d1ea:	4618      	mov	r0, r3
3400d1ec:	f7fb fc88 	bl	34008b00 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM3 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM3) == RCC_PERIPHCLK_LPTIM3)
3400d1f0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d1f4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400d1f8:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
3400d1fc:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
3400d200:	2300      	movs	r3, #0
3400d202:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
3400d206:	e9d7 013c 	ldrd	r0, r1, [r7, #240]	@ 0xf0
3400d20a:	4603      	mov	r3, r0
3400d20c:	460a      	mov	r2, r1
3400d20e:	4313      	orrs	r3, r2
3400d210:	f000 8089 	beq.w	3400d326 <HAL_RCCEx_PeriphCLKConfig+0x35c6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));
3400d214:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d218:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3400d21c:	4b88      	ldr	r3, [pc, #544]	@ (3400d440 <HAL_RCCEx_PeriphCLKConfig+0x36e0>)
3400d21e:	429a      	cmp	r2, r3
3400d220:	d027      	beq.n	3400d272 <HAL_RCCEx_PeriphCLKConfig+0x3512>
3400d222:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d226:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3400d22a:	4b86      	ldr	r3, [pc, #536]	@ (3400d444 <HAL_RCCEx_PeriphCLKConfig+0x36e4>)
3400d22c:	429a      	cmp	r2, r3
3400d22e:	d020      	beq.n	3400d272 <HAL_RCCEx_PeriphCLKConfig+0x3512>
3400d230:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d234:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3400d238:	4b83      	ldr	r3, [pc, #524]	@ (3400d448 <HAL_RCCEx_PeriphCLKConfig+0x36e8>)
3400d23a:	429a      	cmp	r2, r3
3400d23c:	d019      	beq.n	3400d272 <HAL_RCCEx_PeriphCLKConfig+0x3512>
3400d23e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d242:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3400d246:	4b81      	ldr	r3, [pc, #516]	@ (3400d44c <HAL_RCCEx_PeriphCLKConfig+0x36ec>)
3400d248:	429a      	cmp	r2, r3
3400d24a:	d012      	beq.n	3400d272 <HAL_RCCEx_PeriphCLKConfig+0x3512>
3400d24c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d250:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3400d254:	4b7e      	ldr	r3, [pc, #504]	@ (3400d450 <HAL_RCCEx_PeriphCLKConfig+0x36f0>)
3400d256:	429a      	cmp	r2, r3
3400d258:	d00b      	beq.n	3400d272 <HAL_RCCEx_PeriphCLKConfig+0x3512>
3400d25a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d25e:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3400d262:	4b7c      	ldr	r3, [pc, #496]	@ (3400d454 <HAL_RCCEx_PeriphCLKConfig+0x36f4>)
3400d264:	429a      	cmp	r2, r3
3400d266:	d004      	beq.n	3400d272 <HAL_RCCEx_PeriphCLKConfig+0x3512>
3400d268:	f240 418b 	movw	r1, #1163	@ 0x48b
3400d26c:	487a      	ldr	r0, [pc, #488]	@ (3400d458 <HAL_RCCEx_PeriphCLKConfig+0x36f8>)
3400d26e:	f7f4 fecf 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_IC15)
3400d272:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d276:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3400d27a:	4b73      	ldr	r3, [pc, #460]	@ (3400d448 <HAL_RCCEx_PeriphCLKConfig+0x36e8>)
3400d27c:	429a      	cmp	r2, r3
3400d27e:	d142      	bne.n	3400d306 <HAL_RCCEx_PeriphCLKConfig+0x35a6>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400d280:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d284:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400d286:	2b00      	cmp	r3, #0
3400d288:	d016      	beq.n	3400d2b8 <HAL_RCCEx_PeriphCLKConfig+0x3558>
3400d28a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d28e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400d290:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400d294:	d010      	beq.n	3400d2b8 <HAL_RCCEx_PeriphCLKConfig+0x3558>
3400d296:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d29a:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400d29c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d2a0:	d00a      	beq.n	3400d2b8 <HAL_RCCEx_PeriphCLKConfig+0x3558>
3400d2a2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d2a6:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400d2a8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d2ac:	d004      	beq.n	3400d2b8 <HAL_RCCEx_PeriphCLKConfig+0x3558>
3400d2ae:	f44f 6192 	mov.w	r1, #1168	@ 0x490
3400d2b2:	4869      	ldr	r0, [pc, #420]	@ (3400d458 <HAL_RCCEx_PeriphCLKConfig+0x36f8>)
3400d2b4:	f7f4 feac 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400d2b8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d2bc:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400d2be:	2b00      	cmp	r3, #0
3400d2c0:	d005      	beq.n	3400d2ce <HAL_RCCEx_PeriphCLKConfig+0x356e>
3400d2c2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d2c6:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400d2c8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400d2cc:	d904      	bls.n	3400d2d8 <HAL_RCCEx_PeriphCLKConfig+0x3578>
3400d2ce:	f240 4191 	movw	r1, #1169	@ 0x491
3400d2d2:	4861      	ldr	r0, [pc, #388]	@ (3400d458 <HAL_RCCEx_PeriphCLKConfig+0x36f8>)
3400d2d4:	f7f4 fe9c 	bl	34002010 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400d2d8:	4b60      	ldr	r3, [pc, #384]	@ (3400d45c <HAL_RCCEx_PeriphCLKConfig+0x36fc>)
3400d2da:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400d2de:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400d2e2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400d2e6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d2ea:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3400d2ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d2f0:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400d2f2:	3b01      	subs	r3, #1
3400d2f4:	041b      	lsls	r3, r3, #16
3400d2f6:	4313      	orrs	r3, r2
3400d2f8:	4a58      	ldr	r2, [pc, #352]	@ (3400d45c <HAL_RCCEx_PeriphCLKConfig+0x36fc>)
3400d2fa:	430b      	orrs	r3, r1
3400d2fc:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400d300:	f7fc fb8c 	bl	34009a1c <LL_RCC_IC15_Enable>
3400d304:	e008      	b.n	3400d318 <HAL_RCCEx_PeriphCLKConfig+0x35b8>
    }
    else if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_CLKP)
3400d306:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d30a:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3400d30e:	4b4d      	ldr	r3, [pc, #308]	@ (3400d444 <HAL_RCCEx_PeriphCLKConfig+0x36e4>)
3400d310:	429a      	cmp	r2, r3
3400d312:	d101      	bne.n	3400d318 <HAL_RCCEx_PeriphCLKConfig+0x35b8>
    {
      LL_RCC_CLKP_Enable();
3400d314:	f7fc fd02 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM3 clock */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
3400d318:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d31c:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
3400d320:	4618      	mov	r0, r3
3400d322:	f7fb fbed 	bl	34008b00 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM4 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM4) == RCC_PERIPHCLK_LPTIM4)
3400d326:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d32a:	e9d3 2300 	ldrd	r2, r3, [r3]
3400d32e:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
3400d332:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
3400d336:	2300      	movs	r3, #0
3400d338:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
3400d33c:	e9d7 013a 	ldrd	r0, r1, [r7, #232]	@ 0xe8
3400d340:	4603      	mov	r3, r0
3400d342:	460a      	mov	r2, r1
3400d344:	4313      	orrs	r3, r2
3400d346:	f000 80a7 	beq.w	3400d498 <HAL_RCCEx_PeriphCLKConfig+0x3738>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM4CLKSOURCE(PeriphClkInit->Lptim4ClockSelection));
3400d34a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d34e:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
3400d352:	4b43      	ldr	r3, [pc, #268]	@ (3400d460 <HAL_RCCEx_PeriphCLKConfig+0x3700>)
3400d354:	429a      	cmp	r2, r3
3400d356:	d027      	beq.n	3400d3a8 <HAL_RCCEx_PeriphCLKConfig+0x3648>
3400d358:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d35c:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
3400d360:	4b40      	ldr	r3, [pc, #256]	@ (3400d464 <HAL_RCCEx_PeriphCLKConfig+0x3704>)
3400d362:	429a      	cmp	r2, r3
3400d364:	d020      	beq.n	3400d3a8 <HAL_RCCEx_PeriphCLKConfig+0x3648>
3400d366:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d36a:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
3400d36e:	4b3e      	ldr	r3, [pc, #248]	@ (3400d468 <HAL_RCCEx_PeriphCLKConfig+0x3708>)
3400d370:	429a      	cmp	r2, r3
3400d372:	d019      	beq.n	3400d3a8 <HAL_RCCEx_PeriphCLKConfig+0x3648>
3400d374:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d378:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
3400d37c:	4b3b      	ldr	r3, [pc, #236]	@ (3400d46c <HAL_RCCEx_PeriphCLKConfig+0x370c>)
3400d37e:	429a      	cmp	r2, r3
3400d380:	d012      	beq.n	3400d3a8 <HAL_RCCEx_PeriphCLKConfig+0x3648>
3400d382:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d386:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
3400d38a:	4b39      	ldr	r3, [pc, #228]	@ (3400d470 <HAL_RCCEx_PeriphCLKConfig+0x3710>)
3400d38c:	429a      	cmp	r2, r3
3400d38e:	d00b      	beq.n	3400d3a8 <HAL_RCCEx_PeriphCLKConfig+0x3648>
3400d390:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d394:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
3400d398:	4b36      	ldr	r3, [pc, #216]	@ (3400d474 <HAL_RCCEx_PeriphCLKConfig+0x3714>)
3400d39a:	429a      	cmp	r2, r3
3400d39c:	d004      	beq.n	3400d3a8 <HAL_RCCEx_PeriphCLKConfig+0x3648>
3400d39e:	f240 41ab 	movw	r1, #1195	@ 0x4ab
3400d3a2:	482d      	ldr	r0, [pc, #180]	@ (3400d458 <HAL_RCCEx_PeriphCLKConfig+0x36f8>)
3400d3a4:	f7f4 fe34 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_IC15)
3400d3a8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d3ac:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
3400d3b0:	4b2d      	ldr	r3, [pc, #180]	@ (3400d468 <HAL_RCCEx_PeriphCLKConfig+0x3708>)
3400d3b2:	429a      	cmp	r2, r3
3400d3b4:	d160      	bne.n	3400d478 <HAL_RCCEx_PeriphCLKConfig+0x3718>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400d3b6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d3ba:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400d3bc:	2b00      	cmp	r3, #0
3400d3be:	d016      	beq.n	3400d3ee <HAL_RCCEx_PeriphCLKConfig+0x368e>
3400d3c0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d3c4:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400d3c6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400d3ca:	d010      	beq.n	3400d3ee <HAL_RCCEx_PeriphCLKConfig+0x368e>
3400d3cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d3d0:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400d3d2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d3d6:	d00a      	beq.n	3400d3ee <HAL_RCCEx_PeriphCLKConfig+0x368e>
3400d3d8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d3dc:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400d3de:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d3e2:	d004      	beq.n	3400d3ee <HAL_RCCEx_PeriphCLKConfig+0x368e>
3400d3e4:	f44f 6196 	mov.w	r1, #1200	@ 0x4b0
3400d3e8:	481b      	ldr	r0, [pc, #108]	@ (3400d458 <HAL_RCCEx_PeriphCLKConfig+0x36f8>)
3400d3ea:	f7f4 fe11 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400d3ee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d3f2:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400d3f4:	2b00      	cmp	r3, #0
3400d3f6:	d005      	beq.n	3400d404 <HAL_RCCEx_PeriphCLKConfig+0x36a4>
3400d3f8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d3fc:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400d3fe:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400d402:	d904      	bls.n	3400d40e <HAL_RCCEx_PeriphCLKConfig+0x36ae>
3400d404:	f240 41b1 	movw	r1, #1201	@ 0x4b1
3400d408:	4813      	ldr	r0, [pc, #76]	@ (3400d458 <HAL_RCCEx_PeriphCLKConfig+0x36f8>)
3400d40a:	f7f4 fe01 	bl	34002010 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400d40e:	4b13      	ldr	r3, [pc, #76]	@ (3400d45c <HAL_RCCEx_PeriphCLKConfig+0x36fc>)
3400d410:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400d414:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400d418:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400d41c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d420:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3400d422:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d426:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400d428:	3b01      	subs	r3, #1
3400d42a:	041b      	lsls	r3, r3, #16
3400d42c:	4313      	orrs	r3, r2
3400d42e:	4a0b      	ldr	r2, [pc, #44]	@ (3400d45c <HAL_RCCEx_PeriphCLKConfig+0x36fc>)
3400d430:	430b      	orrs	r3, r1
3400d432:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400d436:	f7fc faf1 	bl	34009a1c <LL_RCC_IC15_Enable>
3400d43a:	e026      	b.n	3400d48a <HAL_RCCEx_PeriphCLKConfig+0x372a>
3400d43c:	07010c2c 	.word	0x07010c2c
3400d440:	0700102c 	.word	0x0700102c
3400d444:	0701102c 	.word	0x0701102c
3400d448:	0702102c 	.word	0x0702102c
3400d44c:	0703102c 	.word	0x0703102c
3400d450:	0704102c 	.word	0x0704102c
3400d454:	0705102c 	.word	0x0705102c
3400d458:	3401ee60 	.word	0x3401ee60
3400d45c:	56028000 	.word	0x56028000
3400d460:	0700142c 	.word	0x0700142c
3400d464:	0701142c 	.word	0x0701142c
3400d468:	0702142c 	.word	0x0702142c
3400d46c:	0703142c 	.word	0x0703142c
3400d470:	0704142c 	.word	0x0704142c
3400d474:	0705142c 	.word	0x0705142c
    }
    else if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_CLKP)
3400d478:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d47c:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
3400d480:	4b9b      	ldr	r3, [pc, #620]	@ (3400d6f0 <HAL_RCCEx_PeriphCLKConfig+0x3990>)
3400d482:	429a      	cmp	r2, r3
3400d484:	d101      	bne.n	3400d48a <HAL_RCCEx_PeriphCLKConfig+0x372a>
    {
      LL_RCC_CLKP_Enable();
3400d486:	f7fc fc49 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM4 clock */
    __HAL_RCC_LPTIM4_CONFIG(PeriphClkInit->Lptim4ClockSelection);
3400d48a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d48e:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3400d492:	4618      	mov	r0, r3
3400d494:	f7fb fb34 	bl	34008b00 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM5 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM5) == RCC_PERIPHCLK_LPTIM5)
3400d498:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d49c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400d4a0:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
3400d4a4:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
3400d4a8:	2300      	movs	r3, #0
3400d4aa:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
3400d4ae:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	@ 0xe0
3400d4b2:	4603      	mov	r3, r0
3400d4b4:	460a      	mov	r2, r1
3400d4b6:	4313      	orrs	r3, r2
3400d4b8:	f000 8089 	beq.w	3400d5ce <HAL_RCCEx_PeriphCLKConfig+0x386e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM5CLKSOURCE(PeriphClkInit->Lptim5ClockSelection));
3400d4bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d4c0:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
3400d4c4:	4b8b      	ldr	r3, [pc, #556]	@ (3400d6f4 <HAL_RCCEx_PeriphCLKConfig+0x3994>)
3400d4c6:	429a      	cmp	r2, r3
3400d4c8:	d027      	beq.n	3400d51a <HAL_RCCEx_PeriphCLKConfig+0x37ba>
3400d4ca:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d4ce:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
3400d4d2:	4b89      	ldr	r3, [pc, #548]	@ (3400d6f8 <HAL_RCCEx_PeriphCLKConfig+0x3998>)
3400d4d4:	429a      	cmp	r2, r3
3400d4d6:	d020      	beq.n	3400d51a <HAL_RCCEx_PeriphCLKConfig+0x37ba>
3400d4d8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d4dc:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
3400d4e0:	4b86      	ldr	r3, [pc, #536]	@ (3400d6fc <HAL_RCCEx_PeriphCLKConfig+0x399c>)
3400d4e2:	429a      	cmp	r2, r3
3400d4e4:	d019      	beq.n	3400d51a <HAL_RCCEx_PeriphCLKConfig+0x37ba>
3400d4e6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d4ea:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
3400d4ee:	4b84      	ldr	r3, [pc, #528]	@ (3400d700 <HAL_RCCEx_PeriphCLKConfig+0x39a0>)
3400d4f0:	429a      	cmp	r2, r3
3400d4f2:	d012      	beq.n	3400d51a <HAL_RCCEx_PeriphCLKConfig+0x37ba>
3400d4f4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d4f8:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
3400d4fc:	4b81      	ldr	r3, [pc, #516]	@ (3400d704 <HAL_RCCEx_PeriphCLKConfig+0x39a4>)
3400d4fe:	429a      	cmp	r2, r3
3400d500:	d00b      	beq.n	3400d51a <HAL_RCCEx_PeriphCLKConfig+0x37ba>
3400d502:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d506:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
3400d50a:	4b7f      	ldr	r3, [pc, #508]	@ (3400d708 <HAL_RCCEx_PeriphCLKConfig+0x39a8>)
3400d50c:	429a      	cmp	r2, r3
3400d50e:	d004      	beq.n	3400d51a <HAL_RCCEx_PeriphCLKConfig+0x37ba>
3400d510:	f240 41cb 	movw	r1, #1227	@ 0x4cb
3400d514:	487d      	ldr	r0, [pc, #500]	@ (3400d70c <HAL_RCCEx_PeriphCLKConfig+0x39ac>)
3400d516:	f7f4 fd7b 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_IC15)
3400d51a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d51e:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
3400d522:	4b76      	ldr	r3, [pc, #472]	@ (3400d6fc <HAL_RCCEx_PeriphCLKConfig+0x399c>)
3400d524:	429a      	cmp	r2, r3
3400d526:	d142      	bne.n	3400d5ae <HAL_RCCEx_PeriphCLKConfig+0x384e>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400d528:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d52c:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400d52e:	2b00      	cmp	r3, #0
3400d530:	d016      	beq.n	3400d560 <HAL_RCCEx_PeriphCLKConfig+0x3800>
3400d532:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d536:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400d538:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400d53c:	d010      	beq.n	3400d560 <HAL_RCCEx_PeriphCLKConfig+0x3800>
3400d53e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d542:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400d544:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d548:	d00a      	beq.n	3400d560 <HAL_RCCEx_PeriphCLKConfig+0x3800>
3400d54a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d54e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400d550:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d554:	d004      	beq.n	3400d560 <HAL_RCCEx_PeriphCLKConfig+0x3800>
3400d556:	f44f 619a 	mov.w	r1, #1232	@ 0x4d0
3400d55a:	486c      	ldr	r0, [pc, #432]	@ (3400d70c <HAL_RCCEx_PeriphCLKConfig+0x39ac>)
3400d55c:	f7f4 fd58 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400d560:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d564:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400d566:	2b00      	cmp	r3, #0
3400d568:	d005      	beq.n	3400d576 <HAL_RCCEx_PeriphCLKConfig+0x3816>
3400d56a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d56e:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400d570:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400d574:	d904      	bls.n	3400d580 <HAL_RCCEx_PeriphCLKConfig+0x3820>
3400d576:	f240 41d1 	movw	r1, #1233	@ 0x4d1
3400d57a:	4864      	ldr	r0, [pc, #400]	@ (3400d70c <HAL_RCCEx_PeriphCLKConfig+0x39ac>)
3400d57c:	f7f4 fd48 	bl	34002010 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400d580:	4b63      	ldr	r3, [pc, #396]	@ (3400d710 <HAL_RCCEx_PeriphCLKConfig+0x39b0>)
3400d582:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400d586:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400d58a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400d58e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d592:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3400d594:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d598:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400d59a:	3b01      	subs	r3, #1
3400d59c:	041b      	lsls	r3, r3, #16
3400d59e:	4313      	orrs	r3, r2
3400d5a0:	4a5b      	ldr	r2, [pc, #364]	@ (3400d710 <HAL_RCCEx_PeriphCLKConfig+0x39b0>)
3400d5a2:	430b      	orrs	r3, r1
3400d5a4:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400d5a8:	f7fc fa38 	bl	34009a1c <LL_RCC_IC15_Enable>
3400d5ac:	e008      	b.n	3400d5c0 <HAL_RCCEx_PeriphCLKConfig+0x3860>
    }
    else if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_CLKP)
3400d5ae:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d5b2:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
3400d5b6:	4b50      	ldr	r3, [pc, #320]	@ (3400d6f8 <HAL_RCCEx_PeriphCLKConfig+0x3998>)
3400d5b8:	429a      	cmp	r2, r3
3400d5ba:	d101      	bne.n	3400d5c0 <HAL_RCCEx_PeriphCLKConfig+0x3860>
    {
      LL_RCC_CLKP_Enable();
3400d5bc:	f7fc fbae 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM5 clock */
    __HAL_RCC_LPTIM5_CONFIG(PeriphClkInit->Lptim5ClockSelection);
3400d5c0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d5c4:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3400d5c8:	4618      	mov	r0, r3
3400d5ca:	f7fb fa99 	bl	34008b00 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
3400d5ce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d5d2:	e9d3 2300 	ldrd	r2, r3, [r3]
3400d5d6:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
3400d5da:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
3400d5de:	2300      	movs	r3, #0
3400d5e0:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
3400d5e4:	e9d7 0136 	ldrd	r0, r1, [r7, #216]	@ 0xd8
3400d5e8:	4603      	mov	r3, r0
3400d5ea:	460a      	mov	r2, r1
3400d5ec:	4313      	orrs	r3, r2
3400d5ee:	f000 80eb 	beq.w	3400d7c8 <HAL_RCCEx_PeriphCLKConfig+0x3a68>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));
3400d5f2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d5f6:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3400d5fa:	2b00      	cmp	r3, #0
3400d5fc:	d02e      	beq.n	3400d65c <HAL_RCCEx_PeriphCLKConfig+0x38fc>
3400d5fe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d602:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3400d606:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400d60a:	d027      	beq.n	3400d65c <HAL_RCCEx_PeriphCLKConfig+0x38fc>
3400d60c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d610:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3400d614:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400d618:	d020      	beq.n	3400d65c <HAL_RCCEx_PeriphCLKConfig+0x38fc>
3400d61a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d61e:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3400d622:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3400d626:	d019      	beq.n	3400d65c <HAL_RCCEx_PeriphCLKConfig+0x38fc>
3400d628:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d62c:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3400d630:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3400d634:	d012      	beq.n	3400d65c <HAL_RCCEx_PeriphCLKConfig+0x38fc>
3400d636:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d63a:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3400d63e:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
3400d642:	d00b      	beq.n	3400d65c <HAL_RCCEx_PeriphCLKConfig+0x38fc>
3400d644:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d648:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3400d64c:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
3400d650:	d004      	beq.n	3400d65c <HAL_RCCEx_PeriphCLKConfig+0x38fc>
3400d652:	f240 41eb 	movw	r1, #1259	@ 0x4eb
3400d656:	482d      	ldr	r0, [pc, #180]	@ (3400d70c <HAL_RCCEx_PeriphCLKConfig+0x39ac>)
3400d658:	f7f4 fcda 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC9)
3400d65c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d660:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3400d664:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400d668:	d154      	bne.n	3400d714 <HAL_RCCEx_PeriphCLKConfig+0x39b4>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400d66a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d66e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400d670:	2b00      	cmp	r3, #0
3400d672:	d016      	beq.n	3400d6a2 <HAL_RCCEx_PeriphCLKConfig+0x3942>
3400d674:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d678:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400d67a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400d67e:	d010      	beq.n	3400d6a2 <HAL_RCCEx_PeriphCLKConfig+0x3942>
3400d680:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d684:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400d686:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d68a:	d00a      	beq.n	3400d6a2 <HAL_RCCEx_PeriphCLKConfig+0x3942>
3400d68c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d690:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400d692:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d696:	d004      	beq.n	3400d6a2 <HAL_RCCEx_PeriphCLKConfig+0x3942>
3400d698:	f44f 619e 	mov.w	r1, #1264	@ 0x4f0
3400d69c:	481b      	ldr	r0, [pc, #108]	@ (3400d70c <HAL_RCCEx_PeriphCLKConfig+0x39ac>)
3400d69e:	f7f4 fcb7 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400d6a2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d6a6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400d6a8:	2b00      	cmp	r3, #0
3400d6aa:	d005      	beq.n	3400d6b8 <HAL_RCCEx_PeriphCLKConfig+0x3958>
3400d6ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d6b0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400d6b2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400d6b6:	d904      	bls.n	3400d6c2 <HAL_RCCEx_PeriphCLKConfig+0x3962>
3400d6b8:	f240 41f1 	movw	r1, #1265	@ 0x4f1
3400d6bc:	4813      	ldr	r0, [pc, #76]	@ (3400d70c <HAL_RCCEx_PeriphCLKConfig+0x39ac>)
3400d6be:	f7f4 fca7 	bl	34002010 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400d6c2:	4b13      	ldr	r3, [pc, #76]	@ (3400d710 <HAL_RCCEx_PeriphCLKConfig+0x39b0>)
3400d6c4:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400d6c8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400d6cc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400d6d0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d6d4:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400d6d6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d6da:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400d6dc:	3b01      	subs	r3, #1
3400d6de:	041b      	lsls	r3, r3, #16
3400d6e0:	4313      	orrs	r3, r2
3400d6e2:	4a0b      	ldr	r2, [pc, #44]	@ (3400d710 <HAL_RCCEx_PeriphCLKConfig+0x39b0>)
3400d6e4:	430b      	orrs	r3, r1
3400d6e6:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400d6ea:	f7fc f857 	bl	3400979c <LL_RCC_IC9_Enable>
3400d6ee:	e064      	b.n	3400d7ba <HAL_RCCEx_PeriphCLKConfig+0x3a5a>
3400d6f0:	0701142c 	.word	0x0701142c
3400d6f4:	0700182c 	.word	0x0700182c
3400d6f8:	0701182c 	.word	0x0701182c
3400d6fc:	0702182c 	.word	0x0702182c
3400d700:	0703182c 	.word	0x0703182c
3400d704:	0704182c 	.word	0x0704182c
3400d708:	0705182c 	.word	0x0705182c
3400d70c:	3401ee60 	.word	0x3401ee60
3400d710:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC14)
3400d714:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d718:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3400d71c:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3400d720:	d142      	bne.n	3400d7a8 <HAL_RCCEx_PeriphCLKConfig+0x3a48>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d722:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d726:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400d728:	2b00      	cmp	r3, #0
3400d72a:	d016      	beq.n	3400d75a <HAL_RCCEx_PeriphCLKConfig+0x39fa>
3400d72c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d730:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400d732:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400d736:	d010      	beq.n	3400d75a <HAL_RCCEx_PeriphCLKConfig+0x39fa>
3400d738:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d73c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400d73e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d742:	d00a      	beq.n	3400d75a <HAL_RCCEx_PeriphCLKConfig+0x39fa>
3400d744:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d748:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400d74a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d74e:	d004      	beq.n	3400d75a <HAL_RCCEx_PeriphCLKConfig+0x39fa>
3400d750:	f240 41fd 	movw	r1, #1277	@ 0x4fd
3400d754:	48b2      	ldr	r0, [pc, #712]	@ (3400da20 <HAL_RCCEx_PeriphCLKConfig+0x3cc0>)
3400d756:	f7f4 fc5b 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d75a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d75e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400d760:	2b00      	cmp	r3, #0
3400d762:	d005      	beq.n	3400d770 <HAL_RCCEx_PeriphCLKConfig+0x3a10>
3400d764:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d768:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400d76a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400d76e:	d904      	bls.n	3400d77a <HAL_RCCEx_PeriphCLKConfig+0x3a1a>
3400d770:	f240 41fe 	movw	r1, #1278	@ 0x4fe
3400d774:	48aa      	ldr	r0, [pc, #680]	@ (3400da20 <HAL_RCCEx_PeriphCLKConfig+0x3cc0>)
3400d776:	f7f4 fc4b 	bl	34002010 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d77a:	4baa      	ldr	r3, [pc, #680]	@ (3400da24 <HAL_RCCEx_PeriphCLKConfig+0x3cc4>)
3400d77c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400d780:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400d784:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400d788:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d78c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400d78e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d792:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400d794:	3b01      	subs	r3, #1
3400d796:	041b      	lsls	r3, r3, #16
3400d798:	4313      	orrs	r3, r2
3400d79a:	4aa2      	ldr	r2, [pc, #648]	@ (3400da24 <HAL_RCCEx_PeriphCLKConfig+0x3cc4>)
3400d79c:	430b      	orrs	r3, r1
3400d79e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400d7a2:	f7fc f8fb 	bl	3400999c <LL_RCC_IC14_Enable>
3400d7a6:	e008      	b.n	3400d7ba <HAL_RCCEx_PeriphCLKConfig+0x3a5a>
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_CLKP)
3400d7a8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d7ac:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3400d7b0:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400d7b4:	d101      	bne.n	3400d7ba <HAL_RCCEx_PeriphCLKConfig+0x3a5a>
    {
      LL_RCC_CLKP_Enable();
3400d7b6:	f7fc fab1 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPUART1 clock */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
3400d7ba:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d7be:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3400d7c2:	4618      	mov	r0, r3
3400d7c4:	f7fb f9a8 	bl	34008b18 <LL_RCC_SetLPUARTClockSource>
  }

  /*-------------------------- LTDC Configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
3400d7c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d7cc:	e9d3 2300 	ldrd	r2, r3, [r3]
3400d7d0:	f002 7380 	and.w	r3, r2, #16777216	@ 0x1000000
3400d7d4:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
3400d7d8:	2300      	movs	r3, #0
3400d7da:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
3400d7de:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	@ 0xd0
3400d7e2:	4603      	mov	r3, r0
3400d7e4:	460a      	mov	r2, r1
3400d7e6:	4313      	orrs	r3, r2
3400d7e8:	f000 8082 	beq.w	3400d8f0 <HAL_RCCEx_PeriphCLKConfig+0x3b90>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LTDCCLKSOURCE(PeriphClkInit->LtdcClockSelection));
3400d7ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d7f0:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
3400d7f4:	2b00      	cmp	r3, #0
3400d7f6:	d019      	beq.n	3400d82c <HAL_RCCEx_PeriphCLKConfig+0x3acc>
3400d7f8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d7fc:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
3400d800:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
3400d804:	d012      	beq.n	3400d82c <HAL_RCCEx_PeriphCLKConfig+0x3acc>
3400d806:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d80a:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
3400d80e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3400d812:	d00b      	beq.n	3400d82c <HAL_RCCEx_PeriphCLKConfig+0x3acc>
3400d814:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d818:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
3400d81c:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
3400d820:	d004      	beq.n	3400d82c <HAL_RCCEx_PeriphCLKConfig+0x3acc>
3400d822:	f44f 61a3 	mov.w	r1, #1304	@ 0x518
3400d826:	487e      	ldr	r0, [pc, #504]	@ (3400da20 <HAL_RCCEx_PeriphCLKConfig+0x3cc0>)
3400d828:	f7f4 fbf2 	bl	34002010 <assert_failed>

    if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_IC16)
3400d82c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d830:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
3400d834:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3400d838:	d14a      	bne.n	3400d8d0 <HAL_RCCEx_PeriphCLKConfig+0x3b70>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC16].ClockSelection));
3400d83a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d83e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400d842:	2b00      	cmp	r3, #0
3400d844:	d019      	beq.n	3400d87a <HAL_RCCEx_PeriphCLKConfig+0x3b1a>
3400d846:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d84a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400d84e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400d852:	d012      	beq.n	3400d87a <HAL_RCCEx_PeriphCLKConfig+0x3b1a>
3400d854:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d858:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400d85c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d860:	d00b      	beq.n	3400d87a <HAL_RCCEx_PeriphCLKConfig+0x3b1a>
3400d862:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d866:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400d86a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d86e:	d004      	beq.n	3400d87a <HAL_RCCEx_PeriphCLKConfig+0x3b1a>
3400d870:	f240 511d 	movw	r1, #1309	@ 0x51d
3400d874:	486a      	ldr	r0, [pc, #424]	@ (3400da20 <HAL_RCCEx_PeriphCLKConfig+0x3cc0>)
3400d876:	f7f4 fbcb 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC16].ClockDivider));
3400d87a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d87e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3400d882:	2b00      	cmp	r3, #0
3400d884:	d006      	beq.n	3400d894 <HAL_RCCEx_PeriphCLKConfig+0x3b34>
3400d886:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d88a:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3400d88e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400d892:	d904      	bls.n	3400d89e <HAL_RCCEx_PeriphCLKConfig+0x3b3e>
3400d894:	f240 511e 	movw	r1, #1310	@ 0x51e
3400d898:	4861      	ldr	r0, [pc, #388]	@ (3400da20 <HAL_RCCEx_PeriphCLKConfig+0x3cc0>)
3400d89a:	f7f4 fbb9 	bl	34002010 <assert_failed>

      /* Set IC16 configuration */
      MODIFY_REG(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL | RCC_IC16CFGR_IC16INT,
3400d89e:	4b61      	ldr	r3, [pc, #388]	@ (3400da24 <HAL_RCCEx_PeriphCLKConfig+0x3cc4>)
3400d8a0:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3400d8a4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400d8a8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400d8ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d8b0:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
3400d8b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d8b8:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3400d8bc:	3b01      	subs	r3, #1
3400d8be:	041b      	lsls	r3, r3, #16
3400d8c0:	4313      	orrs	r3, r2
3400d8c2:	4a58      	ldr	r2, [pc, #352]	@ (3400da24 <HAL_RCCEx_PeriphCLKConfig+0x3cc4>)
3400d8c4:	430b      	orrs	r3, r1
3400d8c6:	f8c2 3100 	str.w	r3, [r2, #256]	@ 0x100
                 PeriphClkInit->ICSelection[RCC_IC16].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC16].ClockDivider - 1U) << RCC_IC16CFGR_IC16INT_Pos));

      LL_RCC_IC16_Enable();
3400d8ca:	f7fc f8e7 	bl	34009a9c <LL_RCC_IC16_Enable>
3400d8ce:	e008      	b.n	3400d8e2 <HAL_RCCEx_PeriphCLKConfig+0x3b82>
    }
    else if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_CLKP)
3400d8d0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d8d4:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
3400d8d8:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
3400d8dc:	d101      	bne.n	3400d8e2 <HAL_RCCEx_PeriphCLKConfig+0x3b82>
    {
      LL_RCC_CLKP_Enable();
3400d8de:	f7fc fa1d 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LTDC clock */
    __HAL_RCC_LTDC_CONFIG(PeriphClkInit->LtdcClockSelection);
3400d8e2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d8e6:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
3400d8ea:	4618      	mov	r0, r3
3400d8ec:	f7fb f92a 	bl	34008b44 <LL_RCC_SetLTDCClockSource>
  }

  /*---------------------------- MDF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
3400d8f0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d8f4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400d8f8:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
3400d8fc:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
3400d900:	2300      	movs	r3, #0
3400d902:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
3400d906:	e9d7 0132 	ldrd	r0, r1, [r7, #200]	@ 0xc8
3400d90a:	4603      	mov	r3, r0
3400d90c:	460a      	mov	r2, r1
3400d90e:	4313      	orrs	r3, r2
3400d910:	f000 80e4 	beq.w	3400dadc <HAL_RCCEx_PeriphCLKConfig+0x3d7c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_MDF1CLKSOURCE(PeriphClkInit->Mdf1ClockSelection));
3400d914:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d918:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3400d91c:	2b00      	cmp	r3, #0
3400d91e:	d035      	beq.n	3400d98c <HAL_RCCEx_PeriphCLKConfig+0x3c2c>
3400d920:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d924:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3400d928:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3400d92c:	d02e      	beq.n	3400d98c <HAL_RCCEx_PeriphCLKConfig+0x3c2c>
3400d92e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d932:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3400d936:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400d93a:	d027      	beq.n	3400d98c <HAL_RCCEx_PeriphCLKConfig+0x3c2c>
3400d93c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d940:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3400d944:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400d948:	d020      	beq.n	3400d98c <HAL_RCCEx_PeriphCLKConfig+0x3c2c>
3400d94a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d94e:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3400d952:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400d956:	d019      	beq.n	3400d98c <HAL_RCCEx_PeriphCLKConfig+0x3c2c>
3400d958:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d95c:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3400d960:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
3400d964:	d012      	beq.n	3400d98c <HAL_RCCEx_PeriphCLKConfig+0x3c2c>
3400d966:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d96a:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3400d96e:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
3400d972:	d00b      	beq.n	3400d98c <HAL_RCCEx_PeriphCLKConfig+0x3c2c>
3400d974:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d978:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3400d97c:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
3400d980:	d004      	beq.n	3400d98c <HAL_RCCEx_PeriphCLKConfig+0x3c2c>
3400d982:	f44f 61a7 	mov.w	r1, #1336	@ 0x538
3400d986:	4826      	ldr	r0, [pc, #152]	@ (3400da20 <HAL_RCCEx_PeriphCLKConfig+0x3cc0>)
3400d988:	f7f4 fb42 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC7)
3400d98c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d990:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3400d994:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400d998:	d146      	bne.n	3400da28 <HAL_RCCEx_PeriphCLKConfig+0x3cc8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400d99a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d99e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400d9a0:	2b00      	cmp	r3, #0
3400d9a2:	d016      	beq.n	3400d9d2 <HAL_RCCEx_PeriphCLKConfig+0x3c72>
3400d9a4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d9a8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400d9aa:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400d9ae:	d010      	beq.n	3400d9d2 <HAL_RCCEx_PeriphCLKConfig+0x3c72>
3400d9b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d9b4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400d9b6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d9ba:	d00a      	beq.n	3400d9d2 <HAL_RCCEx_PeriphCLKConfig+0x3c72>
3400d9bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d9c0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400d9c2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d9c6:	d004      	beq.n	3400d9d2 <HAL_RCCEx_PeriphCLKConfig+0x3c72>
3400d9c8:	f240 513d 	movw	r1, #1341	@ 0x53d
3400d9cc:	4814      	ldr	r0, [pc, #80]	@ (3400da20 <HAL_RCCEx_PeriphCLKConfig+0x3cc0>)
3400d9ce:	f7f4 fb1f 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400d9d2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d9d6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400d9d8:	2b00      	cmp	r3, #0
3400d9da:	d005      	beq.n	3400d9e8 <HAL_RCCEx_PeriphCLKConfig+0x3c88>
3400d9dc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400d9e0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400d9e2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400d9e6:	d904      	bls.n	3400d9f2 <HAL_RCCEx_PeriphCLKConfig+0x3c92>
3400d9e8:	f240 513e 	movw	r1, #1342	@ 0x53e
3400d9ec:	480c      	ldr	r0, [pc, #48]	@ (3400da20 <HAL_RCCEx_PeriphCLKConfig+0x3cc0>)
3400d9ee:	f7f4 fb0f 	bl	34002010 <assert_failed>

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400d9f2:	4b0c      	ldr	r3, [pc, #48]	@ (3400da24 <HAL_RCCEx_PeriphCLKConfig+0x3cc4>)
3400d9f4:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400d9f8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400d9fc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400da00:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400da04:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3400da06:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400da0a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400da0c:	3b01      	subs	r3, #1
3400da0e:	041b      	lsls	r3, r3, #16
3400da10:	4313      	orrs	r3, r2
3400da12:	4a04      	ldr	r2, [pc, #16]	@ (3400da24 <HAL_RCCEx_PeriphCLKConfig+0x3cc4>)
3400da14:	430b      	orrs	r3, r1
3400da16:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
3400da1a:	f7fb fe3f 	bl	3400969c <LL_RCC_IC7_Enable>
3400da1e:	e056      	b.n	3400dace <HAL_RCCEx_PeriphCLKConfig+0x3d6e>
3400da20:	3401ee60 	.word	0x3401ee60
3400da24:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC8)
3400da28:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400da2c:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3400da30:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400da34:	d142      	bne.n	3400dabc <HAL_RCCEx_PeriphCLKConfig+0x3d5c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400da36:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400da3a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400da3c:	2b00      	cmp	r3, #0
3400da3e:	d016      	beq.n	3400da6e <HAL_RCCEx_PeriphCLKConfig+0x3d0e>
3400da40:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400da44:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400da46:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400da4a:	d010      	beq.n	3400da6e <HAL_RCCEx_PeriphCLKConfig+0x3d0e>
3400da4c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400da50:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400da52:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400da56:	d00a      	beq.n	3400da6e <HAL_RCCEx_PeriphCLKConfig+0x3d0e>
3400da58:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400da5c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400da5e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400da62:	d004      	beq.n	3400da6e <HAL_RCCEx_PeriphCLKConfig+0x3d0e>
3400da64:	f240 514a 	movw	r1, #1354	@ 0x54a
3400da68:	48b0      	ldr	r0, [pc, #704]	@ (3400dd2c <HAL_RCCEx_PeriphCLKConfig+0x3fcc>)
3400da6a:	f7f4 fad1 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400da6e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400da72:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400da74:	2b00      	cmp	r3, #0
3400da76:	d005      	beq.n	3400da84 <HAL_RCCEx_PeriphCLKConfig+0x3d24>
3400da78:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400da7c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400da7e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400da82:	d904      	bls.n	3400da8e <HAL_RCCEx_PeriphCLKConfig+0x3d2e>
3400da84:	f240 514b 	movw	r1, #1355	@ 0x54b
3400da88:	48a8      	ldr	r0, [pc, #672]	@ (3400dd2c <HAL_RCCEx_PeriphCLKConfig+0x3fcc>)
3400da8a:	f7f4 fac1 	bl	34002010 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400da8e:	4ba8      	ldr	r3, [pc, #672]	@ (3400dd30 <HAL_RCCEx_PeriphCLKConfig+0x3fd0>)
3400da90:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400da94:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400da98:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400da9c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400daa0:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3400daa2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400daa6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400daa8:	3b01      	subs	r3, #1
3400daaa:	041b      	lsls	r3, r3, #16
3400daac:	4313      	orrs	r3, r2
3400daae:	4aa0      	ldr	r2, [pc, #640]	@ (3400dd30 <HAL_RCCEx_PeriphCLKConfig+0x3fd0>)
3400dab0:	430b      	orrs	r3, r1
3400dab2:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3400dab6:	f7fb fe31 	bl	3400971c <LL_RCC_IC8_Enable>
3400daba:	e008      	b.n	3400dace <HAL_RCCEx_PeriphCLKConfig+0x3d6e>
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_CLKP)
3400dabc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dac0:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3400dac4:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3400dac8:	d101      	bne.n	3400dace <HAL_RCCEx_PeriphCLKConfig+0x3d6e>
    {
      LL_RCC_CLKP_Enable();
3400daca:	f7fc f927 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of MDF1 clock*/
    __HAL_RCC_MDF1_CONFIG(PeriphClkInit->Mdf1ClockSelection);
3400dace:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dad2:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3400dad6:	4618      	mov	r0, r3
3400dad8:	f7fb f84a 	bl	34008b70 <LL_RCC_SetMDFClockSource>
  }

  /*---------------------------- PSSI configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PSSI) == RCC_PERIPHCLK_PSSI)
3400dadc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dae0:	e9d3 2300 	ldrd	r2, r3, [r3]
3400dae4:	f002 6380 	and.w	r3, r2, #67108864	@ 0x4000000
3400dae8:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
3400daec:	2300      	movs	r3, #0
3400daee:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
3400daf2:	e9d7 0130 	ldrd	r0, r1, [r7, #192]	@ 0xc0
3400daf6:	4603      	mov	r3, r0
3400daf8:	460a      	mov	r2, r1
3400dafa:	4313      	orrs	r3, r2
3400dafc:	d07c      	beq.n	3400dbf8 <HAL_RCCEx_PeriphCLKConfig+0x3e98>
  {
    /* Check the parameters */
    assert_param(IS_RCC_PSSICLKSOURCE(PeriphClkInit->PssiClockSelection));
3400dafe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400db02:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3400db06:	2b00      	cmp	r3, #0
3400db08:	d016      	beq.n	3400db38 <HAL_RCCEx_PeriphCLKConfig+0x3dd8>
3400db0a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400db0e:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3400db12:	2b10      	cmp	r3, #16
3400db14:	d010      	beq.n	3400db38 <HAL_RCCEx_PeriphCLKConfig+0x3dd8>
3400db16:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400db1a:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3400db1e:	2b20      	cmp	r3, #32
3400db20:	d00a      	beq.n	3400db38 <HAL_RCCEx_PeriphCLKConfig+0x3dd8>
3400db22:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400db26:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3400db2a:	2b30      	cmp	r3, #48	@ 0x30
3400db2c:	d004      	beq.n	3400db38 <HAL_RCCEx_PeriphCLKConfig+0x3dd8>
3400db2e:	f240 5165 	movw	r1, #1381	@ 0x565
3400db32:	487e      	ldr	r0, [pc, #504]	@ (3400dd2c <HAL_RCCEx_PeriphCLKConfig+0x3fcc>)
3400db34:	f7f4 fa6c 	bl	34002010 <assert_failed>

    if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_IC20)
3400db38:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400db3c:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3400db40:	2b20      	cmp	r3, #32
3400db42:	d14a      	bne.n	3400dbda <HAL_RCCEx_PeriphCLKConfig+0x3e7a>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
3400db44:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400db48:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400db4c:	2b00      	cmp	r3, #0
3400db4e:	d019      	beq.n	3400db84 <HAL_RCCEx_PeriphCLKConfig+0x3e24>
3400db50:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400db54:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400db58:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400db5c:	d012      	beq.n	3400db84 <HAL_RCCEx_PeriphCLKConfig+0x3e24>
3400db5e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400db62:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400db66:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400db6a:	d00b      	beq.n	3400db84 <HAL_RCCEx_PeriphCLKConfig+0x3e24>
3400db6c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400db70:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400db74:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400db78:	d004      	beq.n	3400db84 <HAL_RCCEx_PeriphCLKConfig+0x3e24>
3400db7a:	f240 516a 	movw	r1, #1386	@ 0x56a
3400db7e:	486b      	ldr	r0, [pc, #428]	@ (3400dd2c <HAL_RCCEx_PeriphCLKConfig+0x3fcc>)
3400db80:	f7f4 fa46 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));
3400db84:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400db88:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3400db8c:	2b00      	cmp	r3, #0
3400db8e:	d006      	beq.n	3400db9e <HAL_RCCEx_PeriphCLKConfig+0x3e3e>
3400db90:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400db94:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3400db98:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400db9c:	d904      	bls.n	3400dba8 <HAL_RCCEx_PeriphCLKConfig+0x3e48>
3400db9e:	f240 516b 	movw	r1, #1387	@ 0x56b
3400dba2:	4862      	ldr	r0, [pc, #392]	@ (3400dd2c <HAL_RCCEx_PeriphCLKConfig+0x3fcc>)
3400dba4:	f7f4 fa34 	bl	34002010 <assert_failed>

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
3400dba8:	4b61      	ldr	r3, [pc, #388]	@ (3400dd30 <HAL_RCCEx_PeriphCLKConfig+0x3fd0>)
3400dbaa:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3400dbae:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400dbb2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400dbb6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dbba:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
3400dbbe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dbc2:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3400dbc6:	3b01      	subs	r3, #1
3400dbc8:	041b      	lsls	r3, r3, #16
3400dbca:	4313      	orrs	r3, r2
3400dbcc:	4a58      	ldr	r2, [pc, #352]	@ (3400dd30 <HAL_RCCEx_PeriphCLKConfig+0x3fd0>)
3400dbce:	430b      	orrs	r3, r1
3400dbd0:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
3400dbd4:	f7fc f862 	bl	34009c9c <LL_RCC_IC20_Enable>
3400dbd8:	e007      	b.n	3400dbea <HAL_RCCEx_PeriphCLKConfig+0x3e8a>
    }
    else if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_CLKP)
3400dbda:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dbde:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3400dbe2:	2b10      	cmp	r3, #16
3400dbe4:	d101      	bne.n	3400dbea <HAL_RCCEx_PeriphCLKConfig+0x3e8a>
    {
      LL_RCC_CLKP_Enable();
3400dbe6:	f7fc f899 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of PSSI clock*/
    __HAL_RCC_PSSI_CONFIG(PeriphClkInit->PssiClockSelection);
3400dbea:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dbee:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3400dbf2:	4618      	mov	r0, r3
3400dbf4:	f7fa ffe8 	bl	34008bc8 <LL_RCC_SetPSSIClockSource>
  }

  /*---------------------------- SAI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
3400dbf8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dbfc:	e9d3 2300 	ldrd	r2, r3, [r3]
3400dc00:	f002 5380 	and.w	r3, r2, #268435456	@ 0x10000000
3400dc04:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
3400dc08:	2300      	movs	r3, #0
3400dc0a:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
3400dc0e:	e9d7 012e 	ldrd	r0, r1, [r7, #184]	@ 0xb8
3400dc12:	4603      	mov	r3, r0
3400dc14:	460a      	mov	r2, r1
3400dc16:	4313      	orrs	r3, r2
3400dc18:	f000 80f6 	beq.w	3400de08 <HAL_RCCEx_PeriphCLKConfig+0x40a8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));
3400dc1c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dc20:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
3400dc24:	4b43      	ldr	r3, [pc, #268]	@ (3400dd34 <HAL_RCCEx_PeriphCLKConfig+0x3fd4>)
3400dc26:	429a      	cmp	r2, r3
3400dc28:	d035      	beq.n	3400dc96 <HAL_RCCEx_PeriphCLKConfig+0x3f36>
3400dc2a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dc2e:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
3400dc32:	4b41      	ldr	r3, [pc, #260]	@ (3400dd38 <HAL_RCCEx_PeriphCLKConfig+0x3fd8>)
3400dc34:	429a      	cmp	r2, r3
3400dc36:	d02e      	beq.n	3400dc96 <HAL_RCCEx_PeriphCLKConfig+0x3f36>
3400dc38:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dc3c:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
3400dc40:	4b3e      	ldr	r3, [pc, #248]	@ (3400dd3c <HAL_RCCEx_PeriphCLKConfig+0x3fdc>)
3400dc42:	429a      	cmp	r2, r3
3400dc44:	d027      	beq.n	3400dc96 <HAL_RCCEx_PeriphCLKConfig+0x3f36>
3400dc46:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dc4a:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
3400dc4e:	4b3c      	ldr	r3, [pc, #240]	@ (3400dd40 <HAL_RCCEx_PeriphCLKConfig+0x3fe0>)
3400dc50:	429a      	cmp	r2, r3
3400dc52:	d020      	beq.n	3400dc96 <HAL_RCCEx_PeriphCLKConfig+0x3f36>
3400dc54:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dc58:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
3400dc5c:	4b39      	ldr	r3, [pc, #228]	@ (3400dd44 <HAL_RCCEx_PeriphCLKConfig+0x3fe4>)
3400dc5e:	429a      	cmp	r2, r3
3400dc60:	d019      	beq.n	3400dc96 <HAL_RCCEx_PeriphCLKConfig+0x3f36>
3400dc62:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dc66:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
3400dc6a:	4b37      	ldr	r3, [pc, #220]	@ (3400dd48 <HAL_RCCEx_PeriphCLKConfig+0x3fe8>)
3400dc6c:	429a      	cmp	r2, r3
3400dc6e:	d012      	beq.n	3400dc96 <HAL_RCCEx_PeriphCLKConfig+0x3f36>
3400dc70:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dc74:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
3400dc78:	4b34      	ldr	r3, [pc, #208]	@ (3400dd4c <HAL_RCCEx_PeriphCLKConfig+0x3fec>)
3400dc7a:	429a      	cmp	r2, r3
3400dc7c:	d00b      	beq.n	3400dc96 <HAL_RCCEx_PeriphCLKConfig+0x3f36>
3400dc7e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dc82:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
3400dc86:	4b32      	ldr	r3, [pc, #200]	@ (3400dd50 <HAL_RCCEx_PeriphCLKConfig+0x3ff0>)
3400dc88:	429a      	cmp	r2, r3
3400dc8a:	d004      	beq.n	3400dc96 <HAL_RCCEx_PeriphCLKConfig+0x3f36>
3400dc8c:	f240 5185 	movw	r1, #1413	@ 0x585
3400dc90:	4826      	ldr	r0, [pc, #152]	@ (3400dd2c <HAL_RCCEx_PeriphCLKConfig+0x3fcc>)
3400dc92:	f7f4 f9bd 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC7)
3400dc96:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dc9a:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
3400dc9e:	4b27      	ldr	r3, [pc, #156]	@ (3400dd3c <HAL_RCCEx_PeriphCLKConfig+0x3fdc>)
3400dca0:	429a      	cmp	r2, r3
3400dca2:	d157      	bne.n	3400dd54 <HAL_RCCEx_PeriphCLKConfig+0x3ff4>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400dca4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dca8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400dcaa:	2b00      	cmp	r3, #0
3400dcac:	d016      	beq.n	3400dcdc <HAL_RCCEx_PeriphCLKConfig+0x3f7c>
3400dcae:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dcb2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400dcb4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400dcb8:	d010      	beq.n	3400dcdc <HAL_RCCEx_PeriphCLKConfig+0x3f7c>
3400dcba:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dcbe:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400dcc0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400dcc4:	d00a      	beq.n	3400dcdc <HAL_RCCEx_PeriphCLKConfig+0x3f7c>
3400dcc6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dcca:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400dccc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400dcd0:	d004      	beq.n	3400dcdc <HAL_RCCEx_PeriphCLKConfig+0x3f7c>
3400dcd2:	f240 518a 	movw	r1, #1418	@ 0x58a
3400dcd6:	4815      	ldr	r0, [pc, #84]	@ (3400dd2c <HAL_RCCEx_PeriphCLKConfig+0x3fcc>)
3400dcd8:	f7f4 f99a 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400dcdc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dce0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400dce2:	2b00      	cmp	r3, #0
3400dce4:	d005      	beq.n	3400dcf2 <HAL_RCCEx_PeriphCLKConfig+0x3f92>
3400dce6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dcea:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400dcec:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400dcf0:	d904      	bls.n	3400dcfc <HAL_RCCEx_PeriphCLKConfig+0x3f9c>
3400dcf2:	f240 518b 	movw	r1, #1419	@ 0x58b
3400dcf6:	480d      	ldr	r0, [pc, #52]	@ (3400dd2c <HAL_RCCEx_PeriphCLKConfig+0x3fcc>)
3400dcf8:	f7f4 f98a 	bl	34002010 <assert_failed>

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400dcfc:	4b0c      	ldr	r3, [pc, #48]	@ (3400dd30 <HAL_RCCEx_PeriphCLKConfig+0x3fd0>)
3400dcfe:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400dd02:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400dd06:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400dd0a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dd0e:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3400dd10:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dd14:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400dd16:	3b01      	subs	r3, #1
3400dd18:	041b      	lsls	r3, r3, #16
3400dd1a:	4313      	orrs	r3, r2
3400dd1c:	4a04      	ldr	r2, [pc, #16]	@ (3400dd30 <HAL_RCCEx_PeriphCLKConfig+0x3fd0>)
3400dd1e:	430b      	orrs	r3, r1
3400dd20:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
3400dd24:	f7fb fcba 	bl	3400969c <LL_RCC_IC7_Enable>
3400dd28:	e067      	b.n	3400ddfa <HAL_RCCEx_PeriphCLKConfig+0x409a>
3400dd2a:	bf00      	nop
3400dd2c:	3401ee60 	.word	0x3401ee60
3400dd30:	56028000 	.word	0x56028000
3400dd34:	07001418 	.word	0x07001418
3400dd38:	07011418 	.word	0x07011418
3400dd3c:	07021418 	.word	0x07021418
3400dd40:	07031418 	.word	0x07031418
3400dd44:	07041418 	.word	0x07041418
3400dd48:	07051418 	.word	0x07051418
3400dd4c:	07061418 	.word	0x07061418
3400dd50:	07071418 	.word	0x07071418
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC8)
3400dd54:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dd58:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
3400dd5c:	4b9c      	ldr	r3, [pc, #624]	@ (3400dfd0 <HAL_RCCEx_PeriphCLKConfig+0x4270>)
3400dd5e:	429a      	cmp	r2, r3
3400dd60:	d142      	bne.n	3400dde8 <HAL_RCCEx_PeriphCLKConfig+0x4088>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400dd62:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dd66:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400dd68:	2b00      	cmp	r3, #0
3400dd6a:	d016      	beq.n	3400dd9a <HAL_RCCEx_PeriphCLKConfig+0x403a>
3400dd6c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dd70:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400dd72:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400dd76:	d010      	beq.n	3400dd9a <HAL_RCCEx_PeriphCLKConfig+0x403a>
3400dd78:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dd7c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400dd7e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400dd82:	d00a      	beq.n	3400dd9a <HAL_RCCEx_PeriphCLKConfig+0x403a>
3400dd84:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dd88:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400dd8a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400dd8e:	d004      	beq.n	3400dd9a <HAL_RCCEx_PeriphCLKConfig+0x403a>
3400dd90:	f240 5197 	movw	r1, #1431	@ 0x597
3400dd94:	488f      	ldr	r0, [pc, #572]	@ (3400dfd4 <HAL_RCCEx_PeriphCLKConfig+0x4274>)
3400dd96:	f7f4 f93b 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400dd9a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dd9e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400dda0:	2b00      	cmp	r3, #0
3400dda2:	d005      	beq.n	3400ddb0 <HAL_RCCEx_PeriphCLKConfig+0x4050>
3400dda4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dda8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400ddaa:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400ddae:	d904      	bls.n	3400ddba <HAL_RCCEx_PeriphCLKConfig+0x405a>
3400ddb0:	f44f 61b3 	mov.w	r1, #1432	@ 0x598
3400ddb4:	4887      	ldr	r0, [pc, #540]	@ (3400dfd4 <HAL_RCCEx_PeriphCLKConfig+0x4274>)
3400ddb6:	f7f4 f92b 	bl	34002010 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400ddba:	4b87      	ldr	r3, [pc, #540]	@ (3400dfd8 <HAL_RCCEx_PeriphCLKConfig+0x4278>)
3400ddbc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400ddc0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400ddc4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400ddc8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ddcc:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3400ddce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ddd2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400ddd4:	3b01      	subs	r3, #1
3400ddd6:	041b      	lsls	r3, r3, #16
3400ddd8:	4313      	orrs	r3, r2
3400ddda:	4a7f      	ldr	r2, [pc, #508]	@ (3400dfd8 <HAL_RCCEx_PeriphCLKConfig+0x4278>)
3400dddc:	430b      	orrs	r3, r1
3400ddde:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3400dde2:	f7fb fc9b 	bl	3400971c <LL_RCC_IC8_Enable>
3400dde6:	e008      	b.n	3400ddfa <HAL_RCCEx_PeriphCLKConfig+0x409a>
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_CLKP)
3400dde8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ddec:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
3400ddf0:	4b7a      	ldr	r3, [pc, #488]	@ (3400dfdc <HAL_RCCEx_PeriphCLKConfig+0x427c>)
3400ddf2:	429a      	cmp	r2, r3
3400ddf4:	d101      	bne.n	3400ddfa <HAL_RCCEx_PeriphCLKConfig+0x409a>
    {
      LL_RCC_CLKP_Enable();
3400ddf6:	f7fb ff91 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI1 clock*/
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
3400ddfa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ddfe:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
3400de02:	4618      	mov	r0, r3
3400de04:	f7fa fef6 	bl	34008bf4 <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SAI2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
3400de08:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400de0c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400de10:	f002 5300 	and.w	r3, r2, #536870912	@ 0x20000000
3400de14:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
3400de18:	2300      	movs	r3, #0
3400de1a:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
3400de1e:	e9d7 012c 	ldrd	r0, r1, [r7, #176]	@ 0xb0
3400de22:	4603      	mov	r3, r0
3400de24:	460a      	mov	r2, r1
3400de26:	4313      	orrs	r3, r2
3400de28:	f000 80fa 	beq.w	3400e020 <HAL_RCCEx_PeriphCLKConfig+0x42c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));
3400de2c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400de30:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
3400de34:	4b6a      	ldr	r3, [pc, #424]	@ (3400dfe0 <HAL_RCCEx_PeriphCLKConfig+0x4280>)
3400de36:	429a      	cmp	r2, r3
3400de38:	d035      	beq.n	3400dea6 <HAL_RCCEx_PeriphCLKConfig+0x4146>
3400de3a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400de3e:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
3400de42:	4b68      	ldr	r3, [pc, #416]	@ (3400dfe4 <HAL_RCCEx_PeriphCLKConfig+0x4284>)
3400de44:	429a      	cmp	r2, r3
3400de46:	d02e      	beq.n	3400dea6 <HAL_RCCEx_PeriphCLKConfig+0x4146>
3400de48:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400de4c:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
3400de50:	4b65      	ldr	r3, [pc, #404]	@ (3400dfe8 <HAL_RCCEx_PeriphCLKConfig+0x4288>)
3400de52:	429a      	cmp	r2, r3
3400de54:	d027      	beq.n	3400dea6 <HAL_RCCEx_PeriphCLKConfig+0x4146>
3400de56:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400de5a:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
3400de5e:	4b63      	ldr	r3, [pc, #396]	@ (3400dfec <HAL_RCCEx_PeriphCLKConfig+0x428c>)
3400de60:	429a      	cmp	r2, r3
3400de62:	d020      	beq.n	3400dea6 <HAL_RCCEx_PeriphCLKConfig+0x4146>
3400de64:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400de68:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
3400de6c:	4b60      	ldr	r3, [pc, #384]	@ (3400dff0 <HAL_RCCEx_PeriphCLKConfig+0x4290>)
3400de6e:	429a      	cmp	r2, r3
3400de70:	d019      	beq.n	3400dea6 <HAL_RCCEx_PeriphCLKConfig+0x4146>
3400de72:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400de76:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
3400de7a:	4b5e      	ldr	r3, [pc, #376]	@ (3400dff4 <HAL_RCCEx_PeriphCLKConfig+0x4294>)
3400de7c:	429a      	cmp	r2, r3
3400de7e:	d012      	beq.n	3400dea6 <HAL_RCCEx_PeriphCLKConfig+0x4146>
3400de80:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400de84:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
3400de88:	4b5b      	ldr	r3, [pc, #364]	@ (3400dff8 <HAL_RCCEx_PeriphCLKConfig+0x4298>)
3400de8a:	429a      	cmp	r2, r3
3400de8c:	d00b      	beq.n	3400dea6 <HAL_RCCEx_PeriphCLKConfig+0x4146>
3400de8e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400de92:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
3400de96:	4b59      	ldr	r3, [pc, #356]	@ (3400dffc <HAL_RCCEx_PeriphCLKConfig+0x429c>)
3400de98:	429a      	cmp	r2, r3
3400de9a:	d004      	beq.n	3400dea6 <HAL_RCCEx_PeriphCLKConfig+0x4146>
3400de9c:	f240 51b2 	movw	r1, #1458	@ 0x5b2
3400dea0:	484c      	ldr	r0, [pc, #304]	@ (3400dfd4 <HAL_RCCEx_PeriphCLKConfig+0x4274>)
3400dea2:	f7f4 f8b5 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC7)
3400dea6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400deaa:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
3400deae:	4b4e      	ldr	r3, [pc, #312]	@ (3400dfe8 <HAL_RCCEx_PeriphCLKConfig+0x4288>)
3400deb0:	429a      	cmp	r2, r3
3400deb2:	d142      	bne.n	3400df3a <HAL_RCCEx_PeriphCLKConfig+0x41da>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400deb4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400deb8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400deba:	2b00      	cmp	r3, #0
3400debc:	d016      	beq.n	3400deec <HAL_RCCEx_PeriphCLKConfig+0x418c>
3400debe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dec2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400dec4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400dec8:	d010      	beq.n	3400deec <HAL_RCCEx_PeriphCLKConfig+0x418c>
3400deca:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dece:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400ded0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ded4:	d00a      	beq.n	3400deec <HAL_RCCEx_PeriphCLKConfig+0x418c>
3400ded6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400deda:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400dedc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400dee0:	d004      	beq.n	3400deec <HAL_RCCEx_PeriphCLKConfig+0x418c>
3400dee2:	f240 51b7 	movw	r1, #1463	@ 0x5b7
3400dee6:	483b      	ldr	r0, [pc, #236]	@ (3400dfd4 <HAL_RCCEx_PeriphCLKConfig+0x4274>)
3400dee8:	f7f4 f892 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400deec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400def0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400def2:	2b00      	cmp	r3, #0
3400def4:	d005      	beq.n	3400df02 <HAL_RCCEx_PeriphCLKConfig+0x41a2>
3400def6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400defa:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400defc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400df00:	d904      	bls.n	3400df0c <HAL_RCCEx_PeriphCLKConfig+0x41ac>
3400df02:	f44f 61b7 	mov.w	r1, #1464	@ 0x5b8
3400df06:	4833      	ldr	r0, [pc, #204]	@ (3400dfd4 <HAL_RCCEx_PeriphCLKConfig+0x4274>)
3400df08:	f7f4 f882 	bl	34002010 <assert_failed>

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400df0c:	4b32      	ldr	r3, [pc, #200]	@ (3400dfd8 <HAL_RCCEx_PeriphCLKConfig+0x4278>)
3400df0e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400df12:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400df16:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400df1a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400df1e:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3400df20:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400df24:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400df26:	3b01      	subs	r3, #1
3400df28:	041b      	lsls	r3, r3, #16
3400df2a:	4313      	orrs	r3, r2
3400df2c:	4a2a      	ldr	r2, [pc, #168]	@ (3400dfd8 <HAL_RCCEx_PeriphCLKConfig+0x4278>)
3400df2e:	430b      	orrs	r3, r1
3400df30:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
3400df34:	f7fb fbb2 	bl	3400969c <LL_RCC_IC7_Enable>
3400df38:	e06b      	b.n	3400e012 <HAL_RCCEx_PeriphCLKConfig+0x42b2>
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC8)
3400df3a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400df3e:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
3400df42:	4b2a      	ldr	r3, [pc, #168]	@ (3400dfec <HAL_RCCEx_PeriphCLKConfig+0x428c>)
3400df44:	429a      	cmp	r2, r3
3400df46:	d15b      	bne.n	3400e000 <HAL_RCCEx_PeriphCLKConfig+0x42a0>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400df48:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400df4c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400df4e:	2b00      	cmp	r3, #0
3400df50:	d016      	beq.n	3400df80 <HAL_RCCEx_PeriphCLKConfig+0x4220>
3400df52:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400df56:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400df58:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400df5c:	d010      	beq.n	3400df80 <HAL_RCCEx_PeriphCLKConfig+0x4220>
3400df5e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400df62:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400df64:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400df68:	d00a      	beq.n	3400df80 <HAL_RCCEx_PeriphCLKConfig+0x4220>
3400df6a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400df6e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400df70:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400df74:	d004      	beq.n	3400df80 <HAL_RCCEx_PeriphCLKConfig+0x4220>
3400df76:	f240 51c4 	movw	r1, #1476	@ 0x5c4
3400df7a:	4816      	ldr	r0, [pc, #88]	@ (3400dfd4 <HAL_RCCEx_PeriphCLKConfig+0x4274>)
3400df7c:	f7f4 f848 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400df80:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400df84:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400df86:	2b00      	cmp	r3, #0
3400df88:	d005      	beq.n	3400df96 <HAL_RCCEx_PeriphCLKConfig+0x4236>
3400df8a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400df8e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400df90:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400df94:	d904      	bls.n	3400dfa0 <HAL_RCCEx_PeriphCLKConfig+0x4240>
3400df96:	f240 51c5 	movw	r1, #1477	@ 0x5c5
3400df9a:	480e      	ldr	r0, [pc, #56]	@ (3400dfd4 <HAL_RCCEx_PeriphCLKConfig+0x4274>)
3400df9c:	f7f4 f838 	bl	34002010 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400dfa0:	4b0d      	ldr	r3, [pc, #52]	@ (3400dfd8 <HAL_RCCEx_PeriphCLKConfig+0x4278>)
3400dfa2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400dfa6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400dfaa:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400dfae:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dfb2:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3400dfb4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400dfb8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400dfba:	3b01      	subs	r3, #1
3400dfbc:	041b      	lsls	r3, r3, #16
3400dfbe:	4313      	orrs	r3, r2
3400dfc0:	4a05      	ldr	r2, [pc, #20]	@ (3400dfd8 <HAL_RCCEx_PeriphCLKConfig+0x4278>)
3400dfc2:	430b      	orrs	r3, r1
3400dfc4:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3400dfc8:	f7fb fba8 	bl	3400971c <LL_RCC_IC8_Enable>
3400dfcc:	e021      	b.n	3400e012 <HAL_RCCEx_PeriphCLKConfig+0x42b2>
3400dfce:	bf00      	nop
3400dfd0:	07031418 	.word	0x07031418
3400dfd4:	3401ee60 	.word	0x3401ee60
3400dfd8:	56028000 	.word	0x56028000
3400dfdc:	07011418 	.word	0x07011418
3400dfe0:	07001818 	.word	0x07001818
3400dfe4:	07011818 	.word	0x07011818
3400dfe8:	07021818 	.word	0x07021818
3400dfec:	07031818 	.word	0x07031818
3400dff0:	07041818 	.word	0x07041818
3400dff4:	07051818 	.word	0x07051818
3400dff8:	07061818 	.word	0x07061818
3400dffc:	07071818 	.word	0x07071818
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_CLKP)
3400e000:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e004:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
3400e008:	4b6f      	ldr	r3, [pc, #444]	@ (3400e1c8 <HAL_RCCEx_PeriphCLKConfig+0x4468>)
3400e00a:	429a      	cmp	r2, r3
3400e00c:	d101      	bne.n	3400e012 <HAL_RCCEx_PeriphCLKConfig+0x42b2>
    {
      LL_RCC_CLKP_Enable();
3400e00e:	f7fb fe85 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI2 clock*/
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
3400e012:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e016:	f8d3 3128 	ldr.w	r3, [r3, #296]	@ 0x128
3400e01a:	4618      	mov	r0, r3
3400e01c:	f7fa fdea 	bl	34008bf4 <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SPDIFRX1 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPDIFRX1) == RCC_PERIPHCLK_SPDIFRX1)
3400e020:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e024:	e9d3 2300 	ldrd	r2, r3, [r3]
3400e028:	2100      	movs	r1, #0
3400e02a:	f8c7 10a8 	str.w	r1, [r7, #168]	@ 0xa8
3400e02e:	f003 0301 	and.w	r3, r3, #1
3400e032:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
3400e036:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	@ 0xa8
3400e03a:	4603      	mov	r3, r0
3400e03c:	460a      	mov	r2, r1
3400e03e:	4313      	orrs	r3, r2
3400e040:	f000 80d7 	beq.w	3400e1f2 <HAL_RCCEx_PeriphCLKConfig+0x4492>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPDIFRX1CLKSOURCE(PeriphClkInit->Spdifrx1ClockSelection));
3400e044:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e048:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400e04c:	2b00      	cmp	r3, #0
3400e04e:	d028      	beq.n	3400e0a2 <HAL_RCCEx_PeriphCLKConfig+0x4342>
3400e050:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e054:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400e058:	2b01      	cmp	r3, #1
3400e05a:	d022      	beq.n	3400e0a2 <HAL_RCCEx_PeriphCLKConfig+0x4342>
3400e05c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e060:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400e064:	2b02      	cmp	r3, #2
3400e066:	d01c      	beq.n	3400e0a2 <HAL_RCCEx_PeriphCLKConfig+0x4342>
3400e068:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e06c:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400e070:	2b03      	cmp	r3, #3
3400e072:	d016      	beq.n	3400e0a2 <HAL_RCCEx_PeriphCLKConfig+0x4342>
3400e074:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e078:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400e07c:	2b04      	cmp	r3, #4
3400e07e:	d010      	beq.n	3400e0a2 <HAL_RCCEx_PeriphCLKConfig+0x4342>
3400e080:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e084:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400e088:	2b05      	cmp	r3, #5
3400e08a:	d00a      	beq.n	3400e0a2 <HAL_RCCEx_PeriphCLKConfig+0x4342>
3400e08c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e090:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400e094:	2b06      	cmp	r3, #6
3400e096:	d004      	beq.n	3400e0a2 <HAL_RCCEx_PeriphCLKConfig+0x4342>
3400e098:	f240 51df 	movw	r1, #1503	@ 0x5df
3400e09c:	484b      	ldr	r0, [pc, #300]	@ (3400e1cc <HAL_RCCEx_PeriphCLKConfig+0x446c>)
3400e09e:	f7f3 ffb7 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC7)
3400e0a2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e0a6:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400e0aa:	2b02      	cmp	r3, #2
3400e0ac:	d142      	bne.n	3400e134 <HAL_RCCEx_PeriphCLKConfig+0x43d4>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400e0ae:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e0b2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400e0b4:	2b00      	cmp	r3, #0
3400e0b6:	d016      	beq.n	3400e0e6 <HAL_RCCEx_PeriphCLKConfig+0x4386>
3400e0b8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e0bc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400e0be:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e0c2:	d010      	beq.n	3400e0e6 <HAL_RCCEx_PeriphCLKConfig+0x4386>
3400e0c4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e0c8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400e0ca:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e0ce:	d00a      	beq.n	3400e0e6 <HAL_RCCEx_PeriphCLKConfig+0x4386>
3400e0d0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e0d4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400e0d6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e0da:	d004      	beq.n	3400e0e6 <HAL_RCCEx_PeriphCLKConfig+0x4386>
3400e0dc:	f240 51e4 	movw	r1, #1508	@ 0x5e4
3400e0e0:	483a      	ldr	r0, [pc, #232]	@ (3400e1cc <HAL_RCCEx_PeriphCLKConfig+0x446c>)
3400e0e2:	f7f3 ff95 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400e0e6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e0ea:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400e0ec:	2b00      	cmp	r3, #0
3400e0ee:	d005      	beq.n	3400e0fc <HAL_RCCEx_PeriphCLKConfig+0x439c>
3400e0f0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e0f4:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400e0f6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400e0fa:	d904      	bls.n	3400e106 <HAL_RCCEx_PeriphCLKConfig+0x43a6>
3400e0fc:	f240 51e5 	movw	r1, #1509	@ 0x5e5
3400e100:	4832      	ldr	r0, [pc, #200]	@ (3400e1cc <HAL_RCCEx_PeriphCLKConfig+0x446c>)
3400e102:	f7f3 ff85 	bl	34002010 <assert_failed>

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400e106:	4b32      	ldr	r3, [pc, #200]	@ (3400e1d0 <HAL_RCCEx_PeriphCLKConfig+0x4470>)
3400e108:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400e10c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400e110:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400e114:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e118:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3400e11a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e11e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400e120:	3b01      	subs	r3, #1
3400e122:	041b      	lsls	r3, r3, #16
3400e124:	4313      	orrs	r3, r2
3400e126:	4a2a      	ldr	r2, [pc, #168]	@ (3400e1d0 <HAL_RCCEx_PeriphCLKConfig+0x4470>)
3400e128:	430b      	orrs	r3, r1
3400e12a:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
3400e12e:	f7fb fab5 	bl	3400969c <LL_RCC_IC7_Enable>
3400e132:	e057      	b.n	3400e1e4 <HAL_RCCEx_PeriphCLKConfig+0x4484>
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC8)
3400e134:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e138:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400e13c:	2b03      	cmp	r3, #3
3400e13e:	d149      	bne.n	3400e1d4 <HAL_RCCEx_PeriphCLKConfig+0x4474>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400e140:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e144:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e146:	2b00      	cmp	r3, #0
3400e148:	d016      	beq.n	3400e178 <HAL_RCCEx_PeriphCLKConfig+0x4418>
3400e14a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e14e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e150:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e154:	d010      	beq.n	3400e178 <HAL_RCCEx_PeriphCLKConfig+0x4418>
3400e156:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e15a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e15c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e160:	d00a      	beq.n	3400e178 <HAL_RCCEx_PeriphCLKConfig+0x4418>
3400e162:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e166:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e168:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e16c:	d004      	beq.n	3400e178 <HAL_RCCEx_PeriphCLKConfig+0x4418>
3400e16e:	f240 51f1 	movw	r1, #1521	@ 0x5f1
3400e172:	4816      	ldr	r0, [pc, #88]	@ (3400e1cc <HAL_RCCEx_PeriphCLKConfig+0x446c>)
3400e174:	f7f3 ff4c 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400e178:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e17c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400e17e:	2b00      	cmp	r3, #0
3400e180:	d005      	beq.n	3400e18e <HAL_RCCEx_PeriphCLKConfig+0x442e>
3400e182:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e186:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400e188:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400e18c:	d904      	bls.n	3400e198 <HAL_RCCEx_PeriphCLKConfig+0x4438>
3400e18e:	f240 51f2 	movw	r1, #1522	@ 0x5f2
3400e192:	480e      	ldr	r0, [pc, #56]	@ (3400e1cc <HAL_RCCEx_PeriphCLKConfig+0x446c>)
3400e194:	f7f3 ff3c 	bl	34002010 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400e198:	4b0d      	ldr	r3, [pc, #52]	@ (3400e1d0 <HAL_RCCEx_PeriphCLKConfig+0x4470>)
3400e19a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400e19e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400e1a2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400e1a6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e1aa:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3400e1ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e1b0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400e1b2:	3b01      	subs	r3, #1
3400e1b4:	041b      	lsls	r3, r3, #16
3400e1b6:	4313      	orrs	r3, r2
3400e1b8:	4a05      	ldr	r2, [pc, #20]	@ (3400e1d0 <HAL_RCCEx_PeriphCLKConfig+0x4470>)
3400e1ba:	430b      	orrs	r3, r1
3400e1bc:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3400e1c0:	f7fb faac 	bl	3400971c <LL_RCC_IC8_Enable>
3400e1c4:	e00e      	b.n	3400e1e4 <HAL_RCCEx_PeriphCLKConfig+0x4484>
3400e1c6:	bf00      	nop
3400e1c8:	07011818 	.word	0x07011818
3400e1cc:	3401ee60 	.word	0x3401ee60
3400e1d0:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_CLKP)
3400e1d4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e1d8:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400e1dc:	2b01      	cmp	r3, #1
3400e1de:	d101      	bne.n	3400e1e4 <HAL_RCCEx_PeriphCLKConfig+0x4484>
    {
      LL_RCC_CLKP_Enable();
3400e1e0:	f7fb fd9c 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPDIFRX1 clock */
    __HAL_RCC_SPDIFRX1_CONFIG(PeriphClkInit->Spdifrx1ClockSelection);
3400e1e4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e1e8:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400e1ec:	4618      	mov	r0, r3
3400e1ee:	f7fa fd17 	bl	34008c20 <LL_RCC_SetSPDIFRXClockSource>
  }

  /*---------------------------- SPI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
3400e1f2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e1f6:	e9d3 2300 	ldrd	r2, r3, [r3]
3400e1fa:	2100      	movs	r1, #0
3400e1fc:	f8c7 10a0 	str.w	r1, [r7, #160]	@ 0xa0
3400e200:	f003 0302 	and.w	r3, r3, #2
3400e204:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
3400e208:	e9d7 0128 	ldrd	r0, r1, [r7, #160]	@ 0xa0
3400e20c:	4603      	mov	r3, r0
3400e20e:	460a      	mov	r2, r1
3400e210:	4313      	orrs	r3, r2
3400e212:	f000 80da 	beq.w	3400e3ca <HAL_RCCEx_PeriphCLKConfig+0x466a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI1CLKSOURCE(PeriphClkInit->Spi1ClockSelection));
3400e216:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e21a:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
3400e21e:	4bb4      	ldr	r3, [pc, #720]	@ (3400e4f0 <HAL_RCCEx_PeriphCLKConfig+0x4790>)
3400e220:	429a      	cmp	r2, r3
3400e222:	d02e      	beq.n	3400e282 <HAL_RCCEx_PeriphCLKConfig+0x4522>
3400e224:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e228:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
3400e22c:	4bb1      	ldr	r3, [pc, #708]	@ (3400e4f4 <HAL_RCCEx_PeriphCLKConfig+0x4794>)
3400e22e:	429a      	cmp	r2, r3
3400e230:	d027      	beq.n	3400e282 <HAL_RCCEx_PeriphCLKConfig+0x4522>
3400e232:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e236:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
3400e23a:	4baf      	ldr	r3, [pc, #700]	@ (3400e4f8 <HAL_RCCEx_PeriphCLKConfig+0x4798>)
3400e23c:	429a      	cmp	r2, r3
3400e23e:	d020      	beq.n	3400e282 <HAL_RCCEx_PeriphCLKConfig+0x4522>
3400e240:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e244:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
3400e248:	4bac      	ldr	r3, [pc, #688]	@ (3400e4fc <HAL_RCCEx_PeriphCLKConfig+0x479c>)
3400e24a:	429a      	cmp	r2, r3
3400e24c:	d019      	beq.n	3400e282 <HAL_RCCEx_PeriphCLKConfig+0x4522>
3400e24e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e252:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
3400e256:	4baa      	ldr	r3, [pc, #680]	@ (3400e500 <HAL_RCCEx_PeriphCLKConfig+0x47a0>)
3400e258:	429a      	cmp	r2, r3
3400e25a:	d012      	beq.n	3400e282 <HAL_RCCEx_PeriphCLKConfig+0x4522>
3400e25c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e260:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
3400e264:	4ba7      	ldr	r3, [pc, #668]	@ (3400e504 <HAL_RCCEx_PeriphCLKConfig+0x47a4>)
3400e266:	429a      	cmp	r2, r3
3400e268:	d00b      	beq.n	3400e282 <HAL_RCCEx_PeriphCLKConfig+0x4522>
3400e26a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e26e:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
3400e272:	4ba5      	ldr	r3, [pc, #660]	@ (3400e508 <HAL_RCCEx_PeriphCLKConfig+0x47a8>)
3400e274:	429a      	cmp	r2, r3
3400e276:	d004      	beq.n	3400e282 <HAL_RCCEx_PeriphCLKConfig+0x4522>
3400e278:	f240 610c 	movw	r1, #1548	@ 0x60c
3400e27c:	48a3      	ldr	r0, [pc, #652]	@ (3400e50c <HAL_RCCEx_PeriphCLKConfig+0x47ac>)
3400e27e:	f7f3 fec7 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC8)
3400e282:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e286:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
3400e28a:	4b9b      	ldr	r3, [pc, #620]	@ (3400e4f8 <HAL_RCCEx_PeriphCLKConfig+0x4798>)
3400e28c:	429a      	cmp	r2, r3
3400e28e:	d142      	bne.n	3400e316 <HAL_RCCEx_PeriphCLKConfig+0x45b6>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400e290:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e294:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e296:	2b00      	cmp	r3, #0
3400e298:	d016      	beq.n	3400e2c8 <HAL_RCCEx_PeriphCLKConfig+0x4568>
3400e29a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e29e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e2a0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e2a4:	d010      	beq.n	3400e2c8 <HAL_RCCEx_PeriphCLKConfig+0x4568>
3400e2a6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e2aa:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e2ac:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e2b0:	d00a      	beq.n	3400e2c8 <HAL_RCCEx_PeriphCLKConfig+0x4568>
3400e2b2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e2b6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e2b8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e2bc:	d004      	beq.n	3400e2c8 <HAL_RCCEx_PeriphCLKConfig+0x4568>
3400e2be:	f240 6111 	movw	r1, #1553	@ 0x611
3400e2c2:	4892      	ldr	r0, [pc, #584]	@ (3400e50c <HAL_RCCEx_PeriphCLKConfig+0x47ac>)
3400e2c4:	f7f3 fea4 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400e2c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e2cc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400e2ce:	2b00      	cmp	r3, #0
3400e2d0:	d005      	beq.n	3400e2de <HAL_RCCEx_PeriphCLKConfig+0x457e>
3400e2d2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e2d6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400e2d8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400e2dc:	d904      	bls.n	3400e2e8 <HAL_RCCEx_PeriphCLKConfig+0x4588>
3400e2de:	f240 6112 	movw	r1, #1554	@ 0x612
3400e2e2:	488a      	ldr	r0, [pc, #552]	@ (3400e50c <HAL_RCCEx_PeriphCLKConfig+0x47ac>)
3400e2e4:	f7f3 fe94 	bl	34002010 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400e2e8:	4b89      	ldr	r3, [pc, #548]	@ (3400e510 <HAL_RCCEx_PeriphCLKConfig+0x47b0>)
3400e2ea:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400e2ee:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400e2f2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400e2f6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e2fa:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3400e2fc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e300:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400e302:	3b01      	subs	r3, #1
3400e304:	041b      	lsls	r3, r3, #16
3400e306:	4313      	orrs	r3, r2
3400e308:	4a81      	ldr	r2, [pc, #516]	@ (3400e510 <HAL_RCCEx_PeriphCLKConfig+0x47b0>)
3400e30a:	430b      	orrs	r3, r1
3400e30c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3400e310:	f7fb fa04 	bl	3400971c <LL_RCC_IC8_Enable>
3400e314:	e052      	b.n	3400e3bc <HAL_RCCEx_PeriphCLKConfig+0x465c>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC9)
3400e316:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e31a:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
3400e31e:	4b77      	ldr	r3, [pc, #476]	@ (3400e4fc <HAL_RCCEx_PeriphCLKConfig+0x479c>)
3400e320:	429a      	cmp	r2, r3
3400e322:	d142      	bne.n	3400e3aa <HAL_RCCEx_PeriphCLKConfig+0x464a>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400e324:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e328:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e32a:	2b00      	cmp	r3, #0
3400e32c:	d016      	beq.n	3400e35c <HAL_RCCEx_PeriphCLKConfig+0x45fc>
3400e32e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e332:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e334:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e338:	d010      	beq.n	3400e35c <HAL_RCCEx_PeriphCLKConfig+0x45fc>
3400e33a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e33e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e340:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e344:	d00a      	beq.n	3400e35c <HAL_RCCEx_PeriphCLKConfig+0x45fc>
3400e346:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e34a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e34c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e350:	d004      	beq.n	3400e35c <HAL_RCCEx_PeriphCLKConfig+0x45fc>
3400e352:	f240 611e 	movw	r1, #1566	@ 0x61e
3400e356:	486d      	ldr	r0, [pc, #436]	@ (3400e50c <HAL_RCCEx_PeriphCLKConfig+0x47ac>)
3400e358:	f7f3 fe5a 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400e35c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e360:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400e362:	2b00      	cmp	r3, #0
3400e364:	d005      	beq.n	3400e372 <HAL_RCCEx_PeriphCLKConfig+0x4612>
3400e366:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e36a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400e36c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400e370:	d904      	bls.n	3400e37c <HAL_RCCEx_PeriphCLKConfig+0x461c>
3400e372:	f240 611f 	movw	r1, #1567	@ 0x61f
3400e376:	4865      	ldr	r0, [pc, #404]	@ (3400e50c <HAL_RCCEx_PeriphCLKConfig+0x47ac>)
3400e378:	f7f3 fe4a 	bl	34002010 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400e37c:	4b64      	ldr	r3, [pc, #400]	@ (3400e510 <HAL_RCCEx_PeriphCLKConfig+0x47b0>)
3400e37e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400e382:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400e386:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400e38a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e38e:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400e390:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e394:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400e396:	3b01      	subs	r3, #1
3400e398:	041b      	lsls	r3, r3, #16
3400e39a:	4313      	orrs	r3, r2
3400e39c:	4a5c      	ldr	r2, [pc, #368]	@ (3400e510 <HAL_RCCEx_PeriphCLKConfig+0x47b0>)
3400e39e:	430b      	orrs	r3, r1
3400e3a0:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400e3a4:	f7fb f9fa 	bl	3400979c <LL_RCC_IC9_Enable>
3400e3a8:	e008      	b.n	3400e3bc <HAL_RCCEx_PeriphCLKConfig+0x465c>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_CLKP)
3400e3aa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e3ae:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
3400e3b2:	4b50      	ldr	r3, [pc, #320]	@ (3400e4f4 <HAL_RCCEx_PeriphCLKConfig+0x4794>)
3400e3b4:	429a      	cmp	r2, r3
3400e3b6:	d101      	bne.n	3400e3bc <HAL_RCCEx_PeriphCLKConfig+0x465c>
    {
      LL_RCC_CLKP_Enable();
3400e3b8:	f7fb fcb0 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI1 clock*/
    __HAL_RCC_SPI1_CONFIG(PeriphClkInit->Spi1ClockSelection);
3400e3bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e3c0:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
3400e3c4:	4618      	mov	r0, r3
3400e3c6:	f7fa fc41 	bl	34008c4c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI2 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
3400e3ca:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e3ce:	e9d3 2300 	ldrd	r2, r3, [r3]
3400e3d2:	2100      	movs	r1, #0
3400e3d4:	f8c7 1098 	str.w	r1, [r7, #152]	@ 0x98
3400e3d8:	f003 0304 	and.w	r3, r3, #4
3400e3dc:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
3400e3e0:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	@ 0x98
3400e3e4:	4603      	mov	r3, r0
3400e3e6:	460a      	mov	r2, r1
3400e3e8:	4313      	orrs	r3, r2
3400e3ea:	f000 80fb 	beq.w	3400e5e4 <HAL_RCCEx_PeriphCLKConfig+0x4884>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI2CLKSOURCE(PeriphClkInit->Spi2ClockSelection));
3400e3ee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e3f2:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
3400e3f6:	4b47      	ldr	r3, [pc, #284]	@ (3400e514 <HAL_RCCEx_PeriphCLKConfig+0x47b4>)
3400e3f8:	429a      	cmp	r2, r3
3400e3fa:	d02e      	beq.n	3400e45a <HAL_RCCEx_PeriphCLKConfig+0x46fa>
3400e3fc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e400:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
3400e404:	4b44      	ldr	r3, [pc, #272]	@ (3400e518 <HAL_RCCEx_PeriphCLKConfig+0x47b8>)
3400e406:	429a      	cmp	r2, r3
3400e408:	d027      	beq.n	3400e45a <HAL_RCCEx_PeriphCLKConfig+0x46fa>
3400e40a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e40e:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
3400e412:	4b42      	ldr	r3, [pc, #264]	@ (3400e51c <HAL_RCCEx_PeriphCLKConfig+0x47bc>)
3400e414:	429a      	cmp	r2, r3
3400e416:	d020      	beq.n	3400e45a <HAL_RCCEx_PeriphCLKConfig+0x46fa>
3400e418:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e41c:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
3400e420:	4b3f      	ldr	r3, [pc, #252]	@ (3400e520 <HAL_RCCEx_PeriphCLKConfig+0x47c0>)
3400e422:	429a      	cmp	r2, r3
3400e424:	d019      	beq.n	3400e45a <HAL_RCCEx_PeriphCLKConfig+0x46fa>
3400e426:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e42a:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
3400e42e:	4b3d      	ldr	r3, [pc, #244]	@ (3400e524 <HAL_RCCEx_PeriphCLKConfig+0x47c4>)
3400e430:	429a      	cmp	r2, r3
3400e432:	d012      	beq.n	3400e45a <HAL_RCCEx_PeriphCLKConfig+0x46fa>
3400e434:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e438:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
3400e43c:	4b3a      	ldr	r3, [pc, #232]	@ (3400e528 <HAL_RCCEx_PeriphCLKConfig+0x47c8>)
3400e43e:	429a      	cmp	r2, r3
3400e440:	d00b      	beq.n	3400e45a <HAL_RCCEx_PeriphCLKConfig+0x46fa>
3400e442:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e446:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
3400e44a:	4b38      	ldr	r3, [pc, #224]	@ (3400e52c <HAL_RCCEx_PeriphCLKConfig+0x47cc>)
3400e44c:	429a      	cmp	r2, r3
3400e44e:	d004      	beq.n	3400e45a <HAL_RCCEx_PeriphCLKConfig+0x46fa>
3400e450:	f240 6139 	movw	r1, #1593	@ 0x639
3400e454:	482d      	ldr	r0, [pc, #180]	@ (3400e50c <HAL_RCCEx_PeriphCLKConfig+0x47ac>)
3400e456:	f7f3 fddb 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC8)
3400e45a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e45e:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
3400e462:	4b2e      	ldr	r3, [pc, #184]	@ (3400e51c <HAL_RCCEx_PeriphCLKConfig+0x47bc>)
3400e464:	429a      	cmp	r2, r3
3400e466:	d163      	bne.n	3400e530 <HAL_RCCEx_PeriphCLKConfig+0x47d0>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400e468:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e46c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e46e:	2b00      	cmp	r3, #0
3400e470:	d016      	beq.n	3400e4a0 <HAL_RCCEx_PeriphCLKConfig+0x4740>
3400e472:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e476:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e478:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e47c:	d010      	beq.n	3400e4a0 <HAL_RCCEx_PeriphCLKConfig+0x4740>
3400e47e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e482:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e484:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e488:	d00a      	beq.n	3400e4a0 <HAL_RCCEx_PeriphCLKConfig+0x4740>
3400e48a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e48e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e490:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e494:	d004      	beq.n	3400e4a0 <HAL_RCCEx_PeriphCLKConfig+0x4740>
3400e496:	f240 613e 	movw	r1, #1598	@ 0x63e
3400e49a:	481c      	ldr	r0, [pc, #112]	@ (3400e50c <HAL_RCCEx_PeriphCLKConfig+0x47ac>)
3400e49c:	f7f3 fdb8 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400e4a0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e4a4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400e4a6:	2b00      	cmp	r3, #0
3400e4a8:	d005      	beq.n	3400e4b6 <HAL_RCCEx_PeriphCLKConfig+0x4756>
3400e4aa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e4ae:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400e4b0:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400e4b4:	d904      	bls.n	3400e4c0 <HAL_RCCEx_PeriphCLKConfig+0x4760>
3400e4b6:	f240 613f 	movw	r1, #1599	@ 0x63f
3400e4ba:	4814      	ldr	r0, [pc, #80]	@ (3400e50c <HAL_RCCEx_PeriphCLKConfig+0x47ac>)
3400e4bc:	f7f3 fda8 	bl	34002010 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400e4c0:	4b13      	ldr	r3, [pc, #76]	@ (3400e510 <HAL_RCCEx_PeriphCLKConfig+0x47b0>)
3400e4c2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400e4c6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400e4ca:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400e4ce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e4d2:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3400e4d4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e4d8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400e4da:	3b01      	subs	r3, #1
3400e4dc:	041b      	lsls	r3, r3, #16
3400e4de:	4313      	orrs	r3, r2
3400e4e0:	4a0b      	ldr	r2, [pc, #44]	@ (3400e510 <HAL_RCCEx_PeriphCLKConfig+0x47b0>)
3400e4e2:	430b      	orrs	r3, r1
3400e4e4:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3400e4e8:	f7fb f918 	bl	3400971c <LL_RCC_IC8_Enable>
3400e4ec:	e073      	b.n	3400e5d6 <HAL_RCCEx_PeriphCLKConfig+0x4876>
3400e4ee:	bf00      	nop
3400e4f0:	07000420 	.word	0x07000420
3400e4f4:	07010420 	.word	0x07010420
3400e4f8:	07020420 	.word	0x07020420
3400e4fc:	07030420 	.word	0x07030420
3400e500:	07040420 	.word	0x07040420
3400e504:	07050420 	.word	0x07050420
3400e508:	07060420 	.word	0x07060420
3400e50c:	3401ee60 	.word	0x3401ee60
3400e510:	56028000 	.word	0x56028000
3400e514:	07000820 	.word	0x07000820
3400e518:	07010820 	.word	0x07010820
3400e51c:	07020820 	.word	0x07020820
3400e520:	07030820 	.word	0x07030820
3400e524:	07040820 	.word	0x07040820
3400e528:	07050820 	.word	0x07050820
3400e52c:	07060820 	.word	0x07060820
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC9)
3400e530:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e534:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
3400e538:	4b98      	ldr	r3, [pc, #608]	@ (3400e79c <HAL_RCCEx_PeriphCLKConfig+0x4a3c>)
3400e53a:	429a      	cmp	r2, r3
3400e53c:	d142      	bne.n	3400e5c4 <HAL_RCCEx_PeriphCLKConfig+0x4864>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400e53e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e542:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e544:	2b00      	cmp	r3, #0
3400e546:	d016      	beq.n	3400e576 <HAL_RCCEx_PeriphCLKConfig+0x4816>
3400e548:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e54c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e54e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e552:	d010      	beq.n	3400e576 <HAL_RCCEx_PeriphCLKConfig+0x4816>
3400e554:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e558:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e55a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e55e:	d00a      	beq.n	3400e576 <HAL_RCCEx_PeriphCLKConfig+0x4816>
3400e560:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e564:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e566:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e56a:	d004      	beq.n	3400e576 <HAL_RCCEx_PeriphCLKConfig+0x4816>
3400e56c:	f240 614b 	movw	r1, #1611	@ 0x64b
3400e570:	488b      	ldr	r0, [pc, #556]	@ (3400e7a0 <HAL_RCCEx_PeriphCLKConfig+0x4a40>)
3400e572:	f7f3 fd4d 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400e576:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e57a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400e57c:	2b00      	cmp	r3, #0
3400e57e:	d005      	beq.n	3400e58c <HAL_RCCEx_PeriphCLKConfig+0x482c>
3400e580:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e584:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400e586:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400e58a:	d904      	bls.n	3400e596 <HAL_RCCEx_PeriphCLKConfig+0x4836>
3400e58c:	f240 614c 	movw	r1, #1612	@ 0x64c
3400e590:	4883      	ldr	r0, [pc, #524]	@ (3400e7a0 <HAL_RCCEx_PeriphCLKConfig+0x4a40>)
3400e592:	f7f3 fd3d 	bl	34002010 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400e596:	4b83      	ldr	r3, [pc, #524]	@ (3400e7a4 <HAL_RCCEx_PeriphCLKConfig+0x4a44>)
3400e598:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400e59c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400e5a0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400e5a4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e5a8:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400e5aa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e5ae:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400e5b0:	3b01      	subs	r3, #1
3400e5b2:	041b      	lsls	r3, r3, #16
3400e5b4:	4313      	orrs	r3, r2
3400e5b6:	4a7b      	ldr	r2, [pc, #492]	@ (3400e7a4 <HAL_RCCEx_PeriphCLKConfig+0x4a44>)
3400e5b8:	430b      	orrs	r3, r1
3400e5ba:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400e5be:	f7fb f8ed 	bl	3400979c <LL_RCC_IC9_Enable>
3400e5c2:	e008      	b.n	3400e5d6 <HAL_RCCEx_PeriphCLKConfig+0x4876>
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_CLKP)
3400e5c4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e5c8:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
3400e5cc:	4b76      	ldr	r3, [pc, #472]	@ (3400e7a8 <HAL_RCCEx_PeriphCLKConfig+0x4a48>)
3400e5ce:	429a      	cmp	r2, r3
3400e5d0:	d101      	bne.n	3400e5d6 <HAL_RCCEx_PeriphCLKConfig+0x4876>
    {
      LL_RCC_CLKP_Enable();
3400e5d2:	f7fb fba3 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI2 clock*/
    __HAL_RCC_SPI2_CONFIG(PeriphClkInit->Spi2ClockSelection);
3400e5d6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e5da:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
3400e5de:	4618      	mov	r0, r3
3400e5e0:	f7fa fb34 	bl	34008c4c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI3 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
3400e5e4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e5e8:	e9d3 2300 	ldrd	r2, r3, [r3]
3400e5ec:	2100      	movs	r1, #0
3400e5ee:	f8c7 1090 	str.w	r1, [r7, #144]	@ 0x90
3400e5f2:	f003 0308 	and.w	r3, r3, #8
3400e5f6:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
3400e5fa:	e9d7 0124 	ldrd	r0, r1, [r7, #144]	@ 0x90
3400e5fe:	4603      	mov	r3, r0
3400e600:	460a      	mov	r2, r1
3400e602:	4313      	orrs	r3, r2
3400e604:	f000 80f0 	beq.w	3400e7e8 <HAL_RCCEx_PeriphCLKConfig+0x4a88>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI3CLKSOURCE(PeriphClkInit->Spi3ClockSelection));
3400e608:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e60c:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3400e610:	4b66      	ldr	r3, [pc, #408]	@ (3400e7ac <HAL_RCCEx_PeriphCLKConfig+0x4a4c>)
3400e612:	429a      	cmp	r2, r3
3400e614:	d02e      	beq.n	3400e674 <HAL_RCCEx_PeriphCLKConfig+0x4914>
3400e616:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e61a:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3400e61e:	4b64      	ldr	r3, [pc, #400]	@ (3400e7b0 <HAL_RCCEx_PeriphCLKConfig+0x4a50>)
3400e620:	429a      	cmp	r2, r3
3400e622:	d027      	beq.n	3400e674 <HAL_RCCEx_PeriphCLKConfig+0x4914>
3400e624:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e628:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3400e62c:	4b61      	ldr	r3, [pc, #388]	@ (3400e7b4 <HAL_RCCEx_PeriphCLKConfig+0x4a54>)
3400e62e:	429a      	cmp	r2, r3
3400e630:	d020      	beq.n	3400e674 <HAL_RCCEx_PeriphCLKConfig+0x4914>
3400e632:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e636:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3400e63a:	4b5f      	ldr	r3, [pc, #380]	@ (3400e7b8 <HAL_RCCEx_PeriphCLKConfig+0x4a58>)
3400e63c:	429a      	cmp	r2, r3
3400e63e:	d019      	beq.n	3400e674 <HAL_RCCEx_PeriphCLKConfig+0x4914>
3400e640:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e644:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3400e648:	4b5c      	ldr	r3, [pc, #368]	@ (3400e7bc <HAL_RCCEx_PeriphCLKConfig+0x4a5c>)
3400e64a:	429a      	cmp	r2, r3
3400e64c:	d012      	beq.n	3400e674 <HAL_RCCEx_PeriphCLKConfig+0x4914>
3400e64e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e652:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3400e656:	4b5a      	ldr	r3, [pc, #360]	@ (3400e7c0 <HAL_RCCEx_PeriphCLKConfig+0x4a60>)
3400e658:	429a      	cmp	r2, r3
3400e65a:	d00b      	beq.n	3400e674 <HAL_RCCEx_PeriphCLKConfig+0x4914>
3400e65c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e660:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3400e664:	4b57      	ldr	r3, [pc, #348]	@ (3400e7c4 <HAL_RCCEx_PeriphCLKConfig+0x4a64>)
3400e666:	429a      	cmp	r2, r3
3400e668:	d004      	beq.n	3400e674 <HAL_RCCEx_PeriphCLKConfig+0x4914>
3400e66a:	f240 6166 	movw	r1, #1638	@ 0x666
3400e66e:	484c      	ldr	r0, [pc, #304]	@ (3400e7a0 <HAL_RCCEx_PeriphCLKConfig+0x4a40>)
3400e670:	f7f3 fcce 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC8)
3400e674:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e678:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3400e67c:	4b4d      	ldr	r3, [pc, #308]	@ (3400e7b4 <HAL_RCCEx_PeriphCLKConfig+0x4a54>)
3400e67e:	429a      	cmp	r2, r3
3400e680:	d142      	bne.n	3400e708 <HAL_RCCEx_PeriphCLKConfig+0x49a8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400e682:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e686:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e688:	2b00      	cmp	r3, #0
3400e68a:	d016      	beq.n	3400e6ba <HAL_RCCEx_PeriphCLKConfig+0x495a>
3400e68c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e690:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e692:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e696:	d010      	beq.n	3400e6ba <HAL_RCCEx_PeriphCLKConfig+0x495a>
3400e698:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e69c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e69e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e6a2:	d00a      	beq.n	3400e6ba <HAL_RCCEx_PeriphCLKConfig+0x495a>
3400e6a4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e6a8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e6aa:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e6ae:	d004      	beq.n	3400e6ba <HAL_RCCEx_PeriphCLKConfig+0x495a>
3400e6b0:	f240 616b 	movw	r1, #1643	@ 0x66b
3400e6b4:	483a      	ldr	r0, [pc, #232]	@ (3400e7a0 <HAL_RCCEx_PeriphCLKConfig+0x4a40>)
3400e6b6:	f7f3 fcab 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400e6ba:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e6be:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400e6c0:	2b00      	cmp	r3, #0
3400e6c2:	d005      	beq.n	3400e6d0 <HAL_RCCEx_PeriphCLKConfig+0x4970>
3400e6c4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e6c8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400e6ca:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400e6ce:	d904      	bls.n	3400e6da <HAL_RCCEx_PeriphCLKConfig+0x497a>
3400e6d0:	f240 616c 	movw	r1, #1644	@ 0x66c
3400e6d4:	4832      	ldr	r0, [pc, #200]	@ (3400e7a0 <HAL_RCCEx_PeriphCLKConfig+0x4a40>)
3400e6d6:	f7f3 fc9b 	bl	34002010 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400e6da:	4b32      	ldr	r3, [pc, #200]	@ (3400e7a4 <HAL_RCCEx_PeriphCLKConfig+0x4a44>)
3400e6dc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400e6e0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400e6e4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400e6e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e6ec:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3400e6ee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e6f2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400e6f4:	3b01      	subs	r3, #1
3400e6f6:	041b      	lsls	r3, r3, #16
3400e6f8:	4313      	orrs	r3, r2
3400e6fa:	4a2a      	ldr	r2, [pc, #168]	@ (3400e7a4 <HAL_RCCEx_PeriphCLKConfig+0x4a44>)
3400e6fc:	430b      	orrs	r3, r1
3400e6fe:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3400e702:	f7fb f80b 	bl	3400971c <LL_RCC_IC8_Enable>
3400e706:	e068      	b.n	3400e7da <HAL_RCCEx_PeriphCLKConfig+0x4a7a>
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC9)
3400e708:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e70c:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3400e710:	4b29      	ldr	r3, [pc, #164]	@ (3400e7b8 <HAL_RCCEx_PeriphCLKConfig+0x4a58>)
3400e712:	429a      	cmp	r2, r3
3400e714:	d158      	bne.n	3400e7c8 <HAL_RCCEx_PeriphCLKConfig+0x4a68>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400e716:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e71a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e71c:	2b00      	cmp	r3, #0
3400e71e:	d016      	beq.n	3400e74e <HAL_RCCEx_PeriphCLKConfig+0x49ee>
3400e720:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e724:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e726:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e72a:	d010      	beq.n	3400e74e <HAL_RCCEx_PeriphCLKConfig+0x49ee>
3400e72c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e730:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e732:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e736:	d00a      	beq.n	3400e74e <HAL_RCCEx_PeriphCLKConfig+0x49ee>
3400e738:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e73c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e73e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e742:	d004      	beq.n	3400e74e <HAL_RCCEx_PeriphCLKConfig+0x49ee>
3400e744:	f44f 61cf 	mov.w	r1, #1656	@ 0x678
3400e748:	4815      	ldr	r0, [pc, #84]	@ (3400e7a0 <HAL_RCCEx_PeriphCLKConfig+0x4a40>)
3400e74a:	f7f3 fc61 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400e74e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e752:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400e754:	2b00      	cmp	r3, #0
3400e756:	d005      	beq.n	3400e764 <HAL_RCCEx_PeriphCLKConfig+0x4a04>
3400e758:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e75c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400e75e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400e762:	d904      	bls.n	3400e76e <HAL_RCCEx_PeriphCLKConfig+0x4a0e>
3400e764:	f240 6179 	movw	r1, #1657	@ 0x679
3400e768:	480d      	ldr	r0, [pc, #52]	@ (3400e7a0 <HAL_RCCEx_PeriphCLKConfig+0x4a40>)
3400e76a:	f7f3 fc51 	bl	34002010 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400e76e:	4b0d      	ldr	r3, [pc, #52]	@ (3400e7a4 <HAL_RCCEx_PeriphCLKConfig+0x4a44>)
3400e770:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400e774:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400e778:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400e77c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e780:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400e782:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e786:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400e788:	3b01      	subs	r3, #1
3400e78a:	041b      	lsls	r3, r3, #16
3400e78c:	4313      	orrs	r3, r2
3400e78e:	4a05      	ldr	r2, [pc, #20]	@ (3400e7a4 <HAL_RCCEx_PeriphCLKConfig+0x4a44>)
3400e790:	430b      	orrs	r3, r1
3400e792:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400e796:	f7fb f801 	bl	3400979c <LL_RCC_IC9_Enable>
3400e79a:	e01e      	b.n	3400e7da <HAL_RCCEx_PeriphCLKConfig+0x4a7a>
3400e79c:	07030820 	.word	0x07030820
3400e7a0:	3401ee60 	.word	0x3401ee60
3400e7a4:	56028000 	.word	0x56028000
3400e7a8:	07010820 	.word	0x07010820
3400e7ac:	07000c20 	.word	0x07000c20
3400e7b0:	07010c20 	.word	0x07010c20
3400e7b4:	07020c20 	.word	0x07020c20
3400e7b8:	07030c20 	.word	0x07030c20
3400e7bc:	07040c20 	.word	0x07040c20
3400e7c0:	07050c20 	.word	0x07050c20
3400e7c4:	07060c20 	.word	0x07060c20
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_CLKP)
3400e7c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e7cc:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3400e7d0:	4b73      	ldr	r3, [pc, #460]	@ (3400e9a0 <HAL_RCCEx_PeriphCLKConfig+0x4c40>)
3400e7d2:	429a      	cmp	r2, r3
3400e7d4:	d101      	bne.n	3400e7da <HAL_RCCEx_PeriphCLKConfig+0x4a7a>
    {
      LL_RCC_CLKP_Enable();
3400e7d6:	f7fb faa1 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI3 clock*/
    __HAL_RCC_SPI3_CONFIG(PeriphClkInit->Spi3ClockSelection);
3400e7da:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e7de:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
3400e7e2:	4618      	mov	r0, r3
3400e7e4:	f7fa fa32 	bl	34008c4c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI4 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI4) == RCC_PERIPHCLK_SPI4)
3400e7e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e7ec:	e9d3 2300 	ldrd	r2, r3, [r3]
3400e7f0:	2100      	movs	r1, #0
3400e7f2:	f8c7 1088 	str.w	r1, [r7, #136]	@ 0x88
3400e7f6:	f003 0310 	and.w	r3, r3, #16
3400e7fa:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
3400e7fe:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	@ 0x88
3400e802:	4603      	mov	r3, r0
3400e804:	460a      	mov	r2, r1
3400e806:	4313      	orrs	r3, r2
3400e808:	f000 80ee 	beq.w	3400e9e8 <HAL_RCCEx_PeriphCLKConfig+0x4c88>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI4CLKSOURCE(PeriphClkInit->Spi4ClockSelection));
3400e80c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e810:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
3400e814:	4b63      	ldr	r3, [pc, #396]	@ (3400e9a4 <HAL_RCCEx_PeriphCLKConfig+0x4c44>)
3400e816:	429a      	cmp	r2, r3
3400e818:	d02e      	beq.n	3400e878 <HAL_RCCEx_PeriphCLKConfig+0x4b18>
3400e81a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e81e:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
3400e822:	4b61      	ldr	r3, [pc, #388]	@ (3400e9a8 <HAL_RCCEx_PeriphCLKConfig+0x4c48>)
3400e824:	429a      	cmp	r2, r3
3400e826:	d027      	beq.n	3400e878 <HAL_RCCEx_PeriphCLKConfig+0x4b18>
3400e828:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e82c:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
3400e830:	4b5e      	ldr	r3, [pc, #376]	@ (3400e9ac <HAL_RCCEx_PeriphCLKConfig+0x4c4c>)
3400e832:	429a      	cmp	r2, r3
3400e834:	d020      	beq.n	3400e878 <HAL_RCCEx_PeriphCLKConfig+0x4b18>
3400e836:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e83a:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
3400e83e:	4b5c      	ldr	r3, [pc, #368]	@ (3400e9b0 <HAL_RCCEx_PeriphCLKConfig+0x4c50>)
3400e840:	429a      	cmp	r2, r3
3400e842:	d019      	beq.n	3400e878 <HAL_RCCEx_PeriphCLKConfig+0x4b18>
3400e844:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e848:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
3400e84c:	4b59      	ldr	r3, [pc, #356]	@ (3400e9b4 <HAL_RCCEx_PeriphCLKConfig+0x4c54>)
3400e84e:	429a      	cmp	r2, r3
3400e850:	d012      	beq.n	3400e878 <HAL_RCCEx_PeriphCLKConfig+0x4b18>
3400e852:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e856:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
3400e85a:	4b57      	ldr	r3, [pc, #348]	@ (3400e9b8 <HAL_RCCEx_PeriphCLKConfig+0x4c58>)
3400e85c:	429a      	cmp	r2, r3
3400e85e:	d00b      	beq.n	3400e878 <HAL_RCCEx_PeriphCLKConfig+0x4b18>
3400e860:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e864:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
3400e868:	4b54      	ldr	r3, [pc, #336]	@ (3400e9bc <HAL_RCCEx_PeriphCLKConfig+0x4c5c>)
3400e86a:	429a      	cmp	r2, r3
3400e86c:	d004      	beq.n	3400e878 <HAL_RCCEx_PeriphCLKConfig+0x4b18>
3400e86e:	f240 6193 	movw	r1, #1683	@ 0x693
3400e872:	4853      	ldr	r0, [pc, #332]	@ (3400e9c0 <HAL_RCCEx_PeriphCLKConfig+0x4c60>)
3400e874:	f7f3 fbcc 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC9)
3400e878:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e87c:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
3400e880:	4b4a      	ldr	r3, [pc, #296]	@ (3400e9ac <HAL_RCCEx_PeriphCLKConfig+0x4c4c>)
3400e882:	429a      	cmp	r2, r3
3400e884:	d142      	bne.n	3400e90c <HAL_RCCEx_PeriphCLKConfig+0x4bac>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400e886:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e88a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e88c:	2b00      	cmp	r3, #0
3400e88e:	d016      	beq.n	3400e8be <HAL_RCCEx_PeriphCLKConfig+0x4b5e>
3400e890:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e894:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e896:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e89a:	d010      	beq.n	3400e8be <HAL_RCCEx_PeriphCLKConfig+0x4b5e>
3400e89c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e8a0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e8a2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e8a6:	d00a      	beq.n	3400e8be <HAL_RCCEx_PeriphCLKConfig+0x4b5e>
3400e8a8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e8ac:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e8ae:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e8b2:	d004      	beq.n	3400e8be <HAL_RCCEx_PeriphCLKConfig+0x4b5e>
3400e8b4:	f44f 61d3 	mov.w	r1, #1688	@ 0x698
3400e8b8:	4841      	ldr	r0, [pc, #260]	@ (3400e9c0 <HAL_RCCEx_PeriphCLKConfig+0x4c60>)
3400e8ba:	f7f3 fba9 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400e8be:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e8c2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400e8c4:	2b00      	cmp	r3, #0
3400e8c6:	d005      	beq.n	3400e8d4 <HAL_RCCEx_PeriphCLKConfig+0x4b74>
3400e8c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e8cc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400e8ce:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400e8d2:	d904      	bls.n	3400e8de <HAL_RCCEx_PeriphCLKConfig+0x4b7e>
3400e8d4:	f240 6199 	movw	r1, #1689	@ 0x699
3400e8d8:	4839      	ldr	r0, [pc, #228]	@ (3400e9c0 <HAL_RCCEx_PeriphCLKConfig+0x4c60>)
3400e8da:	f7f3 fb99 	bl	34002010 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400e8de:	4b39      	ldr	r3, [pc, #228]	@ (3400e9c4 <HAL_RCCEx_PeriphCLKConfig+0x4c64>)
3400e8e0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400e8e4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400e8e8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400e8ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e8f0:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400e8f2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e8f6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400e8f8:	3b01      	subs	r3, #1
3400e8fa:	041b      	lsls	r3, r3, #16
3400e8fc:	4313      	orrs	r3, r2
3400e8fe:	4a31      	ldr	r2, [pc, #196]	@ (3400e9c4 <HAL_RCCEx_PeriphCLKConfig+0x4c64>)
3400e900:	430b      	orrs	r3, r1
3400e902:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400e906:	f7fa ff49 	bl	3400979c <LL_RCC_IC9_Enable>
3400e90a:	e066      	b.n	3400e9da <HAL_RCCEx_PeriphCLKConfig+0x4c7a>
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC14)
3400e90c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e910:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
3400e914:	4b26      	ldr	r3, [pc, #152]	@ (3400e9b0 <HAL_RCCEx_PeriphCLKConfig+0x4c50>)
3400e916:	429a      	cmp	r2, r3
3400e918:	d156      	bne.n	3400e9c8 <HAL_RCCEx_PeriphCLKConfig+0x4c68>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400e91a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e91e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400e920:	2b00      	cmp	r3, #0
3400e922:	d016      	beq.n	3400e952 <HAL_RCCEx_PeriphCLKConfig+0x4bf2>
3400e924:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e928:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400e92a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e92e:	d010      	beq.n	3400e952 <HAL_RCCEx_PeriphCLKConfig+0x4bf2>
3400e930:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e934:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400e936:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e93a:	d00a      	beq.n	3400e952 <HAL_RCCEx_PeriphCLKConfig+0x4bf2>
3400e93c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e940:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400e942:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e946:	d004      	beq.n	3400e952 <HAL_RCCEx_PeriphCLKConfig+0x4bf2>
3400e948:	f240 61a5 	movw	r1, #1701	@ 0x6a5
3400e94c:	481c      	ldr	r0, [pc, #112]	@ (3400e9c0 <HAL_RCCEx_PeriphCLKConfig+0x4c60>)
3400e94e:	f7f3 fb5f 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400e952:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e956:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400e958:	2b00      	cmp	r3, #0
3400e95a:	d005      	beq.n	3400e968 <HAL_RCCEx_PeriphCLKConfig+0x4c08>
3400e95c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e960:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400e962:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400e966:	d904      	bls.n	3400e972 <HAL_RCCEx_PeriphCLKConfig+0x4c12>
3400e968:	f240 61a6 	movw	r1, #1702	@ 0x6a6
3400e96c:	4814      	ldr	r0, [pc, #80]	@ (3400e9c0 <HAL_RCCEx_PeriphCLKConfig+0x4c60>)
3400e96e:	f7f3 fb4f 	bl	34002010 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400e972:	4b14      	ldr	r3, [pc, #80]	@ (3400e9c4 <HAL_RCCEx_PeriphCLKConfig+0x4c64>)
3400e974:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400e978:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400e97c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400e980:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e984:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400e986:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e98a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400e98c:	3b01      	subs	r3, #1
3400e98e:	041b      	lsls	r3, r3, #16
3400e990:	4313      	orrs	r3, r2
3400e992:	4a0c      	ldr	r2, [pc, #48]	@ (3400e9c4 <HAL_RCCEx_PeriphCLKConfig+0x4c64>)
3400e994:	430b      	orrs	r3, r1
3400e996:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400e99a:	f7fa ffff 	bl	3400999c <LL_RCC_IC14_Enable>
3400e99e:	e01c      	b.n	3400e9da <HAL_RCCEx_PeriphCLKConfig+0x4c7a>
3400e9a0:	07010c20 	.word	0x07010c20
3400e9a4:	07001020 	.word	0x07001020
3400e9a8:	07011020 	.word	0x07011020
3400e9ac:	07021020 	.word	0x07021020
3400e9b0:	07031020 	.word	0x07031020
3400e9b4:	07041020 	.word	0x07041020
3400e9b8:	07051020 	.word	0x07051020
3400e9bc:	07061020 	.word	0x07061020
3400e9c0:	3401ee60 	.word	0x3401ee60
3400e9c4:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_CLKP)
3400e9c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e9cc:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
3400e9d0:	4b73      	ldr	r3, [pc, #460]	@ (3400eba0 <HAL_RCCEx_PeriphCLKConfig+0x4e40>)
3400e9d2:	429a      	cmp	r2, r3
3400e9d4:	d101      	bne.n	3400e9da <HAL_RCCEx_PeriphCLKConfig+0x4c7a>
    {
      LL_RCC_CLKP_Enable();
3400e9d6:	f7fb f9a1 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI4 clock */
    __HAL_RCC_SPI4_CONFIG(PeriphClkInit->Spi4ClockSelection);
3400e9da:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e9de:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
3400e9e2:	4618      	mov	r0, r3
3400e9e4:	f7fa f932 	bl	34008c4c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI5 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI5) == RCC_PERIPHCLK_SPI5)
3400e9e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e9ec:	e9d3 2300 	ldrd	r2, r3, [r3]
3400e9f0:	2100      	movs	r1, #0
3400e9f2:	f8c7 1080 	str.w	r1, [r7, #128]	@ 0x80
3400e9f6:	f003 0320 	and.w	r3, r3, #32
3400e9fa:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
3400e9fe:	e9d7 0120 	ldrd	r0, r1, [r7, #128]	@ 0x80
3400ea02:	4603      	mov	r3, r0
3400ea04:	460a      	mov	r2, r1
3400ea06:	4313      	orrs	r3, r2
3400ea08:	f000 80ee 	beq.w	3400ebe8 <HAL_RCCEx_PeriphCLKConfig+0x4e88>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI5CLKSOURCE(PeriphClkInit->Spi5ClockSelection));
3400ea0c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ea10:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
3400ea14:	4b63      	ldr	r3, [pc, #396]	@ (3400eba4 <HAL_RCCEx_PeriphCLKConfig+0x4e44>)
3400ea16:	429a      	cmp	r2, r3
3400ea18:	d02e      	beq.n	3400ea78 <HAL_RCCEx_PeriphCLKConfig+0x4d18>
3400ea1a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ea1e:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
3400ea22:	4b61      	ldr	r3, [pc, #388]	@ (3400eba8 <HAL_RCCEx_PeriphCLKConfig+0x4e48>)
3400ea24:	429a      	cmp	r2, r3
3400ea26:	d027      	beq.n	3400ea78 <HAL_RCCEx_PeriphCLKConfig+0x4d18>
3400ea28:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ea2c:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
3400ea30:	4b5e      	ldr	r3, [pc, #376]	@ (3400ebac <HAL_RCCEx_PeriphCLKConfig+0x4e4c>)
3400ea32:	429a      	cmp	r2, r3
3400ea34:	d020      	beq.n	3400ea78 <HAL_RCCEx_PeriphCLKConfig+0x4d18>
3400ea36:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ea3a:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
3400ea3e:	4b5c      	ldr	r3, [pc, #368]	@ (3400ebb0 <HAL_RCCEx_PeriphCLKConfig+0x4e50>)
3400ea40:	429a      	cmp	r2, r3
3400ea42:	d019      	beq.n	3400ea78 <HAL_RCCEx_PeriphCLKConfig+0x4d18>
3400ea44:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ea48:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
3400ea4c:	4b59      	ldr	r3, [pc, #356]	@ (3400ebb4 <HAL_RCCEx_PeriphCLKConfig+0x4e54>)
3400ea4e:	429a      	cmp	r2, r3
3400ea50:	d012      	beq.n	3400ea78 <HAL_RCCEx_PeriphCLKConfig+0x4d18>
3400ea52:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ea56:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
3400ea5a:	4b57      	ldr	r3, [pc, #348]	@ (3400ebb8 <HAL_RCCEx_PeriphCLKConfig+0x4e58>)
3400ea5c:	429a      	cmp	r2, r3
3400ea5e:	d00b      	beq.n	3400ea78 <HAL_RCCEx_PeriphCLKConfig+0x4d18>
3400ea60:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ea64:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
3400ea68:	4b54      	ldr	r3, [pc, #336]	@ (3400ebbc <HAL_RCCEx_PeriphCLKConfig+0x4e5c>)
3400ea6a:	429a      	cmp	r2, r3
3400ea6c:	d004      	beq.n	3400ea78 <HAL_RCCEx_PeriphCLKConfig+0x4d18>
3400ea6e:	f44f 61d8 	mov.w	r1, #1728	@ 0x6c0
3400ea72:	4853      	ldr	r0, [pc, #332]	@ (3400ebc0 <HAL_RCCEx_PeriphCLKConfig+0x4e60>)
3400ea74:	f7f3 facc 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC9)
3400ea78:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ea7c:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
3400ea80:	4b4a      	ldr	r3, [pc, #296]	@ (3400ebac <HAL_RCCEx_PeriphCLKConfig+0x4e4c>)
3400ea82:	429a      	cmp	r2, r3
3400ea84:	d142      	bne.n	3400eb0c <HAL_RCCEx_PeriphCLKConfig+0x4dac>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400ea86:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ea8a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400ea8c:	2b00      	cmp	r3, #0
3400ea8e:	d016      	beq.n	3400eabe <HAL_RCCEx_PeriphCLKConfig+0x4d5e>
3400ea90:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ea94:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400ea96:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ea9a:	d010      	beq.n	3400eabe <HAL_RCCEx_PeriphCLKConfig+0x4d5e>
3400ea9c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eaa0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400eaa2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400eaa6:	d00a      	beq.n	3400eabe <HAL_RCCEx_PeriphCLKConfig+0x4d5e>
3400eaa8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eaac:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400eaae:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400eab2:	d004      	beq.n	3400eabe <HAL_RCCEx_PeriphCLKConfig+0x4d5e>
3400eab4:	f240 61c5 	movw	r1, #1733	@ 0x6c5
3400eab8:	4841      	ldr	r0, [pc, #260]	@ (3400ebc0 <HAL_RCCEx_PeriphCLKConfig+0x4e60>)
3400eaba:	f7f3 faa9 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400eabe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eac2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400eac4:	2b00      	cmp	r3, #0
3400eac6:	d005      	beq.n	3400ead4 <HAL_RCCEx_PeriphCLKConfig+0x4d74>
3400eac8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eacc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400eace:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400ead2:	d904      	bls.n	3400eade <HAL_RCCEx_PeriphCLKConfig+0x4d7e>
3400ead4:	f240 61c6 	movw	r1, #1734	@ 0x6c6
3400ead8:	4839      	ldr	r0, [pc, #228]	@ (3400ebc0 <HAL_RCCEx_PeriphCLKConfig+0x4e60>)
3400eada:	f7f3 fa99 	bl	34002010 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400eade:	4b39      	ldr	r3, [pc, #228]	@ (3400ebc4 <HAL_RCCEx_PeriphCLKConfig+0x4e64>)
3400eae0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400eae4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400eae8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400eaec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eaf0:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400eaf2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eaf6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400eaf8:	3b01      	subs	r3, #1
3400eafa:	041b      	lsls	r3, r3, #16
3400eafc:	4313      	orrs	r3, r2
3400eafe:	4a31      	ldr	r2, [pc, #196]	@ (3400ebc4 <HAL_RCCEx_PeriphCLKConfig+0x4e64>)
3400eb00:	430b      	orrs	r3, r1
3400eb02:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400eb06:	f7fa fe49 	bl	3400979c <LL_RCC_IC9_Enable>
3400eb0a:	e066      	b.n	3400ebda <HAL_RCCEx_PeriphCLKConfig+0x4e7a>
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC14)
3400eb0c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eb10:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
3400eb14:	4b26      	ldr	r3, [pc, #152]	@ (3400ebb0 <HAL_RCCEx_PeriphCLKConfig+0x4e50>)
3400eb16:	429a      	cmp	r2, r3
3400eb18:	d156      	bne.n	3400ebc8 <HAL_RCCEx_PeriphCLKConfig+0x4e68>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400eb1a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eb1e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400eb20:	2b00      	cmp	r3, #0
3400eb22:	d016      	beq.n	3400eb52 <HAL_RCCEx_PeriphCLKConfig+0x4df2>
3400eb24:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eb28:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400eb2a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400eb2e:	d010      	beq.n	3400eb52 <HAL_RCCEx_PeriphCLKConfig+0x4df2>
3400eb30:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eb34:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400eb36:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400eb3a:	d00a      	beq.n	3400eb52 <HAL_RCCEx_PeriphCLKConfig+0x4df2>
3400eb3c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eb40:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400eb42:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400eb46:	d004      	beq.n	3400eb52 <HAL_RCCEx_PeriphCLKConfig+0x4df2>
3400eb48:	f240 61d2 	movw	r1, #1746	@ 0x6d2
3400eb4c:	481c      	ldr	r0, [pc, #112]	@ (3400ebc0 <HAL_RCCEx_PeriphCLKConfig+0x4e60>)
3400eb4e:	f7f3 fa5f 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400eb52:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eb56:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400eb58:	2b00      	cmp	r3, #0
3400eb5a:	d005      	beq.n	3400eb68 <HAL_RCCEx_PeriphCLKConfig+0x4e08>
3400eb5c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eb60:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400eb62:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400eb66:	d904      	bls.n	3400eb72 <HAL_RCCEx_PeriphCLKConfig+0x4e12>
3400eb68:	f240 61d3 	movw	r1, #1747	@ 0x6d3
3400eb6c:	4814      	ldr	r0, [pc, #80]	@ (3400ebc0 <HAL_RCCEx_PeriphCLKConfig+0x4e60>)
3400eb6e:	f7f3 fa4f 	bl	34002010 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400eb72:	4b14      	ldr	r3, [pc, #80]	@ (3400ebc4 <HAL_RCCEx_PeriphCLKConfig+0x4e64>)
3400eb74:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400eb78:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400eb7c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400eb80:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eb84:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400eb86:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eb8a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400eb8c:	3b01      	subs	r3, #1
3400eb8e:	041b      	lsls	r3, r3, #16
3400eb90:	4313      	orrs	r3, r2
3400eb92:	4a0c      	ldr	r2, [pc, #48]	@ (3400ebc4 <HAL_RCCEx_PeriphCLKConfig+0x4e64>)
3400eb94:	430b      	orrs	r3, r1
3400eb96:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400eb9a:	f7fa feff 	bl	3400999c <LL_RCC_IC14_Enable>
3400eb9e:	e01c      	b.n	3400ebda <HAL_RCCEx_PeriphCLKConfig+0x4e7a>
3400eba0:	07011020 	.word	0x07011020
3400eba4:	07001420 	.word	0x07001420
3400eba8:	07011420 	.word	0x07011420
3400ebac:	07021420 	.word	0x07021420
3400ebb0:	07031420 	.word	0x07031420
3400ebb4:	07041420 	.word	0x07041420
3400ebb8:	07051420 	.word	0x07051420
3400ebbc:	07061420 	.word	0x07061420
3400ebc0:	3401ee60 	.word	0x3401ee60
3400ebc4:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_CLKP)
3400ebc8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ebcc:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
3400ebd0:	4b72      	ldr	r3, [pc, #456]	@ (3400ed9c <HAL_RCCEx_PeriphCLKConfig+0x503c>)
3400ebd2:	429a      	cmp	r2, r3
3400ebd4:	d101      	bne.n	3400ebda <HAL_RCCEx_PeriphCLKConfig+0x4e7a>
    {
      LL_RCC_CLKP_Enable();
3400ebd6:	f7fb f8a1 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI5 clock */
    __HAL_RCC_SPI5_CONFIG(PeriphClkInit->Spi5ClockSelection);
3400ebda:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ebde:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400ebe2:	4618      	mov	r0, r3
3400ebe4:	f7fa f832 	bl	34008c4c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
3400ebe8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ebec:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ebf0:	2100      	movs	r1, #0
3400ebf2:	67b9      	str	r1, [r7, #120]	@ 0x78
3400ebf4:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400ebf8:	67fb      	str	r3, [r7, #124]	@ 0x7c
3400ebfa:	e9d7 011e 	ldrd	r0, r1, [r7, #120]	@ 0x78
3400ebfe:	4603      	mov	r3, r0
3400ec00:	460a      	mov	r2, r1
3400ec02:	4313      	orrs	r3, r2
3400ec04:	f000 80ee 	beq.w	3400ede4 <HAL_RCCEx_PeriphCLKConfig+0x5084>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI6CLKSOURCE(PeriphClkInit->Spi6ClockSelection));
3400ec08:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ec0c:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3400ec10:	4b63      	ldr	r3, [pc, #396]	@ (3400eda0 <HAL_RCCEx_PeriphCLKConfig+0x5040>)
3400ec12:	429a      	cmp	r2, r3
3400ec14:	d02e      	beq.n	3400ec74 <HAL_RCCEx_PeriphCLKConfig+0x4f14>
3400ec16:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ec1a:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3400ec1e:	4b61      	ldr	r3, [pc, #388]	@ (3400eda4 <HAL_RCCEx_PeriphCLKConfig+0x5044>)
3400ec20:	429a      	cmp	r2, r3
3400ec22:	d027      	beq.n	3400ec74 <HAL_RCCEx_PeriphCLKConfig+0x4f14>
3400ec24:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ec28:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3400ec2c:	4b5e      	ldr	r3, [pc, #376]	@ (3400eda8 <HAL_RCCEx_PeriphCLKConfig+0x5048>)
3400ec2e:	429a      	cmp	r2, r3
3400ec30:	d020      	beq.n	3400ec74 <HAL_RCCEx_PeriphCLKConfig+0x4f14>
3400ec32:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ec36:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3400ec3a:	4b5c      	ldr	r3, [pc, #368]	@ (3400edac <HAL_RCCEx_PeriphCLKConfig+0x504c>)
3400ec3c:	429a      	cmp	r2, r3
3400ec3e:	d019      	beq.n	3400ec74 <HAL_RCCEx_PeriphCLKConfig+0x4f14>
3400ec40:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ec44:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3400ec48:	4b59      	ldr	r3, [pc, #356]	@ (3400edb0 <HAL_RCCEx_PeriphCLKConfig+0x5050>)
3400ec4a:	429a      	cmp	r2, r3
3400ec4c:	d012      	beq.n	3400ec74 <HAL_RCCEx_PeriphCLKConfig+0x4f14>
3400ec4e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ec52:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3400ec56:	4b57      	ldr	r3, [pc, #348]	@ (3400edb4 <HAL_RCCEx_PeriphCLKConfig+0x5054>)
3400ec58:	429a      	cmp	r2, r3
3400ec5a:	d00b      	beq.n	3400ec74 <HAL_RCCEx_PeriphCLKConfig+0x4f14>
3400ec5c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ec60:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3400ec64:	4b54      	ldr	r3, [pc, #336]	@ (3400edb8 <HAL_RCCEx_PeriphCLKConfig+0x5058>)
3400ec66:	429a      	cmp	r2, r3
3400ec68:	d004      	beq.n	3400ec74 <HAL_RCCEx_PeriphCLKConfig+0x4f14>
3400ec6a:	f240 61ed 	movw	r1, #1773	@ 0x6ed
3400ec6e:	4853      	ldr	r0, [pc, #332]	@ (3400edbc <HAL_RCCEx_PeriphCLKConfig+0x505c>)
3400ec70:	f7f3 f9ce 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC8)
3400ec74:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ec78:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3400ec7c:	4b4a      	ldr	r3, [pc, #296]	@ (3400eda8 <HAL_RCCEx_PeriphCLKConfig+0x5048>)
3400ec7e:	429a      	cmp	r2, r3
3400ec80:	d142      	bne.n	3400ed08 <HAL_RCCEx_PeriphCLKConfig+0x4fa8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400ec82:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ec86:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400ec88:	2b00      	cmp	r3, #0
3400ec8a:	d016      	beq.n	3400ecba <HAL_RCCEx_PeriphCLKConfig+0x4f5a>
3400ec8c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ec90:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400ec92:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ec96:	d010      	beq.n	3400ecba <HAL_RCCEx_PeriphCLKConfig+0x4f5a>
3400ec98:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ec9c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400ec9e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400eca2:	d00a      	beq.n	3400ecba <HAL_RCCEx_PeriphCLKConfig+0x4f5a>
3400eca4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eca8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400ecaa:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ecae:	d004      	beq.n	3400ecba <HAL_RCCEx_PeriphCLKConfig+0x4f5a>
3400ecb0:	f240 61f2 	movw	r1, #1778	@ 0x6f2
3400ecb4:	4841      	ldr	r0, [pc, #260]	@ (3400edbc <HAL_RCCEx_PeriphCLKConfig+0x505c>)
3400ecb6:	f7f3 f9ab 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400ecba:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ecbe:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400ecc0:	2b00      	cmp	r3, #0
3400ecc2:	d005      	beq.n	3400ecd0 <HAL_RCCEx_PeriphCLKConfig+0x4f70>
3400ecc4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ecc8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400ecca:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400ecce:	d904      	bls.n	3400ecda <HAL_RCCEx_PeriphCLKConfig+0x4f7a>
3400ecd0:	f240 61f3 	movw	r1, #1779	@ 0x6f3
3400ecd4:	4839      	ldr	r0, [pc, #228]	@ (3400edbc <HAL_RCCEx_PeriphCLKConfig+0x505c>)
3400ecd6:	f7f3 f99b 	bl	34002010 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400ecda:	4b39      	ldr	r3, [pc, #228]	@ (3400edc0 <HAL_RCCEx_PeriphCLKConfig+0x5060>)
3400ecdc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400ece0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400ece4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400ece8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ecec:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3400ecee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ecf2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400ecf4:	3b01      	subs	r3, #1
3400ecf6:	041b      	lsls	r3, r3, #16
3400ecf8:	4313      	orrs	r3, r2
3400ecfa:	4a31      	ldr	r2, [pc, #196]	@ (3400edc0 <HAL_RCCEx_PeriphCLKConfig+0x5060>)
3400ecfc:	430b      	orrs	r3, r1
3400ecfe:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3400ed02:	f7fa fd0b 	bl	3400971c <LL_RCC_IC8_Enable>
3400ed06:	e066      	b.n	3400edd6 <HAL_RCCEx_PeriphCLKConfig+0x5076>
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC9)
3400ed08:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ed0c:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3400ed10:	4b26      	ldr	r3, [pc, #152]	@ (3400edac <HAL_RCCEx_PeriphCLKConfig+0x504c>)
3400ed12:	429a      	cmp	r2, r3
3400ed14:	d156      	bne.n	3400edc4 <HAL_RCCEx_PeriphCLKConfig+0x5064>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400ed16:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ed1a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400ed1c:	2b00      	cmp	r3, #0
3400ed1e:	d016      	beq.n	3400ed4e <HAL_RCCEx_PeriphCLKConfig+0x4fee>
3400ed20:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ed24:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400ed26:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ed2a:	d010      	beq.n	3400ed4e <HAL_RCCEx_PeriphCLKConfig+0x4fee>
3400ed2c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ed30:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400ed32:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ed36:	d00a      	beq.n	3400ed4e <HAL_RCCEx_PeriphCLKConfig+0x4fee>
3400ed38:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ed3c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400ed3e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ed42:	d004      	beq.n	3400ed4e <HAL_RCCEx_PeriphCLKConfig+0x4fee>
3400ed44:	f240 61ff 	movw	r1, #1791	@ 0x6ff
3400ed48:	481c      	ldr	r0, [pc, #112]	@ (3400edbc <HAL_RCCEx_PeriphCLKConfig+0x505c>)
3400ed4a:	f7f3 f961 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400ed4e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ed52:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400ed54:	2b00      	cmp	r3, #0
3400ed56:	d005      	beq.n	3400ed64 <HAL_RCCEx_PeriphCLKConfig+0x5004>
3400ed58:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ed5c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400ed5e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400ed62:	d904      	bls.n	3400ed6e <HAL_RCCEx_PeriphCLKConfig+0x500e>
3400ed64:	f44f 61e0 	mov.w	r1, #1792	@ 0x700
3400ed68:	4814      	ldr	r0, [pc, #80]	@ (3400edbc <HAL_RCCEx_PeriphCLKConfig+0x505c>)
3400ed6a:	f7f3 f951 	bl	34002010 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400ed6e:	4b14      	ldr	r3, [pc, #80]	@ (3400edc0 <HAL_RCCEx_PeriphCLKConfig+0x5060>)
3400ed70:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400ed74:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400ed78:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400ed7c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ed80:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400ed82:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ed86:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400ed88:	3b01      	subs	r3, #1
3400ed8a:	041b      	lsls	r3, r3, #16
3400ed8c:	4313      	orrs	r3, r2
3400ed8e:	4a0c      	ldr	r2, [pc, #48]	@ (3400edc0 <HAL_RCCEx_PeriphCLKConfig+0x5060>)
3400ed90:	430b      	orrs	r3, r1
3400ed92:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400ed96:	f7fa fd01 	bl	3400979c <LL_RCC_IC9_Enable>
3400ed9a:	e01c      	b.n	3400edd6 <HAL_RCCEx_PeriphCLKConfig+0x5076>
3400ed9c:	07011420 	.word	0x07011420
3400eda0:	07001820 	.word	0x07001820
3400eda4:	07011820 	.word	0x07011820
3400eda8:	07021820 	.word	0x07021820
3400edac:	07031820 	.word	0x07031820
3400edb0:	07041820 	.word	0x07041820
3400edb4:	07051820 	.word	0x07051820
3400edb8:	07061820 	.word	0x07061820
3400edbc:	3401ee60 	.word	0x3401ee60
3400edc0:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_CLKP)
3400edc4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400edc8:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3400edcc:	4b72      	ldr	r3, [pc, #456]	@ (3400ef98 <HAL_RCCEx_PeriphCLKConfig+0x5238>)
3400edce:	429a      	cmp	r2, r3
3400edd0:	d101      	bne.n	3400edd6 <HAL_RCCEx_PeriphCLKConfig+0x5076>
    {
      LL_RCC_CLKP_Enable();
3400edd2:	f7fa ffa3 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI6 clock*/
    __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
3400edd6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400edda:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3400edde:	4618      	mov	r0, r3
3400ede0:	f7f9 ff34 	bl	34008c4c <LL_RCC_SetSPIClockSource>
  }

  /*-------------------------- USART1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
3400ede4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ede8:	e9d3 2300 	ldrd	r2, r3, [r3]
3400edec:	2100      	movs	r1, #0
3400edee:	6739      	str	r1, [r7, #112]	@ 0x70
3400edf0:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400edf4:	677b      	str	r3, [r7, #116]	@ 0x74
3400edf6:	e9d7 011c 	ldrd	r0, r1, [r7, #112]	@ 0x70
3400edfa:	4603      	mov	r3, r0
3400edfc:	460a      	mov	r2, r1
3400edfe:	4313      	orrs	r3, r2
3400ee00:	f000 80ee 	beq.w	3400efe0 <HAL_RCCEx_PeriphCLKConfig+0x5280>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
3400ee04:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ee08:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
3400ee0c:	4b63      	ldr	r3, [pc, #396]	@ (3400ef9c <HAL_RCCEx_PeriphCLKConfig+0x523c>)
3400ee0e:	429a      	cmp	r2, r3
3400ee10:	d02e      	beq.n	3400ee70 <HAL_RCCEx_PeriphCLKConfig+0x5110>
3400ee12:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ee16:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
3400ee1a:	4b61      	ldr	r3, [pc, #388]	@ (3400efa0 <HAL_RCCEx_PeriphCLKConfig+0x5240>)
3400ee1c:	429a      	cmp	r2, r3
3400ee1e:	d027      	beq.n	3400ee70 <HAL_RCCEx_PeriphCLKConfig+0x5110>
3400ee20:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ee24:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
3400ee28:	4b5e      	ldr	r3, [pc, #376]	@ (3400efa4 <HAL_RCCEx_PeriphCLKConfig+0x5244>)
3400ee2a:	429a      	cmp	r2, r3
3400ee2c:	d020      	beq.n	3400ee70 <HAL_RCCEx_PeriphCLKConfig+0x5110>
3400ee2e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ee32:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
3400ee36:	4b5c      	ldr	r3, [pc, #368]	@ (3400efa8 <HAL_RCCEx_PeriphCLKConfig+0x5248>)
3400ee38:	429a      	cmp	r2, r3
3400ee3a:	d019      	beq.n	3400ee70 <HAL_RCCEx_PeriphCLKConfig+0x5110>
3400ee3c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ee40:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
3400ee44:	4b59      	ldr	r3, [pc, #356]	@ (3400efac <HAL_RCCEx_PeriphCLKConfig+0x524c>)
3400ee46:	429a      	cmp	r2, r3
3400ee48:	d012      	beq.n	3400ee70 <HAL_RCCEx_PeriphCLKConfig+0x5110>
3400ee4a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ee4e:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
3400ee52:	4b57      	ldr	r3, [pc, #348]	@ (3400efb0 <HAL_RCCEx_PeriphCLKConfig+0x5250>)
3400ee54:	429a      	cmp	r2, r3
3400ee56:	d00b      	beq.n	3400ee70 <HAL_RCCEx_PeriphCLKConfig+0x5110>
3400ee58:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ee5c:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
3400ee60:	4b54      	ldr	r3, [pc, #336]	@ (3400efb4 <HAL_RCCEx_PeriphCLKConfig+0x5254>)
3400ee62:	429a      	cmp	r2, r3
3400ee64:	d004      	beq.n	3400ee70 <HAL_RCCEx_PeriphCLKConfig+0x5110>
3400ee66:	f240 711a 	movw	r1, #1818	@ 0x71a
3400ee6a:	4853      	ldr	r0, [pc, #332]	@ (3400efb8 <HAL_RCCEx_PeriphCLKConfig+0x5258>)
3400ee6c:	f7f3 f8d0 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC9)
3400ee70:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ee74:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
3400ee78:	4b4a      	ldr	r3, [pc, #296]	@ (3400efa4 <HAL_RCCEx_PeriphCLKConfig+0x5244>)
3400ee7a:	429a      	cmp	r2, r3
3400ee7c:	d142      	bne.n	3400ef04 <HAL_RCCEx_PeriphCLKConfig+0x51a4>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400ee7e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ee82:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400ee84:	2b00      	cmp	r3, #0
3400ee86:	d016      	beq.n	3400eeb6 <HAL_RCCEx_PeriphCLKConfig+0x5156>
3400ee88:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ee8c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400ee8e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ee92:	d010      	beq.n	3400eeb6 <HAL_RCCEx_PeriphCLKConfig+0x5156>
3400ee94:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ee98:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400ee9a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ee9e:	d00a      	beq.n	3400eeb6 <HAL_RCCEx_PeriphCLKConfig+0x5156>
3400eea0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eea4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400eea6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400eeaa:	d004      	beq.n	3400eeb6 <HAL_RCCEx_PeriphCLKConfig+0x5156>
3400eeac:	f240 711f 	movw	r1, #1823	@ 0x71f
3400eeb0:	4841      	ldr	r0, [pc, #260]	@ (3400efb8 <HAL_RCCEx_PeriphCLKConfig+0x5258>)
3400eeb2:	f7f3 f8ad 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400eeb6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eeba:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400eebc:	2b00      	cmp	r3, #0
3400eebe:	d005      	beq.n	3400eecc <HAL_RCCEx_PeriphCLKConfig+0x516c>
3400eec0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eec4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400eec6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400eeca:	d904      	bls.n	3400eed6 <HAL_RCCEx_PeriphCLKConfig+0x5176>
3400eecc:	f44f 61e4 	mov.w	r1, #1824	@ 0x720
3400eed0:	4839      	ldr	r0, [pc, #228]	@ (3400efb8 <HAL_RCCEx_PeriphCLKConfig+0x5258>)
3400eed2:	f7f3 f89d 	bl	34002010 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400eed6:	4b39      	ldr	r3, [pc, #228]	@ (3400efbc <HAL_RCCEx_PeriphCLKConfig+0x525c>)
3400eed8:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400eedc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400eee0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400eee4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eee8:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400eeea:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eeee:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400eef0:	3b01      	subs	r3, #1
3400eef2:	041b      	lsls	r3, r3, #16
3400eef4:	4313      	orrs	r3, r2
3400eef6:	4a31      	ldr	r2, [pc, #196]	@ (3400efbc <HAL_RCCEx_PeriphCLKConfig+0x525c>)
3400eef8:	430b      	orrs	r3, r1
3400eefa:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400eefe:	f7fa fc4d 	bl	3400979c <LL_RCC_IC9_Enable>
3400ef02:	e066      	b.n	3400efd2 <HAL_RCCEx_PeriphCLKConfig+0x5272>
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC14)
3400ef04:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ef08:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
3400ef0c:	4b26      	ldr	r3, [pc, #152]	@ (3400efa8 <HAL_RCCEx_PeriphCLKConfig+0x5248>)
3400ef0e:	429a      	cmp	r2, r3
3400ef10:	d156      	bne.n	3400efc0 <HAL_RCCEx_PeriphCLKConfig+0x5260>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400ef12:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ef16:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400ef18:	2b00      	cmp	r3, #0
3400ef1a:	d016      	beq.n	3400ef4a <HAL_RCCEx_PeriphCLKConfig+0x51ea>
3400ef1c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ef20:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400ef22:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ef26:	d010      	beq.n	3400ef4a <HAL_RCCEx_PeriphCLKConfig+0x51ea>
3400ef28:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ef2c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400ef2e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ef32:	d00a      	beq.n	3400ef4a <HAL_RCCEx_PeriphCLKConfig+0x51ea>
3400ef34:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ef38:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400ef3a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ef3e:	d004      	beq.n	3400ef4a <HAL_RCCEx_PeriphCLKConfig+0x51ea>
3400ef40:	f240 712c 	movw	r1, #1836	@ 0x72c
3400ef44:	481c      	ldr	r0, [pc, #112]	@ (3400efb8 <HAL_RCCEx_PeriphCLKConfig+0x5258>)
3400ef46:	f7f3 f863 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400ef4a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ef4e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400ef50:	2b00      	cmp	r3, #0
3400ef52:	d005      	beq.n	3400ef60 <HAL_RCCEx_PeriphCLKConfig+0x5200>
3400ef54:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ef58:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400ef5a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400ef5e:	d904      	bls.n	3400ef6a <HAL_RCCEx_PeriphCLKConfig+0x520a>
3400ef60:	f240 712d 	movw	r1, #1837	@ 0x72d
3400ef64:	4814      	ldr	r0, [pc, #80]	@ (3400efb8 <HAL_RCCEx_PeriphCLKConfig+0x5258>)
3400ef66:	f7f3 f853 	bl	34002010 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400ef6a:	4b14      	ldr	r3, [pc, #80]	@ (3400efbc <HAL_RCCEx_PeriphCLKConfig+0x525c>)
3400ef6c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400ef70:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400ef74:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400ef78:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ef7c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400ef7e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ef82:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400ef84:	3b01      	subs	r3, #1
3400ef86:	041b      	lsls	r3, r3, #16
3400ef88:	4313      	orrs	r3, r2
3400ef8a:	4a0c      	ldr	r2, [pc, #48]	@ (3400efbc <HAL_RCCEx_PeriphCLKConfig+0x525c>)
3400ef8c:	430b      	orrs	r3, r1
3400ef8e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400ef92:	f7fa fd03 	bl	3400999c <LL_RCC_IC14_Enable>
3400ef96:	e01c      	b.n	3400efd2 <HAL_RCCEx_PeriphCLKConfig+0x5272>
3400ef98:	07011820 	.word	0x07011820
3400ef9c:	07000030 	.word	0x07000030
3400efa0:	07010030 	.word	0x07010030
3400efa4:	07020030 	.word	0x07020030
3400efa8:	07030030 	.word	0x07030030
3400efac:	07040030 	.word	0x07040030
3400efb0:	07050030 	.word	0x07050030
3400efb4:	07060030 	.word	0x07060030
3400efb8:	3401ee60 	.word	0x3401ee60
3400efbc:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_CLKP)
3400efc0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400efc4:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
3400efc8:	4b72      	ldr	r3, [pc, #456]	@ (3400f194 <HAL_RCCEx_PeriphCLKConfig+0x5434>)
3400efca:	429a      	cmp	r2, r3
3400efcc:	d101      	bne.n	3400efd2 <HAL_RCCEx_PeriphCLKConfig+0x5272>
    {
      LL_RCC_CLKP_Enable();
3400efce:	f7fa fea5 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART1 clock */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
3400efd2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400efd6:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
3400efda:	4618      	mov	r0, r3
3400efdc:	f7f9 fe41 	bl	34008c62 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
3400efe0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400efe4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400efe8:	2100      	movs	r1, #0
3400efea:	66b9      	str	r1, [r7, #104]	@ 0x68
3400efec:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400eff0:	66fb      	str	r3, [r7, #108]	@ 0x6c
3400eff2:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	@ 0x68
3400eff6:	4603      	mov	r3, r0
3400eff8:	460a      	mov	r2, r1
3400effa:	4313      	orrs	r3, r2
3400effc:	f000 80ee 	beq.w	3400f1dc <HAL_RCCEx_PeriphCLKConfig+0x547c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
3400f000:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f004:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
3400f008:	4b63      	ldr	r3, [pc, #396]	@ (3400f198 <HAL_RCCEx_PeriphCLKConfig+0x5438>)
3400f00a:	429a      	cmp	r2, r3
3400f00c:	d02e      	beq.n	3400f06c <HAL_RCCEx_PeriphCLKConfig+0x530c>
3400f00e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f012:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
3400f016:	4b61      	ldr	r3, [pc, #388]	@ (3400f19c <HAL_RCCEx_PeriphCLKConfig+0x543c>)
3400f018:	429a      	cmp	r2, r3
3400f01a:	d027      	beq.n	3400f06c <HAL_RCCEx_PeriphCLKConfig+0x530c>
3400f01c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f020:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
3400f024:	4b5e      	ldr	r3, [pc, #376]	@ (3400f1a0 <HAL_RCCEx_PeriphCLKConfig+0x5440>)
3400f026:	429a      	cmp	r2, r3
3400f028:	d020      	beq.n	3400f06c <HAL_RCCEx_PeriphCLKConfig+0x530c>
3400f02a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f02e:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
3400f032:	4b5c      	ldr	r3, [pc, #368]	@ (3400f1a4 <HAL_RCCEx_PeriphCLKConfig+0x5444>)
3400f034:	429a      	cmp	r2, r3
3400f036:	d019      	beq.n	3400f06c <HAL_RCCEx_PeriphCLKConfig+0x530c>
3400f038:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f03c:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
3400f040:	4b59      	ldr	r3, [pc, #356]	@ (3400f1a8 <HAL_RCCEx_PeriphCLKConfig+0x5448>)
3400f042:	429a      	cmp	r2, r3
3400f044:	d012      	beq.n	3400f06c <HAL_RCCEx_PeriphCLKConfig+0x530c>
3400f046:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f04a:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
3400f04e:	4b57      	ldr	r3, [pc, #348]	@ (3400f1ac <HAL_RCCEx_PeriphCLKConfig+0x544c>)
3400f050:	429a      	cmp	r2, r3
3400f052:	d00b      	beq.n	3400f06c <HAL_RCCEx_PeriphCLKConfig+0x530c>
3400f054:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f058:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
3400f05c:	4b54      	ldr	r3, [pc, #336]	@ (3400f1b0 <HAL_RCCEx_PeriphCLKConfig+0x5450>)
3400f05e:	429a      	cmp	r2, r3
3400f060:	d004      	beq.n	3400f06c <HAL_RCCEx_PeriphCLKConfig+0x530c>
3400f062:	f240 7147 	movw	r1, #1863	@ 0x747
3400f066:	4853      	ldr	r0, [pc, #332]	@ (3400f1b4 <HAL_RCCEx_PeriphCLKConfig+0x5454>)
3400f068:	f7f2 ffd2 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC9)
3400f06c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f070:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
3400f074:	4b4a      	ldr	r3, [pc, #296]	@ (3400f1a0 <HAL_RCCEx_PeriphCLKConfig+0x5440>)
3400f076:	429a      	cmp	r2, r3
3400f078:	d142      	bne.n	3400f100 <HAL_RCCEx_PeriphCLKConfig+0x53a0>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400f07a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f07e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f080:	2b00      	cmp	r3, #0
3400f082:	d016      	beq.n	3400f0b2 <HAL_RCCEx_PeriphCLKConfig+0x5352>
3400f084:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f088:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f08a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f08e:	d010      	beq.n	3400f0b2 <HAL_RCCEx_PeriphCLKConfig+0x5352>
3400f090:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f094:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f096:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f09a:	d00a      	beq.n	3400f0b2 <HAL_RCCEx_PeriphCLKConfig+0x5352>
3400f09c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f0a0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f0a2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f0a6:	d004      	beq.n	3400f0b2 <HAL_RCCEx_PeriphCLKConfig+0x5352>
3400f0a8:	f240 714c 	movw	r1, #1868	@ 0x74c
3400f0ac:	4841      	ldr	r0, [pc, #260]	@ (3400f1b4 <HAL_RCCEx_PeriphCLKConfig+0x5454>)
3400f0ae:	f7f2 ffaf 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400f0b2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f0b6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400f0b8:	2b00      	cmp	r3, #0
3400f0ba:	d005      	beq.n	3400f0c8 <HAL_RCCEx_PeriphCLKConfig+0x5368>
3400f0bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f0c0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400f0c2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400f0c6:	d904      	bls.n	3400f0d2 <HAL_RCCEx_PeriphCLKConfig+0x5372>
3400f0c8:	f240 714d 	movw	r1, #1869	@ 0x74d
3400f0cc:	4839      	ldr	r0, [pc, #228]	@ (3400f1b4 <HAL_RCCEx_PeriphCLKConfig+0x5454>)
3400f0ce:	f7f2 ff9f 	bl	34002010 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400f0d2:	4b39      	ldr	r3, [pc, #228]	@ (3400f1b8 <HAL_RCCEx_PeriphCLKConfig+0x5458>)
3400f0d4:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400f0d8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400f0dc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400f0e0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f0e4:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400f0e6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f0ea:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400f0ec:	3b01      	subs	r3, #1
3400f0ee:	041b      	lsls	r3, r3, #16
3400f0f0:	4313      	orrs	r3, r2
3400f0f2:	4a31      	ldr	r2, [pc, #196]	@ (3400f1b8 <HAL_RCCEx_PeriphCLKConfig+0x5458>)
3400f0f4:	430b      	orrs	r3, r1
3400f0f6:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400f0fa:	f7fa fb4f 	bl	3400979c <LL_RCC_IC9_Enable>
3400f0fe:	e066      	b.n	3400f1ce <HAL_RCCEx_PeriphCLKConfig+0x546e>
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC14)
3400f100:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f104:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
3400f108:	4b26      	ldr	r3, [pc, #152]	@ (3400f1a4 <HAL_RCCEx_PeriphCLKConfig+0x5444>)
3400f10a:	429a      	cmp	r2, r3
3400f10c:	d156      	bne.n	3400f1bc <HAL_RCCEx_PeriphCLKConfig+0x545c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400f10e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f112:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f114:	2b00      	cmp	r3, #0
3400f116:	d016      	beq.n	3400f146 <HAL_RCCEx_PeriphCLKConfig+0x53e6>
3400f118:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f11c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f11e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f122:	d010      	beq.n	3400f146 <HAL_RCCEx_PeriphCLKConfig+0x53e6>
3400f124:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f128:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f12a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f12e:	d00a      	beq.n	3400f146 <HAL_RCCEx_PeriphCLKConfig+0x53e6>
3400f130:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f134:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f136:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f13a:	d004      	beq.n	3400f146 <HAL_RCCEx_PeriphCLKConfig+0x53e6>
3400f13c:	f240 7159 	movw	r1, #1881	@ 0x759
3400f140:	481c      	ldr	r0, [pc, #112]	@ (3400f1b4 <HAL_RCCEx_PeriphCLKConfig+0x5454>)
3400f142:	f7f2 ff65 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400f146:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f14a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400f14c:	2b00      	cmp	r3, #0
3400f14e:	d005      	beq.n	3400f15c <HAL_RCCEx_PeriphCLKConfig+0x53fc>
3400f150:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f154:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400f156:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400f15a:	d904      	bls.n	3400f166 <HAL_RCCEx_PeriphCLKConfig+0x5406>
3400f15c:	f240 715a 	movw	r1, #1882	@ 0x75a
3400f160:	4814      	ldr	r0, [pc, #80]	@ (3400f1b4 <HAL_RCCEx_PeriphCLKConfig+0x5454>)
3400f162:	f7f2 ff55 	bl	34002010 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400f166:	4b14      	ldr	r3, [pc, #80]	@ (3400f1b8 <HAL_RCCEx_PeriphCLKConfig+0x5458>)
3400f168:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400f16c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400f170:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400f174:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f178:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400f17a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f17e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400f180:	3b01      	subs	r3, #1
3400f182:	041b      	lsls	r3, r3, #16
3400f184:	4313      	orrs	r3, r2
3400f186:	4a0c      	ldr	r2, [pc, #48]	@ (3400f1b8 <HAL_RCCEx_PeriphCLKConfig+0x5458>)
3400f188:	430b      	orrs	r3, r1
3400f18a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400f18e:	f7fa fc05 	bl	3400999c <LL_RCC_IC14_Enable>
3400f192:	e01c      	b.n	3400f1ce <HAL_RCCEx_PeriphCLKConfig+0x546e>
3400f194:	07010030 	.word	0x07010030
3400f198:	07000430 	.word	0x07000430
3400f19c:	07010430 	.word	0x07010430
3400f1a0:	07020430 	.word	0x07020430
3400f1a4:	07030430 	.word	0x07030430
3400f1a8:	07040430 	.word	0x07040430
3400f1ac:	07050430 	.word	0x07050430
3400f1b0:	07060430 	.word	0x07060430
3400f1b4:	3401ee60 	.word	0x3401ee60
3400f1b8:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_CLKP)
3400f1bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f1c0:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
3400f1c4:	4b72      	ldr	r3, [pc, #456]	@ (3400f390 <HAL_RCCEx_PeriphCLKConfig+0x5630>)
3400f1c6:	429a      	cmp	r2, r3
3400f1c8:	d101      	bne.n	3400f1ce <HAL_RCCEx_PeriphCLKConfig+0x546e>
    {
      LL_RCC_CLKP_Enable();
3400f1ca:	f7fa fda7 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART2 clock */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
3400f1ce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f1d2:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
3400f1d6:	4618      	mov	r0, r3
3400f1d8:	f7f9 fd43 	bl	34008c62 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART3 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
3400f1dc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f1e0:	e9d3 2300 	ldrd	r2, r3, [r3]
3400f1e4:	2100      	movs	r1, #0
3400f1e6:	6639      	str	r1, [r7, #96]	@ 0x60
3400f1e8:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3400f1ec:	667b      	str	r3, [r7, #100]	@ 0x64
3400f1ee:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
3400f1f2:	4603      	mov	r3, r0
3400f1f4:	460a      	mov	r2, r1
3400f1f6:	4313      	orrs	r3, r2
3400f1f8:	f000 80ee 	beq.w	3400f3d8 <HAL_RCCEx_PeriphCLKConfig+0x5678>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
3400f1fc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f200:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
3400f204:	4b63      	ldr	r3, [pc, #396]	@ (3400f394 <HAL_RCCEx_PeriphCLKConfig+0x5634>)
3400f206:	429a      	cmp	r2, r3
3400f208:	d02e      	beq.n	3400f268 <HAL_RCCEx_PeriphCLKConfig+0x5508>
3400f20a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f20e:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
3400f212:	4b61      	ldr	r3, [pc, #388]	@ (3400f398 <HAL_RCCEx_PeriphCLKConfig+0x5638>)
3400f214:	429a      	cmp	r2, r3
3400f216:	d027      	beq.n	3400f268 <HAL_RCCEx_PeriphCLKConfig+0x5508>
3400f218:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f21c:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
3400f220:	4b5e      	ldr	r3, [pc, #376]	@ (3400f39c <HAL_RCCEx_PeriphCLKConfig+0x563c>)
3400f222:	429a      	cmp	r2, r3
3400f224:	d020      	beq.n	3400f268 <HAL_RCCEx_PeriphCLKConfig+0x5508>
3400f226:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f22a:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
3400f22e:	4b5c      	ldr	r3, [pc, #368]	@ (3400f3a0 <HAL_RCCEx_PeriphCLKConfig+0x5640>)
3400f230:	429a      	cmp	r2, r3
3400f232:	d019      	beq.n	3400f268 <HAL_RCCEx_PeriphCLKConfig+0x5508>
3400f234:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f238:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
3400f23c:	4b59      	ldr	r3, [pc, #356]	@ (3400f3a4 <HAL_RCCEx_PeriphCLKConfig+0x5644>)
3400f23e:	429a      	cmp	r2, r3
3400f240:	d012      	beq.n	3400f268 <HAL_RCCEx_PeriphCLKConfig+0x5508>
3400f242:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f246:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
3400f24a:	4b57      	ldr	r3, [pc, #348]	@ (3400f3a8 <HAL_RCCEx_PeriphCLKConfig+0x5648>)
3400f24c:	429a      	cmp	r2, r3
3400f24e:	d00b      	beq.n	3400f268 <HAL_RCCEx_PeriphCLKConfig+0x5508>
3400f250:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f254:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
3400f258:	4b54      	ldr	r3, [pc, #336]	@ (3400f3ac <HAL_RCCEx_PeriphCLKConfig+0x564c>)
3400f25a:	429a      	cmp	r2, r3
3400f25c:	d004      	beq.n	3400f268 <HAL_RCCEx_PeriphCLKConfig+0x5508>
3400f25e:	f240 7174 	movw	r1, #1908	@ 0x774
3400f262:	4853      	ldr	r0, [pc, #332]	@ (3400f3b0 <HAL_RCCEx_PeriphCLKConfig+0x5650>)
3400f264:	f7f2 fed4 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC9)
3400f268:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f26c:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
3400f270:	4b4a      	ldr	r3, [pc, #296]	@ (3400f39c <HAL_RCCEx_PeriphCLKConfig+0x563c>)
3400f272:	429a      	cmp	r2, r3
3400f274:	d142      	bne.n	3400f2fc <HAL_RCCEx_PeriphCLKConfig+0x559c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400f276:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f27a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f27c:	2b00      	cmp	r3, #0
3400f27e:	d016      	beq.n	3400f2ae <HAL_RCCEx_PeriphCLKConfig+0x554e>
3400f280:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f284:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f286:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f28a:	d010      	beq.n	3400f2ae <HAL_RCCEx_PeriphCLKConfig+0x554e>
3400f28c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f290:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f292:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f296:	d00a      	beq.n	3400f2ae <HAL_RCCEx_PeriphCLKConfig+0x554e>
3400f298:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f29c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f29e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f2a2:	d004      	beq.n	3400f2ae <HAL_RCCEx_PeriphCLKConfig+0x554e>
3400f2a4:	f240 7179 	movw	r1, #1913	@ 0x779
3400f2a8:	4841      	ldr	r0, [pc, #260]	@ (3400f3b0 <HAL_RCCEx_PeriphCLKConfig+0x5650>)
3400f2aa:	f7f2 feb1 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400f2ae:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f2b2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400f2b4:	2b00      	cmp	r3, #0
3400f2b6:	d005      	beq.n	3400f2c4 <HAL_RCCEx_PeriphCLKConfig+0x5564>
3400f2b8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f2bc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400f2be:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400f2c2:	d904      	bls.n	3400f2ce <HAL_RCCEx_PeriphCLKConfig+0x556e>
3400f2c4:	f240 717a 	movw	r1, #1914	@ 0x77a
3400f2c8:	4839      	ldr	r0, [pc, #228]	@ (3400f3b0 <HAL_RCCEx_PeriphCLKConfig+0x5650>)
3400f2ca:	f7f2 fea1 	bl	34002010 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400f2ce:	4b39      	ldr	r3, [pc, #228]	@ (3400f3b4 <HAL_RCCEx_PeriphCLKConfig+0x5654>)
3400f2d0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400f2d4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400f2d8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400f2dc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f2e0:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400f2e2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f2e6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400f2e8:	3b01      	subs	r3, #1
3400f2ea:	041b      	lsls	r3, r3, #16
3400f2ec:	4313      	orrs	r3, r2
3400f2ee:	4a31      	ldr	r2, [pc, #196]	@ (3400f3b4 <HAL_RCCEx_PeriphCLKConfig+0x5654>)
3400f2f0:	430b      	orrs	r3, r1
3400f2f2:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400f2f6:	f7fa fa51 	bl	3400979c <LL_RCC_IC9_Enable>
3400f2fa:	e066      	b.n	3400f3ca <HAL_RCCEx_PeriphCLKConfig+0x566a>
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC14)
3400f2fc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f300:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
3400f304:	4b26      	ldr	r3, [pc, #152]	@ (3400f3a0 <HAL_RCCEx_PeriphCLKConfig+0x5640>)
3400f306:	429a      	cmp	r2, r3
3400f308:	d156      	bne.n	3400f3b8 <HAL_RCCEx_PeriphCLKConfig+0x5658>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400f30a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f30e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f310:	2b00      	cmp	r3, #0
3400f312:	d016      	beq.n	3400f342 <HAL_RCCEx_PeriphCLKConfig+0x55e2>
3400f314:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f318:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f31a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f31e:	d010      	beq.n	3400f342 <HAL_RCCEx_PeriphCLKConfig+0x55e2>
3400f320:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f324:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f326:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f32a:	d00a      	beq.n	3400f342 <HAL_RCCEx_PeriphCLKConfig+0x55e2>
3400f32c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f330:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f332:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f336:	d004      	beq.n	3400f342 <HAL_RCCEx_PeriphCLKConfig+0x55e2>
3400f338:	f240 7186 	movw	r1, #1926	@ 0x786
3400f33c:	481c      	ldr	r0, [pc, #112]	@ (3400f3b0 <HAL_RCCEx_PeriphCLKConfig+0x5650>)
3400f33e:	f7f2 fe67 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400f342:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f346:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400f348:	2b00      	cmp	r3, #0
3400f34a:	d005      	beq.n	3400f358 <HAL_RCCEx_PeriphCLKConfig+0x55f8>
3400f34c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f350:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400f352:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400f356:	d904      	bls.n	3400f362 <HAL_RCCEx_PeriphCLKConfig+0x5602>
3400f358:	f240 7187 	movw	r1, #1927	@ 0x787
3400f35c:	4814      	ldr	r0, [pc, #80]	@ (3400f3b0 <HAL_RCCEx_PeriphCLKConfig+0x5650>)
3400f35e:	f7f2 fe57 	bl	34002010 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400f362:	4b14      	ldr	r3, [pc, #80]	@ (3400f3b4 <HAL_RCCEx_PeriphCLKConfig+0x5654>)
3400f364:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400f368:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400f36c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400f370:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f374:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400f376:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f37a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400f37c:	3b01      	subs	r3, #1
3400f37e:	041b      	lsls	r3, r3, #16
3400f380:	4313      	orrs	r3, r2
3400f382:	4a0c      	ldr	r2, [pc, #48]	@ (3400f3b4 <HAL_RCCEx_PeriphCLKConfig+0x5654>)
3400f384:	430b      	orrs	r3, r1
3400f386:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400f38a:	f7fa fb07 	bl	3400999c <LL_RCC_IC14_Enable>
3400f38e:	e01c      	b.n	3400f3ca <HAL_RCCEx_PeriphCLKConfig+0x566a>
3400f390:	07010430 	.word	0x07010430
3400f394:	07000830 	.word	0x07000830
3400f398:	07010830 	.word	0x07010830
3400f39c:	07020830 	.word	0x07020830
3400f3a0:	07030830 	.word	0x07030830
3400f3a4:	07040830 	.word	0x07040830
3400f3a8:	07050830 	.word	0x07050830
3400f3ac:	07060830 	.word	0x07060830
3400f3b0:	3401ee60 	.word	0x3401ee60
3400f3b4:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_CLKP)
3400f3b8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f3bc:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
3400f3c0:	4b72      	ldr	r3, [pc, #456]	@ (3400f58c <HAL_RCCEx_PeriphCLKConfig+0x582c>)
3400f3c2:	429a      	cmp	r2, r3
3400f3c4:	d101      	bne.n	3400f3ca <HAL_RCCEx_PeriphCLKConfig+0x566a>
    {
      LL_RCC_CLKP_Enable();
3400f3c6:	f7fa fca9 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART3 clock */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
3400f3ca:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f3ce:	f8d3 3158 	ldr.w	r3, [r3, #344]	@ 0x158
3400f3d2:	4618      	mov	r0, r3
3400f3d4:	f7f9 fc45 	bl	34008c62 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART4 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
3400f3d8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f3dc:	e9d3 2300 	ldrd	r2, r3, [r3]
3400f3e0:	2100      	movs	r1, #0
3400f3e2:	65b9      	str	r1, [r7, #88]	@ 0x58
3400f3e4:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3400f3e8:	65fb      	str	r3, [r7, #92]	@ 0x5c
3400f3ea:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
3400f3ee:	4603      	mov	r3, r0
3400f3f0:	460a      	mov	r2, r1
3400f3f2:	4313      	orrs	r3, r2
3400f3f4:	f000 80ee 	beq.w	3400f5d4 <HAL_RCCEx_PeriphCLKConfig+0x5874>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));
3400f3f8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f3fc:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3400f400:	4b63      	ldr	r3, [pc, #396]	@ (3400f590 <HAL_RCCEx_PeriphCLKConfig+0x5830>)
3400f402:	429a      	cmp	r2, r3
3400f404:	d02e      	beq.n	3400f464 <HAL_RCCEx_PeriphCLKConfig+0x5704>
3400f406:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f40a:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3400f40e:	4b61      	ldr	r3, [pc, #388]	@ (3400f594 <HAL_RCCEx_PeriphCLKConfig+0x5834>)
3400f410:	429a      	cmp	r2, r3
3400f412:	d027      	beq.n	3400f464 <HAL_RCCEx_PeriphCLKConfig+0x5704>
3400f414:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f418:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3400f41c:	4b5e      	ldr	r3, [pc, #376]	@ (3400f598 <HAL_RCCEx_PeriphCLKConfig+0x5838>)
3400f41e:	429a      	cmp	r2, r3
3400f420:	d020      	beq.n	3400f464 <HAL_RCCEx_PeriphCLKConfig+0x5704>
3400f422:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f426:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3400f42a:	4b5c      	ldr	r3, [pc, #368]	@ (3400f59c <HAL_RCCEx_PeriphCLKConfig+0x583c>)
3400f42c:	429a      	cmp	r2, r3
3400f42e:	d019      	beq.n	3400f464 <HAL_RCCEx_PeriphCLKConfig+0x5704>
3400f430:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f434:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3400f438:	4b59      	ldr	r3, [pc, #356]	@ (3400f5a0 <HAL_RCCEx_PeriphCLKConfig+0x5840>)
3400f43a:	429a      	cmp	r2, r3
3400f43c:	d012      	beq.n	3400f464 <HAL_RCCEx_PeriphCLKConfig+0x5704>
3400f43e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f442:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3400f446:	4b57      	ldr	r3, [pc, #348]	@ (3400f5a4 <HAL_RCCEx_PeriphCLKConfig+0x5844>)
3400f448:	429a      	cmp	r2, r3
3400f44a:	d00b      	beq.n	3400f464 <HAL_RCCEx_PeriphCLKConfig+0x5704>
3400f44c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f450:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3400f454:	4b54      	ldr	r3, [pc, #336]	@ (3400f5a8 <HAL_RCCEx_PeriphCLKConfig+0x5848>)
3400f456:	429a      	cmp	r2, r3
3400f458:	d004      	beq.n	3400f464 <HAL_RCCEx_PeriphCLKConfig+0x5704>
3400f45a:	f240 71a1 	movw	r1, #1953	@ 0x7a1
3400f45e:	4853      	ldr	r0, [pc, #332]	@ (3400f5ac <HAL_RCCEx_PeriphCLKConfig+0x584c>)
3400f460:	f7f2 fdd6 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC9)
3400f464:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f468:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3400f46c:	4b4a      	ldr	r3, [pc, #296]	@ (3400f598 <HAL_RCCEx_PeriphCLKConfig+0x5838>)
3400f46e:	429a      	cmp	r2, r3
3400f470:	d142      	bne.n	3400f4f8 <HAL_RCCEx_PeriphCLKConfig+0x5798>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400f472:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f476:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f478:	2b00      	cmp	r3, #0
3400f47a:	d016      	beq.n	3400f4aa <HAL_RCCEx_PeriphCLKConfig+0x574a>
3400f47c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f480:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f482:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f486:	d010      	beq.n	3400f4aa <HAL_RCCEx_PeriphCLKConfig+0x574a>
3400f488:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f48c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f48e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f492:	d00a      	beq.n	3400f4aa <HAL_RCCEx_PeriphCLKConfig+0x574a>
3400f494:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f498:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f49a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f49e:	d004      	beq.n	3400f4aa <HAL_RCCEx_PeriphCLKConfig+0x574a>
3400f4a0:	f240 71a6 	movw	r1, #1958	@ 0x7a6
3400f4a4:	4841      	ldr	r0, [pc, #260]	@ (3400f5ac <HAL_RCCEx_PeriphCLKConfig+0x584c>)
3400f4a6:	f7f2 fdb3 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400f4aa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f4ae:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400f4b0:	2b00      	cmp	r3, #0
3400f4b2:	d005      	beq.n	3400f4c0 <HAL_RCCEx_PeriphCLKConfig+0x5760>
3400f4b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f4b8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400f4ba:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400f4be:	d904      	bls.n	3400f4ca <HAL_RCCEx_PeriphCLKConfig+0x576a>
3400f4c0:	f240 71a7 	movw	r1, #1959	@ 0x7a7
3400f4c4:	4839      	ldr	r0, [pc, #228]	@ (3400f5ac <HAL_RCCEx_PeriphCLKConfig+0x584c>)
3400f4c6:	f7f2 fda3 	bl	34002010 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400f4ca:	4b39      	ldr	r3, [pc, #228]	@ (3400f5b0 <HAL_RCCEx_PeriphCLKConfig+0x5850>)
3400f4cc:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400f4d0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400f4d4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400f4d8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f4dc:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400f4de:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f4e2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400f4e4:	3b01      	subs	r3, #1
3400f4e6:	041b      	lsls	r3, r3, #16
3400f4e8:	4313      	orrs	r3, r2
3400f4ea:	4a31      	ldr	r2, [pc, #196]	@ (3400f5b0 <HAL_RCCEx_PeriphCLKConfig+0x5850>)
3400f4ec:	430b      	orrs	r3, r1
3400f4ee:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400f4f2:	f7fa f953 	bl	3400979c <LL_RCC_IC9_Enable>
3400f4f6:	e066      	b.n	3400f5c6 <HAL_RCCEx_PeriphCLKConfig+0x5866>
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC14)
3400f4f8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f4fc:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3400f500:	4b26      	ldr	r3, [pc, #152]	@ (3400f59c <HAL_RCCEx_PeriphCLKConfig+0x583c>)
3400f502:	429a      	cmp	r2, r3
3400f504:	d156      	bne.n	3400f5b4 <HAL_RCCEx_PeriphCLKConfig+0x5854>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400f506:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f50a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f50c:	2b00      	cmp	r3, #0
3400f50e:	d016      	beq.n	3400f53e <HAL_RCCEx_PeriphCLKConfig+0x57de>
3400f510:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f514:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f516:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f51a:	d010      	beq.n	3400f53e <HAL_RCCEx_PeriphCLKConfig+0x57de>
3400f51c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f520:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f522:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f526:	d00a      	beq.n	3400f53e <HAL_RCCEx_PeriphCLKConfig+0x57de>
3400f528:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f52c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f52e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f532:	d004      	beq.n	3400f53e <HAL_RCCEx_PeriphCLKConfig+0x57de>
3400f534:	f240 71b3 	movw	r1, #1971	@ 0x7b3
3400f538:	481c      	ldr	r0, [pc, #112]	@ (3400f5ac <HAL_RCCEx_PeriphCLKConfig+0x584c>)
3400f53a:	f7f2 fd69 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400f53e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f542:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400f544:	2b00      	cmp	r3, #0
3400f546:	d005      	beq.n	3400f554 <HAL_RCCEx_PeriphCLKConfig+0x57f4>
3400f548:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f54c:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400f54e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400f552:	d904      	bls.n	3400f55e <HAL_RCCEx_PeriphCLKConfig+0x57fe>
3400f554:	f240 71b4 	movw	r1, #1972	@ 0x7b4
3400f558:	4814      	ldr	r0, [pc, #80]	@ (3400f5ac <HAL_RCCEx_PeriphCLKConfig+0x584c>)
3400f55a:	f7f2 fd59 	bl	34002010 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400f55e:	4b14      	ldr	r3, [pc, #80]	@ (3400f5b0 <HAL_RCCEx_PeriphCLKConfig+0x5850>)
3400f560:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400f564:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400f568:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400f56c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f570:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400f572:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f576:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400f578:	3b01      	subs	r3, #1
3400f57a:	041b      	lsls	r3, r3, #16
3400f57c:	4313      	orrs	r3, r2
3400f57e:	4a0c      	ldr	r2, [pc, #48]	@ (3400f5b0 <HAL_RCCEx_PeriphCLKConfig+0x5850>)
3400f580:	430b      	orrs	r3, r1
3400f582:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400f586:	f7fa fa09 	bl	3400999c <LL_RCC_IC14_Enable>
3400f58a:	e01c      	b.n	3400f5c6 <HAL_RCCEx_PeriphCLKConfig+0x5866>
3400f58c:	07010830 	.word	0x07010830
3400f590:	07000c30 	.word	0x07000c30
3400f594:	07010c30 	.word	0x07010c30
3400f598:	07020c30 	.word	0x07020c30
3400f59c:	07030c30 	.word	0x07030c30
3400f5a0:	07040c30 	.word	0x07040c30
3400f5a4:	07050c30 	.word	0x07050c30
3400f5a8:	07060c30 	.word	0x07060c30
3400f5ac:	3401ee60 	.word	0x3401ee60
3400f5b0:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_CLKP)
3400f5b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f5b8:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3400f5bc:	4b72      	ldr	r3, [pc, #456]	@ (3400f788 <HAL_RCCEx_PeriphCLKConfig+0x5a28>)
3400f5be:	429a      	cmp	r2, r3
3400f5c0:	d101      	bne.n	3400f5c6 <HAL_RCCEx_PeriphCLKConfig+0x5866>
    {
      LL_RCC_CLKP_Enable();
3400f5c2:	f7fa fbab 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART4 clock */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
3400f5c6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f5ca:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400f5ce:	4618      	mov	r0, r3
3400f5d0:	f7f9 fb47 	bl	34008c62 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART5 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
3400f5d4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f5d8:	e9d3 2300 	ldrd	r2, r3, [r3]
3400f5dc:	2100      	movs	r1, #0
3400f5de:	6539      	str	r1, [r7, #80]	@ 0x50
3400f5e0:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3400f5e4:	657b      	str	r3, [r7, #84]	@ 0x54
3400f5e6:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
3400f5ea:	4603      	mov	r3, r0
3400f5ec:	460a      	mov	r2, r1
3400f5ee:	4313      	orrs	r3, r2
3400f5f0:	f000 80ee 	beq.w	3400f7d0 <HAL_RCCEx_PeriphCLKConfig+0x5a70>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));
3400f5f4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f5f8:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
3400f5fc:	4b63      	ldr	r3, [pc, #396]	@ (3400f78c <HAL_RCCEx_PeriphCLKConfig+0x5a2c>)
3400f5fe:	429a      	cmp	r2, r3
3400f600:	d02e      	beq.n	3400f660 <HAL_RCCEx_PeriphCLKConfig+0x5900>
3400f602:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f606:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
3400f60a:	4b61      	ldr	r3, [pc, #388]	@ (3400f790 <HAL_RCCEx_PeriphCLKConfig+0x5a30>)
3400f60c:	429a      	cmp	r2, r3
3400f60e:	d027      	beq.n	3400f660 <HAL_RCCEx_PeriphCLKConfig+0x5900>
3400f610:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f614:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
3400f618:	4b5e      	ldr	r3, [pc, #376]	@ (3400f794 <HAL_RCCEx_PeriphCLKConfig+0x5a34>)
3400f61a:	429a      	cmp	r2, r3
3400f61c:	d020      	beq.n	3400f660 <HAL_RCCEx_PeriphCLKConfig+0x5900>
3400f61e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f622:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
3400f626:	4b5c      	ldr	r3, [pc, #368]	@ (3400f798 <HAL_RCCEx_PeriphCLKConfig+0x5a38>)
3400f628:	429a      	cmp	r2, r3
3400f62a:	d019      	beq.n	3400f660 <HAL_RCCEx_PeriphCLKConfig+0x5900>
3400f62c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f630:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
3400f634:	4b59      	ldr	r3, [pc, #356]	@ (3400f79c <HAL_RCCEx_PeriphCLKConfig+0x5a3c>)
3400f636:	429a      	cmp	r2, r3
3400f638:	d012      	beq.n	3400f660 <HAL_RCCEx_PeriphCLKConfig+0x5900>
3400f63a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f63e:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
3400f642:	4b57      	ldr	r3, [pc, #348]	@ (3400f7a0 <HAL_RCCEx_PeriphCLKConfig+0x5a40>)
3400f644:	429a      	cmp	r2, r3
3400f646:	d00b      	beq.n	3400f660 <HAL_RCCEx_PeriphCLKConfig+0x5900>
3400f648:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f64c:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
3400f650:	4b54      	ldr	r3, [pc, #336]	@ (3400f7a4 <HAL_RCCEx_PeriphCLKConfig+0x5a44>)
3400f652:	429a      	cmp	r2, r3
3400f654:	d004      	beq.n	3400f660 <HAL_RCCEx_PeriphCLKConfig+0x5900>
3400f656:	f240 71ce 	movw	r1, #1998	@ 0x7ce
3400f65a:	4853      	ldr	r0, [pc, #332]	@ (3400f7a8 <HAL_RCCEx_PeriphCLKConfig+0x5a48>)
3400f65c:	f7f2 fcd8 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC9)
3400f660:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f664:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
3400f668:	4b4a      	ldr	r3, [pc, #296]	@ (3400f794 <HAL_RCCEx_PeriphCLKConfig+0x5a34>)
3400f66a:	429a      	cmp	r2, r3
3400f66c:	d142      	bne.n	3400f6f4 <HAL_RCCEx_PeriphCLKConfig+0x5994>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400f66e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f672:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f674:	2b00      	cmp	r3, #0
3400f676:	d016      	beq.n	3400f6a6 <HAL_RCCEx_PeriphCLKConfig+0x5946>
3400f678:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f67c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f67e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f682:	d010      	beq.n	3400f6a6 <HAL_RCCEx_PeriphCLKConfig+0x5946>
3400f684:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f688:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f68a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f68e:	d00a      	beq.n	3400f6a6 <HAL_RCCEx_PeriphCLKConfig+0x5946>
3400f690:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f694:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f696:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f69a:	d004      	beq.n	3400f6a6 <HAL_RCCEx_PeriphCLKConfig+0x5946>
3400f69c:	f240 71d3 	movw	r1, #2003	@ 0x7d3
3400f6a0:	4841      	ldr	r0, [pc, #260]	@ (3400f7a8 <HAL_RCCEx_PeriphCLKConfig+0x5a48>)
3400f6a2:	f7f2 fcb5 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400f6a6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f6aa:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400f6ac:	2b00      	cmp	r3, #0
3400f6ae:	d005      	beq.n	3400f6bc <HAL_RCCEx_PeriphCLKConfig+0x595c>
3400f6b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f6b4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400f6b6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400f6ba:	d904      	bls.n	3400f6c6 <HAL_RCCEx_PeriphCLKConfig+0x5966>
3400f6bc:	f240 71d4 	movw	r1, #2004	@ 0x7d4
3400f6c0:	4839      	ldr	r0, [pc, #228]	@ (3400f7a8 <HAL_RCCEx_PeriphCLKConfig+0x5a48>)
3400f6c2:	f7f2 fca5 	bl	34002010 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400f6c6:	4b39      	ldr	r3, [pc, #228]	@ (3400f7ac <HAL_RCCEx_PeriphCLKConfig+0x5a4c>)
3400f6c8:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400f6cc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400f6d0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400f6d4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f6d8:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400f6da:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f6de:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400f6e0:	3b01      	subs	r3, #1
3400f6e2:	041b      	lsls	r3, r3, #16
3400f6e4:	4313      	orrs	r3, r2
3400f6e6:	4a31      	ldr	r2, [pc, #196]	@ (3400f7ac <HAL_RCCEx_PeriphCLKConfig+0x5a4c>)
3400f6e8:	430b      	orrs	r3, r1
3400f6ea:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400f6ee:	f7fa f855 	bl	3400979c <LL_RCC_IC9_Enable>
3400f6f2:	e066      	b.n	3400f7c2 <HAL_RCCEx_PeriphCLKConfig+0x5a62>
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC14)
3400f6f4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f6f8:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
3400f6fc:	4b26      	ldr	r3, [pc, #152]	@ (3400f798 <HAL_RCCEx_PeriphCLKConfig+0x5a38>)
3400f6fe:	429a      	cmp	r2, r3
3400f700:	d156      	bne.n	3400f7b0 <HAL_RCCEx_PeriphCLKConfig+0x5a50>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400f702:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f706:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f708:	2b00      	cmp	r3, #0
3400f70a:	d016      	beq.n	3400f73a <HAL_RCCEx_PeriphCLKConfig+0x59da>
3400f70c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f710:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f712:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f716:	d010      	beq.n	3400f73a <HAL_RCCEx_PeriphCLKConfig+0x59da>
3400f718:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f71c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f71e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f722:	d00a      	beq.n	3400f73a <HAL_RCCEx_PeriphCLKConfig+0x59da>
3400f724:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f728:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f72a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f72e:	d004      	beq.n	3400f73a <HAL_RCCEx_PeriphCLKConfig+0x59da>
3400f730:	f44f 61fc 	mov.w	r1, #2016	@ 0x7e0
3400f734:	481c      	ldr	r0, [pc, #112]	@ (3400f7a8 <HAL_RCCEx_PeriphCLKConfig+0x5a48>)
3400f736:	f7f2 fc6b 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400f73a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f73e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400f740:	2b00      	cmp	r3, #0
3400f742:	d005      	beq.n	3400f750 <HAL_RCCEx_PeriphCLKConfig+0x59f0>
3400f744:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f748:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400f74a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400f74e:	d904      	bls.n	3400f75a <HAL_RCCEx_PeriphCLKConfig+0x59fa>
3400f750:	f240 71e1 	movw	r1, #2017	@ 0x7e1
3400f754:	4814      	ldr	r0, [pc, #80]	@ (3400f7a8 <HAL_RCCEx_PeriphCLKConfig+0x5a48>)
3400f756:	f7f2 fc5b 	bl	34002010 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400f75a:	4b14      	ldr	r3, [pc, #80]	@ (3400f7ac <HAL_RCCEx_PeriphCLKConfig+0x5a4c>)
3400f75c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400f760:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400f764:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400f768:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f76c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400f76e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f772:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400f774:	3b01      	subs	r3, #1
3400f776:	041b      	lsls	r3, r3, #16
3400f778:	4313      	orrs	r3, r2
3400f77a:	4a0c      	ldr	r2, [pc, #48]	@ (3400f7ac <HAL_RCCEx_PeriphCLKConfig+0x5a4c>)
3400f77c:	430b      	orrs	r3, r1
3400f77e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400f782:	f7fa f90b 	bl	3400999c <LL_RCC_IC14_Enable>
3400f786:	e01c      	b.n	3400f7c2 <HAL_RCCEx_PeriphCLKConfig+0x5a62>
3400f788:	07010c30 	.word	0x07010c30
3400f78c:	07001030 	.word	0x07001030
3400f790:	07011030 	.word	0x07011030
3400f794:	07021030 	.word	0x07021030
3400f798:	07031030 	.word	0x07031030
3400f79c:	07041030 	.word	0x07041030
3400f7a0:	07051030 	.word	0x07051030
3400f7a4:	07061030 	.word	0x07061030
3400f7a8:	3401ee60 	.word	0x3401ee60
3400f7ac:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_CLKP)
3400f7b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f7b4:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
3400f7b8:	4b72      	ldr	r3, [pc, #456]	@ (3400f984 <HAL_RCCEx_PeriphCLKConfig+0x5c24>)
3400f7ba:	429a      	cmp	r2, r3
3400f7bc:	d101      	bne.n	3400f7c2 <HAL_RCCEx_PeriphCLKConfig+0x5a62>
    {
      LL_RCC_CLKP_Enable();
3400f7be:	f7fa faad 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART5 clock */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
3400f7c2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f7c6:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
3400f7ca:	4618      	mov	r0, r3
3400f7cc:	f7f9 fa49 	bl	34008c62 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
3400f7d0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f7d4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400f7d8:	2100      	movs	r1, #0
3400f7da:	64b9      	str	r1, [r7, #72]	@ 0x48
3400f7dc:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
3400f7e0:	64fb      	str	r3, [r7, #76]	@ 0x4c
3400f7e2:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
3400f7e6:	4603      	mov	r3, r0
3400f7e8:	460a      	mov	r2, r1
3400f7ea:	4313      	orrs	r3, r2
3400f7ec:	f000 80ee 	beq.w	3400f9cc <HAL_RCCEx_PeriphCLKConfig+0x5c6c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));
3400f7f0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f7f4:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3400f7f8:	4b63      	ldr	r3, [pc, #396]	@ (3400f988 <HAL_RCCEx_PeriphCLKConfig+0x5c28>)
3400f7fa:	429a      	cmp	r2, r3
3400f7fc:	d02e      	beq.n	3400f85c <HAL_RCCEx_PeriphCLKConfig+0x5afc>
3400f7fe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f802:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3400f806:	4b61      	ldr	r3, [pc, #388]	@ (3400f98c <HAL_RCCEx_PeriphCLKConfig+0x5c2c>)
3400f808:	429a      	cmp	r2, r3
3400f80a:	d027      	beq.n	3400f85c <HAL_RCCEx_PeriphCLKConfig+0x5afc>
3400f80c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f810:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3400f814:	4b5e      	ldr	r3, [pc, #376]	@ (3400f990 <HAL_RCCEx_PeriphCLKConfig+0x5c30>)
3400f816:	429a      	cmp	r2, r3
3400f818:	d020      	beq.n	3400f85c <HAL_RCCEx_PeriphCLKConfig+0x5afc>
3400f81a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f81e:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3400f822:	4b5c      	ldr	r3, [pc, #368]	@ (3400f994 <HAL_RCCEx_PeriphCLKConfig+0x5c34>)
3400f824:	429a      	cmp	r2, r3
3400f826:	d019      	beq.n	3400f85c <HAL_RCCEx_PeriphCLKConfig+0x5afc>
3400f828:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f82c:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3400f830:	4b59      	ldr	r3, [pc, #356]	@ (3400f998 <HAL_RCCEx_PeriphCLKConfig+0x5c38>)
3400f832:	429a      	cmp	r2, r3
3400f834:	d012      	beq.n	3400f85c <HAL_RCCEx_PeriphCLKConfig+0x5afc>
3400f836:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f83a:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3400f83e:	4b57      	ldr	r3, [pc, #348]	@ (3400f99c <HAL_RCCEx_PeriphCLKConfig+0x5c3c>)
3400f840:	429a      	cmp	r2, r3
3400f842:	d00b      	beq.n	3400f85c <HAL_RCCEx_PeriphCLKConfig+0x5afc>
3400f844:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f848:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3400f84c:	4b54      	ldr	r3, [pc, #336]	@ (3400f9a0 <HAL_RCCEx_PeriphCLKConfig+0x5c40>)
3400f84e:	429a      	cmp	r2, r3
3400f850:	d004      	beq.n	3400f85c <HAL_RCCEx_PeriphCLKConfig+0x5afc>
3400f852:	f240 71fb 	movw	r1, #2043	@ 0x7fb
3400f856:	4853      	ldr	r0, [pc, #332]	@ (3400f9a4 <HAL_RCCEx_PeriphCLKConfig+0x5c44>)
3400f858:	f7f2 fbda 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC9)
3400f85c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f860:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3400f864:	4b4a      	ldr	r3, [pc, #296]	@ (3400f990 <HAL_RCCEx_PeriphCLKConfig+0x5c30>)
3400f866:	429a      	cmp	r2, r3
3400f868:	d142      	bne.n	3400f8f0 <HAL_RCCEx_PeriphCLKConfig+0x5b90>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400f86a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f86e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f870:	2b00      	cmp	r3, #0
3400f872:	d016      	beq.n	3400f8a2 <HAL_RCCEx_PeriphCLKConfig+0x5b42>
3400f874:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f878:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f87a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f87e:	d010      	beq.n	3400f8a2 <HAL_RCCEx_PeriphCLKConfig+0x5b42>
3400f880:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f884:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f886:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f88a:	d00a      	beq.n	3400f8a2 <HAL_RCCEx_PeriphCLKConfig+0x5b42>
3400f88c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f890:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f892:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f896:	d004      	beq.n	3400f8a2 <HAL_RCCEx_PeriphCLKConfig+0x5b42>
3400f898:	f44f 6100 	mov.w	r1, #2048	@ 0x800
3400f89c:	4841      	ldr	r0, [pc, #260]	@ (3400f9a4 <HAL_RCCEx_PeriphCLKConfig+0x5c44>)
3400f89e:	f7f2 fbb7 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400f8a2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f8a6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400f8a8:	2b00      	cmp	r3, #0
3400f8aa:	d005      	beq.n	3400f8b8 <HAL_RCCEx_PeriphCLKConfig+0x5b58>
3400f8ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f8b0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400f8b2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400f8b6:	d904      	bls.n	3400f8c2 <HAL_RCCEx_PeriphCLKConfig+0x5b62>
3400f8b8:	f640 0101 	movw	r1, #2049	@ 0x801
3400f8bc:	4839      	ldr	r0, [pc, #228]	@ (3400f9a4 <HAL_RCCEx_PeriphCLKConfig+0x5c44>)
3400f8be:	f7f2 fba7 	bl	34002010 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400f8c2:	4b39      	ldr	r3, [pc, #228]	@ (3400f9a8 <HAL_RCCEx_PeriphCLKConfig+0x5c48>)
3400f8c4:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400f8c8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400f8cc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400f8d0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f8d4:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400f8d6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f8da:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400f8dc:	3b01      	subs	r3, #1
3400f8de:	041b      	lsls	r3, r3, #16
3400f8e0:	4313      	orrs	r3, r2
3400f8e2:	4a31      	ldr	r2, [pc, #196]	@ (3400f9a8 <HAL_RCCEx_PeriphCLKConfig+0x5c48>)
3400f8e4:	430b      	orrs	r3, r1
3400f8e6:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400f8ea:	f7f9 ff57 	bl	3400979c <LL_RCC_IC9_Enable>
3400f8ee:	e066      	b.n	3400f9be <HAL_RCCEx_PeriphCLKConfig+0x5c5e>
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC14)
3400f8f0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f8f4:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3400f8f8:	4b26      	ldr	r3, [pc, #152]	@ (3400f994 <HAL_RCCEx_PeriphCLKConfig+0x5c34>)
3400f8fa:	429a      	cmp	r2, r3
3400f8fc:	d156      	bne.n	3400f9ac <HAL_RCCEx_PeriphCLKConfig+0x5c4c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400f8fe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f902:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f904:	2b00      	cmp	r3, #0
3400f906:	d016      	beq.n	3400f936 <HAL_RCCEx_PeriphCLKConfig+0x5bd6>
3400f908:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f90c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f90e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f912:	d010      	beq.n	3400f936 <HAL_RCCEx_PeriphCLKConfig+0x5bd6>
3400f914:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f918:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f91a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f91e:	d00a      	beq.n	3400f936 <HAL_RCCEx_PeriphCLKConfig+0x5bd6>
3400f920:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f924:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400f926:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f92a:	d004      	beq.n	3400f936 <HAL_RCCEx_PeriphCLKConfig+0x5bd6>
3400f92c:	f640 010d 	movw	r1, #2061	@ 0x80d
3400f930:	481c      	ldr	r0, [pc, #112]	@ (3400f9a4 <HAL_RCCEx_PeriphCLKConfig+0x5c44>)
3400f932:	f7f2 fb6d 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400f936:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f93a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400f93c:	2b00      	cmp	r3, #0
3400f93e:	d005      	beq.n	3400f94c <HAL_RCCEx_PeriphCLKConfig+0x5bec>
3400f940:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f944:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400f946:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400f94a:	d904      	bls.n	3400f956 <HAL_RCCEx_PeriphCLKConfig+0x5bf6>
3400f94c:	f640 010e 	movw	r1, #2062	@ 0x80e
3400f950:	4814      	ldr	r0, [pc, #80]	@ (3400f9a4 <HAL_RCCEx_PeriphCLKConfig+0x5c44>)
3400f952:	f7f2 fb5d 	bl	34002010 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400f956:	4b14      	ldr	r3, [pc, #80]	@ (3400f9a8 <HAL_RCCEx_PeriphCLKConfig+0x5c48>)
3400f958:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400f95c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400f960:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400f964:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f968:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400f96a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f96e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400f970:	3b01      	subs	r3, #1
3400f972:	041b      	lsls	r3, r3, #16
3400f974:	4313      	orrs	r3, r2
3400f976:	4a0c      	ldr	r2, [pc, #48]	@ (3400f9a8 <HAL_RCCEx_PeriphCLKConfig+0x5c48>)
3400f978:	430b      	orrs	r3, r1
3400f97a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400f97e:	f7fa f80d 	bl	3400999c <LL_RCC_IC14_Enable>
3400f982:	e01c      	b.n	3400f9be <HAL_RCCEx_PeriphCLKConfig+0x5c5e>
3400f984:	07011030 	.word	0x07011030
3400f988:	07001430 	.word	0x07001430
3400f98c:	07011430 	.word	0x07011430
3400f990:	07021430 	.word	0x07021430
3400f994:	07031430 	.word	0x07031430
3400f998:	07041430 	.word	0x07041430
3400f99c:	07051430 	.word	0x07051430
3400f9a0:	07061430 	.word	0x07061430
3400f9a4:	3401ee60 	.word	0x3401ee60
3400f9a8:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_CLKP)
3400f9ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f9b0:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3400f9b4:	4b72      	ldr	r3, [pc, #456]	@ (3400fb80 <HAL_RCCEx_PeriphCLKConfig+0x5e20>)
3400f9b6:	429a      	cmp	r2, r3
3400f9b8:	d101      	bne.n	3400f9be <HAL_RCCEx_PeriphCLKConfig+0x5c5e>
    {
      LL_RCC_CLKP_Enable();
3400f9ba:	f7fa f9af 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART6 clock */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
3400f9be:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f9c2:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
3400f9c6:	4618      	mov	r0, r3
3400f9c8:	f7f9 f94b 	bl	34008c62 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART7 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
3400f9cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f9d0:	e9d3 2300 	ldrd	r2, r3, [r3]
3400f9d4:	2100      	movs	r1, #0
3400f9d6:	6439      	str	r1, [r7, #64]	@ 0x40
3400f9d8:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3400f9dc:	647b      	str	r3, [r7, #68]	@ 0x44
3400f9de:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
3400f9e2:	4603      	mov	r3, r0
3400f9e4:	460a      	mov	r2, r1
3400f9e6:	4313      	orrs	r3, r2
3400f9e8:	f000 80ee 	beq.w	3400fbc8 <HAL_RCCEx_PeriphCLKConfig+0x5e68>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));
3400f9ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f9f0:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
3400f9f4:	4b63      	ldr	r3, [pc, #396]	@ (3400fb84 <HAL_RCCEx_PeriphCLKConfig+0x5e24>)
3400f9f6:	429a      	cmp	r2, r3
3400f9f8:	d02e      	beq.n	3400fa58 <HAL_RCCEx_PeriphCLKConfig+0x5cf8>
3400f9fa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f9fe:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
3400fa02:	4b61      	ldr	r3, [pc, #388]	@ (3400fb88 <HAL_RCCEx_PeriphCLKConfig+0x5e28>)
3400fa04:	429a      	cmp	r2, r3
3400fa06:	d027      	beq.n	3400fa58 <HAL_RCCEx_PeriphCLKConfig+0x5cf8>
3400fa08:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fa0c:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
3400fa10:	4b5e      	ldr	r3, [pc, #376]	@ (3400fb8c <HAL_RCCEx_PeriphCLKConfig+0x5e2c>)
3400fa12:	429a      	cmp	r2, r3
3400fa14:	d020      	beq.n	3400fa58 <HAL_RCCEx_PeriphCLKConfig+0x5cf8>
3400fa16:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fa1a:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
3400fa1e:	4b5c      	ldr	r3, [pc, #368]	@ (3400fb90 <HAL_RCCEx_PeriphCLKConfig+0x5e30>)
3400fa20:	429a      	cmp	r2, r3
3400fa22:	d019      	beq.n	3400fa58 <HAL_RCCEx_PeriphCLKConfig+0x5cf8>
3400fa24:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fa28:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
3400fa2c:	4b59      	ldr	r3, [pc, #356]	@ (3400fb94 <HAL_RCCEx_PeriphCLKConfig+0x5e34>)
3400fa2e:	429a      	cmp	r2, r3
3400fa30:	d012      	beq.n	3400fa58 <HAL_RCCEx_PeriphCLKConfig+0x5cf8>
3400fa32:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fa36:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
3400fa3a:	4b57      	ldr	r3, [pc, #348]	@ (3400fb98 <HAL_RCCEx_PeriphCLKConfig+0x5e38>)
3400fa3c:	429a      	cmp	r2, r3
3400fa3e:	d00b      	beq.n	3400fa58 <HAL_RCCEx_PeriphCLKConfig+0x5cf8>
3400fa40:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fa44:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
3400fa48:	4b54      	ldr	r3, [pc, #336]	@ (3400fb9c <HAL_RCCEx_PeriphCLKConfig+0x5e3c>)
3400fa4a:	429a      	cmp	r2, r3
3400fa4c:	d004      	beq.n	3400fa58 <HAL_RCCEx_PeriphCLKConfig+0x5cf8>
3400fa4e:	f640 0128 	movw	r1, #2088	@ 0x828
3400fa52:	4853      	ldr	r0, [pc, #332]	@ (3400fba0 <HAL_RCCEx_PeriphCLKConfig+0x5e40>)
3400fa54:	f7f2 fadc 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC9)
3400fa58:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fa5c:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
3400fa60:	4b4a      	ldr	r3, [pc, #296]	@ (3400fb8c <HAL_RCCEx_PeriphCLKConfig+0x5e2c>)
3400fa62:	429a      	cmp	r2, r3
3400fa64:	d142      	bne.n	3400faec <HAL_RCCEx_PeriphCLKConfig+0x5d8c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400fa66:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fa6a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400fa6c:	2b00      	cmp	r3, #0
3400fa6e:	d016      	beq.n	3400fa9e <HAL_RCCEx_PeriphCLKConfig+0x5d3e>
3400fa70:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fa74:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400fa76:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400fa7a:	d010      	beq.n	3400fa9e <HAL_RCCEx_PeriphCLKConfig+0x5d3e>
3400fa7c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fa80:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400fa82:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400fa86:	d00a      	beq.n	3400fa9e <HAL_RCCEx_PeriphCLKConfig+0x5d3e>
3400fa88:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fa8c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400fa8e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400fa92:	d004      	beq.n	3400fa9e <HAL_RCCEx_PeriphCLKConfig+0x5d3e>
3400fa94:	f640 012d 	movw	r1, #2093	@ 0x82d
3400fa98:	4841      	ldr	r0, [pc, #260]	@ (3400fba0 <HAL_RCCEx_PeriphCLKConfig+0x5e40>)
3400fa9a:	f7f2 fab9 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400fa9e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400faa2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400faa4:	2b00      	cmp	r3, #0
3400faa6:	d005      	beq.n	3400fab4 <HAL_RCCEx_PeriphCLKConfig+0x5d54>
3400faa8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400faac:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400faae:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400fab2:	d904      	bls.n	3400fabe <HAL_RCCEx_PeriphCLKConfig+0x5d5e>
3400fab4:	f640 012e 	movw	r1, #2094	@ 0x82e
3400fab8:	4839      	ldr	r0, [pc, #228]	@ (3400fba0 <HAL_RCCEx_PeriphCLKConfig+0x5e40>)
3400faba:	f7f2 faa9 	bl	34002010 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400fabe:	4b39      	ldr	r3, [pc, #228]	@ (3400fba4 <HAL_RCCEx_PeriphCLKConfig+0x5e44>)
3400fac0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400fac4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400fac8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400facc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fad0:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400fad2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fad6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400fad8:	3b01      	subs	r3, #1
3400fada:	041b      	lsls	r3, r3, #16
3400fadc:	4313      	orrs	r3, r2
3400fade:	4a31      	ldr	r2, [pc, #196]	@ (3400fba4 <HAL_RCCEx_PeriphCLKConfig+0x5e44>)
3400fae0:	430b      	orrs	r3, r1
3400fae2:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400fae6:	f7f9 fe59 	bl	3400979c <LL_RCC_IC9_Enable>
3400faea:	e066      	b.n	3400fbba <HAL_RCCEx_PeriphCLKConfig+0x5e5a>
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC14)
3400faec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400faf0:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
3400faf4:	4b26      	ldr	r3, [pc, #152]	@ (3400fb90 <HAL_RCCEx_PeriphCLKConfig+0x5e30>)
3400faf6:	429a      	cmp	r2, r3
3400faf8:	d156      	bne.n	3400fba8 <HAL_RCCEx_PeriphCLKConfig+0x5e48>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400fafa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fafe:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400fb00:	2b00      	cmp	r3, #0
3400fb02:	d016      	beq.n	3400fb32 <HAL_RCCEx_PeriphCLKConfig+0x5dd2>
3400fb04:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fb08:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400fb0a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400fb0e:	d010      	beq.n	3400fb32 <HAL_RCCEx_PeriphCLKConfig+0x5dd2>
3400fb10:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fb14:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400fb16:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400fb1a:	d00a      	beq.n	3400fb32 <HAL_RCCEx_PeriphCLKConfig+0x5dd2>
3400fb1c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fb20:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400fb22:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400fb26:	d004      	beq.n	3400fb32 <HAL_RCCEx_PeriphCLKConfig+0x5dd2>
3400fb28:	f640 013a 	movw	r1, #2106	@ 0x83a
3400fb2c:	481c      	ldr	r0, [pc, #112]	@ (3400fba0 <HAL_RCCEx_PeriphCLKConfig+0x5e40>)
3400fb2e:	f7f2 fa6f 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400fb32:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fb36:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400fb38:	2b00      	cmp	r3, #0
3400fb3a:	d005      	beq.n	3400fb48 <HAL_RCCEx_PeriphCLKConfig+0x5de8>
3400fb3c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fb40:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400fb42:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400fb46:	d904      	bls.n	3400fb52 <HAL_RCCEx_PeriphCLKConfig+0x5df2>
3400fb48:	f640 013b 	movw	r1, #2107	@ 0x83b
3400fb4c:	4814      	ldr	r0, [pc, #80]	@ (3400fba0 <HAL_RCCEx_PeriphCLKConfig+0x5e40>)
3400fb4e:	f7f2 fa5f 	bl	34002010 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400fb52:	4b14      	ldr	r3, [pc, #80]	@ (3400fba4 <HAL_RCCEx_PeriphCLKConfig+0x5e44>)
3400fb54:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400fb58:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400fb5c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400fb60:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fb64:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400fb66:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fb6a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400fb6c:	3b01      	subs	r3, #1
3400fb6e:	041b      	lsls	r3, r3, #16
3400fb70:	4313      	orrs	r3, r2
3400fb72:	4a0c      	ldr	r2, [pc, #48]	@ (3400fba4 <HAL_RCCEx_PeriphCLKConfig+0x5e44>)
3400fb74:	430b      	orrs	r3, r1
3400fb76:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400fb7a:	f7f9 ff0f 	bl	3400999c <LL_RCC_IC14_Enable>
3400fb7e:	e01c      	b.n	3400fbba <HAL_RCCEx_PeriphCLKConfig+0x5e5a>
3400fb80:	07011430 	.word	0x07011430
3400fb84:	07001830 	.word	0x07001830
3400fb88:	07011830 	.word	0x07011830
3400fb8c:	07021830 	.word	0x07021830
3400fb90:	07031830 	.word	0x07031830
3400fb94:	07041830 	.word	0x07041830
3400fb98:	07051830 	.word	0x07051830
3400fb9c:	07061830 	.word	0x07061830
3400fba0:	3401ee60 	.word	0x3401ee60
3400fba4:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_CLKP)
3400fba8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fbac:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
3400fbb0:	4b72      	ldr	r3, [pc, #456]	@ (3400fd7c <HAL_RCCEx_PeriphCLKConfig+0x601c>)
3400fbb2:	429a      	cmp	r2, r3
3400fbb4:	d101      	bne.n	3400fbba <HAL_RCCEx_PeriphCLKConfig+0x5e5a>
    {
      LL_RCC_CLKP_Enable();
3400fbb6:	f7fa f8b1 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART7 clock */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
3400fbba:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fbbe:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
3400fbc2:	4618      	mov	r0, r3
3400fbc4:	f7f9 f84d 	bl	34008c62 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART8 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
3400fbc8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fbcc:	e9d3 2300 	ldrd	r2, r3, [r3]
3400fbd0:	2100      	movs	r1, #0
3400fbd2:	63b9      	str	r1, [r7, #56]	@ 0x38
3400fbd4:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
3400fbd8:	63fb      	str	r3, [r7, #60]	@ 0x3c
3400fbda:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
3400fbde:	4603      	mov	r3, r0
3400fbe0:	460a      	mov	r2, r1
3400fbe2:	4313      	orrs	r3, r2
3400fbe4:	f000 80ee 	beq.w	3400fdc4 <HAL_RCCEx_PeriphCLKConfig+0x6064>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));
3400fbe8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fbec:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
3400fbf0:	4b63      	ldr	r3, [pc, #396]	@ (3400fd80 <HAL_RCCEx_PeriphCLKConfig+0x6020>)
3400fbf2:	429a      	cmp	r2, r3
3400fbf4:	d02e      	beq.n	3400fc54 <HAL_RCCEx_PeriphCLKConfig+0x5ef4>
3400fbf6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fbfa:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
3400fbfe:	4b61      	ldr	r3, [pc, #388]	@ (3400fd84 <HAL_RCCEx_PeriphCLKConfig+0x6024>)
3400fc00:	429a      	cmp	r2, r3
3400fc02:	d027      	beq.n	3400fc54 <HAL_RCCEx_PeriphCLKConfig+0x5ef4>
3400fc04:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc08:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
3400fc0c:	4b5e      	ldr	r3, [pc, #376]	@ (3400fd88 <HAL_RCCEx_PeriphCLKConfig+0x6028>)
3400fc0e:	429a      	cmp	r2, r3
3400fc10:	d020      	beq.n	3400fc54 <HAL_RCCEx_PeriphCLKConfig+0x5ef4>
3400fc12:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc16:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
3400fc1a:	4b5c      	ldr	r3, [pc, #368]	@ (3400fd8c <HAL_RCCEx_PeriphCLKConfig+0x602c>)
3400fc1c:	429a      	cmp	r2, r3
3400fc1e:	d019      	beq.n	3400fc54 <HAL_RCCEx_PeriphCLKConfig+0x5ef4>
3400fc20:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc24:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
3400fc28:	4b59      	ldr	r3, [pc, #356]	@ (3400fd90 <HAL_RCCEx_PeriphCLKConfig+0x6030>)
3400fc2a:	429a      	cmp	r2, r3
3400fc2c:	d012      	beq.n	3400fc54 <HAL_RCCEx_PeriphCLKConfig+0x5ef4>
3400fc2e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc32:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
3400fc36:	4b57      	ldr	r3, [pc, #348]	@ (3400fd94 <HAL_RCCEx_PeriphCLKConfig+0x6034>)
3400fc38:	429a      	cmp	r2, r3
3400fc3a:	d00b      	beq.n	3400fc54 <HAL_RCCEx_PeriphCLKConfig+0x5ef4>
3400fc3c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc40:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
3400fc44:	4b54      	ldr	r3, [pc, #336]	@ (3400fd98 <HAL_RCCEx_PeriphCLKConfig+0x6038>)
3400fc46:	429a      	cmp	r2, r3
3400fc48:	d004      	beq.n	3400fc54 <HAL_RCCEx_PeriphCLKConfig+0x5ef4>
3400fc4a:	f640 0155 	movw	r1, #2133	@ 0x855
3400fc4e:	4853      	ldr	r0, [pc, #332]	@ (3400fd9c <HAL_RCCEx_PeriphCLKConfig+0x603c>)
3400fc50:	f7f2 f9de 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC9)
3400fc54:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc58:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
3400fc5c:	4b4a      	ldr	r3, [pc, #296]	@ (3400fd88 <HAL_RCCEx_PeriphCLKConfig+0x6028>)
3400fc5e:	429a      	cmp	r2, r3
3400fc60:	d142      	bne.n	3400fce8 <HAL_RCCEx_PeriphCLKConfig+0x5f88>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400fc62:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc66:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400fc68:	2b00      	cmp	r3, #0
3400fc6a:	d016      	beq.n	3400fc9a <HAL_RCCEx_PeriphCLKConfig+0x5f3a>
3400fc6c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc70:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400fc72:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400fc76:	d010      	beq.n	3400fc9a <HAL_RCCEx_PeriphCLKConfig+0x5f3a>
3400fc78:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc7c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400fc7e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400fc82:	d00a      	beq.n	3400fc9a <HAL_RCCEx_PeriphCLKConfig+0x5f3a>
3400fc84:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc88:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400fc8a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400fc8e:	d004      	beq.n	3400fc9a <HAL_RCCEx_PeriphCLKConfig+0x5f3a>
3400fc90:	f640 015a 	movw	r1, #2138	@ 0x85a
3400fc94:	4841      	ldr	r0, [pc, #260]	@ (3400fd9c <HAL_RCCEx_PeriphCLKConfig+0x603c>)
3400fc96:	f7f2 f9bb 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400fc9a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc9e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400fca0:	2b00      	cmp	r3, #0
3400fca2:	d005      	beq.n	3400fcb0 <HAL_RCCEx_PeriphCLKConfig+0x5f50>
3400fca4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fca8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400fcaa:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400fcae:	d904      	bls.n	3400fcba <HAL_RCCEx_PeriphCLKConfig+0x5f5a>
3400fcb0:	f640 015b 	movw	r1, #2139	@ 0x85b
3400fcb4:	4839      	ldr	r0, [pc, #228]	@ (3400fd9c <HAL_RCCEx_PeriphCLKConfig+0x603c>)
3400fcb6:	f7f2 f9ab 	bl	34002010 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400fcba:	4b39      	ldr	r3, [pc, #228]	@ (3400fda0 <HAL_RCCEx_PeriphCLKConfig+0x6040>)
3400fcbc:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400fcc0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400fcc4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400fcc8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fccc:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400fcce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fcd2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400fcd4:	3b01      	subs	r3, #1
3400fcd6:	041b      	lsls	r3, r3, #16
3400fcd8:	4313      	orrs	r3, r2
3400fcda:	4a31      	ldr	r2, [pc, #196]	@ (3400fda0 <HAL_RCCEx_PeriphCLKConfig+0x6040>)
3400fcdc:	430b      	orrs	r3, r1
3400fcde:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400fce2:	f7f9 fd5b 	bl	3400979c <LL_RCC_IC9_Enable>
3400fce6:	e066      	b.n	3400fdb6 <HAL_RCCEx_PeriphCLKConfig+0x6056>
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC14)
3400fce8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fcec:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
3400fcf0:	4b26      	ldr	r3, [pc, #152]	@ (3400fd8c <HAL_RCCEx_PeriphCLKConfig+0x602c>)
3400fcf2:	429a      	cmp	r2, r3
3400fcf4:	d156      	bne.n	3400fda4 <HAL_RCCEx_PeriphCLKConfig+0x6044>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400fcf6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fcfa:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400fcfc:	2b00      	cmp	r3, #0
3400fcfe:	d016      	beq.n	3400fd2e <HAL_RCCEx_PeriphCLKConfig+0x5fce>
3400fd00:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fd04:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400fd06:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400fd0a:	d010      	beq.n	3400fd2e <HAL_RCCEx_PeriphCLKConfig+0x5fce>
3400fd0c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fd10:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400fd12:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400fd16:	d00a      	beq.n	3400fd2e <HAL_RCCEx_PeriphCLKConfig+0x5fce>
3400fd18:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fd1c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400fd1e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400fd22:	d004      	beq.n	3400fd2e <HAL_RCCEx_PeriphCLKConfig+0x5fce>
3400fd24:	f640 0167 	movw	r1, #2151	@ 0x867
3400fd28:	481c      	ldr	r0, [pc, #112]	@ (3400fd9c <HAL_RCCEx_PeriphCLKConfig+0x603c>)
3400fd2a:	f7f2 f971 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400fd2e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fd32:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400fd34:	2b00      	cmp	r3, #0
3400fd36:	d005      	beq.n	3400fd44 <HAL_RCCEx_PeriphCLKConfig+0x5fe4>
3400fd38:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fd3c:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400fd3e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400fd42:	d904      	bls.n	3400fd4e <HAL_RCCEx_PeriphCLKConfig+0x5fee>
3400fd44:	f640 0168 	movw	r1, #2152	@ 0x868
3400fd48:	4814      	ldr	r0, [pc, #80]	@ (3400fd9c <HAL_RCCEx_PeriphCLKConfig+0x603c>)
3400fd4a:	f7f2 f961 	bl	34002010 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400fd4e:	4b14      	ldr	r3, [pc, #80]	@ (3400fda0 <HAL_RCCEx_PeriphCLKConfig+0x6040>)
3400fd50:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400fd54:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400fd58:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400fd5c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fd60:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400fd62:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fd66:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400fd68:	3b01      	subs	r3, #1
3400fd6a:	041b      	lsls	r3, r3, #16
3400fd6c:	4313      	orrs	r3, r2
3400fd6e:	4a0c      	ldr	r2, [pc, #48]	@ (3400fda0 <HAL_RCCEx_PeriphCLKConfig+0x6040>)
3400fd70:	430b      	orrs	r3, r1
3400fd72:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400fd76:	f7f9 fe11 	bl	3400999c <LL_RCC_IC14_Enable>
3400fd7a:	e01c      	b.n	3400fdb6 <HAL_RCCEx_PeriphCLKConfig+0x6056>
3400fd7c:	07011830 	.word	0x07011830
3400fd80:	07001c30 	.word	0x07001c30
3400fd84:	07011c30 	.word	0x07011c30
3400fd88:	07021c30 	.word	0x07021c30
3400fd8c:	07031c30 	.word	0x07031c30
3400fd90:	07041c30 	.word	0x07041c30
3400fd94:	07051c30 	.word	0x07051c30
3400fd98:	07061c30 	.word	0x07061c30
3400fd9c:	3401ee60 	.word	0x3401ee60
3400fda0:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_CLKP)
3400fda4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fda8:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
3400fdac:	4b72      	ldr	r3, [pc, #456]	@ (3400ff78 <HAL_RCCEx_PeriphCLKConfig+0x6218>)
3400fdae:	429a      	cmp	r2, r3
3400fdb0:	d101      	bne.n	3400fdb6 <HAL_RCCEx_PeriphCLKConfig+0x6056>
    {
      LL_RCC_CLKP_Enable();
3400fdb2:	f7f9 ffb3 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART8 clock */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
3400fdb6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fdba:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
3400fdbe:	4618      	mov	r0, r3
3400fdc0:	f7f8 ff4f 	bl	34008c62 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART9 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART9) == RCC_PERIPHCLK_UART9)
3400fdc4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fdc8:	e9d3 2300 	ldrd	r2, r3, [r3]
3400fdcc:	2100      	movs	r1, #0
3400fdce:	6339      	str	r1, [r7, #48]	@ 0x30
3400fdd0:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3400fdd4:	637b      	str	r3, [r7, #52]	@ 0x34
3400fdd6:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
3400fdda:	4603      	mov	r3, r0
3400fddc:	460a      	mov	r2, r1
3400fdde:	4313      	orrs	r3, r2
3400fde0:	f000 80ee 	beq.w	3400ffc0 <HAL_RCCEx_PeriphCLKConfig+0x6260>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART9CLKSOURCE(PeriphClkInit->Uart9ClockSelection));
3400fde4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fde8:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3400fdec:	4a63      	ldr	r2, [pc, #396]	@ (3400ff7c <HAL_RCCEx_PeriphCLKConfig+0x621c>)
3400fdee:	4293      	cmp	r3, r2
3400fdf0:	d02e      	beq.n	3400fe50 <HAL_RCCEx_PeriphCLKConfig+0x60f0>
3400fdf2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fdf6:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3400fdfa:	4a61      	ldr	r2, [pc, #388]	@ (3400ff80 <HAL_RCCEx_PeriphCLKConfig+0x6220>)
3400fdfc:	4293      	cmp	r3, r2
3400fdfe:	d027      	beq.n	3400fe50 <HAL_RCCEx_PeriphCLKConfig+0x60f0>
3400fe00:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe04:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3400fe08:	4a5e      	ldr	r2, [pc, #376]	@ (3400ff84 <HAL_RCCEx_PeriphCLKConfig+0x6224>)
3400fe0a:	4293      	cmp	r3, r2
3400fe0c:	d020      	beq.n	3400fe50 <HAL_RCCEx_PeriphCLKConfig+0x60f0>
3400fe0e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe12:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3400fe16:	4a5c      	ldr	r2, [pc, #368]	@ (3400ff88 <HAL_RCCEx_PeriphCLKConfig+0x6228>)
3400fe18:	4293      	cmp	r3, r2
3400fe1a:	d019      	beq.n	3400fe50 <HAL_RCCEx_PeriphCLKConfig+0x60f0>
3400fe1c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe20:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3400fe24:	4a59      	ldr	r2, [pc, #356]	@ (3400ff8c <HAL_RCCEx_PeriphCLKConfig+0x622c>)
3400fe26:	4293      	cmp	r3, r2
3400fe28:	d012      	beq.n	3400fe50 <HAL_RCCEx_PeriphCLKConfig+0x60f0>
3400fe2a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe2e:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3400fe32:	4a57      	ldr	r2, [pc, #348]	@ (3400ff90 <HAL_RCCEx_PeriphCLKConfig+0x6230>)
3400fe34:	4293      	cmp	r3, r2
3400fe36:	d00b      	beq.n	3400fe50 <HAL_RCCEx_PeriphCLKConfig+0x60f0>
3400fe38:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe3c:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3400fe40:	4a54      	ldr	r2, [pc, #336]	@ (3400ff94 <HAL_RCCEx_PeriphCLKConfig+0x6234>)
3400fe42:	4293      	cmp	r3, r2
3400fe44:	d004      	beq.n	3400fe50 <HAL_RCCEx_PeriphCLKConfig+0x60f0>
3400fe46:	f640 0182 	movw	r1, #2178	@ 0x882
3400fe4a:	4853      	ldr	r0, [pc, #332]	@ (3400ff98 <HAL_RCCEx_PeriphCLKConfig+0x6238>)
3400fe4c:	f7f2 f8e0 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC9)
3400fe50:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe54:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3400fe58:	4a4a      	ldr	r2, [pc, #296]	@ (3400ff84 <HAL_RCCEx_PeriphCLKConfig+0x6224>)
3400fe5a:	4293      	cmp	r3, r2
3400fe5c:	d142      	bne.n	3400fee4 <HAL_RCCEx_PeriphCLKConfig+0x6184>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400fe5e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe62:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400fe64:	2b00      	cmp	r3, #0
3400fe66:	d016      	beq.n	3400fe96 <HAL_RCCEx_PeriphCLKConfig+0x6136>
3400fe68:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe6c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400fe6e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400fe72:	d010      	beq.n	3400fe96 <HAL_RCCEx_PeriphCLKConfig+0x6136>
3400fe74:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe78:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400fe7a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400fe7e:	d00a      	beq.n	3400fe96 <HAL_RCCEx_PeriphCLKConfig+0x6136>
3400fe80:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe84:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400fe86:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400fe8a:	d004      	beq.n	3400fe96 <HAL_RCCEx_PeriphCLKConfig+0x6136>
3400fe8c:	f640 0187 	movw	r1, #2183	@ 0x887
3400fe90:	4841      	ldr	r0, [pc, #260]	@ (3400ff98 <HAL_RCCEx_PeriphCLKConfig+0x6238>)
3400fe92:	f7f2 f8bd 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400fe96:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe9a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400fe9c:	2b00      	cmp	r3, #0
3400fe9e:	d005      	beq.n	3400feac <HAL_RCCEx_PeriphCLKConfig+0x614c>
3400fea0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fea4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400fea6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400feaa:	d904      	bls.n	3400feb6 <HAL_RCCEx_PeriphCLKConfig+0x6156>
3400feac:	f640 0188 	movw	r1, #2184	@ 0x888
3400feb0:	4839      	ldr	r0, [pc, #228]	@ (3400ff98 <HAL_RCCEx_PeriphCLKConfig+0x6238>)
3400feb2:	f7f2 f8ad 	bl	34002010 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400feb6:	4b39      	ldr	r3, [pc, #228]	@ (3400ff9c <HAL_RCCEx_PeriphCLKConfig+0x623c>)
3400feb8:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400febc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400fec0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400fec4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fec8:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400feca:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fece:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400fed0:	3b01      	subs	r3, #1
3400fed2:	041b      	lsls	r3, r3, #16
3400fed4:	4313      	orrs	r3, r2
3400fed6:	4a31      	ldr	r2, [pc, #196]	@ (3400ff9c <HAL_RCCEx_PeriphCLKConfig+0x623c>)
3400fed8:	430b      	orrs	r3, r1
3400feda:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400fede:	f7f9 fc5d 	bl	3400979c <LL_RCC_IC9_Enable>
3400fee2:	e066      	b.n	3400ffb2 <HAL_RCCEx_PeriphCLKConfig+0x6252>
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC14)
3400fee4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fee8:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3400feec:	4a26      	ldr	r2, [pc, #152]	@ (3400ff88 <HAL_RCCEx_PeriphCLKConfig+0x6228>)
3400feee:	4293      	cmp	r3, r2
3400fef0:	d156      	bne.n	3400ffa0 <HAL_RCCEx_PeriphCLKConfig+0x6240>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400fef2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fef6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400fef8:	2b00      	cmp	r3, #0
3400fefa:	d016      	beq.n	3400ff2a <HAL_RCCEx_PeriphCLKConfig+0x61ca>
3400fefc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ff00:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400ff02:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ff06:	d010      	beq.n	3400ff2a <HAL_RCCEx_PeriphCLKConfig+0x61ca>
3400ff08:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ff0c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400ff0e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ff12:	d00a      	beq.n	3400ff2a <HAL_RCCEx_PeriphCLKConfig+0x61ca>
3400ff14:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ff18:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400ff1a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ff1e:	d004      	beq.n	3400ff2a <HAL_RCCEx_PeriphCLKConfig+0x61ca>
3400ff20:	f640 0194 	movw	r1, #2196	@ 0x894
3400ff24:	481c      	ldr	r0, [pc, #112]	@ (3400ff98 <HAL_RCCEx_PeriphCLKConfig+0x6238>)
3400ff26:	f7f2 f873 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400ff2a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ff2e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400ff30:	2b00      	cmp	r3, #0
3400ff32:	d005      	beq.n	3400ff40 <HAL_RCCEx_PeriphCLKConfig+0x61e0>
3400ff34:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ff38:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400ff3a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400ff3e:	d904      	bls.n	3400ff4a <HAL_RCCEx_PeriphCLKConfig+0x61ea>
3400ff40:	f640 0195 	movw	r1, #2197	@ 0x895
3400ff44:	4814      	ldr	r0, [pc, #80]	@ (3400ff98 <HAL_RCCEx_PeriphCLKConfig+0x6238>)
3400ff46:	f7f2 f863 	bl	34002010 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400ff4a:	4b14      	ldr	r3, [pc, #80]	@ (3400ff9c <HAL_RCCEx_PeriphCLKConfig+0x623c>)
3400ff4c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400ff50:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400ff54:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400ff58:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ff5c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400ff5e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ff62:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400ff64:	3b01      	subs	r3, #1
3400ff66:	041b      	lsls	r3, r3, #16
3400ff68:	4313      	orrs	r3, r2
3400ff6a:	4a0c      	ldr	r2, [pc, #48]	@ (3400ff9c <HAL_RCCEx_PeriphCLKConfig+0x623c>)
3400ff6c:	430b      	orrs	r3, r1
3400ff6e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400ff72:	f7f9 fd13 	bl	3400999c <LL_RCC_IC14_Enable>
3400ff76:	e01c      	b.n	3400ffb2 <HAL_RCCEx_PeriphCLKConfig+0x6252>
3400ff78:	07011c30 	.word	0x07011c30
3400ff7c:	07000034 	.word	0x07000034
3400ff80:	07010034 	.word	0x07010034
3400ff84:	07020034 	.word	0x07020034
3400ff88:	07030034 	.word	0x07030034
3400ff8c:	07040034 	.word	0x07040034
3400ff90:	07050034 	.word	0x07050034
3400ff94:	07060034 	.word	0x07060034
3400ff98:	3401ee60 	.word	0x3401ee60
3400ff9c:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_CLKP)
3400ffa0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ffa4:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3400ffa8:	4ab7      	ldr	r2, [pc, #732]	@ (34010288 <HAL_RCCEx_PeriphCLKConfig+0x6528>)
3400ffaa:	4293      	cmp	r3, r2
3400ffac:	d101      	bne.n	3400ffb2 <HAL_RCCEx_PeriphCLKConfig+0x6252>
    {
      LL_RCC_CLKP_Enable();
3400ffae:	f7f9 feb5 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART9 clock */
    __HAL_RCC_UART9_CONFIG(PeriphClkInit->Uart9ClockSelection);
3400ffb2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ffb6:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3400ffba:	4618      	mov	r0, r3
3400ffbc:	f7f8 fe51 	bl	34008c62 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART10 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART10) == RCC_PERIPHCLK_USART10)
3400ffc0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ffc4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ffc8:	2100      	movs	r1, #0
3400ffca:	62b9      	str	r1, [r7, #40]	@ 0x28
3400ffcc:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
3400ffd0:	62fb      	str	r3, [r7, #44]	@ 0x2c
3400ffd2:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
3400ffd6:	4603      	mov	r3, r0
3400ffd8:	460a      	mov	r2, r1
3400ffda:	4313      	orrs	r3, r2
3400ffdc:	f000 80da 	beq.w	34010194 <HAL_RCCEx_PeriphCLKConfig+0x6434>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART10CLKSOURCE(PeriphClkInit->Usart10ClockSelection));
3400ffe0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ffe4:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
3400ffe8:	4aa8      	ldr	r2, [pc, #672]	@ (3401028c <HAL_RCCEx_PeriphCLKConfig+0x652c>)
3400ffea:	4293      	cmp	r3, r2
3400ffec:	d02e      	beq.n	3401004c <HAL_RCCEx_PeriphCLKConfig+0x62ec>
3400ffee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fff2:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
3400fff6:	4aa6      	ldr	r2, [pc, #664]	@ (34010290 <HAL_RCCEx_PeriphCLKConfig+0x6530>)
3400fff8:	4293      	cmp	r3, r2
3400fffa:	d027      	beq.n	3401004c <HAL_RCCEx_PeriphCLKConfig+0x62ec>
3400fffc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010000:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34010004:	4aa3      	ldr	r2, [pc, #652]	@ (34010294 <HAL_RCCEx_PeriphCLKConfig+0x6534>)
34010006:	4293      	cmp	r3, r2
34010008:	d020      	beq.n	3401004c <HAL_RCCEx_PeriphCLKConfig+0x62ec>
3401000a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401000e:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34010012:	4aa1      	ldr	r2, [pc, #644]	@ (34010298 <HAL_RCCEx_PeriphCLKConfig+0x6538>)
34010014:	4293      	cmp	r3, r2
34010016:	d019      	beq.n	3401004c <HAL_RCCEx_PeriphCLKConfig+0x62ec>
34010018:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401001c:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34010020:	4a9e      	ldr	r2, [pc, #632]	@ (3401029c <HAL_RCCEx_PeriphCLKConfig+0x653c>)
34010022:	4293      	cmp	r3, r2
34010024:	d012      	beq.n	3401004c <HAL_RCCEx_PeriphCLKConfig+0x62ec>
34010026:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401002a:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
3401002e:	4a9c      	ldr	r2, [pc, #624]	@ (340102a0 <HAL_RCCEx_PeriphCLKConfig+0x6540>)
34010030:	4293      	cmp	r3, r2
34010032:	d00b      	beq.n	3401004c <HAL_RCCEx_PeriphCLKConfig+0x62ec>
34010034:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010038:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
3401003c:	4a99      	ldr	r2, [pc, #612]	@ (340102a4 <HAL_RCCEx_PeriphCLKConfig+0x6544>)
3401003e:	4293      	cmp	r3, r2
34010040:	d004      	beq.n	3401004c <HAL_RCCEx_PeriphCLKConfig+0x62ec>
34010042:	f640 01af 	movw	r1, #2223	@ 0x8af
34010046:	4898      	ldr	r0, [pc, #608]	@ (340102a8 <HAL_RCCEx_PeriphCLKConfig+0x6548>)
34010048:	f7f1 ffe2 	bl	34002010 <assert_failed>

    if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC9)
3401004c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010050:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34010054:	4a8f      	ldr	r2, [pc, #572]	@ (34010294 <HAL_RCCEx_PeriphCLKConfig+0x6534>)
34010056:	4293      	cmp	r3, r2
34010058:	d142      	bne.n	340100e0 <HAL_RCCEx_PeriphCLKConfig+0x6380>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3401005a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401005e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34010060:	2b00      	cmp	r3, #0
34010062:	d016      	beq.n	34010092 <HAL_RCCEx_PeriphCLKConfig+0x6332>
34010064:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010068:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401006a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401006e:	d010      	beq.n	34010092 <HAL_RCCEx_PeriphCLKConfig+0x6332>
34010070:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010074:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34010076:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401007a:	d00a      	beq.n	34010092 <HAL_RCCEx_PeriphCLKConfig+0x6332>
3401007c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010080:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34010082:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34010086:	d004      	beq.n	34010092 <HAL_RCCEx_PeriphCLKConfig+0x6332>
34010088:	f640 01b4 	movw	r1, #2228	@ 0x8b4
3401008c:	4886      	ldr	r0, [pc, #536]	@ (340102a8 <HAL_RCCEx_PeriphCLKConfig+0x6548>)
3401008e:	f7f1 ffbf 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
34010092:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010096:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34010098:	2b00      	cmp	r3, #0
3401009a:	d005      	beq.n	340100a8 <HAL_RCCEx_PeriphCLKConfig+0x6348>
3401009c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340100a0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340100a2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340100a6:	d904      	bls.n	340100b2 <HAL_RCCEx_PeriphCLKConfig+0x6352>
340100a8:	f640 01b5 	movw	r1, #2229	@ 0x8b5
340100ac:	487e      	ldr	r0, [pc, #504]	@ (340102a8 <HAL_RCCEx_PeriphCLKConfig+0x6548>)
340100ae:	f7f1 ffaf 	bl	34002010 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
340100b2:	4b7e      	ldr	r3, [pc, #504]	@ (340102ac <HAL_RCCEx_PeriphCLKConfig+0x654c>)
340100b4:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340100b8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340100bc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340100c0:	f8d7 237c 	ldr.w	r2, [r7, #892]	@ 0x37c
340100c4:	6c91      	ldr	r1, [r2, #72]	@ 0x48
340100c6:	f8d7 237c 	ldr.w	r2, [r7, #892]	@ 0x37c
340100ca:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
340100cc:	3a01      	subs	r2, #1
340100ce:	0412      	lsls	r2, r2, #16
340100d0:	430a      	orrs	r2, r1
340100d2:	4976      	ldr	r1, [pc, #472]	@ (340102ac <HAL_RCCEx_PeriphCLKConfig+0x654c>)
340100d4:	4313      	orrs	r3, r2
340100d6:	f8c1 30e4 	str.w	r3, [r1, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
340100da:	f7f9 fb5f 	bl	3400979c <LL_RCC_IC9_Enable>
340100de:	e052      	b.n	34010186 <HAL_RCCEx_PeriphCLKConfig+0x6426>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC14)
340100e0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340100e4:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
340100e8:	4a6b      	ldr	r2, [pc, #428]	@ (34010298 <HAL_RCCEx_PeriphCLKConfig+0x6538>)
340100ea:	4293      	cmp	r3, r2
340100ec:	d142      	bne.n	34010174 <HAL_RCCEx_PeriphCLKConfig+0x6414>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
340100ee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340100f2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340100f4:	2b00      	cmp	r3, #0
340100f6:	d016      	beq.n	34010126 <HAL_RCCEx_PeriphCLKConfig+0x63c6>
340100f8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340100fc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340100fe:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34010102:	d010      	beq.n	34010126 <HAL_RCCEx_PeriphCLKConfig+0x63c6>
34010104:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010108:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3401010a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401010e:	d00a      	beq.n	34010126 <HAL_RCCEx_PeriphCLKConfig+0x63c6>
34010110:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010114:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34010116:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401011a:	d004      	beq.n	34010126 <HAL_RCCEx_PeriphCLKConfig+0x63c6>
3401011c:	f640 01c1 	movw	r1, #2241	@ 0x8c1
34010120:	4861      	ldr	r0, [pc, #388]	@ (340102a8 <HAL_RCCEx_PeriphCLKConfig+0x6548>)
34010122:	f7f1 ff75 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
34010126:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401012a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3401012c:	2b00      	cmp	r3, #0
3401012e:	d005      	beq.n	3401013c <HAL_RCCEx_PeriphCLKConfig+0x63dc>
34010130:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010134:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34010136:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401013a:	d904      	bls.n	34010146 <HAL_RCCEx_PeriphCLKConfig+0x63e6>
3401013c:	f640 01c2 	movw	r1, #2242	@ 0x8c2
34010140:	4859      	ldr	r0, [pc, #356]	@ (340102a8 <HAL_RCCEx_PeriphCLKConfig+0x6548>)
34010142:	f7f1 ff65 	bl	34002010 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34010146:	4b59      	ldr	r3, [pc, #356]	@ (340102ac <HAL_RCCEx_PeriphCLKConfig+0x654c>)
34010148:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3401014c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34010150:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34010154:	f8d7 237c 	ldr.w	r2, [r7, #892]	@ 0x37c
34010158:	6f11      	ldr	r1, [r2, #112]	@ 0x70
3401015a:	f8d7 237c 	ldr.w	r2, [r7, #892]	@ 0x37c
3401015e:	6f52      	ldr	r2, [r2, #116]	@ 0x74
34010160:	3a01      	subs	r2, #1
34010162:	0412      	lsls	r2, r2, #16
34010164:	430a      	orrs	r2, r1
34010166:	4951      	ldr	r1, [pc, #324]	@ (340102ac <HAL_RCCEx_PeriphCLKConfig+0x654c>)
34010168:	4313      	orrs	r3, r2
3401016a:	f8c1 30f8 	str.w	r3, [r1, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3401016e:	f7f9 fc15 	bl	3400999c <LL_RCC_IC14_Enable>
34010172:	e008      	b.n	34010186 <HAL_RCCEx_PeriphCLKConfig+0x6426>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_CLKP)
34010174:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010178:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
3401017c:	4a44      	ldr	r2, [pc, #272]	@ (34010290 <HAL_RCCEx_PeriphCLKConfig+0x6530>)
3401017e:	4293      	cmp	r3, r2
34010180:	d101      	bne.n	34010186 <HAL_RCCEx_PeriphCLKConfig+0x6426>
    {
      LL_RCC_CLKP_Enable();
34010182:	f7f9 fdcb 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART10 clock */
    __HAL_RCC_USART10_CONFIG(PeriphClkInit->Usart10ClockSelection);
34010186:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401018a:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
3401018e:	4618      	mov	r0, r3
34010190:	f7f8 fd67 	bl	34008c62 <LL_RCC_SetUSARTClockSource>
  }

  /*------------------------------ USBPHY1 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY1) == RCC_PERIPHCLK_USBPHY1)
34010194:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010198:	e9d3 2300 	ldrd	r2, r3, [r3]
3401019c:	2100      	movs	r1, #0
3401019e:	6239      	str	r1, [r7, #32]
340101a0:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
340101a4:	627b      	str	r3, [r7, #36]	@ 0x24
340101a6:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
340101aa:	4603      	mov	r3, r0
340101ac:	460a      	mov	r2, r1
340101ae:	4313      	orrs	r3, r2
340101b0:	d02e      	beq.n	34010210 <HAL_RCCEx_PeriphCLKConfig+0x64b0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY1CLKSOURCE(PeriphClkInit->UsbPhy1ClockSelection));
340101b2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340101b6:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
340101ba:	4a3d      	ldr	r2, [pc, #244]	@ (340102b0 <HAL_RCCEx_PeriphCLKConfig+0x6550>)
340101bc:	4293      	cmp	r3, r2
340101be:	d012      	beq.n	340101e6 <HAL_RCCEx_PeriphCLKConfig+0x6486>
340101c0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340101c4:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
340101c8:	4a3a      	ldr	r2, [pc, #232]	@ (340102b4 <HAL_RCCEx_PeriphCLKConfig+0x6554>)
340101ca:	4293      	cmp	r3, r2
340101cc:	d00b      	beq.n	340101e6 <HAL_RCCEx_PeriphCLKConfig+0x6486>
340101ce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340101d2:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
340101d6:	4a38      	ldr	r2, [pc, #224]	@ (340102b8 <HAL_RCCEx_PeriphCLKConfig+0x6558>)
340101d8:	4293      	cmp	r3, r2
340101da:	d004      	beq.n	340101e6 <HAL_RCCEx_PeriphCLKConfig+0x6486>
340101dc:	f640 01dc 	movw	r1, #2268	@ 0x8dc
340101e0:	4831      	ldr	r0, [pc, #196]	@ (340102a8 <HAL_RCCEx_PeriphCLKConfig+0x6548>)
340101e2:	f7f1 ff15 	bl	34002010 <assert_failed>

    /* Set the source of USBPHY1 clock*/
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
340101e6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340101ea:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
340101ee:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
340101f2:	4618      	mov	r0, r3
340101f4:	f7f8 fcdd 	bl	34008bb2 <LL_RCC_SetOTGPHYCKREFClockSource>
340101f8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340101fc:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34010200:	0fdb      	lsrs	r3, r3, #31
34010202:	2b01      	cmp	r3, #1
34010204:	d102      	bne.n	3401020c <HAL_RCCEx_PeriphCLKConfig+0x64ac>
34010206:	f7f8 fa7f 	bl	34008708 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
3401020a:	e001      	b.n	34010210 <HAL_RCCEx_PeriphCLKConfig+0x64b0>
3401020c:	f7f8 fa6c 	bl	340086e8 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBPHY2 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY2) == RCC_PERIPHCLK_USBPHY2)
34010210:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010214:	e9d3 2300 	ldrd	r2, r3, [r3]
34010218:	2100      	movs	r1, #0
3401021a:	61b9      	str	r1, [r7, #24]
3401021c:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
34010220:	61fb      	str	r3, [r7, #28]
34010222:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
34010226:	4603      	mov	r3, r0
34010228:	460a      	mov	r2, r1
3401022a:	4313      	orrs	r3, r2
3401022c:	d04e      	beq.n	340102cc <HAL_RCCEx_PeriphCLKConfig+0x656c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY2CLKSOURCE(PeriphClkInit->UsbPhy2ClockSelection));
3401022e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010232:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
34010236:	4a21      	ldr	r2, [pc, #132]	@ (340102bc <HAL_RCCEx_PeriphCLKConfig+0x655c>)
34010238:	4293      	cmp	r3, r2
3401023a:	d012      	beq.n	34010262 <HAL_RCCEx_PeriphCLKConfig+0x6502>
3401023c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010240:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
34010244:	4a1e      	ldr	r2, [pc, #120]	@ (340102c0 <HAL_RCCEx_PeriphCLKConfig+0x6560>)
34010246:	4293      	cmp	r3, r2
34010248:	d00b      	beq.n	34010262 <HAL_RCCEx_PeriphCLKConfig+0x6502>
3401024a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401024e:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
34010252:	4a1c      	ldr	r2, [pc, #112]	@ (340102c4 <HAL_RCCEx_PeriphCLKConfig+0x6564>)
34010254:	4293      	cmp	r3, r2
34010256:	d004      	beq.n	34010262 <HAL_RCCEx_PeriphCLKConfig+0x6502>
34010258:	f640 01e6 	movw	r1, #2278	@ 0x8e6
3401025c:	4812      	ldr	r0, [pc, #72]	@ (340102a8 <HAL_RCCEx_PeriphCLKConfig+0x6548>)
3401025e:	f7f1 fed7 	bl	34002010 <assert_failed>

    /* Set the source of USBPHY2 clock*/
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
34010262:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010266:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
3401026a:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3401026e:	4618      	mov	r0, r3
34010270:	f7f8 fc9f 	bl	34008bb2 <LL_RCC_SetOTGPHYCKREFClockSource>
34010274:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010278:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
3401027c:	0fdb      	lsrs	r3, r3, #31
3401027e:	2b01      	cmp	r3, #1
34010280:	d122      	bne.n	340102c8 <HAL_RCCEx_PeriphCLKConfig+0x6568>
34010282:	f7f8 fa41 	bl	34008708 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34010286:	e021      	b.n	340102cc <HAL_RCCEx_PeriphCLKConfig+0x656c>
34010288:	07010034 	.word	0x07010034
3401028c:	07000434 	.word	0x07000434
34010290:	07010434 	.word	0x07010434
34010294:	07020434 	.word	0x07020434
34010298:	07030434 	.word	0x07030434
3401029c:	07040434 	.word	0x07040434
340102a0:	07050434 	.word	0x07050434
340102a4:	07060434 	.word	0x07060434
340102a8:	3401ee60 	.word	0x3401ee60
340102ac:	56028000 	.word	0x56028000
340102b0:	01001014 	.word	0x01001014
340102b4:	01011014 	.word	0x01011014
340102b8:	81011014 	.word	0x81011014
340102bc:	01001814 	.word	0x01001814
340102c0:	01011814 	.word	0x01011814
340102c4:	81011814 	.word	0x81011814
340102c8:	f7f8 fa0e 	bl	340086e8 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS1 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS1) == RCC_PERIPHCLK_USBOTGHS1)
340102cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340102d0:	e9d3 2300 	ldrd	r2, r3, [r3]
340102d4:	2100      	movs	r1, #0
340102d6:	6139      	str	r1, [r7, #16]
340102d8:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
340102dc:	617b      	str	r3, [r7, #20]
340102de:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
340102e2:	4603      	mov	r3, r0
340102e4:	460a      	mov	r2, r1
340102e6:	4313      	orrs	r3, r2
340102e8:	f000 8090 	beq.w	3401040c <HAL_RCCEx_PeriphCLKConfig+0x66ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS1CLKSOURCE(PeriphClkInit->UsbOtgHs1ClockSelection));
340102ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340102f0:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
340102f4:	4ab5      	ldr	r2, [pc, #724]	@ (340105cc <HAL_RCCEx_PeriphCLKConfig+0x686c>)
340102f6:	4293      	cmp	r3, r2
340102f8:	d020      	beq.n	3401033c <HAL_RCCEx_PeriphCLKConfig+0x65dc>
340102fa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340102fe:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34010302:	4ab3      	ldr	r2, [pc, #716]	@ (340105d0 <HAL_RCCEx_PeriphCLKConfig+0x6870>)
34010304:	4293      	cmp	r3, r2
34010306:	d019      	beq.n	3401033c <HAL_RCCEx_PeriphCLKConfig+0x65dc>
34010308:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401030c:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34010310:	4ab0      	ldr	r2, [pc, #704]	@ (340105d4 <HAL_RCCEx_PeriphCLKConfig+0x6874>)
34010312:	4293      	cmp	r3, r2
34010314:	d012      	beq.n	3401033c <HAL_RCCEx_PeriphCLKConfig+0x65dc>
34010316:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401031a:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
3401031e:	4aae      	ldr	r2, [pc, #696]	@ (340105d8 <HAL_RCCEx_PeriphCLKConfig+0x6878>)
34010320:	4293      	cmp	r3, r2
34010322:	d00b      	beq.n	3401033c <HAL_RCCEx_PeriphCLKConfig+0x65dc>
34010324:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010328:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
3401032c:	4aab      	ldr	r2, [pc, #684]	@ (340105dc <HAL_RCCEx_PeriphCLKConfig+0x687c>)
3401032e:	4293      	cmp	r3, r2
34010330:	d004      	beq.n	3401033c <HAL_RCCEx_PeriphCLKConfig+0x65dc>
34010332:	f44f 610f 	mov.w	r1, #2288	@ 0x8f0
34010336:	48aa      	ldr	r0, [pc, #680]	@ (340105e0 <HAL_RCCEx_PeriphCLKConfig+0x6880>)
34010338:	f7f1 fe6a 	bl	34002010 <assert_failed>

    if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_IC15)
3401033c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010340:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34010344:	4aa3      	ldr	r2, [pc, #652]	@ (340105d4 <HAL_RCCEx_PeriphCLKConfig+0x6874>)
34010346:	4293      	cmp	r3, r2
34010348:	d142      	bne.n	340103d0 <HAL_RCCEx_PeriphCLKConfig+0x6670>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3401034a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401034e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34010350:	2b00      	cmp	r3, #0
34010352:	d016      	beq.n	34010382 <HAL_RCCEx_PeriphCLKConfig+0x6622>
34010354:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010358:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3401035a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401035e:	d010      	beq.n	34010382 <HAL_RCCEx_PeriphCLKConfig+0x6622>
34010360:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010364:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34010366:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401036a:	d00a      	beq.n	34010382 <HAL_RCCEx_PeriphCLKConfig+0x6622>
3401036c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010370:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34010372:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34010376:	d004      	beq.n	34010382 <HAL_RCCEx_PeriphCLKConfig+0x6622>
34010378:	f640 01f5 	movw	r1, #2293	@ 0x8f5
3401037c:	4898      	ldr	r0, [pc, #608]	@ (340105e0 <HAL_RCCEx_PeriphCLKConfig+0x6880>)
3401037e:	f7f1 fe47 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
34010382:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010386:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34010388:	2b00      	cmp	r3, #0
3401038a:	d005      	beq.n	34010398 <HAL_RCCEx_PeriphCLKConfig+0x6638>
3401038c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010390:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34010392:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34010396:	d904      	bls.n	340103a2 <HAL_RCCEx_PeriphCLKConfig+0x6642>
34010398:	f640 01f6 	movw	r1, #2294	@ 0x8f6
3401039c:	4890      	ldr	r0, [pc, #576]	@ (340105e0 <HAL_RCCEx_PeriphCLKConfig+0x6880>)
3401039e:	f7f1 fe37 	bl	34002010 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340103a2:	4b90      	ldr	r3, [pc, #576]	@ (340105e4 <HAL_RCCEx_PeriphCLKConfig+0x6884>)
340103a4:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340103a8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340103ac:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340103b0:	f8d7 237c 	ldr.w	r2, [r7, #892]	@ 0x37c
340103b4:	6f91      	ldr	r1, [r2, #120]	@ 0x78
340103b6:	f8d7 237c 	ldr.w	r2, [r7, #892]	@ 0x37c
340103ba:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
340103bc:	3a01      	subs	r2, #1
340103be:	0412      	lsls	r2, r2, #16
340103c0:	430a      	orrs	r2, r1
340103c2:	4988      	ldr	r1, [pc, #544]	@ (340105e4 <HAL_RCCEx_PeriphCLKConfig+0x6884>)
340103c4:	4313      	orrs	r3, r2
340103c6:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340103ca:	f7f9 fb27 	bl	34009a1c <LL_RCC_IC15_Enable>
340103ce:	e008      	b.n	340103e2 <HAL_RCCEx_PeriphCLKConfig+0x6682>
    }
    else if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_CLKP)
340103d0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340103d4:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
340103d8:	4a7d      	ldr	r2, [pc, #500]	@ (340105d0 <HAL_RCCEx_PeriphCLKConfig+0x6870>)
340103da:	4293      	cmp	r3, r2
340103dc:	d101      	bne.n	340103e2 <HAL_RCCEx_PeriphCLKConfig+0x6682>
    {
      LL_RCC_CLKP_Enable();
340103de:	f7f9 fc9d 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBOTGHS1 clock */
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
340103e2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340103e6:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
340103ea:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
340103ee:	4618      	mov	r0, r3
340103f0:	f7f8 fbd4 	bl	34008b9c <LL_RCC_SetOTGPHYClockSource>
340103f4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340103f8:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
340103fc:	0fdb      	lsrs	r3, r3, #31
340103fe:	2b01      	cmp	r3, #1
34010400:	d102      	bne.n	34010408 <HAL_RCCEx_PeriphCLKConfig+0x66a8>
34010402:	f7f8 f981 	bl	34008708 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34010406:	e001      	b.n	3401040c <HAL_RCCEx_PeriphCLKConfig+0x66ac>
34010408:	f7f8 f96e 	bl	340086e8 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS2 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS2) == RCC_PERIPHCLK_USBOTGHS2)
3401040c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010410:	e9d3 2300 	ldrd	r2, r3, [r3]
34010414:	2100      	movs	r1, #0
34010416:	60b9      	str	r1, [r7, #8]
34010418:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
3401041c:	60fb      	str	r3, [r7, #12]
3401041e:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
34010422:	4603      	mov	r3, r0
34010424:	460a      	mov	r2, r1
34010426:	4313      	orrs	r3, r2
34010428:	f000 8090 	beq.w	3401054c <HAL_RCCEx_PeriphCLKConfig+0x67ec>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS2CLKSOURCE(PeriphClkInit->UsbOtgHs2ClockSelection));
3401042c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010430:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34010434:	4a6c      	ldr	r2, [pc, #432]	@ (340105e8 <HAL_RCCEx_PeriphCLKConfig+0x6888>)
34010436:	4293      	cmp	r3, r2
34010438:	d020      	beq.n	3401047c <HAL_RCCEx_PeriphCLKConfig+0x671c>
3401043a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401043e:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34010442:	4a6a      	ldr	r2, [pc, #424]	@ (340105ec <HAL_RCCEx_PeriphCLKConfig+0x688c>)
34010444:	4293      	cmp	r3, r2
34010446:	d019      	beq.n	3401047c <HAL_RCCEx_PeriphCLKConfig+0x671c>
34010448:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401044c:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34010450:	4a67      	ldr	r2, [pc, #412]	@ (340105f0 <HAL_RCCEx_PeriphCLKConfig+0x6890>)
34010452:	4293      	cmp	r3, r2
34010454:	d012      	beq.n	3401047c <HAL_RCCEx_PeriphCLKConfig+0x671c>
34010456:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401045a:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
3401045e:	4a65      	ldr	r2, [pc, #404]	@ (340105f4 <HAL_RCCEx_PeriphCLKConfig+0x6894>)
34010460:	4293      	cmp	r3, r2
34010462:	d00b      	beq.n	3401047c <HAL_RCCEx_PeriphCLKConfig+0x671c>
34010464:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010468:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
3401046c:	4a62      	ldr	r2, [pc, #392]	@ (340105f8 <HAL_RCCEx_PeriphCLKConfig+0x6898>)
3401046e:	4293      	cmp	r3, r2
34010470:	d004      	beq.n	3401047c <HAL_RCCEx_PeriphCLKConfig+0x671c>
34010472:	f44f 6111 	mov.w	r1, #2320	@ 0x910
34010476:	485a      	ldr	r0, [pc, #360]	@ (340105e0 <HAL_RCCEx_PeriphCLKConfig+0x6880>)
34010478:	f7f1 fdca 	bl	34002010 <assert_failed>

    if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_IC15)
3401047c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010480:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34010484:	4a5a      	ldr	r2, [pc, #360]	@ (340105f0 <HAL_RCCEx_PeriphCLKConfig+0x6890>)
34010486:	4293      	cmp	r3, r2
34010488:	d142      	bne.n	34010510 <HAL_RCCEx_PeriphCLKConfig+0x67b0>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3401048a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401048e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34010490:	2b00      	cmp	r3, #0
34010492:	d016      	beq.n	340104c2 <HAL_RCCEx_PeriphCLKConfig+0x6762>
34010494:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010498:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3401049a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401049e:	d010      	beq.n	340104c2 <HAL_RCCEx_PeriphCLKConfig+0x6762>
340104a0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340104a4:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
340104a6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340104aa:	d00a      	beq.n	340104c2 <HAL_RCCEx_PeriphCLKConfig+0x6762>
340104ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340104b0:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
340104b2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340104b6:	d004      	beq.n	340104c2 <HAL_RCCEx_PeriphCLKConfig+0x6762>
340104b8:	f640 1115 	movw	r1, #2325	@ 0x915
340104bc:	4848      	ldr	r0, [pc, #288]	@ (340105e0 <HAL_RCCEx_PeriphCLKConfig+0x6880>)
340104be:	f7f1 fda7 	bl	34002010 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
340104c2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340104c6:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340104c8:	2b00      	cmp	r3, #0
340104ca:	d005      	beq.n	340104d8 <HAL_RCCEx_PeriphCLKConfig+0x6778>
340104cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340104d0:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340104d2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340104d6:	d904      	bls.n	340104e2 <HAL_RCCEx_PeriphCLKConfig+0x6782>
340104d8:	f640 1116 	movw	r1, #2326	@ 0x916
340104dc:	4840      	ldr	r0, [pc, #256]	@ (340105e0 <HAL_RCCEx_PeriphCLKConfig+0x6880>)
340104de:	f7f1 fd97 	bl	34002010 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340104e2:	4b40      	ldr	r3, [pc, #256]	@ (340105e4 <HAL_RCCEx_PeriphCLKConfig+0x6884>)
340104e4:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340104e8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340104ec:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340104f0:	f8d7 237c 	ldr.w	r2, [r7, #892]	@ 0x37c
340104f4:	6f91      	ldr	r1, [r2, #120]	@ 0x78
340104f6:	f8d7 237c 	ldr.w	r2, [r7, #892]	@ 0x37c
340104fa:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
340104fc:	3a01      	subs	r2, #1
340104fe:	0412      	lsls	r2, r2, #16
34010500:	430a      	orrs	r2, r1
34010502:	4938      	ldr	r1, [pc, #224]	@ (340105e4 <HAL_RCCEx_PeriphCLKConfig+0x6884>)
34010504:	4313      	orrs	r3, r2
34010506:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3401050a:	f7f9 fa87 	bl	34009a1c <LL_RCC_IC15_Enable>
3401050e:	e008      	b.n	34010522 <HAL_RCCEx_PeriphCLKConfig+0x67c2>
    }
    else if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_CLKP)
34010510:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010514:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34010518:	4a34      	ldr	r2, [pc, #208]	@ (340105ec <HAL_RCCEx_PeriphCLKConfig+0x688c>)
3401051a:	4293      	cmp	r3, r2
3401051c:	d101      	bne.n	34010522 <HAL_RCCEx_PeriphCLKConfig+0x67c2>
    {
      LL_RCC_CLKP_Enable();
3401051e:	f7f9 fbfd 	bl	34009d1c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBOTGHS2 clock */
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
34010522:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010526:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
3401052a:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3401052e:	4618      	mov	r0, r3
34010530:	f7f8 fb34 	bl	34008b9c <LL_RCC_SetOTGPHYClockSource>
34010534:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010538:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
3401053c:	0fdb      	lsrs	r3, r3, #31
3401053e:	2b01      	cmp	r3, #1
34010540:	d102      	bne.n	34010548 <HAL_RCCEx_PeriphCLKConfig+0x67e8>
34010542:	f7f8 f8e1 	bl	34008708 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34010546:	e001      	b.n	3401054c <HAL_RCCEx_PeriphCLKConfig+0x67ec>
34010548:	f7f8 f8ce 	bl	340086e8 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
3401054c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010550:	e9d3 2300 	ldrd	r2, r3, [r3]
34010554:	2100      	movs	r1, #0
34010556:	6039      	str	r1, [r7, #0]
34010558:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3401055c:	607b      	str	r3, [r7, #4]
3401055e:	e9d7 0100 	ldrd	r0, r1, [r7]
34010562:	4603      	mov	r3, r0
34010564:	460a      	mov	r2, r1
34010566:	4313      	orrs	r3, r2
34010568:	d023      	beq.n	340105b2 <HAL_RCCEx_PeriphCLKConfig+0x6852>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
3401056a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401056e:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
34010572:	2b00      	cmp	r3, #0
34010574:	d016      	beq.n	340105a4 <HAL_RCCEx_PeriphCLKConfig+0x6844>
34010576:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401057a:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
3401057e:	2b01      	cmp	r3, #1
34010580:	d010      	beq.n	340105a4 <HAL_RCCEx_PeriphCLKConfig+0x6844>
34010582:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010586:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
3401058a:	2b02      	cmp	r3, #2
3401058c:	d00a      	beq.n	340105a4 <HAL_RCCEx_PeriphCLKConfig+0x6844>
3401058e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010592:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
34010596:	2b03      	cmp	r3, #3
34010598:	d004      	beq.n	340105a4 <HAL_RCCEx_PeriphCLKConfig+0x6844>
3401059a:	f44f 6113 	mov.w	r1, #2352	@ 0x930
3401059e:	4810      	ldr	r0, [pc, #64]	@ (340105e0 <HAL_RCCEx_PeriphCLKConfig+0x6880>)
340105a0:	f7f1 fd36 	bl	34002010 <assert_failed>

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER_CONFIG(PeriphClkInit->TIMPresSelection);
340105a4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340105a8:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
340105ac:	4618      	mov	r0, r3
340105ae:	f7f8 fd31 	bl	34009014 <LL_RCC_SetTIMPrescaler>
  }

  if (status == HAL_OK)
340105b2:	f897 338e 	ldrb.w	r3, [r7, #910]	@ 0x38e
340105b6:	2b00      	cmp	r3, #0
340105b8:	d101      	bne.n	340105be <HAL_RCCEx_PeriphCLKConfig+0x685e>
  {
    return HAL_OK;
340105ba:	2300      	movs	r3, #0
340105bc:	e000      	b.n	340105c0 <HAL_RCCEx_PeriphCLKConfig+0x6860>
  }
  return HAL_ERROR;
340105be:	2301      	movs	r3, #1
}
340105c0:	4618      	mov	r0, r3
340105c2:	f507 7764 	add.w	r7, r7, #912	@ 0x390
340105c6:	46bd      	mov	sp, r7
340105c8:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
340105cc:	03000c14 	.word	0x03000c14
340105d0:	03010c14 	.word	0x03010c14
340105d4:	03020c14 	.word	0x03020c14
340105d8:	03030c14 	.word	0x03030c14
340105dc:	83030c14 	.word	0x83030c14
340105e0:	3401ee60 	.word	0x3401ee60
340105e4:	56028000 	.word	0x56028000
340105e8:	03001414 	.word	0x03001414
340105ec:	03011414 	.word	0x03011414
340105f0:	03021414 	.word	0x03021414
340105f4:	03031414 	.word	0x03031414
340105f8:	83031414 	.word	0x83031414

340105fc <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg RCC_PERIPHCLK_XSPI2    : XSPI2 peripheral clock
  *            @arg RCC_PERIPHCLK_XSPI3    : XSPI3 peripheral clock
  * @retval Frequency in KHz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint64_t PeriphClk)
{
340105fc:	b590      	push	{r4, r7, lr}
340105fe:	b085      	sub	sp, #20
34010600:	af00      	add	r7, sp, #0
34010602:	e9c7 0100 	strd	r0, r1, [r7]
  uint32_t frequency = 0;   /* Set to 0 for returned value if no source clock */
34010606:	2100      	movs	r1, #0
34010608:	60f9      	str	r1, [r7, #12]

  switch (PeriphClk)
3401060a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401060e:	f101 447f 	add.w	r4, r1, #4278190080	@ 0xff000000
34010612:	ea50 0104 	orrs.w	r1, r0, r4
34010616:	f000 8436 	beq.w	34010e86 <HAL_RCCEx_GetPeriphCLKFreq+0x88a>
3401061a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401061e:	2801      	cmp	r0, #1
34010620:	f171 7180 	sbcs.w	r1, r1, #16777216	@ 0x1000000
34010624:	f080 8434 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010628:	e9d7 0100 	ldrd	r0, r1, [r7]
3401062c:	f5a1 0400 	sub.w	r4, r1, #8388608	@ 0x800000
34010630:	ea50 0104 	orrs.w	r1, r0, r4
34010634:	f000 8422 	beq.w	34010e7c <HAL_RCCEx_GetPeriphCLKFreq+0x880>
34010638:	e9d7 0100 	ldrd	r0, r1, [r7]
3401063c:	2801      	cmp	r0, #1
3401063e:	f571 0100 	sbcs.w	r1, r1, #8388608	@ 0x800000
34010642:	f080 8425 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010646:	e9d7 0100 	ldrd	r0, r1, [r7]
3401064a:	f5a1 0480 	sub.w	r4, r1, #4194304	@ 0x400000
3401064e:	ea50 0104 	orrs.w	r1, r0, r4
34010652:	f000 840e 	beq.w	34010e72 <HAL_RCCEx_GetPeriphCLKFreq+0x876>
34010656:	e9d7 0100 	ldrd	r0, r1, [r7]
3401065a:	2801      	cmp	r0, #1
3401065c:	f571 0180 	sbcs.w	r1, r1, #4194304	@ 0x400000
34010660:	f080 8416 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010664:	e9d7 0100 	ldrd	r0, r1, [r7]
34010668:	f5a1 1400 	sub.w	r4, r1, #2097152	@ 0x200000
3401066c:	ea50 0104 	orrs.w	r1, r0, r4
34010670:	f000 83fa 	beq.w	34010e68 <HAL_RCCEx_GetPeriphCLKFreq+0x86c>
34010674:	e9d7 0100 	ldrd	r0, r1, [r7]
34010678:	2801      	cmp	r0, #1
3401067a:	f571 1100 	sbcs.w	r1, r1, #2097152	@ 0x200000
3401067e:	f080 8407 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010682:	e9d7 0100 	ldrd	r0, r1, [r7]
34010686:	f5a1 1480 	sub.w	r4, r1, #1048576	@ 0x100000
3401068a:	ea50 0104 	orrs.w	r1, r0, r4
3401068e:	f000 83e6 	beq.w	34010e5e <HAL_RCCEx_GetPeriphCLKFreq+0x862>
34010692:	e9d7 0100 	ldrd	r0, r1, [r7]
34010696:	2801      	cmp	r0, #1
34010698:	f571 1180 	sbcs.w	r1, r1, #1048576	@ 0x100000
3401069c:	f080 83f8 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340106a0:	e9d7 0100 	ldrd	r0, r1, [r7]
340106a4:	f5a1 2400 	sub.w	r4, r1, #524288	@ 0x80000
340106a8:	ea50 0104 	orrs.w	r1, r0, r4
340106ac:	f000 83d2 	beq.w	34010e54 <HAL_RCCEx_GetPeriphCLKFreq+0x858>
340106b0:	e9d7 0100 	ldrd	r0, r1, [r7]
340106b4:	2801      	cmp	r0, #1
340106b6:	f571 2100 	sbcs.w	r1, r1, #524288	@ 0x80000
340106ba:	f080 83e9 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340106be:	e9d7 0100 	ldrd	r0, r1, [r7]
340106c2:	f5a1 2480 	sub.w	r4, r1, #262144	@ 0x40000
340106c6:	ea50 0104 	orrs.w	r1, r0, r4
340106ca:	f000 83be 	beq.w	34010e4a <HAL_RCCEx_GetPeriphCLKFreq+0x84e>
340106ce:	e9d7 0100 	ldrd	r0, r1, [r7]
340106d2:	2801      	cmp	r0, #1
340106d4:	f571 2180 	sbcs.w	r1, r1, #262144	@ 0x40000
340106d8:	f080 83da 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340106dc:	e9d7 0100 	ldrd	r0, r1, [r7]
340106e0:	f5a1 3400 	sub.w	r4, r1, #131072	@ 0x20000
340106e4:	ea50 0104 	orrs.w	r1, r0, r4
340106e8:	f000 83aa 	beq.w	34010e40 <HAL_RCCEx_GetPeriphCLKFreq+0x844>
340106ec:	e9d7 0100 	ldrd	r0, r1, [r7]
340106f0:	2801      	cmp	r0, #1
340106f2:	f571 3100 	sbcs.w	r1, r1, #131072	@ 0x20000
340106f6:	f080 83cb 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340106fa:	e9d7 0100 	ldrd	r0, r1, [r7]
340106fe:	f5a1 3480 	sub.w	r4, r1, #65536	@ 0x10000
34010702:	ea50 0104 	orrs.w	r1, r0, r4
34010706:	f000 8396 	beq.w	34010e36 <HAL_RCCEx_GetPeriphCLKFreq+0x83a>
3401070a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401070e:	2801      	cmp	r0, #1
34010710:	f571 3180 	sbcs.w	r1, r1, #65536	@ 0x10000
34010714:	f080 83bc 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010718:	e9d7 0100 	ldrd	r0, r1, [r7]
3401071c:	f5a1 4400 	sub.w	r4, r1, #32768	@ 0x8000
34010720:	ea50 0104 	orrs.w	r1, r0, r4
34010724:	f000 8382 	beq.w	34010e2c <HAL_RCCEx_GetPeriphCLKFreq+0x830>
34010728:	e9d7 0100 	ldrd	r0, r1, [r7]
3401072c:	2801      	cmp	r0, #1
3401072e:	f571 4100 	sbcs.w	r1, r1, #32768	@ 0x8000
34010732:	f080 83ad 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010736:	e9d7 0100 	ldrd	r0, r1, [r7]
3401073a:	f5a1 4480 	sub.w	r4, r1, #16384	@ 0x4000
3401073e:	ea50 0104 	orrs.w	r1, r0, r4
34010742:	f000 836e 	beq.w	34010e22 <HAL_RCCEx_GetPeriphCLKFreq+0x826>
34010746:	e9d7 0100 	ldrd	r0, r1, [r7]
3401074a:	2801      	cmp	r0, #1
3401074c:	f571 4180 	sbcs.w	r1, r1, #16384	@ 0x4000
34010750:	f080 839e 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010754:	e9d7 0100 	ldrd	r0, r1, [r7]
34010758:	f5a1 5400 	sub.w	r4, r1, #8192	@ 0x2000
3401075c:	ea50 0104 	orrs.w	r1, r0, r4
34010760:	f000 835a 	beq.w	34010e18 <HAL_RCCEx_GetPeriphCLKFreq+0x81c>
34010764:	e9d7 0100 	ldrd	r0, r1, [r7]
34010768:	2801      	cmp	r0, #1
3401076a:	f571 5100 	sbcs.w	r1, r1, #8192	@ 0x2000
3401076e:	f080 838f 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010772:	e9d7 0100 	ldrd	r0, r1, [r7]
34010776:	f5a1 5480 	sub.w	r4, r1, #4096	@ 0x1000
3401077a:	ea50 0104 	orrs.w	r1, r0, r4
3401077e:	f000 8346 	beq.w	34010e0e <HAL_RCCEx_GetPeriphCLKFreq+0x812>
34010782:	e9d7 0100 	ldrd	r0, r1, [r7]
34010786:	2801      	cmp	r0, #1
34010788:	f571 5180 	sbcs.w	r1, r1, #4096	@ 0x1000
3401078c:	f080 8380 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010790:	e9d7 0100 	ldrd	r0, r1, [r7]
34010794:	f5a1 6400 	sub.w	r4, r1, #2048	@ 0x800
34010798:	ea50 0104 	orrs.w	r1, r0, r4
3401079c:	f000 8332 	beq.w	34010e04 <HAL_RCCEx_GetPeriphCLKFreq+0x808>
340107a0:	e9d7 0100 	ldrd	r0, r1, [r7]
340107a4:	2801      	cmp	r0, #1
340107a6:	f571 6100 	sbcs.w	r1, r1, #2048	@ 0x800
340107aa:	f080 8371 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340107ae:	e9d7 0100 	ldrd	r0, r1, [r7]
340107b2:	f5a1 6480 	sub.w	r4, r1, #1024	@ 0x400
340107b6:	ea50 0104 	orrs.w	r1, r0, r4
340107ba:	f000 831e 	beq.w	34010dfa <HAL_RCCEx_GetPeriphCLKFreq+0x7fe>
340107be:	e9d7 0100 	ldrd	r0, r1, [r7]
340107c2:	2801      	cmp	r0, #1
340107c4:	f571 6180 	sbcs.w	r1, r1, #1024	@ 0x400
340107c8:	f080 8362 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340107cc:	e9d7 0100 	ldrd	r0, r1, [r7]
340107d0:	f5a1 7400 	sub.w	r4, r1, #512	@ 0x200
340107d4:	ea50 0104 	orrs.w	r1, r0, r4
340107d8:	f000 830a 	beq.w	34010df0 <HAL_RCCEx_GetPeriphCLKFreq+0x7f4>
340107dc:	e9d7 0100 	ldrd	r0, r1, [r7]
340107e0:	2801      	cmp	r0, #1
340107e2:	f571 7100 	sbcs.w	r1, r1, #512	@ 0x200
340107e6:	f080 8353 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340107ea:	e9d7 0100 	ldrd	r0, r1, [r7]
340107ee:	f5a1 7480 	sub.w	r4, r1, #256	@ 0x100
340107f2:	ea50 0104 	orrs.w	r1, r0, r4
340107f6:	f000 82f6 	beq.w	34010de6 <HAL_RCCEx_GetPeriphCLKFreq+0x7ea>
340107fa:	e9d7 0100 	ldrd	r0, r1, [r7]
340107fe:	2801      	cmp	r0, #1
34010800:	f571 7180 	sbcs.w	r1, r1, #256	@ 0x100
34010804:	f080 8344 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010808:	e9d7 0100 	ldrd	r0, r1, [r7]
3401080c:	f1a1 0440 	sub.w	r4, r1, #64	@ 0x40
34010810:	ea50 0104 	orrs.w	r1, r0, r4
34010814:	f000 82e2 	beq.w	34010ddc <HAL_RCCEx_GetPeriphCLKFreq+0x7e0>
34010818:	e9d7 0100 	ldrd	r0, r1, [r7]
3401081c:	2801      	cmp	r0, #1
3401081e:	f171 0140 	sbcs.w	r1, r1, #64	@ 0x40
34010822:	f080 8335 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010826:	e9d7 0100 	ldrd	r0, r1, [r7]
3401082a:	f1a1 0420 	sub.w	r4, r1, #32
3401082e:	ea50 0104 	orrs.w	r1, r0, r4
34010832:	f000 82ce 	beq.w	34010dd2 <HAL_RCCEx_GetPeriphCLKFreq+0x7d6>
34010836:	e9d7 0100 	ldrd	r0, r1, [r7]
3401083a:	2801      	cmp	r0, #1
3401083c:	f171 0120 	sbcs.w	r1, r1, #32
34010840:	f080 8326 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010844:	e9d7 0100 	ldrd	r0, r1, [r7]
34010848:	f1a1 0410 	sub.w	r4, r1, #16
3401084c:	ea50 0104 	orrs.w	r1, r0, r4
34010850:	f000 82ba 	beq.w	34010dc8 <HAL_RCCEx_GetPeriphCLKFreq+0x7cc>
34010854:	e9d7 0100 	ldrd	r0, r1, [r7]
34010858:	2801      	cmp	r0, #1
3401085a:	f171 0110 	sbcs.w	r1, r1, #16
3401085e:	f080 8317 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010862:	e9d7 0100 	ldrd	r0, r1, [r7]
34010866:	f1a1 0408 	sub.w	r4, r1, #8
3401086a:	ea50 0104 	orrs.w	r1, r0, r4
3401086e:	f000 82a6 	beq.w	34010dbe <HAL_RCCEx_GetPeriphCLKFreq+0x7c2>
34010872:	e9d7 0100 	ldrd	r0, r1, [r7]
34010876:	2801      	cmp	r0, #1
34010878:	f171 0108 	sbcs.w	r1, r1, #8
3401087c:	f080 8308 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010880:	e9d7 0100 	ldrd	r0, r1, [r7]
34010884:	1f0c      	subs	r4, r1, #4
34010886:	ea50 0104 	orrs.w	r1, r0, r4
3401088a:	f000 8293 	beq.w	34010db4 <HAL_RCCEx_GetPeriphCLKFreq+0x7b8>
3401088e:	e9d7 0100 	ldrd	r0, r1, [r7]
34010892:	2801      	cmp	r0, #1
34010894:	f171 0104 	sbcs.w	r1, r1, #4
34010898:	f080 82fa 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401089c:	e9d7 0100 	ldrd	r0, r1, [r7]
340108a0:	1e8c      	subs	r4, r1, #2
340108a2:	ea50 0104 	orrs.w	r1, r0, r4
340108a6:	f000 8280 	beq.w	34010daa <HAL_RCCEx_GetPeriphCLKFreq+0x7ae>
340108aa:	e9d7 0100 	ldrd	r0, r1, [r7]
340108ae:	2801      	cmp	r0, #1
340108b0:	f171 0102 	sbcs.w	r1, r1, #2
340108b4:	f080 82ec 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340108b8:	e9d7 0100 	ldrd	r0, r1, [r7]
340108bc:	1e4c      	subs	r4, r1, #1
340108be:	ea50 0104 	orrs.w	r1, r0, r4
340108c2:	f000 826d 	beq.w	34010da0 <HAL_RCCEx_GetPeriphCLKFreq+0x7a4>
340108c6:	e9d7 0100 	ldrd	r0, r1, [r7]
340108ca:	2801      	cmp	r0, #1
340108cc:	f171 0101 	sbcs.w	r1, r1, #1
340108d0:	f080 82de 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340108d4:	e9d7 0100 	ldrd	r0, r1, [r7]
340108d8:	f100 4400 	add.w	r4, r0, #2147483648	@ 0x80000000
340108dc:	4321      	orrs	r1, r4
340108de:	f000 825a 	beq.w	34010d96 <HAL_RCCEx_GetPeriphCLKFreq+0x79a>
340108e2:	e9d7 0100 	ldrd	r0, r1, [r7]
340108e6:	4cda      	ldr	r4, [pc, #872]	@ (34010c50 <HAL_RCCEx_GetPeriphCLKFreq+0x654>)
340108e8:	42a0      	cmp	r0, r4
340108ea:	f171 0100 	sbcs.w	r1, r1, #0
340108ee:	f080 82cf 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340108f2:	e9d7 0100 	ldrd	r0, r1, [r7]
340108f6:	f100 4440 	add.w	r4, r0, #3221225472	@ 0xc0000000
340108fa:	4321      	orrs	r1, r4
340108fc:	f000 8246 	beq.w	34010d8c <HAL_RCCEx_GetPeriphCLKFreq+0x790>
34010900:	e9d7 0100 	ldrd	r0, r1, [r7]
34010904:	4cd3      	ldr	r4, [pc, #844]	@ (34010c54 <HAL_RCCEx_GetPeriphCLKFreq+0x658>)
34010906:	42a0      	cmp	r0, r4
34010908:	f171 0100 	sbcs.w	r1, r1, #0
3401090c:	f080 82c0 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010910:	e9d7 0100 	ldrd	r0, r1, [r7]
34010914:	f100 4460 	add.w	r4, r0, #3758096384	@ 0xe0000000
34010918:	4321      	orrs	r1, r4
3401091a:	f000 8232 	beq.w	34010d82 <HAL_RCCEx_GetPeriphCLKFreq+0x786>
3401091e:	e9d7 0100 	ldrd	r0, r1, [r7]
34010922:	4ccd      	ldr	r4, [pc, #820]	@ (34010c58 <HAL_RCCEx_GetPeriphCLKFreq+0x65c>)
34010924:	42a0      	cmp	r0, r4
34010926:	f171 0100 	sbcs.w	r1, r1, #0
3401092a:	f080 82b1 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401092e:	e9d7 0100 	ldrd	r0, r1, [r7]
34010932:	f100 4470 	add.w	r4, r0, #4026531840	@ 0xf0000000
34010936:	4321      	orrs	r1, r4
34010938:	f000 821e 	beq.w	34010d78 <HAL_RCCEx_GetPeriphCLKFreq+0x77c>
3401093c:	e9d7 0100 	ldrd	r0, r1, [r7]
34010940:	4cc6      	ldr	r4, [pc, #792]	@ (34010c5c <HAL_RCCEx_GetPeriphCLKFreq+0x660>)
34010942:	42a0      	cmp	r0, r4
34010944:	f171 0100 	sbcs.w	r1, r1, #0
34010948:	f080 82a2 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401094c:	e9d7 0100 	ldrd	r0, r1, [r7]
34010950:	f100 4478 	add.w	r4, r0, #4160749568	@ 0xf8000000
34010954:	4321      	orrs	r1, r4
34010956:	f000 820b 	beq.w	34010d70 <HAL_RCCEx_GetPeriphCLKFreq+0x774>
3401095a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401095e:	4cc0      	ldr	r4, [pc, #768]	@ (34010c60 <HAL_RCCEx_GetPeriphCLKFreq+0x664>)
34010960:	42a0      	cmp	r0, r4
34010962:	f171 0100 	sbcs.w	r1, r1, #0
34010966:	f080 8293 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401096a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401096e:	f100 447c 	add.w	r4, r0, #4227858432	@ 0xfc000000
34010972:	4321      	orrs	r1, r4
34010974:	f000 81f7 	beq.w	34010d66 <HAL_RCCEx_GetPeriphCLKFreq+0x76a>
34010978:	e9d7 0100 	ldrd	r0, r1, [r7]
3401097c:	4cb9      	ldr	r4, [pc, #740]	@ (34010c64 <HAL_RCCEx_GetPeriphCLKFreq+0x668>)
3401097e:	42a0      	cmp	r0, r4
34010980:	f171 0100 	sbcs.w	r1, r1, #0
34010984:	f080 8284 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010988:	e9d7 0100 	ldrd	r0, r1, [r7]
3401098c:	f100 447e 	add.w	r4, r0, #4261412864	@ 0xfe000000
34010990:	4321      	orrs	r1, r4
34010992:	f000 81e2 	beq.w	34010d5a <HAL_RCCEx_GetPeriphCLKFreq+0x75e>
34010996:	e9d7 0100 	ldrd	r0, r1, [r7]
3401099a:	4cb3      	ldr	r4, [pc, #716]	@ (34010c68 <HAL_RCCEx_GetPeriphCLKFreq+0x66c>)
3401099c:	42a0      	cmp	r0, r4
3401099e:	f171 0100 	sbcs.w	r1, r1, #0
340109a2:	f080 8275 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340109a6:	e9d7 0100 	ldrd	r0, r1, [r7]
340109aa:	f100 447f 	add.w	r4, r0, #4278190080	@ 0xff000000
340109ae:	4321      	orrs	r1, r4
340109b0:	f000 81cd 	beq.w	34010d4e <HAL_RCCEx_GetPeriphCLKFreq+0x752>
340109b4:	e9d7 0100 	ldrd	r0, r1, [r7]
340109b8:	4cac      	ldr	r4, [pc, #688]	@ (34010c6c <HAL_RCCEx_GetPeriphCLKFreq+0x670>)
340109ba:	42a0      	cmp	r0, r4
340109bc:	f171 0100 	sbcs.w	r1, r1, #0
340109c0:	f080 8266 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340109c4:	e9d7 0100 	ldrd	r0, r1, [r7]
340109c8:	f5a0 0400 	sub.w	r4, r0, #8388608	@ 0x800000
340109cc:	4321      	orrs	r1, r4
340109ce:	f000 81b8 	beq.w	34010d42 <HAL_RCCEx_GetPeriphCLKFreq+0x746>
340109d2:	e9d7 0100 	ldrd	r0, r1, [r7]
340109d6:	4ca6      	ldr	r4, [pc, #664]	@ (34010c70 <HAL_RCCEx_GetPeriphCLKFreq+0x674>)
340109d8:	42a0      	cmp	r0, r4
340109da:	f171 0100 	sbcs.w	r1, r1, #0
340109de:	f080 8257 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340109e2:	e9d7 0100 	ldrd	r0, r1, [r7]
340109e6:	f5a0 0480 	sub.w	r4, r0, #4194304	@ 0x400000
340109ea:	4321      	orrs	r1, r4
340109ec:	f000 81a4 	beq.w	34010d38 <HAL_RCCEx_GetPeriphCLKFreq+0x73c>
340109f0:	e9d7 0100 	ldrd	r0, r1, [r7]
340109f4:	4c9f      	ldr	r4, [pc, #636]	@ (34010c74 <HAL_RCCEx_GetPeriphCLKFreq+0x678>)
340109f6:	42a0      	cmp	r0, r4
340109f8:	f171 0100 	sbcs.w	r1, r1, #0
340109fc:	f080 8248 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010a00:	e9d7 0100 	ldrd	r0, r1, [r7]
34010a04:	f5a0 1400 	sub.w	r4, r0, #2097152	@ 0x200000
34010a08:	4321      	orrs	r1, r4
34010a0a:	f000 8190 	beq.w	34010d2e <HAL_RCCEx_GetPeriphCLKFreq+0x732>
34010a0e:	e9d7 0100 	ldrd	r0, r1, [r7]
34010a12:	4c99      	ldr	r4, [pc, #612]	@ (34010c78 <HAL_RCCEx_GetPeriphCLKFreq+0x67c>)
34010a14:	42a0      	cmp	r0, r4
34010a16:	f171 0100 	sbcs.w	r1, r1, #0
34010a1a:	f080 8239 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010a1e:	e9d7 0100 	ldrd	r0, r1, [r7]
34010a22:	f5a0 1480 	sub.w	r4, r0, #1048576	@ 0x100000
34010a26:	4321      	orrs	r1, r4
34010a28:	f000 817c 	beq.w	34010d24 <HAL_RCCEx_GetPeriphCLKFreq+0x728>
34010a2c:	e9d7 0100 	ldrd	r0, r1, [r7]
34010a30:	4c92      	ldr	r4, [pc, #584]	@ (34010c7c <HAL_RCCEx_GetPeriphCLKFreq+0x680>)
34010a32:	42a0      	cmp	r0, r4
34010a34:	f171 0100 	sbcs.w	r1, r1, #0
34010a38:	f080 822a 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010a3c:	e9d7 0100 	ldrd	r0, r1, [r7]
34010a40:	f5a0 2400 	sub.w	r4, r0, #524288	@ 0x80000
34010a44:	4321      	orrs	r1, r4
34010a46:	f000 8168 	beq.w	34010d1a <HAL_RCCEx_GetPeriphCLKFreq+0x71e>
34010a4a:	e9d7 0100 	ldrd	r0, r1, [r7]
34010a4e:	4c8c      	ldr	r4, [pc, #560]	@ (34010c80 <HAL_RCCEx_GetPeriphCLKFreq+0x684>)
34010a50:	42a0      	cmp	r0, r4
34010a52:	f171 0100 	sbcs.w	r1, r1, #0
34010a56:	f080 821b 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010a5a:	e9d7 0100 	ldrd	r0, r1, [r7]
34010a5e:	f5a0 2480 	sub.w	r4, r0, #262144	@ 0x40000
34010a62:	4321      	orrs	r1, r4
34010a64:	f000 8154 	beq.w	34010d10 <HAL_RCCEx_GetPeriphCLKFreq+0x714>
34010a68:	e9d7 0100 	ldrd	r0, r1, [r7]
34010a6c:	4c85      	ldr	r4, [pc, #532]	@ (34010c84 <HAL_RCCEx_GetPeriphCLKFreq+0x688>)
34010a6e:	42a0      	cmp	r0, r4
34010a70:	f171 0100 	sbcs.w	r1, r1, #0
34010a74:	f080 820c 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010a78:	e9d7 0100 	ldrd	r0, r1, [r7]
34010a7c:	f5a0 3400 	sub.w	r4, r0, #131072	@ 0x20000
34010a80:	4321      	orrs	r1, r4
34010a82:	f000 8140 	beq.w	34010d06 <HAL_RCCEx_GetPeriphCLKFreq+0x70a>
34010a86:	e9d7 0100 	ldrd	r0, r1, [r7]
34010a8a:	4c7f      	ldr	r4, [pc, #508]	@ (34010c88 <HAL_RCCEx_GetPeriphCLKFreq+0x68c>)
34010a8c:	42a0      	cmp	r0, r4
34010a8e:	f171 0100 	sbcs.w	r1, r1, #0
34010a92:	f080 81fd 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010a96:	e9d7 0100 	ldrd	r0, r1, [r7]
34010a9a:	f5a0 3480 	sub.w	r4, r0, #65536	@ 0x10000
34010a9e:	4321      	orrs	r1, r4
34010aa0:	f000 812c 	beq.w	34010cfc <HAL_RCCEx_GetPeriphCLKFreq+0x700>
34010aa4:	e9d7 0100 	ldrd	r0, r1, [r7]
34010aa8:	f1b0 1f01 	cmp.w	r0, #65537	@ 0x10001
34010aac:	f171 0100 	sbcs.w	r1, r1, #0
34010ab0:	f080 81ee 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010ab4:	e9d7 0100 	ldrd	r0, r1, [r7]
34010ab8:	f5a0 4400 	sub.w	r4, r0, #32768	@ 0x8000
34010abc:	4321      	orrs	r1, r4
34010abe:	f000 8118 	beq.w	34010cf2 <HAL_RCCEx_GetPeriphCLKFreq+0x6f6>
34010ac2:	e9d7 0100 	ldrd	r0, r1, [r7]
34010ac6:	f248 0401 	movw	r4, #32769	@ 0x8001
34010aca:	42a0      	cmp	r0, r4
34010acc:	f171 0100 	sbcs.w	r1, r1, #0
34010ad0:	f080 81de 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010ad4:	e9d7 0100 	ldrd	r0, r1, [r7]
34010ad8:	f5a0 4480 	sub.w	r4, r0, #16384	@ 0x4000
34010adc:	4321      	orrs	r1, r4
34010ade:	f000 8103 	beq.w	34010ce8 <HAL_RCCEx_GetPeriphCLKFreq+0x6ec>
34010ae2:	e9d7 0100 	ldrd	r0, r1, [r7]
34010ae6:	f244 0401 	movw	r4, #16385	@ 0x4001
34010aea:	42a0      	cmp	r0, r4
34010aec:	f171 0100 	sbcs.w	r1, r1, #0
34010af0:	f080 81ce 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010af4:	e9d7 0100 	ldrd	r0, r1, [r7]
34010af8:	f5a0 5400 	sub.w	r4, r0, #8192	@ 0x2000
34010afc:	4321      	orrs	r1, r4
34010afe:	f000 80ee 	beq.w	34010cde <HAL_RCCEx_GetPeriphCLKFreq+0x6e2>
34010b02:	e9d7 0100 	ldrd	r0, r1, [r7]
34010b06:	f242 0401 	movw	r4, #8193	@ 0x2001
34010b0a:	42a0      	cmp	r0, r4
34010b0c:	f171 0100 	sbcs.w	r1, r1, #0
34010b10:	f080 81be 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010b14:	e9d7 0100 	ldrd	r0, r1, [r7]
34010b18:	f5a0 5480 	sub.w	r4, r0, #4096	@ 0x1000
34010b1c:	4321      	orrs	r1, r4
34010b1e:	f000 80d9 	beq.w	34010cd4 <HAL_RCCEx_GetPeriphCLKFreq+0x6d8>
34010b22:	e9d7 0100 	ldrd	r0, r1, [r7]
34010b26:	f241 0401 	movw	r4, #4097	@ 0x1001
34010b2a:	42a0      	cmp	r0, r4
34010b2c:	f171 0100 	sbcs.w	r1, r1, #0
34010b30:	f080 81ae 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010b34:	e9d7 0100 	ldrd	r0, r1, [r7]
34010b38:	f5a0 6400 	sub.w	r4, r0, #2048	@ 0x800
34010b3c:	4321      	orrs	r1, r4
34010b3e:	f000 80c4 	beq.w	34010cca <HAL_RCCEx_GetPeriphCLKFreq+0x6ce>
34010b42:	e9d7 0100 	ldrd	r0, r1, [r7]
34010b46:	f640 0401 	movw	r4, #2049	@ 0x801
34010b4a:	42a0      	cmp	r0, r4
34010b4c:	f171 0100 	sbcs.w	r1, r1, #0
34010b50:	f080 819e 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010b54:	e9d7 0100 	ldrd	r0, r1, [r7]
34010b58:	f5a0 6480 	sub.w	r4, r0, #1024	@ 0x400
34010b5c:	4321      	orrs	r1, r4
34010b5e:	f000 80af 	beq.w	34010cc0 <HAL_RCCEx_GetPeriphCLKFreq+0x6c4>
34010b62:	e9d7 0100 	ldrd	r0, r1, [r7]
34010b66:	f240 4401 	movw	r4, #1025	@ 0x401
34010b6a:	42a0      	cmp	r0, r4
34010b6c:	f171 0100 	sbcs.w	r1, r1, #0
34010b70:	f080 818e 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010b74:	e9d7 0100 	ldrd	r0, r1, [r7]
34010b78:	2821      	cmp	r0, #33	@ 0x21
34010b7a:	f171 0100 	sbcs.w	r1, r1, #0
34010b7e:	d255      	bcs.n	34010c2c <HAL_RCCEx_GetPeriphCLKFreq+0x630>
34010b80:	e9d7 0100 	ldrd	r0, r1, [r7]
34010b84:	4301      	orrs	r1, r0
34010b86:	f000 8183 	beq.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010b8a:	e9d7 0100 	ldrd	r0, r1, [r7]
34010b8e:	1e42      	subs	r2, r0, #1
34010b90:	f141 33ff 	adc.w	r3, r1, #4294967295	@ 0xffffffff
34010b94:	2a20      	cmp	r2, #32
34010b96:	f173 0100 	sbcs.w	r1, r3, #0
34010b9a:	f080 8179 	bcs.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010b9e:	2a1f      	cmp	r2, #31
34010ba0:	f200 8176 	bhi.w	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34010ba4:	a101      	add	r1, pc, #4	@ (adr r1, 34010bac <HAL_RCCEx_GetPeriphCLKFreq+0x5b0>)
34010ba6:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
34010baa:	bf00      	nop
34010bac:	34010c3b 	.word	0x34010c3b
34010bb0:	34010c45 	.word	0x34010c45
34010bb4:	34010e91 	.word	0x34010e91
34010bb8:	34010c95 	.word	0x34010c95
34010bbc:	34010e91 	.word	0x34010e91
34010bc0:	34010e91 	.word	0x34010e91
34010bc4:	34010e91 	.word	0x34010e91
34010bc8:	34010c8d 	.word	0x34010c8d
34010bcc:	34010e91 	.word	0x34010e91
34010bd0:	34010e91 	.word	0x34010e91
34010bd4:	34010e91 	.word	0x34010e91
34010bd8:	34010e91 	.word	0x34010e91
34010bdc:	34010e91 	.word	0x34010e91
34010be0:	34010e91 	.word	0x34010e91
34010be4:	34010e91 	.word	0x34010e91
34010be8:	34010c9f 	.word	0x34010c9f
34010bec:	34010e91 	.word	0x34010e91
34010bf0:	34010e91 	.word	0x34010e91
34010bf4:	34010e91 	.word	0x34010e91
34010bf8:	34010e91 	.word	0x34010e91
34010bfc:	34010e91 	.word	0x34010e91
34010c00:	34010e91 	.word	0x34010e91
34010c04:	34010e91 	.word	0x34010e91
34010c08:	34010e91 	.word	0x34010e91
34010c0c:	34010e91 	.word	0x34010e91
34010c10:	34010e91 	.word	0x34010e91
34010c14:	34010e91 	.word	0x34010e91
34010c18:	34010e91 	.word	0x34010e91
34010c1c:	34010e91 	.word	0x34010e91
34010c20:	34010e91 	.word	0x34010e91
34010c24:	34010e91 	.word	0x34010e91
34010c28:	34010cab 	.word	0x34010cab
34010c2c:	e9d7 2300 	ldrd	r2, r3, [r7]
34010c30:	f5a2 7100 	sub.w	r1, r2, #512	@ 0x200
34010c34:	430b      	orrs	r3, r1
34010c36:	d03e      	beq.n	34010cb6 <HAL_RCCEx_GetPeriphCLKFreq+0x6ba>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
      break;

    default:
      /* Unexpected case, frequency is by default set to 0 */
      break;
34010c38:	e12a      	b.n	34010e90 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
      frequency = RCCEx_GetADCCLKFreq(LL_RCC_ADC_CLKSOURCE);
34010c3a:	2070      	movs	r0, #112	@ 0x70
34010c3c:	f000 fb90 	bl	34011360 <RCCEx_GetADCCLKFreq>
34010c40:	60f8      	str	r0, [r7, #12]
      break;
34010c42:	e126      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetADFCLKFreq(LL_RCC_ADF1_CLKSOURCE);
34010c44:	2007      	movs	r0, #7
34010c46:	f000 fc8d 	bl	34011564 <RCCEx_GetADFCLKFreq>
34010c4a:	60f8      	str	r0, [r7, #12]
      break;
34010c4c:	e121      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
34010c4e:	bf00      	nop
34010c50:	80000001 	.word	0x80000001
34010c54:	40000001 	.word	0x40000001
34010c58:	20000001 	.word	0x20000001
34010c5c:	10000001 	.word	0x10000001
34010c60:	08000001 	.word	0x08000001
34010c64:	04000001 	.word	0x04000001
34010c68:	02000001 	.word	0x02000001
34010c6c:	01000001 	.word	0x01000001
34010c70:	00800001 	.word	0x00800001
34010c74:	00400001 	.word	0x00400001
34010c78:	00200001 	.word	0x00200001
34010c7c:	00100001 	.word	0x00100001
34010c80:	00080001 	.word	0x00080001
34010c84:	00040001 	.word	0x00040001
34010c88:	00020001 	.word	0x00020001
      frequency = RCCEx_GetCSICLKFreq();
34010c8c:	f000 ff0c 	bl	34011aa8 <RCCEx_GetCSICLKFreq>
34010c90:	60f8      	str	r0, [r7, #12]
      break;
34010c92:	e0fe      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34010c94:	2007      	movs	r0, #7
34010c96:	f000 fd51 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
34010c9a:	60f8      	str	r0, [r7, #12]
      break;
34010c9c:	e0f9      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetDCMIPPCLKFreq(LL_RCC_DCMIPP_CLKSOURCE);
34010c9e:	f44f 1040 	mov.w	r0, #3145728	@ 0x300000
34010ca2:	f000 ff4d 	bl	34011b40 <RCCEx_GetDCMIPPCLKFreq>
34010ca6:	60f8      	str	r0, [r7, #12]
      break;
34010ca8:	e0f3      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetETH1CLKFreq(LL_RCC_ETH1_CLKSOURCE);
34010caa:	f44f 5040 	mov.w	r0, #12288	@ 0x3000
34010cae:	f000 ffd1 	bl	34011c54 <RCCEx_GetETH1CLKFreq>
34010cb2:	60f8      	str	r0, [r7, #12]
      break;
34010cb4:	e0ed      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetETH1PTPCLKFreq(LL_RCC_ETH1PTP_CLKSOURCE);
34010cb6:	2003      	movs	r0, #3
34010cb8:	f001 f84c 	bl	34011d54 <RCCEx_GetETH1PTPCLKFreq>
34010cbc:	60f8      	str	r0, [r7, #12]
      break;
34010cbe:	e0e8      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetFDCANCLKFreq(LL_RCC_FDCAN_CLKSOURCE);
34010cc0:	2003      	movs	r0, #3
34010cc2:	f001 f8cb 	bl	34011e5c <RCCEx_GetFDCANCLKFreq>
34010cc6:	60f8      	str	r0, [r7, #12]
      break;
34010cc8:	e0e3      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetFMCCLKFreq(LL_RCC_FMC_CLKSOURCE);
34010cca:	2030      	movs	r0, #48	@ 0x30
34010ccc:	f001 f946 	bl	34011f5c <RCCEx_GetFMCCLKFreq>
34010cd0:	60f8      	str	r0, [r7, #12]
      break;
34010cd2:	e0de      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C1_CLKSOURCE);
34010cd4:	4871      	ldr	r0, [pc, #452]	@ (34010e9c <HAL_RCCEx_GetPeriphCLKFreq+0x8a0>)
34010cd6:	f001 f9f9 	bl	340120cc <RCCEx_GetI2CCLKFreq>
34010cda:	60f8      	str	r0, [r7, #12]
      break;
34010cdc:	e0d9      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C2_CLKSOURCE);
34010cde:	4870      	ldr	r0, [pc, #448]	@ (34010ea0 <HAL_RCCEx_GetPeriphCLKFreq+0x8a4>)
34010ce0:	f001 f9f4 	bl	340120cc <RCCEx_GetI2CCLKFreq>
34010ce4:	60f8      	str	r0, [r7, #12]
      break;
34010ce6:	e0d4      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C3_CLKSOURCE);
34010ce8:	486e      	ldr	r0, [pc, #440]	@ (34010ea4 <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>)
34010cea:	f001 f9ef 	bl	340120cc <RCCEx_GetI2CCLKFreq>
34010cee:	60f8      	str	r0, [r7, #12]
      break;
34010cf0:	e0cf      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C4_CLKSOURCE);
34010cf2:	486d      	ldr	r0, [pc, #436]	@ (34010ea8 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>)
34010cf4:	f001 f9ea 	bl	340120cc <RCCEx_GetI2CCLKFreq>
34010cf8:	60f8      	str	r0, [r7, #12]
      break;
34010cfa:	e0ca      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C1_CLKSOURCE);
34010cfc:	486b      	ldr	r0, [pc, #428]	@ (34010eac <HAL_RCCEx_GetPeriphCLKFreq+0x8b0>)
34010cfe:	f001 fb8d 	bl	3401241c <RCCEx_GetI3CCLKFreq>
34010d02:	60f8      	str	r0, [r7, #12]
      break;
34010d04:	e0c5      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C2_CLKSOURCE);
34010d06:	486a      	ldr	r0, [pc, #424]	@ (34010eb0 <HAL_RCCEx_GetPeriphCLKFreq+0x8b4>)
34010d08:	f001 fb88 	bl	3401241c <RCCEx_GetI3CCLKFreq>
34010d0c:	60f8      	str	r0, [r7, #12]
      break;
34010d0e:	e0c0      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM1_CLKSOURCE);
34010d10:	4868      	ldr	r0, [pc, #416]	@ (34010eb4 <HAL_RCCEx_GetPeriphCLKFreq+0x8b8>)
34010d12:	f001 fcb7 	bl	34012684 <RCCEx_GetLPTIMCLKFreq>
34010d16:	60f8      	str	r0, [r7, #12]
      break;
34010d18:	e0bb      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM2_CLKSOURCE);
34010d1a:	4867      	ldr	r0, [pc, #412]	@ (34010eb8 <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
34010d1c:	f001 fcb2 	bl	34012684 <RCCEx_GetLPTIMCLKFreq>
34010d20:	60f8      	str	r0, [r7, #12]
      break;
34010d22:	e0b6      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM3_CLKSOURCE);
34010d24:	4865      	ldr	r0, [pc, #404]	@ (34010ebc <HAL_RCCEx_GetPeriphCLKFreq+0x8c0>)
34010d26:	f001 fcad 	bl	34012684 <RCCEx_GetLPTIMCLKFreq>
34010d2a:	60f8      	str	r0, [r7, #12]
      break;
34010d2c:	e0b1      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM4_CLKSOURCE);
34010d2e:	4864      	ldr	r0, [pc, #400]	@ (34010ec0 <HAL_RCCEx_GetPeriphCLKFreq+0x8c4>)
34010d30:	f001 fca8 	bl	34012684 <RCCEx_GetLPTIMCLKFreq>
34010d34:	60f8      	str	r0, [r7, #12]
      break;
34010d36:	e0ac      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM5_CLKSOURCE);
34010d38:	4862      	ldr	r0, [pc, #392]	@ (34010ec4 <HAL_RCCEx_GetPeriphCLKFreq+0x8c8>)
34010d3a:	f001 fca3 	bl	34012684 <RCCEx_GetLPTIMCLKFreq>
34010d3e:	60f8      	str	r0, [r7, #12]
      break;
34010d40:	e0a7      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPUARTCLKFreq(LL_RCC_LPUART1_CLKSOURCE);
34010d42:	f44f 60e0 	mov.w	r0, #1792	@ 0x700
34010d46:	f001 fe47 	bl	340129d8 <RCCEx_GetLPUARTCLKFreq>
34010d4a:	60f8      	str	r0, [r7, #12]
      break;
34010d4c:	e0a1      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLTDCCLKFreq(LL_RCC_LTDC_CLKSOURCE);
34010d4e:	f04f 7040 	mov.w	r0, #50331648	@ 0x3000000
34010d52:	f001 ff43 	bl	34012bdc <RCCEx_GetLTDCCLKFreq>
34010d56:	60f8      	str	r0, [r7, #12]
      break;
34010d58:	e09b      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetMDFCLKFreq(LL_RCC_MDF1_CLKSOURCE);
34010d5a:	f44f 20e0 	mov.w	r0, #458752	@ 0x70000
34010d5e:	f001 ffc7 	bl	34012cf0 <RCCEx_GetMDFCLKFreq>
34010d62:	60f8      	str	r0, [r7, #12]
      break;
34010d64:	e095      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetPSSICLKFreq(LL_RCC_PSSI_CLKSOURCE);
34010d66:	2030      	movs	r0, #48	@ 0x30
34010d68:	f002 f8cc 	bl	34012f04 <RCCEx_GetPSSICLKFreq>
34010d6c:	60f8      	str	r0, [r7, #12]
      break;
34010d6e:	e090      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetRTCCLKFreq();
34010d70:	f002 f94a 	bl	34013008 <RCCEx_GetRTCCLKFreq>
34010d74:	60f8      	str	r0, [r7, #12]
      break;
34010d76:	e08c      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI1_CLKSOURCE);
34010d78:	4853      	ldr	r0, [pc, #332]	@ (34010ec8 <HAL_RCCEx_GetPeriphCLKFreq+0x8cc>)
34010d7a:	f002 f997 	bl	340130ac <RCCEx_GetSAICLKFreq>
34010d7e:	60f8      	str	r0, [r7, #12]
      break;
34010d80:	e087      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI2_CLKSOURCE);
34010d82:	4852      	ldr	r0, [pc, #328]	@ (34010ecc <HAL_RCCEx_GetPeriphCLKFreq+0x8d0>)
34010d84:	f002 f992 	bl	340130ac <RCCEx_GetSAICLKFreq>
34010d88:	60f8      	str	r0, [r7, #12]
      break;
34010d8a:	e082      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC1_CLKSOURCE);
34010d8c:	4850      	ldr	r0, [pc, #320]	@ (34010ed0 <HAL_RCCEx_GetPeriphCLKFreq+0x8d4>)
34010d8e:	f002 faf3 	bl	34013378 <RCCEx_GetSDMMCCLKFreq>
34010d92:	60f8      	str	r0, [r7, #12]
      break;
34010d94:	e07d      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC2_CLKSOURCE);
34010d96:	484f      	ldr	r0, [pc, #316]	@ (34010ed4 <HAL_RCCEx_GetPeriphCLKFreq+0x8d8>)
34010d98:	f002 faee 	bl	34013378 <RCCEx_GetSDMMCCLKFreq>
34010d9c:	60f8      	str	r0, [r7, #12]
      break;
34010d9e:	e078      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
34010da0:	2007      	movs	r0, #7
34010da2:	f002 fbd3 	bl	3401354c <RCCEx_GetSPDIFRXCLKFreq>
34010da6:	60f8      	str	r0, [r7, #12]
      break;
34010da8:	e073      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI1_CLKSOURCE);
34010daa:	484b      	ldr	r0, [pc, #300]	@ (34010ed8 <HAL_RCCEx_GetPeriphCLKFreq+0x8dc>)
34010dac:	f002 fcb2 	bl	34013714 <RCCEx_GetSPICLKFreq>
34010db0:	60f8      	str	r0, [r7, #12]
      break;
34010db2:	e06e      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI2_CLKSOURCE);
34010db4:	4849      	ldr	r0, [pc, #292]	@ (34010edc <HAL_RCCEx_GetPeriphCLKFreq+0x8e0>)
34010db6:	f002 fcad 	bl	34013714 <RCCEx_GetSPICLKFreq>
34010dba:	60f8      	str	r0, [r7, #12]
      break;
34010dbc:	e069      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI3_CLKSOURCE);
34010dbe:	4848      	ldr	r0, [pc, #288]	@ (34010ee0 <HAL_RCCEx_GetPeriphCLKFreq+0x8e4>)
34010dc0:	f002 fca8 	bl	34013714 <RCCEx_GetSPICLKFreq>
34010dc4:	60f8      	str	r0, [r7, #12]
      break;
34010dc6:	e064      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI4_CLKSOURCE);
34010dc8:	4846      	ldr	r0, [pc, #280]	@ (34010ee4 <HAL_RCCEx_GetPeriphCLKFreq+0x8e8>)
34010dca:	f002 fca3 	bl	34013714 <RCCEx_GetSPICLKFreq>
34010dce:	60f8      	str	r0, [r7, #12]
      break;
34010dd0:	e05f      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI5_CLKSOURCE);
34010dd2:	4845      	ldr	r0, [pc, #276]	@ (34010ee8 <HAL_RCCEx_GetPeriphCLKFreq+0x8ec>)
34010dd4:	f002 fc9e 	bl	34013714 <RCCEx_GetSPICLKFreq>
34010dd8:	60f8      	str	r0, [r7, #12]
      break;
34010dda:	e05a      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI6_CLKSOURCE);
34010ddc:	4843      	ldr	r0, [pc, #268]	@ (34010eec <HAL_RCCEx_GetPeriphCLKFreq+0x8f0>)
34010dde:	f002 fc99 	bl	34013714 <RCCEx_GetSPICLKFreq>
34010de2:	60f8      	str	r0, [r7, #12]
      break;
34010de4:	e055      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART1_CLKSOURCE);
34010de6:	4842      	ldr	r0, [pc, #264]	@ (34010ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x8f4>)
34010de8:	f003 f990 	bl	3401410c <RCCEx_GetUSARTCLKFreq>
34010dec:	60f8      	str	r0, [r7, #12]
      break;
34010dee:	e050      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART2_CLKSOURCE);
34010df0:	4840      	ldr	r0, [pc, #256]	@ (34010ef4 <HAL_RCCEx_GetPeriphCLKFreq+0x8f8>)
34010df2:	f003 f98b 	bl	3401410c <RCCEx_GetUSARTCLKFreq>
34010df6:	60f8      	str	r0, [r7, #12]
      break;
34010df8:	e04b      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART3_CLKSOURCE);
34010dfa:	483f      	ldr	r0, [pc, #252]	@ (34010ef8 <HAL_RCCEx_GetPeriphCLKFreq+0x8fc>)
34010dfc:	f003 f986 	bl	3401410c <RCCEx_GetUSARTCLKFreq>
34010e00:	60f8      	str	r0, [r7, #12]
      break;
34010e02:	e046      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART4_CLKSOURCE);
34010e04:	483d      	ldr	r0, [pc, #244]	@ (34010efc <HAL_RCCEx_GetPeriphCLKFreq+0x900>)
34010e06:	f002 ff57 	bl	34013cb8 <RCCEx_GetUARTCLKFreq>
34010e0a:	60f8      	str	r0, [r7, #12]
      break;
34010e0c:	e041      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART5_CLKSOURCE);
34010e0e:	483c      	ldr	r0, [pc, #240]	@ (34010f00 <HAL_RCCEx_GetPeriphCLKFreq+0x904>)
34010e10:	f002 ff52 	bl	34013cb8 <RCCEx_GetUARTCLKFreq>
34010e14:	60f8      	str	r0, [r7, #12]
      break;
34010e16:	e03c      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART6_CLKSOURCE);
34010e18:	483a      	ldr	r0, [pc, #232]	@ (34010f04 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
34010e1a:	f003 f977 	bl	3401410c <RCCEx_GetUSARTCLKFreq>
34010e1e:	60f8      	str	r0, [r7, #12]
      break;
34010e20:	e037      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART7_CLKSOURCE);
34010e22:	4839      	ldr	r0, [pc, #228]	@ (34010f08 <HAL_RCCEx_GetPeriphCLKFreq+0x90c>)
34010e24:	f002 ff48 	bl	34013cb8 <RCCEx_GetUARTCLKFreq>
34010e28:	60f8      	str	r0, [r7, #12]
      break;
34010e2a:	e032      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART8_CLKSOURCE);
34010e2c:	4837      	ldr	r0, [pc, #220]	@ (34010f0c <HAL_RCCEx_GetPeriphCLKFreq+0x910>)
34010e2e:	f002 ff43 	bl	34013cb8 <RCCEx_GetUARTCLKFreq>
34010e32:	60f8      	str	r0, [r7, #12]
      break;
34010e34:	e02d      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART9_CLKSOURCE);
34010e36:	4836      	ldr	r0, [pc, #216]	@ (34010f10 <HAL_RCCEx_GetPeriphCLKFreq+0x914>)
34010e38:	f002 ff3e 	bl	34013cb8 <RCCEx_GetUARTCLKFreq>
34010e3c:	60f8      	str	r0, [r7, #12]
      break;
34010e3e:	e028      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART10_CLKSOURCE);
34010e40:	4834      	ldr	r0, [pc, #208]	@ (34010f14 <HAL_RCCEx_GetPeriphCLKFreq+0x918>)
34010e42:	f003 f963 	bl	3401410c <RCCEx_GetUSARTCLKFreq>
34010e46:	60f8      	str	r0, [r7, #12]
      break;
34010e48:	e023      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY1CKREF_CLKSOURCE);
34010e4a:	4833      	ldr	r0, [pc, #204]	@ (34010f18 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>)
34010e4c:	f003 fc3e 	bl	340146cc <RCCEx_GetOTGPHYCKREFCLKFreq>
34010e50:	60f8      	str	r0, [r7, #12]
      break;
34010e52:	e01e      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
34010e54:	4831      	ldr	r0, [pc, #196]	@ (34010f1c <HAL_RCCEx_GetPeriphCLKFreq+0x920>)
34010e56:	f003 fb83 	bl	34014560 <RCCEx_GetOTGPHYCLKFreq>
34010e5a:	60f8      	str	r0, [r7, #12]
      break;
34010e5c:	e019      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY2CKREF_CLKSOURCE);
34010e5e:	4830      	ldr	r0, [pc, #192]	@ (34010f20 <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
34010e60:	f003 fc34 	bl	340146cc <RCCEx_GetOTGPHYCKREFCLKFreq>
34010e64:	60f8      	str	r0, [r7, #12]
      break;
34010e66:	e014      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
34010e68:	482e      	ldr	r0, [pc, #184]	@ (34010f24 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
34010e6a:	f003 fb79 	bl	34014560 <RCCEx_GetOTGPHYCLKFreq>
34010e6e:	60f8      	str	r0, [r7, #12]
      break;
34010e70:	e00f      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI1_CLKSOURCE);
34010e72:	482d      	ldr	r0, [pc, #180]	@ (34010f28 <HAL_RCCEx_GetPeriphCLKFreq+0x92c>)
34010e74:	f003 fc7a 	bl	3401476c <RCCEx_GetXSPICLKFreq>
34010e78:	60f8      	str	r0, [r7, #12]
      break;
34010e7a:	e00a      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI2_CLKSOURCE);
34010e7c:	482b      	ldr	r0, [pc, #172]	@ (34010f2c <HAL_RCCEx_GetPeriphCLKFreq+0x930>)
34010e7e:	f003 fc75 	bl	3401476c <RCCEx_GetXSPICLKFreq>
34010e82:	60f8      	str	r0, [r7, #12]
      break;
34010e84:	e005      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
34010e86:	482a      	ldr	r0, [pc, #168]	@ (34010f30 <HAL_RCCEx_GetPeriphCLKFreq+0x934>)
34010e88:	f003 fc70 	bl	3401476c <RCCEx_GetXSPICLKFreq>
34010e8c:	60f8      	str	r0, [r7, #12]
      break;
34010e8e:	e000      	b.n	34010e92 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      break;
34010e90:	bf00      	nop
  }

  return frequency;
34010e92:	68fb      	ldr	r3, [r7, #12]
}
34010e94:	4618      	mov	r0, r3
34010e96:	3714      	adds	r7, #20
34010e98:	46bd      	mov	sp, r7
34010e9a:	bd90      	pop	{r4, r7, pc}
34010e9c:	0700000c 	.word	0x0700000c
34010ea0:	0700040c 	.word	0x0700040c
34010ea4:	0700080c 	.word	0x0700080c
34010ea8:	07000c0c 	.word	0x07000c0c
34010eac:	0700100c 	.word	0x0700100c
34010eb0:	0700140c 	.word	0x0700140c
34010eb4:	0700082c 	.word	0x0700082c
34010eb8:	07000c2c 	.word	0x07000c2c
34010ebc:	0700102c 	.word	0x0700102c
34010ec0:	0700142c 	.word	0x0700142c
34010ec4:	0700182c 	.word	0x0700182c
34010ec8:	07001418 	.word	0x07001418
34010ecc:	07001818 	.word	0x07001818
34010ed0:	0300001c 	.word	0x0300001c
34010ed4:	0300041c 	.word	0x0300041c
34010ed8:	07000420 	.word	0x07000420
34010edc:	07000820 	.word	0x07000820
34010ee0:	07000c20 	.word	0x07000c20
34010ee4:	07001020 	.word	0x07001020
34010ee8:	07001420 	.word	0x07001420
34010eec:	07001820 	.word	0x07001820
34010ef0:	07000030 	.word	0x07000030
34010ef4:	07000430 	.word	0x07000430
34010ef8:	07000830 	.word	0x07000830
34010efc:	07000c30 	.word	0x07000c30
34010f00:	07001030 	.word	0x07001030
34010f04:	07001430 	.word	0x07001430
34010f08:	07001830 	.word	0x07001830
34010f0c:	07001c30 	.word	0x07001c30
34010f10:	07000034 	.word	0x07000034
34010f14:	07000434 	.word	0x07000434
34010f18:	01001014 	.word	0x01001014
34010f1c:	03000c14 	.word	0x03000c14
34010f20:	01001814 	.word	0x01001814
34010f24:	03001414 	.word	0x03001414
34010f28:	03000014 	.word	0x03000014
34010f2c:	03000414 	.word	0x03000414
34010f30:	03000814 	.word	0x03000814

34010f34 <HAL_RCCEx_GetPLL1CLKFreq>:
  * @brief  Return PLL1 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL1 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL1CLKFreq(void)
{
34010f34:	b5f0      	push	{r4, r5, r6, r7, lr}
34010f36:	b087      	sub	sp, #28
34010f38:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34010f3a:	2300      	movs	r3, #0
34010f3c:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL1_IsReady() != 0U)
34010f3e:	f7f8 f89b 	bl	34009078 <LL_RCC_PLL1_IsReady>
34010f42:	4603      	mov	r3, r0
34010f44:	2b00      	cmp	r3, #0
34010f46:	d02a      	beq.n	34010f9e <HAL_RCCEx_GetPLL1CLKFreq+0x6a>
  {
    if (LL_RCC_PLL1P_IsEnabled() != 0U)
34010f48:	f7f8 f8fe 	bl	34009148 <LL_RCC_PLL1P_IsEnabled>
34010f4c:	4603      	mov	r3, r0
34010f4e:	2b00      	cmp	r3, #0
34010f50:	d031      	beq.n	34010fb6 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
34010f52:	f7f8 f883 	bl	3400905c <LL_RCC_PLL1_GetSource>
34010f56:	4603      	mov	r3, r0
34010f58:	4618      	mov	r0, r3
34010f5a:	f000 f957 	bl	3401120c <RCCEx_GetPLLSourceFreq>
34010f5e:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34010f60:	68bb      	ldr	r3, [r7, #8]
34010f62:	2b00      	cmp	r3, #0
34010f64:	d027      	beq.n	34010fb6 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
      {
        divm = LL_RCC_PLL1_GetM();
34010f66:	f7f8 f8bf 	bl	340090e8 <LL_RCC_PLL1_GetM>
34010f6a:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34010f6c:	687b      	ldr	r3, [r7, #4]
34010f6e:	2b00      	cmp	r3, #0
34010f70:	d021      	beq.n	34010fb6 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL1_GetN(), LL_RCC_PLL1_GetFRACN(), \
34010f72:	f7f8 f8a9 	bl	340090c8 <LL_RCC_PLL1_GetN>
34010f76:	4605      	mov	r5, r0
34010f78:	f7f8 f8fa 	bl	34009170 <LL_RCC_PLL1_GetFRACN>
34010f7c:	4606      	mov	r6, r0
34010f7e:	f7f8 f8c3 	bl	34009108 <LL_RCC_PLL1_GetP1>
34010f82:	4604      	mov	r4, r0
34010f84:	f7f8 f8d0 	bl	34009128 <LL_RCC_PLL1_GetP2>
34010f88:	4603      	mov	r3, r0
34010f8a:	9301      	str	r3, [sp, #4]
34010f8c:	9400      	str	r4, [sp, #0]
34010f8e:	4633      	mov	r3, r6
34010f90:	462a      	mov	r2, r5
34010f92:	6879      	ldr	r1, [r7, #4]
34010f94:	68b8      	ldr	r0, [r7, #8]
34010f96:	f000 f997 	bl	340112c8 <RCCEx_CalcPLLFreq>
34010f9a:	60f8      	str	r0, [r7, #12]
34010f9c:	e00b      	b.n	34010fb6 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
                                            LL_RCC_PLL1_GetP1(), LL_RCC_PLL1_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL1_IsEnabledBypass() != 0U)
34010f9e:	f7f8 f87f 	bl	340090a0 <LL_RCC_PLL1_IsEnabledBypass>
34010fa2:	4603      	mov	r3, r0
34010fa4:	2b00      	cmp	r3, #0
34010fa6:	d006      	beq.n	34010fb6 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
34010fa8:	f7f8 f858 	bl	3400905c <LL_RCC_PLL1_GetSource>
34010fac:	4603      	mov	r3, r0
34010fae:	4618      	mov	r0, r3
34010fb0:	f000 f92c 	bl	3401120c <RCCEx_GetPLLSourceFreq>
34010fb4:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34010fb6:	68fb      	ldr	r3, [r7, #12]
}
34010fb8:	4618      	mov	r0, r3
34010fba:	3714      	adds	r7, #20
34010fbc:	46bd      	mov	sp, r7
34010fbe:	bdf0      	pop	{r4, r5, r6, r7, pc}

34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>:
  * @brief  Return PLL2 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL2 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL2CLKFreq(void)
{
34010fc0:	b5f0      	push	{r4, r5, r6, r7, lr}
34010fc2:	b087      	sub	sp, #28
34010fc4:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34010fc6:	2300      	movs	r3, #0
34010fc8:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL2_IsReady() != 0U)
34010fca:	f7f8 f8ed 	bl	340091a8 <LL_RCC_PLL2_IsReady>
34010fce:	4603      	mov	r3, r0
34010fd0:	2b00      	cmp	r3, #0
34010fd2:	d02a      	beq.n	3401102a <HAL_RCCEx_GetPLL2CLKFreq+0x6a>
  {
    if (LL_RCC_PLL2P_IsEnabled() != 0U)
34010fd4:	f7f8 f950 	bl	34009278 <LL_RCC_PLL2P_IsEnabled>
34010fd8:	4603      	mov	r3, r0
34010fda:	2b00      	cmp	r3, #0
34010fdc:	d031      	beq.n	34011042 <HAL_RCCEx_GetPLL2CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
34010fde:	f7f8 f8d5 	bl	3400918c <LL_RCC_PLL2_GetSource>
34010fe2:	4603      	mov	r3, r0
34010fe4:	4618      	mov	r0, r3
34010fe6:	f000 f911 	bl	3401120c <RCCEx_GetPLLSourceFreq>
34010fea:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34010fec:	68bb      	ldr	r3, [r7, #8]
34010fee:	2b00      	cmp	r3, #0
34010ff0:	d027      	beq.n	34011042 <HAL_RCCEx_GetPLL2CLKFreq+0x82>
      {

        divm = LL_RCC_PLL2_GetM();
34010ff2:	f7f8 f911 	bl	34009218 <LL_RCC_PLL2_GetM>
34010ff6:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34010ff8:	687b      	ldr	r3, [r7, #4]
34010ffa:	2b00      	cmp	r3, #0
34010ffc:	d021      	beq.n	34011042 <HAL_RCCEx_GetPLL2CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL2_GetN(), LL_RCC_PLL2_GetFRACN(), \
34010ffe:	f7f8 f8fb 	bl	340091f8 <LL_RCC_PLL2_GetN>
34011002:	4605      	mov	r5, r0
34011004:	f7f8 f94c 	bl	340092a0 <LL_RCC_PLL2_GetFRACN>
34011008:	4606      	mov	r6, r0
3401100a:	f7f8 f915 	bl	34009238 <LL_RCC_PLL2_GetP1>
3401100e:	4604      	mov	r4, r0
34011010:	f7f8 f922 	bl	34009258 <LL_RCC_PLL2_GetP2>
34011014:	4603      	mov	r3, r0
34011016:	9301      	str	r3, [sp, #4]
34011018:	9400      	str	r4, [sp, #0]
3401101a:	4633      	mov	r3, r6
3401101c:	462a      	mov	r2, r5
3401101e:	6879      	ldr	r1, [r7, #4]
34011020:	68b8      	ldr	r0, [r7, #8]
34011022:	f000 f951 	bl	340112c8 <RCCEx_CalcPLLFreq>
34011026:	60f8      	str	r0, [r7, #12]
34011028:	e00b      	b.n	34011042 <HAL_RCCEx_GetPLL2CLKFreq+0x82>
                                            LL_RCC_PLL2_GetP1(), LL_RCC_PLL2_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL2_IsEnabledBypass() != 0U)
3401102a:	f7f8 f8d1 	bl	340091d0 <LL_RCC_PLL2_IsEnabledBypass>
3401102e:	4603      	mov	r3, r0
34011030:	2b00      	cmp	r3, #0
34011032:	d006      	beq.n	34011042 <HAL_RCCEx_GetPLL2CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
34011034:	f7f8 f8aa 	bl	3400918c <LL_RCC_PLL2_GetSource>
34011038:	4603      	mov	r3, r0
3401103a:	4618      	mov	r0, r3
3401103c:	f000 f8e6 	bl	3401120c <RCCEx_GetPLLSourceFreq>
34011040:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34011042:	68fb      	ldr	r3, [r7, #12]
}
34011044:	4618      	mov	r0, r3
34011046:	3714      	adds	r7, #20
34011048:	46bd      	mov	sp, r7
3401104a:	bdf0      	pop	{r4, r5, r6, r7, pc}

3401104c <HAL_RCCEx_GetPLL3CLKFreq>:
  * @brief  Return PLL3 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL3 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL3CLKFreq(void)
{
3401104c:	b5f0      	push	{r4, r5, r6, r7, lr}
3401104e:	b087      	sub	sp, #28
34011050:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34011052:	2300      	movs	r3, #0
34011054:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL3_IsReady() != 0U)
34011056:	f7f8 f93f 	bl	340092d8 <LL_RCC_PLL3_IsReady>
3401105a:	4603      	mov	r3, r0
3401105c:	2b00      	cmp	r3, #0
3401105e:	d02a      	beq.n	340110b6 <HAL_RCCEx_GetPLL3CLKFreq+0x6a>
  {
    if (LL_RCC_PLL3P_IsEnabled() != 0U)
34011060:	f7f8 f9a2 	bl	340093a8 <LL_RCC_PLL3P_IsEnabled>
34011064:	4603      	mov	r3, r0
34011066:	2b00      	cmp	r3, #0
34011068:	d031      	beq.n	340110ce <HAL_RCCEx_GetPLL3CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
3401106a:	f7f8 f927 	bl	340092bc <LL_RCC_PLL3_GetSource>
3401106e:	4603      	mov	r3, r0
34011070:	4618      	mov	r0, r3
34011072:	f000 f8cb 	bl	3401120c <RCCEx_GetPLLSourceFreq>
34011076:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34011078:	68bb      	ldr	r3, [r7, #8]
3401107a:	2b00      	cmp	r3, #0
3401107c:	d027      	beq.n	340110ce <HAL_RCCEx_GetPLL3CLKFreq+0x82>
      {
        divm = LL_RCC_PLL3_GetM();
3401107e:	f7f8 f963 	bl	34009348 <LL_RCC_PLL3_GetM>
34011082:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34011084:	687b      	ldr	r3, [r7, #4]
34011086:	2b00      	cmp	r3, #0
34011088:	d021      	beq.n	340110ce <HAL_RCCEx_GetPLL3CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL3_GetN(), LL_RCC_PLL3_GetFRACN(), \
3401108a:	f7f8 f94d 	bl	34009328 <LL_RCC_PLL3_GetN>
3401108e:	4605      	mov	r5, r0
34011090:	f7f8 f99e 	bl	340093d0 <LL_RCC_PLL3_GetFRACN>
34011094:	4606      	mov	r6, r0
34011096:	f7f8 f967 	bl	34009368 <LL_RCC_PLL3_GetP1>
3401109a:	4604      	mov	r4, r0
3401109c:	f7f8 f974 	bl	34009388 <LL_RCC_PLL3_GetP2>
340110a0:	4603      	mov	r3, r0
340110a2:	9301      	str	r3, [sp, #4]
340110a4:	9400      	str	r4, [sp, #0]
340110a6:	4633      	mov	r3, r6
340110a8:	462a      	mov	r2, r5
340110aa:	6879      	ldr	r1, [r7, #4]
340110ac:	68b8      	ldr	r0, [r7, #8]
340110ae:	f000 f90b 	bl	340112c8 <RCCEx_CalcPLLFreq>
340110b2:	60f8      	str	r0, [r7, #12]
340110b4:	e00b      	b.n	340110ce <HAL_RCCEx_GetPLL3CLKFreq+0x82>
                                            LL_RCC_PLL3_GetP1(), LL_RCC_PLL3_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL3_IsEnabledBypass() != 0U)
340110b6:	f7f8 f923 	bl	34009300 <LL_RCC_PLL3_IsEnabledBypass>
340110ba:	4603      	mov	r3, r0
340110bc:	2b00      	cmp	r3, #0
340110be:	d006      	beq.n	340110ce <HAL_RCCEx_GetPLL3CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
340110c0:	f7f8 f8fc 	bl	340092bc <LL_RCC_PLL3_GetSource>
340110c4:	4603      	mov	r3, r0
340110c6:	4618      	mov	r0, r3
340110c8:	f000 f8a0 	bl	3401120c <RCCEx_GetPLLSourceFreq>
340110cc:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
340110ce:	68fb      	ldr	r3, [r7, #12]
}
340110d0:	4618      	mov	r0, r3
340110d2:	3714      	adds	r7, #20
340110d4:	46bd      	mov	sp, r7
340110d6:	bdf0      	pop	{r4, r5, r6, r7, pc}

340110d8 <HAL_RCCEx_GetPLL4CLKFreq>:
  * @brief  Return PLL4 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL4 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL4CLKFreq(void)
{
340110d8:	b5f0      	push	{r4, r5, r6, r7, lr}
340110da:	b087      	sub	sp, #28
340110dc:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
340110de:	2300      	movs	r3, #0
340110e0:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL4_IsReady() != 0U)
340110e2:	f7f8 f991 	bl	34009408 <LL_RCC_PLL4_IsReady>
340110e6:	4603      	mov	r3, r0
340110e8:	2b00      	cmp	r3, #0
340110ea:	d02a      	beq.n	34011142 <HAL_RCCEx_GetPLL4CLKFreq+0x6a>
  {
    if (LL_RCC_PLL4P_IsEnabled() != 0U)
340110ec:	f7f8 f9f4 	bl	340094d8 <LL_RCC_PLL4P_IsEnabled>
340110f0:	4603      	mov	r3, r0
340110f2:	2b00      	cmp	r3, #0
340110f4:	d031      	beq.n	3401115a <HAL_RCCEx_GetPLL4CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
340110f6:	f7f8 f979 	bl	340093ec <LL_RCC_PLL4_GetSource>
340110fa:	4603      	mov	r3, r0
340110fc:	4618      	mov	r0, r3
340110fe:	f000 f885 	bl	3401120c <RCCEx_GetPLLSourceFreq>
34011102:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34011104:	68bb      	ldr	r3, [r7, #8]
34011106:	2b00      	cmp	r3, #0
34011108:	d027      	beq.n	3401115a <HAL_RCCEx_GetPLL4CLKFreq+0x82>
      {

        divm = LL_RCC_PLL4_GetM();
3401110a:	f7f8 f9b5 	bl	34009478 <LL_RCC_PLL4_GetM>
3401110e:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34011110:	687b      	ldr	r3, [r7, #4]
34011112:	2b00      	cmp	r3, #0
34011114:	d021      	beq.n	3401115a <HAL_RCCEx_GetPLL4CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL4_GetN(), LL_RCC_PLL4_GetFRACN(), \
34011116:	f7f8 f99f 	bl	34009458 <LL_RCC_PLL4_GetN>
3401111a:	4605      	mov	r5, r0
3401111c:	f7f8 f9f0 	bl	34009500 <LL_RCC_PLL4_GetFRACN>
34011120:	4606      	mov	r6, r0
34011122:	f7f8 f9b9 	bl	34009498 <LL_RCC_PLL4_GetP1>
34011126:	4604      	mov	r4, r0
34011128:	f7f8 f9c6 	bl	340094b8 <LL_RCC_PLL4_GetP2>
3401112c:	4603      	mov	r3, r0
3401112e:	9301      	str	r3, [sp, #4]
34011130:	9400      	str	r4, [sp, #0]
34011132:	4633      	mov	r3, r6
34011134:	462a      	mov	r2, r5
34011136:	6879      	ldr	r1, [r7, #4]
34011138:	68b8      	ldr	r0, [r7, #8]
3401113a:	f000 f8c5 	bl	340112c8 <RCCEx_CalcPLLFreq>
3401113e:	60f8      	str	r0, [r7, #12]
34011140:	e00b      	b.n	3401115a <HAL_RCCEx_GetPLL4CLKFreq+0x82>
                                            LL_RCC_PLL4_GetP1(), LL_RCC_PLL4_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL4_IsEnabledBypass() != 0U)
34011142:	f7f8 f975 	bl	34009430 <LL_RCC_PLL4_IsEnabledBypass>
34011146:	4603      	mov	r3, r0
34011148:	2b00      	cmp	r3, #0
3401114a:	d006      	beq.n	3401115a <HAL_RCCEx_GetPLL4CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
3401114c:	f7f8 f94e 	bl	340093ec <LL_RCC_PLL4_GetSource>
34011150:	4603      	mov	r3, r0
34011152:	4618      	mov	r0, r3
34011154:	f000 f85a 	bl	3401120c <RCCEx_GetPLLSourceFreq>
34011158:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
3401115a:	68fb      	ldr	r3, [r7, #12]
}
3401115c:	4618      	mov	r0, r3
3401115e:	3714      	adds	r7, #20
34011160:	46bd      	mov	sp, r7
34011162:	bdf0      	pop	{r4, r5, r6, r7, pc}

34011164 <RCCEx_GetHCLKFreq>:
  * @brief  Return HCLK clock frequency
  * @param  SYSCLK_Frequency SYSCLK clock frequency
  * @retval HCLK clock frequency (in Hz)
  */
static uint32_t RCCEx_GetHCLKFreq(uint32_t SYSCLK_Frequency)
{
34011164:	b580      	push	{r7, lr}
34011166:	b082      	sub	sp, #8
34011168:	af00      	add	r7, sp, #0
3401116a:	6078      	str	r0, [r7, #4]
  /* HCLK clock frequency */
  return LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
3401116c:	f7f7 fb60 	bl	34008830 <LL_RCC_GetAHBPrescaler>
34011170:	4603      	mov	r3, r0
34011172:	0d1b      	lsrs	r3, r3, #20
34011174:	f003 0307 	and.w	r3, r3, #7
34011178:	687a      	ldr	r2, [r7, #4]
3401117a:	fa22 f303 	lsr.w	r3, r2, r3
}
3401117e:	4618      	mov	r0, r3
34011180:	3708      	adds	r7, #8
34011182:	46bd      	mov	sp, r7
34011184:	bd80      	pop	{r7, pc}

34011186 <RCCEx_GetPCLK1Freq>:
  * @brief  Return PCLK1 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK1 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK1Freq(uint32_t HCLK_Frequency)
{
34011186:	b580      	push	{r7, lr}
34011188:	b082      	sub	sp, #8
3401118a:	af00      	add	r7, sp, #0
3401118c:	6078      	str	r0, [r7, #4]
  /* PCLK1 clock frequency */
  return LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
3401118e:	f7f7 fb5d 	bl	3400884c <LL_RCC_GetAPB1Prescaler>
34011192:	4603      	mov	r3, r0
34011194:	f003 0307 	and.w	r3, r3, #7
34011198:	687a      	ldr	r2, [r7, #4]
3401119a:	fa22 f303 	lsr.w	r3, r2, r3
}
3401119e:	4618      	mov	r0, r3
340111a0:	3708      	adds	r7, #8
340111a2:	46bd      	mov	sp, r7
340111a4:	bd80      	pop	{r7, pc}

340111a6 <RCCEx_GetPCLK2Freq>:
  * @brief  Return PCLK2 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK2 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK2Freq(uint32_t HCLK_Frequency)
{
340111a6:	b580      	push	{r7, lr}
340111a8:	b082      	sub	sp, #8
340111aa:	af00      	add	r7, sp, #0
340111ac:	6078      	str	r0, [r7, #4]
  /* PCLK2 clock frequency */
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
340111ae:	f7f7 fb5b 	bl	34008868 <LL_RCC_GetAPB2Prescaler>
340111b2:	4603      	mov	r3, r0
340111b4:	091b      	lsrs	r3, r3, #4
340111b6:	f003 0307 	and.w	r3, r3, #7
340111ba:	687a      	ldr	r2, [r7, #4]
340111bc:	fa22 f303 	lsr.w	r3, r2, r3
}
340111c0:	4618      	mov	r0, r3
340111c2:	3708      	adds	r7, #8
340111c4:	46bd      	mov	sp, r7
340111c6:	bd80      	pop	{r7, pc}

340111c8 <RCCEx_GetPCLK4Freq>:
  * @brief  Return PCLK4 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK4 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK4Freq(uint32_t HCLK_Frequency)
{
340111c8:	b580      	push	{r7, lr}
340111ca:	b082      	sub	sp, #8
340111cc:	af00      	add	r7, sp, #0
340111ce:	6078      	str	r0, [r7, #4]
  /* PCLK4 clock frequency */
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
340111d0:	f7f7 fb58 	bl	34008884 <LL_RCC_GetAPB4Prescaler>
340111d4:	4603      	mov	r3, r0
340111d6:	0b1b      	lsrs	r3, r3, #12
340111d8:	f003 0307 	and.w	r3, r3, #7
340111dc:	687a      	ldr	r2, [r7, #4]
340111de:	fa22 f303 	lsr.w	r3, r2, r3
}
340111e2:	4618      	mov	r0, r3
340111e4:	3708      	adds	r7, #8
340111e6:	46bd      	mov	sp, r7
340111e8:	bd80      	pop	{r7, pc}

340111ea <RCCEx_GetPCLK5Freq>:
  * @brief  Return PCLK5 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK5 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK5Freq(uint32_t HCLK_Frequency)
{
340111ea:	b580      	push	{r7, lr}
340111ec:	b082      	sub	sp, #8
340111ee:	af00      	add	r7, sp, #0
340111f0:	6078      	str	r0, [r7, #4]
  /* PCLK5 clock frequency */
  return LL_RCC_CALC_PCLK5_FREQ(HCLK_Frequency, LL_RCC_GetAPB5Prescaler());
340111f2:	f7f7 fb55 	bl	340088a0 <LL_RCC_GetAPB5Prescaler>
340111f6:	4603      	mov	r3, r0
340111f8:	0c1b      	lsrs	r3, r3, #16
340111fa:	f003 0307 	and.w	r3, r3, #7
340111fe:	687a      	ldr	r2, [r7, #4]
34011200:	fa22 f303 	lsr.w	r3, r2, r3
}
34011204:	4618      	mov	r0, r3
34011206:	3708      	adds	r7, #8
34011208:	46bd      	mov	sp, r7
3401120a:	bd80      	pop	{r7, pc}

3401120c <RCCEx_GetPLLSourceFreq>:
  * @brief  Return PLL source clock frequency
  * @param  PLLsource PLL source clock
  * @retval PLL source clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPLLSourceFreq(uint32_t PLLsource)
{
3401120c:	b580      	push	{r7, lr}
3401120e:	b084      	sub	sp, #16
34011210:	af00      	add	r7, sp, #0
34011212:	6078      	str	r0, [r7, #4]
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;
34011214:	2300      	movs	r3, #0
34011216:	60fb      	str	r3, [r7, #12]

  switch (PLLsource)
34011218:	687b      	ldr	r3, [r7, #4]
3401121a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401121e:	d039      	beq.n	34011294 <RCCEx_GetPLLSourceFreq+0x88>
34011220:	687b      	ldr	r3, [r7, #4]
34011222:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011226:	d838      	bhi.n	3401129a <RCCEx_GetPLLSourceFreq+0x8e>
34011228:	687b      	ldr	r3, [r7, #4]
3401122a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401122e:	d029      	beq.n	34011284 <RCCEx_GetPLLSourceFreq+0x78>
34011230:	687b      	ldr	r3, [r7, #4]
34011232:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011236:	d830      	bhi.n	3401129a <RCCEx_GetPLLSourceFreq+0x8e>
34011238:	687b      	ldr	r3, [r7, #4]
3401123a:	2b00      	cmp	r3, #0
3401123c:	d004      	beq.n	34011248 <RCCEx_GetPLLSourceFreq+0x3c>
3401123e:	687b      	ldr	r3, [r7, #4]
34011240:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011244:	d00e      	beq.n	34011264 <RCCEx_GetPLLSourceFreq+0x58>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
      break;

    default:
      /* unexpected case */
      break;
34011246:	e028      	b.n	3401129a <RCCEx_GetPLLSourceFreq+0x8e>
      if (LL_RCC_HSI_IsReady() != 0U)
34011248:	f7f7 fa92 	bl	34008770 <LL_RCC_HSI_IsReady>
3401124c:	4603      	mov	r3, r0
3401124e:	2b00      	cmp	r3, #0
34011250:	d025      	beq.n	3401129e <RCCEx_GetPLLSourceFreq+0x92>
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34011252:	f7f7 fa9f 	bl	34008794 <LL_RCC_HSI_GetDivider>
34011256:	4603      	mov	r3, r0
34011258:	09db      	lsrs	r3, r3, #7
3401125a:	4a16      	ldr	r2, [pc, #88]	@ (340112b4 <RCCEx_GetPLLSourceFreq+0xa8>)
3401125c:	fa22 f303 	lsr.w	r3, r2, r3
34011260:	60fb      	str	r3, [r7, #12]
      break;
34011262:	e01c      	b.n	3401129e <RCCEx_GetPLLSourceFreq+0x92>
      if (LL_RCC_MSI_IsReady() != 0U)
34011264:	f7f7 faa4 	bl	340087b0 <LL_RCC_MSI_IsReady>
34011268:	4603      	mov	r3, r0
3401126a:	2b00      	cmp	r3, #0
3401126c:	d019      	beq.n	340112a2 <RCCEx_GetPLLSourceFreq+0x96>
        if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
3401126e:	f7f7 fab1 	bl	340087d4 <LL_RCC_MSI_GetFrequency>
34011272:	4603      	mov	r3, r0
34011274:	2b00      	cmp	r3, #0
34011276:	d102      	bne.n	3401127e <RCCEx_GetPLLSourceFreq+0x72>
          pllinputfreq = MSI_VALUE;
34011278:	4b0f      	ldr	r3, [pc, #60]	@ (340112b8 <RCCEx_GetPLLSourceFreq+0xac>)
3401127a:	60fb      	str	r3, [r7, #12]
      break;
3401127c:	e011      	b.n	340112a2 <RCCEx_GetPLLSourceFreq+0x96>
          pllinputfreq = 16000000UL;
3401127e:	4b0f      	ldr	r3, [pc, #60]	@ (340112bc <RCCEx_GetPLLSourceFreq+0xb0>)
34011280:	60fb      	str	r3, [r7, #12]
      break;
34011282:	e00e      	b.n	340112a2 <RCCEx_GetPLLSourceFreq+0x96>
      if (LL_RCC_HSE_IsReady() != 0U)
34011284:	f7f7 fa62 	bl	3400874c <LL_RCC_HSE_IsReady>
34011288:	4603      	mov	r3, r0
3401128a:	2b00      	cmp	r3, #0
3401128c:	d00b      	beq.n	340112a6 <RCCEx_GetPLLSourceFreq+0x9a>
        pllinputfreq = HSE_VALUE;
3401128e:	4b0c      	ldr	r3, [pc, #48]	@ (340112c0 <RCCEx_GetPLLSourceFreq+0xb4>)
34011290:	60fb      	str	r3, [r7, #12]
      break;
34011292:	e008      	b.n	340112a6 <RCCEx_GetPLLSourceFreq+0x9a>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
34011294:	4b0b      	ldr	r3, [pc, #44]	@ (340112c4 <RCCEx_GetPLLSourceFreq+0xb8>)
34011296:	60fb      	str	r3, [r7, #12]
      break;
34011298:	e006      	b.n	340112a8 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
3401129a:	bf00      	nop
3401129c:	e004      	b.n	340112a8 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
3401129e:	bf00      	nop
340112a0:	e002      	b.n	340112a8 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
340112a2:	bf00      	nop
340112a4:	e000      	b.n	340112a8 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
340112a6:	bf00      	nop
  }

  return pllinputfreq;
340112a8:	68fb      	ldr	r3, [r7, #12]
}
340112aa:	4618      	mov	r0, r3
340112ac:	3710      	adds	r7, #16
340112ae:	46bd      	mov	sp, r7
340112b0:	bd80      	pop	{r7, pc}
340112b2:	bf00      	nop
340112b4:	03d09000 	.word	0x03d09000
340112b8:	003d0900 	.word	0x003d0900
340112bc:	00f42400 	.word	0x00f42400
340112c0:	02dc6c00 	.word	0x02dc6c00
340112c4:	00bb8000 	.word	0x00bb8000

340112c8 <RCCEx_CalcPLLFreq>:
  * @param  P2     VCO output divider P2 between 1 and 7
  * @retval PLL clock frequency (in Hz)
  */
static uint32_t RCCEx_CalcPLLFreq(uint32_t PLLInputFreq, uint32_t M, uint32_t N, uint32_t FRACN, uint32_t P1,
                                  uint32_t P2)
{
340112c8:	b480      	push	{r7}
340112ca:	b087      	sub	sp, #28
340112cc:	af00      	add	r7, sp, #0
340112ce:	60f8      	str	r0, [r7, #12]
340112d0:	60b9      	str	r1, [r7, #8]
340112d2:	607a      	str	r2, [r7, #4]
340112d4:	603b      	str	r3, [r7, #0]
  float_t freq;

  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
340112d6:	68fb      	ldr	r3, [r7, #12]
340112d8:	ee07 3a90 	vmov	s15, r3
340112dc:	eeb8 7a67 	vcvt.f32.u32	s14, s15
340112e0:	687b      	ldr	r3, [r7, #4]
340112e2:	ee07 3a90 	vmov	s15, r3
340112e6:	eef8 6a67 	vcvt.f32.u32	s13, s15
340112ea:	683b      	ldr	r3, [r7, #0]
340112ec:	ee07 3a90 	vmov	s15, r3
340112f0:	eeb8 6a67 	vcvt.f32.u32	s12, s15
340112f4:	eddf 5a19 	vldr	s11, [pc, #100]	@ 3401135c <RCCEx_CalcPLLFreq+0x94>
340112f8:	eec6 7a25 	vdiv.f32	s15, s12, s11
340112fc:	ee76 7aa7 	vadd.f32	s15, s13, s15
34011300:	ee67 6a27 	vmul.f32	s13, s14, s15
34011304:	68bb      	ldr	r3, [r7, #8]
34011306:	ee07 3a90 	vmov	s15, r3
3401130a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401130e:	eec6 7a87 	vdiv.f32	s15, s13, s14
34011312:	edc7 7a05 	vstr	s15, [r7, #20]

  freq = freq / (float_t)P1;
34011316:	6a3b      	ldr	r3, [r7, #32]
34011318:	ee07 3a90 	vmov	s15, r3
3401131c:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34011320:	edd7 6a05 	vldr	s13, [r7, #20]
34011324:	eec6 7a87 	vdiv.f32	s15, s13, s14
34011328:	edc7 7a05 	vstr	s15, [r7, #20]
  freq = freq / (float_t)P2;
3401132c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401132e:	ee07 3a90 	vmov	s15, r3
34011332:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34011336:	edd7 6a05 	vldr	s13, [r7, #20]
3401133a:	eec6 7a87 	vdiv.f32	s15, s13, s14
3401133e:	edc7 7a05 	vstr	s15, [r7, #20]

  return (uint32_t)freq;
34011342:	edd7 7a05 	vldr	s15, [r7, #20]
34011346:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3401134a:	ee17 3a90 	vmov	r3, s15
}
3401134e:	4618      	mov	r0, r3
34011350:	371c      	adds	r7, #28
34011352:	46bd      	mov	sp, r7
34011354:	f85d 7b04 	ldr.w	r7, [sp], #4
34011358:	4770      	bx	lr
3401135a:	bf00      	nop
3401135c:	4b800000 	.word	0x4b800000

34011360 <RCCEx_GetADCCLKFreq>:
  *         @arg @ref RCCEx_ADC_Clock_Source
  * @retval ADC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetADCCLKFreq(uint32_t ADCxSource)
{
34011360:	b590      	push	{r4, r7, lr}
34011362:	b085      	sub	sp, #20
34011364:	af00      	add	r7, sp, #0
34011366:	6078      	str	r0, [r7, #4]
  uint32_t adc_frequency = RCC_PERIPH_FREQUENCY_NO;
34011368:	2300      	movs	r3, #0
3401136a:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetADCClockSource(ADCxSource))
3401136c:	6878      	ldr	r0, [r7, #4]
3401136e:	f7f7 fcb5 	bl	34008cdc <LL_RCC_GetADCClockSource>
34011372:	4603      	mov	r3, r0
34011374:	2b70      	cmp	r3, #112	@ 0x70
34011376:	f000 80d1 	beq.w	3401151c <RCCEx_GetADCCLKFreq+0x1bc>
3401137a:	2b70      	cmp	r3, #112	@ 0x70
3401137c:	f200 80d8 	bhi.w	34011530 <RCCEx_GetADCCLKFreq+0x1d0>
34011380:	2b60      	cmp	r3, #96	@ 0x60
34011382:	f000 80c8 	beq.w	34011516 <RCCEx_GetADCCLKFreq+0x1b6>
34011386:	2b60      	cmp	r3, #96	@ 0x60
34011388:	f200 80d2 	bhi.w	34011530 <RCCEx_GetADCCLKFreq+0x1d0>
3401138c:	2b50      	cmp	r3, #80	@ 0x50
3401138e:	f000 80ac 	beq.w	340114ea <RCCEx_GetADCCLKFreq+0x18a>
34011392:	2b50      	cmp	r3, #80	@ 0x50
34011394:	f200 80cc 	bhi.w	34011530 <RCCEx_GetADCCLKFreq+0x1d0>
34011398:	2b40      	cmp	r3, #64	@ 0x40
3401139a:	f000 80b4 	beq.w	34011506 <RCCEx_GetADCCLKFreq+0x1a6>
3401139e:	2b40      	cmp	r3, #64	@ 0x40
340113a0:	f200 80c6 	bhi.w	34011530 <RCCEx_GetADCCLKFreq+0x1d0>
340113a4:	2b30      	cmp	r3, #48	@ 0x30
340113a6:	d05d      	beq.n	34011464 <RCCEx_GetADCCLKFreq+0x104>
340113a8:	2b30      	cmp	r3, #48	@ 0x30
340113aa:	f200 80c1 	bhi.w	34011530 <RCCEx_GetADCCLKFreq+0x1d0>
340113ae:	2b20      	cmp	r3, #32
340113b0:	d014      	beq.n	340113dc <RCCEx_GetADCCLKFreq+0x7c>
340113b2:	2b20      	cmp	r3, #32
340113b4:	f200 80bc 	bhi.w	34011530 <RCCEx_GetADCCLKFreq+0x1d0>
340113b8:	2b00      	cmp	r3, #0
340113ba:	d002      	beq.n	340113c2 <RCCEx_GetADCCLKFreq+0x62>
340113bc:	2b10      	cmp	r3, #16
340113be:	d008      	beq.n	340113d2 <RCCEx_GetADCCLKFreq+0x72>
      adc_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
      break;

    default:
      /* Unexpected case */
      break;
340113c0:	e0b6      	b.n	34011530 <RCCEx_GetADCCLKFreq+0x1d0>
      adc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
340113c2:	f7f6 fdd7 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
340113c6:	4603      	mov	r3, r0
340113c8:	4618      	mov	r0, r3
340113ca:	f7ff fecb 	bl	34011164 <RCCEx_GetHCLKFreq>
340113ce:	60f8      	str	r0, [r7, #12]
      break;
340113d0:	e0b7      	b.n	34011542 <RCCEx_GetADCCLKFreq+0x1e2>
      adc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340113d2:	2007      	movs	r0, #7
340113d4:	f000 f9b2 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
340113d8:	60f8      	str	r0, [r7, #12]
      break;
340113da:	e0b2      	b.n	34011542 <RCCEx_GetADCCLKFreq+0x1e2>
      if (LL_RCC_IC7_IsEnabled() != 0U)
340113dc:	f7f8 f96c 	bl	340096b8 <LL_RCC_IC7_IsEnabled>
340113e0:	4603      	mov	r3, r0
340113e2:	2b00      	cmp	r3, #0
340113e4:	f000 80a6 	beq.w	34011534 <RCCEx_GetADCCLKFreq+0x1d4>
        ic_divider = LL_RCC_IC7_GetDivider();
340113e8:	f7f8 f988 	bl	340096fc <LL_RCC_IC7_GetDivider>
340113ec:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
340113ee:	f7f8 f977 	bl	340096e0 <LL_RCC_IC7_GetSource>
340113f2:	4603      	mov	r3, r0
340113f4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340113f8:	d029      	beq.n	3401144e <RCCEx_GetADCCLKFreq+0xee>
340113fa:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340113fe:	d82f      	bhi.n	34011460 <RCCEx_GetADCCLKFreq+0x100>
34011400:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011404:	d01a      	beq.n	3401143c <RCCEx_GetADCCLKFreq+0xdc>
34011406:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401140a:	d829      	bhi.n	34011460 <RCCEx_GetADCCLKFreq+0x100>
3401140c:	2b00      	cmp	r3, #0
3401140e:	d003      	beq.n	34011418 <RCCEx_GetADCCLKFreq+0xb8>
34011410:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011414:	d009      	beq.n	3401142a <RCCEx_GetADCCLKFreq+0xca>
            break;
34011416:	e023      	b.n	34011460 <RCCEx_GetADCCLKFreq+0x100>
            adc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34011418:	f7ff fd8c 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
3401141c:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
3401141e:	68fa      	ldr	r2, [r7, #12]
34011420:	68bb      	ldr	r3, [r7, #8]
34011422:	fbb2 f3f3 	udiv	r3, r2, r3
34011426:	60fb      	str	r3, [r7, #12]
            break;
34011428:	e01b      	b.n	34011462 <RCCEx_GetADCCLKFreq+0x102>
            adc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3401142a:	f7ff fdc9 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
3401142e:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34011430:	68fa      	ldr	r2, [r7, #12]
34011432:	68bb      	ldr	r3, [r7, #8]
34011434:	fbb2 f3f3 	udiv	r3, r2, r3
34011438:	60fb      	str	r3, [r7, #12]
            break;
3401143a:	e012      	b.n	34011462 <RCCEx_GetADCCLKFreq+0x102>
            adc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401143c:	f7ff fe06 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34011440:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34011442:	68fa      	ldr	r2, [r7, #12]
34011444:	68bb      	ldr	r3, [r7, #8]
34011446:	fbb2 f3f3 	udiv	r3, r2, r3
3401144a:	60fb      	str	r3, [r7, #12]
            break;
3401144c:	e009      	b.n	34011462 <RCCEx_GetADCCLKFreq+0x102>
            adc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401144e:	f7ff fe43 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34011452:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34011454:	68fa      	ldr	r2, [r7, #12]
34011456:	68bb      	ldr	r3, [r7, #8]
34011458:	fbb2 f3f3 	udiv	r3, r2, r3
3401145c:	60fb      	str	r3, [r7, #12]
            break;
3401145e:	e000      	b.n	34011462 <RCCEx_GetADCCLKFreq+0x102>
            break;
34011460:	bf00      	nop
      break;
34011462:	e067      	b.n	34011534 <RCCEx_GetADCCLKFreq+0x1d4>
      if (LL_RCC_IC8_IsEnabled() != 0U)
34011464:	f7f8 f968 	bl	34009738 <LL_RCC_IC8_IsEnabled>
34011468:	4603      	mov	r3, r0
3401146a:	2b00      	cmp	r3, #0
3401146c:	d064      	beq.n	34011538 <RCCEx_GetADCCLKFreq+0x1d8>
        ic_divider = LL_RCC_IC8_GetDivider();
3401146e:	f7f8 f985 	bl	3400977c <LL_RCC_IC8_GetDivider>
34011472:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34011474:	f7f8 f974 	bl	34009760 <LL_RCC_IC8_GetSource>
34011478:	4603      	mov	r3, r0
3401147a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401147e:	d029      	beq.n	340114d4 <RCCEx_GetADCCLKFreq+0x174>
34011480:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011484:	d82f      	bhi.n	340114e6 <RCCEx_GetADCCLKFreq+0x186>
34011486:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401148a:	d01a      	beq.n	340114c2 <RCCEx_GetADCCLKFreq+0x162>
3401148c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011490:	d829      	bhi.n	340114e6 <RCCEx_GetADCCLKFreq+0x186>
34011492:	2b00      	cmp	r3, #0
34011494:	d003      	beq.n	3401149e <RCCEx_GetADCCLKFreq+0x13e>
34011496:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401149a:	d009      	beq.n	340114b0 <RCCEx_GetADCCLKFreq+0x150>
            break;
3401149c:	e023      	b.n	340114e6 <RCCEx_GetADCCLKFreq+0x186>
            adc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3401149e:	f7ff fd49 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
340114a2:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
340114a4:	68fa      	ldr	r2, [r7, #12]
340114a6:	68bb      	ldr	r3, [r7, #8]
340114a8:	fbb2 f3f3 	udiv	r3, r2, r3
340114ac:	60fb      	str	r3, [r7, #12]
            break;
340114ae:	e01b      	b.n	340114e8 <RCCEx_GetADCCLKFreq+0x188>
            adc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340114b0:	f7ff fd86 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
340114b4:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
340114b6:	68fa      	ldr	r2, [r7, #12]
340114b8:	68bb      	ldr	r3, [r7, #8]
340114ba:	fbb2 f3f3 	udiv	r3, r2, r3
340114be:	60fb      	str	r3, [r7, #12]
            break;
340114c0:	e012      	b.n	340114e8 <RCCEx_GetADCCLKFreq+0x188>
            adc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340114c2:	f7ff fdc3 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
340114c6:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
340114c8:	68fa      	ldr	r2, [r7, #12]
340114ca:	68bb      	ldr	r3, [r7, #8]
340114cc:	fbb2 f3f3 	udiv	r3, r2, r3
340114d0:	60fb      	str	r3, [r7, #12]
            break;
340114d2:	e009      	b.n	340114e8 <RCCEx_GetADCCLKFreq+0x188>
            adc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340114d4:	f7ff fe00 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
340114d8:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
340114da:	68fa      	ldr	r2, [r7, #12]
340114dc:	68bb      	ldr	r3, [r7, #8]
340114de:	fbb2 f3f3 	udiv	r3, r2, r3
340114e2:	60fb      	str	r3, [r7, #12]
            break;
340114e4:	e000      	b.n	340114e8 <RCCEx_GetADCCLKFreq+0x188>
            break;
340114e6:	bf00      	nop
      break;
340114e8:	e026      	b.n	34011538 <RCCEx_GetADCCLKFreq+0x1d8>
      if (LL_RCC_HSI_IsReady() != 0U)
340114ea:	f7f7 f941 	bl	34008770 <LL_RCC_HSI_IsReady>
340114ee:	4603      	mov	r3, r0
340114f0:	2b00      	cmp	r3, #0
340114f2:	d023      	beq.n	3401153c <RCCEx_GetADCCLKFreq+0x1dc>
        adc_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340114f4:	f7f7 f94e 	bl	34008794 <LL_RCC_HSI_GetDivider>
340114f8:	4603      	mov	r3, r0
340114fa:	09db      	lsrs	r3, r3, #7
340114fc:	4a16      	ldr	r2, [pc, #88]	@ (34011558 <RCCEx_GetADCCLKFreq+0x1f8>)
340114fe:	fa22 f303 	lsr.w	r3, r2, r3
34011502:	60fb      	str	r3, [r7, #12]
      break;
34011504:	e01a      	b.n	3401153c <RCCEx_GetADCCLKFreq+0x1dc>
      if (LL_RCC_MSI_IsReady() != 0U)
34011506:	f7f7 f953 	bl	340087b0 <LL_RCC_MSI_IsReady>
3401150a:	4603      	mov	r3, r0
3401150c:	2b00      	cmp	r3, #0
3401150e:	d017      	beq.n	34011540 <RCCEx_GetADCCLKFreq+0x1e0>
        adc_frequency = MSI_VALUE;
34011510:	4b12      	ldr	r3, [pc, #72]	@ (3401155c <RCCEx_GetADCCLKFreq+0x1fc>)
34011512:	60fb      	str	r3, [r7, #12]
      break;
34011514:	e014      	b.n	34011540 <RCCEx_GetADCCLKFreq+0x1e0>
      adc_frequency = EXTERNAL_CLOCK_VALUE;
34011516:	4b12      	ldr	r3, [pc, #72]	@ (34011560 <RCCEx_GetADCCLKFreq+0x200>)
34011518:	60fb      	str	r3, [r7, #12]
      break;
3401151a:	e012      	b.n	34011542 <RCCEx_GetADCCLKFreq+0x1e2>
      adc_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
3401151c:	f7f6 fd2a 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34011520:	4604      	mov	r4, r0
34011522:	f7f7 fd8d 	bl	34009040 <LL_RCC_GetTIMPrescaler>
34011526:	4603      	mov	r3, r0
34011528:	fa24 f303 	lsr.w	r3, r4, r3
3401152c:	60fb      	str	r3, [r7, #12]
      break;
3401152e:	e008      	b.n	34011542 <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34011530:	bf00      	nop
34011532:	e006      	b.n	34011542 <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34011534:	bf00      	nop
34011536:	e004      	b.n	34011542 <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34011538:	bf00      	nop
3401153a:	e002      	b.n	34011542 <RCCEx_GetADCCLKFreq+0x1e2>
      break;
3401153c:	bf00      	nop
3401153e:	e000      	b.n	34011542 <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34011540:	bf00      	nop
  }

  return (adc_frequency / __HAL_RCC_GET_ADC_DIVIDER());
34011542:	f7f7 f9e5 	bl	34008910 <LL_RCC_GetADCPrescaler>
34011546:	4603      	mov	r3, r0
34011548:	3301      	adds	r3, #1
3401154a:	68fa      	ldr	r2, [r7, #12]
3401154c:	fbb2 f3f3 	udiv	r3, r2, r3
}
34011550:	4618      	mov	r0, r3
34011552:	3714      	adds	r7, #20
34011554:	46bd      	mov	sp, r7
34011556:	bd90      	pop	{r4, r7, pc}
34011558:	03d09000 	.word	0x03d09000
3401155c:	003d0900 	.word	0x003d0900
34011560:	00bb8000 	.word	0x00bb8000

34011564 <RCCEx_GetADFCLKFreq>:
  *         @arg @ref RCCEx_ADF1_Clock_Source
  * @retval ADF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetADFCLKFreq(uint32_t ADFxSource)
{
34011564:	b590      	push	{r4, r7, lr}
34011566:	b085      	sub	sp, #20
34011568:	af00      	add	r7, sp, #0
3401156a:	6078      	str	r0, [r7, #4]
  uint32_t adf_frequency = RCC_PERIPH_FREQUENCY_NO;
3401156c:	2300      	movs	r3, #0
3401156e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetADFClockSource(ADFxSource))
34011570:	6878      	ldr	r0, [r7, #4]
34011572:	f7f7 fbc5 	bl	34008d00 <LL_RCC_GetADFClockSource>
34011576:	4603      	mov	r3, r0
34011578:	2b07      	cmp	r3, #7
3401157a:	f200 80ca 	bhi.w	34011712 <RCCEx_GetADFCLKFreq+0x1ae>
3401157e:	a201      	add	r2, pc, #4	@ (adr r2, 34011584 <RCCEx_GetADFCLKFreq+0x20>)
34011580:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34011584:	340115a5 	.word	0x340115a5
34011588:	340115b5 	.word	0x340115b5
3401158c:	340115bf 	.word	0x340115bf
34011590:	34011647 	.word	0x34011647
34011594:	340116e9 	.word	0x340116e9
34011598:	340116cd 	.word	0x340116cd
3401159c:	340116f9 	.word	0x340116f9
340115a0:	340116ff 	.word	0x340116ff
  {
    case LL_RCC_ADF1_CLKSOURCE_HCLK:
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
340115a4:	f7f6 fce6 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
340115a8:	4603      	mov	r3, r0
340115aa:	4618      	mov	r0, r3
340115ac:	f7ff fdda 	bl	34011164 <RCCEx_GetHCLKFreq>
340115b0:	60f8      	str	r0, [r7, #12]
      break;
340115b2:	e0b7      	b.n	34011724 <RCCEx_GetADFCLKFreq+0x1c0>

    case LL_RCC_ADF1_CLKSOURCE_CLKP:
      adf_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340115b4:	2007      	movs	r0, #7
340115b6:	f000 f8c1 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
340115ba:	60f8      	str	r0, [r7, #12]
      break;
340115bc:	e0b2      	b.n	34011724 <RCCEx_GetADFCLKFreq+0x1c0>

    case LL_RCC_ADF1_CLKSOURCE_IC7:
      if (LL_RCC_IC7_IsEnabled() != 0U)
340115be:	f7f8 f87b 	bl	340096b8 <LL_RCC_IC7_IsEnabled>
340115c2:	4603      	mov	r3, r0
340115c4:	2b00      	cmp	r3, #0
340115c6:	f000 80a6 	beq.w	34011716 <RCCEx_GetADFCLKFreq+0x1b2>
      {
        ic_divider = LL_RCC_IC7_GetDivider();
340115ca:	f7f8 f897 	bl	340096fc <LL_RCC_IC7_GetDivider>
340115ce:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
340115d0:	f7f8 f886 	bl	340096e0 <LL_RCC_IC7_GetSource>
340115d4:	4603      	mov	r3, r0
340115d6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340115da:	d029      	beq.n	34011630 <RCCEx_GetADFCLKFreq+0xcc>
340115dc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340115e0:	d82f      	bhi.n	34011642 <RCCEx_GetADFCLKFreq+0xde>
340115e2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340115e6:	d01a      	beq.n	3401161e <RCCEx_GetADFCLKFreq+0xba>
340115e8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340115ec:	d829      	bhi.n	34011642 <RCCEx_GetADFCLKFreq+0xde>
340115ee:	2b00      	cmp	r3, #0
340115f0:	d003      	beq.n	340115fa <RCCEx_GetADFCLKFreq+0x96>
340115f2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340115f6:	d009      	beq.n	3401160c <RCCEx_GetADFCLKFreq+0xa8>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            adf_frequency = adf_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
340115f8:	e023      	b.n	34011642 <RCCEx_GetADFCLKFreq+0xde>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340115fa:	f7ff fc9b 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
340115fe:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34011600:	68fa      	ldr	r2, [r7, #12]
34011602:	68bb      	ldr	r3, [r7, #8]
34011604:	fbb2 f3f3 	udiv	r3, r2, r3
34011608:	60fb      	str	r3, [r7, #12]
            break;
3401160a:	e01b      	b.n	34011644 <RCCEx_GetADFCLKFreq+0xe0>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3401160c:	f7ff fcd8 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34011610:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34011612:	68fa      	ldr	r2, [r7, #12]
34011614:	68bb      	ldr	r3, [r7, #8]
34011616:	fbb2 f3f3 	udiv	r3, r2, r3
3401161a:	60fb      	str	r3, [r7, #12]
            break;
3401161c:	e012      	b.n	34011644 <RCCEx_GetADFCLKFreq+0xe0>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401161e:	f7ff fd15 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34011622:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34011624:	68fa      	ldr	r2, [r7, #12]
34011626:	68bb      	ldr	r3, [r7, #8]
34011628:	fbb2 f3f3 	udiv	r3, r2, r3
3401162c:	60fb      	str	r3, [r7, #12]
            break;
3401162e:	e009      	b.n	34011644 <RCCEx_GetADFCLKFreq+0xe0>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34011630:	f7ff fd52 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34011634:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34011636:	68fa      	ldr	r2, [r7, #12]
34011638:	68bb      	ldr	r3, [r7, #8]
3401163a:	fbb2 f3f3 	udiv	r3, r2, r3
3401163e:	60fb      	str	r3, [r7, #12]
            break;
34011640:	e000      	b.n	34011644 <RCCEx_GetADFCLKFreq+0xe0>
            break;
34011642:	bf00      	nop
        }
      }
      break;
34011644:	e067      	b.n	34011716 <RCCEx_GetADFCLKFreq+0x1b2>

    case LL_RCC_ADF1_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
34011646:	f7f8 f877 	bl	34009738 <LL_RCC_IC8_IsEnabled>
3401164a:	4603      	mov	r3, r0
3401164c:	2b00      	cmp	r3, #0
3401164e:	d064      	beq.n	3401171a <RCCEx_GetADFCLKFreq+0x1b6>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
34011650:	f7f8 f894 	bl	3400977c <LL_RCC_IC8_GetDivider>
34011654:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34011656:	f7f8 f883 	bl	34009760 <LL_RCC_IC8_GetSource>
3401165a:	4603      	mov	r3, r0
3401165c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011660:	d029      	beq.n	340116b6 <RCCEx_GetADFCLKFreq+0x152>
34011662:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011666:	d82f      	bhi.n	340116c8 <RCCEx_GetADFCLKFreq+0x164>
34011668:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401166c:	d01a      	beq.n	340116a4 <RCCEx_GetADFCLKFreq+0x140>
3401166e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011672:	d829      	bhi.n	340116c8 <RCCEx_GetADFCLKFreq+0x164>
34011674:	2b00      	cmp	r3, #0
34011676:	d003      	beq.n	34011680 <RCCEx_GetADFCLKFreq+0x11c>
34011678:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401167c:	d009      	beq.n	34011692 <RCCEx_GetADFCLKFreq+0x12e>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            adf_frequency = adf_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3401167e:	e023      	b.n	340116c8 <RCCEx_GetADFCLKFreq+0x164>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34011680:	f7ff fc58 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34011684:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34011686:	68fa      	ldr	r2, [r7, #12]
34011688:	68bb      	ldr	r3, [r7, #8]
3401168a:	fbb2 f3f3 	udiv	r3, r2, r3
3401168e:	60fb      	str	r3, [r7, #12]
            break;
34011690:	e01b      	b.n	340116ca <RCCEx_GetADFCLKFreq+0x166>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34011692:	f7ff fc95 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34011696:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34011698:	68fa      	ldr	r2, [r7, #12]
3401169a:	68bb      	ldr	r3, [r7, #8]
3401169c:	fbb2 f3f3 	udiv	r3, r2, r3
340116a0:	60fb      	str	r3, [r7, #12]
            break;
340116a2:	e012      	b.n	340116ca <RCCEx_GetADFCLKFreq+0x166>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340116a4:	f7ff fcd2 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
340116a8:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
340116aa:	68fa      	ldr	r2, [r7, #12]
340116ac:	68bb      	ldr	r3, [r7, #8]
340116ae:	fbb2 f3f3 	udiv	r3, r2, r3
340116b2:	60fb      	str	r3, [r7, #12]
            break;
340116b4:	e009      	b.n	340116ca <RCCEx_GetADFCLKFreq+0x166>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340116b6:	f7ff fd0f 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
340116ba:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
340116bc:	68fa      	ldr	r2, [r7, #12]
340116be:	68bb      	ldr	r3, [r7, #8]
340116c0:	fbb2 f3f3 	udiv	r3, r2, r3
340116c4:	60fb      	str	r3, [r7, #12]
            break;
340116c6:	e000      	b.n	340116ca <RCCEx_GetADFCLKFreq+0x166>
            break;
340116c8:	bf00      	nop
        }
      }
      break;
340116ca:	e026      	b.n	3401171a <RCCEx_GetADFCLKFreq+0x1b6>

    case LL_RCC_ADF1_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
340116cc:	f7f7 f850 	bl	34008770 <LL_RCC_HSI_IsReady>
340116d0:	4603      	mov	r3, r0
340116d2:	2b00      	cmp	r3, #0
340116d4:	d023      	beq.n	3401171e <RCCEx_GetADFCLKFreq+0x1ba>
      {
        adf_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340116d6:	f7f7 f85d 	bl	34008794 <LL_RCC_HSI_GetDivider>
340116da:	4603      	mov	r3, r0
340116dc:	09db      	lsrs	r3, r3, #7
340116de:	4a14      	ldr	r2, [pc, #80]	@ (34011730 <RCCEx_GetADFCLKFreq+0x1cc>)
340116e0:	fa22 f303 	lsr.w	r3, r2, r3
340116e4:	60fb      	str	r3, [r7, #12]
      }
      break;
340116e6:	e01a      	b.n	3401171e <RCCEx_GetADFCLKFreq+0x1ba>

    case LL_RCC_ADF1_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
340116e8:	f7f7 f862 	bl	340087b0 <LL_RCC_MSI_IsReady>
340116ec:	4603      	mov	r3, r0
340116ee:	2b00      	cmp	r3, #0
340116f0:	d017      	beq.n	34011722 <RCCEx_GetADFCLKFreq+0x1be>
      {
        adf_frequency = MSI_VALUE;
340116f2:	4b10      	ldr	r3, [pc, #64]	@ (34011734 <RCCEx_GetADFCLKFreq+0x1d0>)
340116f4:	60fb      	str	r3, [r7, #12]
      }
      break;
340116f6:	e014      	b.n	34011722 <RCCEx_GetADFCLKFreq+0x1be>

    case LL_RCC_ADF1_CLKSOURCE_I2S_CKIN:
      adf_frequency = EXTERNAL_CLOCK_VALUE;
340116f8:	4b0f      	ldr	r3, [pc, #60]	@ (34011738 <RCCEx_GetADFCLKFreq+0x1d4>)
340116fa:	60fb      	str	r3, [r7, #12]
      break;
340116fc:	e012      	b.n	34011724 <RCCEx_GetADFCLKFreq+0x1c0>

    case LL_RCC_ADF1_CLKSOURCE_TIMG:
      adf_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
340116fe:	f7f6 fc39 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34011702:	4604      	mov	r4, r0
34011704:	f7f7 fc9c 	bl	34009040 <LL_RCC_GetTIMPrescaler>
34011708:	4603      	mov	r3, r0
3401170a:	fa24 f303 	lsr.w	r3, r4, r3
3401170e:	60fb      	str	r3, [r7, #12]
      break;
34011710:	e008      	b.n	34011724 <RCCEx_GetADFCLKFreq+0x1c0>

    default:
      /* Unexpected case */
      break;
34011712:	bf00      	nop
34011714:	e006      	b.n	34011724 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
34011716:	bf00      	nop
34011718:	e004      	b.n	34011724 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
3401171a:	bf00      	nop
3401171c:	e002      	b.n	34011724 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
3401171e:	bf00      	nop
34011720:	e000      	b.n	34011724 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
34011722:	bf00      	nop
  }

  return adf_frequency;
34011724:	68fb      	ldr	r3, [r7, #12]
}
34011726:	4618      	mov	r0, r3
34011728:	3714      	adds	r7, #20
3401172a:	46bd      	mov	sp, r7
3401172c:	bd90      	pop	{r4, r7, pc}
3401172e:	bf00      	nop
34011730:	03d09000 	.word	0x03d09000
34011734:	003d0900 	.word	0x003d0900
34011738:	00bb8000 	.word	0x00bb8000

3401173c <RCCEx_GetCLKPCLKFreq>:
  *         @arg @ref RCCEx_CLKP_Clock_Source
  * @retval CLKP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetCLKPCLKFreq(uint32_t CLKPxSource)
{
3401173c:	b580      	push	{r7, lr}
3401173e:	b084      	sub	sp, #16
34011740:	af00      	add	r7, sp, #0
34011742:	6078      	str	r0, [r7, #4]
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
34011744:	2300      	movs	r3, #0
34011746:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  if (LL_RCC_CLKP_IsEnabled() == 1U)
34011748:	f7f8 faf6 	bl	34009d38 <LL_RCC_CLKP_IsEnabled>
3401174c:	4603      	mov	r3, r0
3401174e:	2b01      	cmp	r3, #1
34011750:	f040 81a5 	bne.w	34011a9e <RCCEx_GetCLKPCLKFreq+0x362>
  {
    switch (LL_RCC_GetCLKPClockSource(CLKPxSource))
34011754:	6878      	ldr	r0, [r7, #4]
34011756:	f7f7 fae5 	bl	34008d24 <LL_RCC_GetCLKPClockSource>
3401175a:	4603      	mov	r3, r0
3401175c:	2b07      	cmp	r3, #7
3401175e:	f200 818d 	bhi.w	34011a7c <RCCEx_GetCLKPCLKFreq+0x340>
34011762:	a201      	add	r2, pc, #4	@ (adr r2, 34011768 <RCCEx_GetCLKPCLKFreq+0x2c>)
34011764:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34011768:	34011789 	.word	0x34011789
3401176c:	340117a7 	.word	0x340117a7
34011770:	340117b9 	.word	0x340117b9
34011774:	34011963 	.word	0x34011963
34011778:	340117cb 	.word	0x340117cb
3401177c:	34011853 	.word	0x34011853
34011780:	340118db 	.word	0x340118db
34011784:	340119eb 	.word	0x340119eb
    {
      case LL_RCC_CLKP_CLKSOURCE_HSI:
        if (LL_RCC_HSI_IsReady() != 0U)
34011788:	f7f6 fff2 	bl	34008770 <LL_RCC_HSI_IsReady>
3401178c:	4603      	mov	r3, r0
3401178e:	2b00      	cmp	r3, #0
34011790:	f000 8176 	beq.w	34011a80 <RCCEx_GetCLKPCLKFreq+0x344>
        {
          clkp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34011794:	f7f6 fffe 	bl	34008794 <LL_RCC_HSI_GetDivider>
34011798:	4603      	mov	r3, r0
3401179a:	09db      	lsrs	r3, r3, #7
3401179c:	4aa1      	ldr	r2, [pc, #644]	@ (34011a24 <RCCEx_GetCLKPCLKFreq+0x2e8>)
3401179e:	fa22 f303 	lsr.w	r3, r2, r3
340117a2:	60fb      	str	r3, [r7, #12]
        }
        break;
340117a4:	e16c      	b.n	34011a80 <RCCEx_GetCLKPCLKFreq+0x344>

      case LL_RCC_CLKP_CLKSOURCE_MSI:
        if (LL_RCC_MSI_IsReady() != 0U)
340117a6:	f7f7 f803 	bl	340087b0 <LL_RCC_MSI_IsReady>
340117aa:	4603      	mov	r3, r0
340117ac:	2b00      	cmp	r3, #0
340117ae:	f000 8169 	beq.w	34011a84 <RCCEx_GetCLKPCLKFreq+0x348>
        {
          clkp_frequency = MSI_VALUE;
340117b2:	4b9d      	ldr	r3, [pc, #628]	@ (34011a28 <RCCEx_GetCLKPCLKFreq+0x2ec>)
340117b4:	60fb      	str	r3, [r7, #12]
        }
        break;
340117b6:	e165      	b.n	34011a84 <RCCEx_GetCLKPCLKFreq+0x348>

      case LL_RCC_CLKP_CLKSOURCE_HSE:
        if (LL_RCC_HSE_IsReady() != 0U)
340117b8:	f7f6 ffc8 	bl	3400874c <LL_RCC_HSE_IsReady>
340117bc:	4603      	mov	r3, r0
340117be:	2b00      	cmp	r3, #0
340117c0:	f000 8162 	beq.w	34011a88 <RCCEx_GetCLKPCLKFreq+0x34c>
        {
          clkp_frequency = HSE_VALUE;
340117c4:	4b99      	ldr	r3, [pc, #612]	@ (34011a2c <RCCEx_GetCLKPCLKFreq+0x2f0>)
340117c6:	60fb      	str	r3, [r7, #12]
        }
        break;
340117c8:	e15e      	b.n	34011a88 <RCCEx_GetCLKPCLKFreq+0x34c>

      case LL_RCC_CLKP_CLKSOURCE_IC5:
        if (LL_RCC_IC5_IsEnabled() != 0U)
340117ca:	f7f7 ff35 	bl	34009638 <LL_RCC_IC5_IsEnabled>
340117ce:	4603      	mov	r3, r0
340117d0:	2b00      	cmp	r3, #0
340117d2:	f000 815b 	beq.w	34011a8c <RCCEx_GetCLKPCLKFreq+0x350>
        {
          ic_divider = LL_RCC_IC5_GetDivider();
340117d6:	f7f7 ff51 	bl	3400967c <LL_RCC_IC5_GetDivider>
340117da:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC5_GetSource())
340117dc:	f7f7 ff40 	bl	34009660 <LL_RCC_IC5_GetSource>
340117e0:	4603      	mov	r3, r0
340117e2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340117e6:	d029      	beq.n	3401183c <RCCEx_GetCLKPCLKFreq+0x100>
340117e8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340117ec:	d82f      	bhi.n	3401184e <RCCEx_GetCLKPCLKFreq+0x112>
340117ee:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340117f2:	d01a      	beq.n	3401182a <RCCEx_GetCLKPCLKFreq+0xee>
340117f4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340117f8:	d829      	bhi.n	3401184e <RCCEx_GetCLKPCLKFreq+0x112>
340117fa:	2b00      	cmp	r3, #0
340117fc:	d003      	beq.n	34011806 <RCCEx_GetCLKPCLKFreq+0xca>
340117fe:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011802:	d009      	beq.n	34011818 <RCCEx_GetCLKPCLKFreq+0xdc>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
34011804:	e023      	b.n	3401184e <RCCEx_GetCLKPCLKFreq+0x112>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34011806:	f7ff fb95 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
3401180a:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3401180c:	68fa      	ldr	r2, [r7, #12]
3401180e:	68bb      	ldr	r3, [r7, #8]
34011810:	fbb2 f3f3 	udiv	r3, r2, r3
34011814:	60fb      	str	r3, [r7, #12]
              break;
34011816:	e01b      	b.n	34011850 <RCCEx_GetCLKPCLKFreq+0x114>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34011818:	f7ff fbd2 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
3401181c:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3401181e:	68fa      	ldr	r2, [r7, #12]
34011820:	68bb      	ldr	r3, [r7, #8]
34011822:	fbb2 f3f3 	udiv	r3, r2, r3
34011826:	60fb      	str	r3, [r7, #12]
              break;
34011828:	e012      	b.n	34011850 <RCCEx_GetCLKPCLKFreq+0x114>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401182a:	f7ff fc0f 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
3401182e:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34011830:	68fa      	ldr	r2, [r7, #12]
34011832:	68bb      	ldr	r3, [r7, #8]
34011834:	fbb2 f3f3 	udiv	r3, r2, r3
34011838:	60fb      	str	r3, [r7, #12]
              break;
3401183a:	e009      	b.n	34011850 <RCCEx_GetCLKPCLKFreq+0x114>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401183c:	f7ff fc4c 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34011840:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34011842:	68fa      	ldr	r2, [r7, #12]
34011844:	68bb      	ldr	r3, [r7, #8]
34011846:	fbb2 f3f3 	udiv	r3, r2, r3
3401184a:	60fb      	str	r3, [r7, #12]
              break;
3401184c:	e000      	b.n	34011850 <RCCEx_GetCLKPCLKFreq+0x114>
              break;
3401184e:	bf00      	nop
          }
        }
        break;
34011850:	e11c      	b.n	34011a8c <RCCEx_GetCLKPCLKFreq+0x350>

      case LL_RCC_CLKP_CLKSOURCE_IC10:
        if (LL_RCC_IC10_IsEnabled() != 0U)
34011852:	f7f7 fff1 	bl	34009838 <LL_RCC_IC10_IsEnabled>
34011856:	4603      	mov	r3, r0
34011858:	2b00      	cmp	r3, #0
3401185a:	f000 8119 	beq.w	34011a90 <RCCEx_GetCLKPCLKFreq+0x354>
        {
          ic_divider = LL_RCC_IC10_GetDivider();
3401185e:	f7f8 f80d 	bl	3400987c <LL_RCC_IC10_GetDivider>
34011862:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC10_GetSource())
34011864:	f7f7 fffc 	bl	34009860 <LL_RCC_IC10_GetSource>
34011868:	4603      	mov	r3, r0
3401186a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401186e:	d029      	beq.n	340118c4 <RCCEx_GetCLKPCLKFreq+0x188>
34011870:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011874:	d82f      	bhi.n	340118d6 <RCCEx_GetCLKPCLKFreq+0x19a>
34011876:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401187a:	d01a      	beq.n	340118b2 <RCCEx_GetCLKPCLKFreq+0x176>
3401187c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011880:	d829      	bhi.n	340118d6 <RCCEx_GetCLKPCLKFreq+0x19a>
34011882:	2b00      	cmp	r3, #0
34011884:	d003      	beq.n	3401188e <RCCEx_GetCLKPCLKFreq+0x152>
34011886:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401188a:	d009      	beq.n	340118a0 <RCCEx_GetCLKPCLKFreq+0x164>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
3401188c:	e023      	b.n	340118d6 <RCCEx_GetCLKPCLKFreq+0x19a>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3401188e:	f7ff fb51 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34011892:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34011894:	68fa      	ldr	r2, [r7, #12]
34011896:	68bb      	ldr	r3, [r7, #8]
34011898:	fbb2 f3f3 	udiv	r3, r2, r3
3401189c:	60fb      	str	r3, [r7, #12]
              break;
3401189e:	e01b      	b.n	340118d8 <RCCEx_GetCLKPCLKFreq+0x19c>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340118a0:	f7ff fb8e 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
340118a4:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340118a6:	68fa      	ldr	r2, [r7, #12]
340118a8:	68bb      	ldr	r3, [r7, #8]
340118aa:	fbb2 f3f3 	udiv	r3, r2, r3
340118ae:	60fb      	str	r3, [r7, #12]
              break;
340118b0:	e012      	b.n	340118d8 <RCCEx_GetCLKPCLKFreq+0x19c>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340118b2:	f7ff fbcb 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
340118b6:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340118b8:	68fa      	ldr	r2, [r7, #12]
340118ba:	68bb      	ldr	r3, [r7, #8]
340118bc:	fbb2 f3f3 	udiv	r3, r2, r3
340118c0:	60fb      	str	r3, [r7, #12]
              break;
340118c2:	e009      	b.n	340118d8 <RCCEx_GetCLKPCLKFreq+0x19c>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340118c4:	f7ff fc08 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
340118c8:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340118ca:	68fa      	ldr	r2, [r7, #12]
340118cc:	68bb      	ldr	r3, [r7, #8]
340118ce:	fbb2 f3f3 	udiv	r3, r2, r3
340118d2:	60fb      	str	r3, [r7, #12]
              break;
340118d4:	e000      	b.n	340118d8 <RCCEx_GetCLKPCLKFreq+0x19c>
              break;
340118d6:	bf00      	nop
          }
        }
        break;
340118d8:	e0da      	b.n	34011a90 <RCCEx_GetCLKPCLKFreq+0x354>

      case LL_RCC_CLKP_CLKSOURCE_IC15:
        if (LL_RCC_IC15_IsEnabled() != 0U)
340118da:	f7f8 f8ad 	bl	34009a38 <LL_RCC_IC15_IsEnabled>
340118de:	4603      	mov	r3, r0
340118e0:	2b00      	cmp	r3, #0
340118e2:	f000 80d7 	beq.w	34011a94 <RCCEx_GetCLKPCLKFreq+0x358>
        {
          ic_divider = LL_RCC_IC15_GetDivider();
340118e6:	f7f8 f8c9 	bl	34009a7c <LL_RCC_IC15_GetDivider>
340118ea:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC15_GetSource())
340118ec:	f7f8 f8b8 	bl	34009a60 <LL_RCC_IC15_GetSource>
340118f0:	4603      	mov	r3, r0
340118f2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340118f6:	d029      	beq.n	3401194c <RCCEx_GetCLKPCLKFreq+0x210>
340118f8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340118fc:	d82f      	bhi.n	3401195e <RCCEx_GetCLKPCLKFreq+0x222>
340118fe:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011902:	d01a      	beq.n	3401193a <RCCEx_GetCLKPCLKFreq+0x1fe>
34011904:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011908:	d829      	bhi.n	3401195e <RCCEx_GetCLKPCLKFreq+0x222>
3401190a:	2b00      	cmp	r3, #0
3401190c:	d003      	beq.n	34011916 <RCCEx_GetCLKPCLKFreq+0x1da>
3401190e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011912:	d009      	beq.n	34011928 <RCCEx_GetCLKPCLKFreq+0x1ec>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
34011914:	e023      	b.n	3401195e <RCCEx_GetCLKPCLKFreq+0x222>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34011916:	f7ff fb0d 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
3401191a:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3401191c:	68fa      	ldr	r2, [r7, #12]
3401191e:	68bb      	ldr	r3, [r7, #8]
34011920:	fbb2 f3f3 	udiv	r3, r2, r3
34011924:	60fb      	str	r3, [r7, #12]
              break;
34011926:	e01b      	b.n	34011960 <RCCEx_GetCLKPCLKFreq+0x224>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34011928:	f7ff fb4a 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
3401192c:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3401192e:	68fa      	ldr	r2, [r7, #12]
34011930:	68bb      	ldr	r3, [r7, #8]
34011932:	fbb2 f3f3 	udiv	r3, r2, r3
34011936:	60fb      	str	r3, [r7, #12]
              break;
34011938:	e012      	b.n	34011960 <RCCEx_GetCLKPCLKFreq+0x224>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401193a:	f7ff fb87 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
3401193e:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34011940:	68fa      	ldr	r2, [r7, #12]
34011942:	68bb      	ldr	r3, [r7, #8]
34011944:	fbb2 f3f3 	udiv	r3, r2, r3
34011948:	60fb      	str	r3, [r7, #12]
              break;
3401194a:	e009      	b.n	34011960 <RCCEx_GetCLKPCLKFreq+0x224>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401194c:	f7ff fbc4 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34011950:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34011952:	68fa      	ldr	r2, [r7, #12]
34011954:	68bb      	ldr	r3, [r7, #8]
34011956:	fbb2 f3f3 	udiv	r3, r2, r3
3401195a:	60fb      	str	r3, [r7, #12]
              break;
3401195c:	e000      	b.n	34011960 <RCCEx_GetCLKPCLKFreq+0x224>
              break;
3401195e:	bf00      	nop
          }
        }
        break;
34011960:	e098      	b.n	34011a94 <RCCEx_GetCLKPCLKFreq+0x358>

      case LL_RCC_CLKP_CLKSOURCE_IC19:
        if (LL_RCC_IC19_IsEnabled() != 0U)
34011962:	f7f8 f969 	bl	34009c38 <LL_RCC_IC19_IsEnabled>
34011966:	4603      	mov	r3, r0
34011968:	2b00      	cmp	r3, #0
3401196a:	f000 8095 	beq.w	34011a98 <RCCEx_GetCLKPCLKFreq+0x35c>
        {
          ic_divider = LL_RCC_IC19_GetDivider();
3401196e:	f7f8 f985 	bl	34009c7c <LL_RCC_IC19_GetDivider>
34011972:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC19_GetSource())
34011974:	f7f8 f974 	bl	34009c60 <LL_RCC_IC19_GetSource>
34011978:	4603      	mov	r3, r0
3401197a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401197e:	d029      	beq.n	340119d4 <RCCEx_GetCLKPCLKFreq+0x298>
34011980:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011984:	d82f      	bhi.n	340119e6 <RCCEx_GetCLKPCLKFreq+0x2aa>
34011986:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401198a:	d01a      	beq.n	340119c2 <RCCEx_GetCLKPCLKFreq+0x286>
3401198c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011990:	d829      	bhi.n	340119e6 <RCCEx_GetCLKPCLKFreq+0x2aa>
34011992:	2b00      	cmp	r3, #0
34011994:	d003      	beq.n	3401199e <RCCEx_GetCLKPCLKFreq+0x262>
34011996:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401199a:	d009      	beq.n	340119b0 <RCCEx_GetCLKPCLKFreq+0x274>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
3401199c:	e023      	b.n	340119e6 <RCCEx_GetCLKPCLKFreq+0x2aa>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3401199e:	f7ff fac9 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
340119a2:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340119a4:	68fa      	ldr	r2, [r7, #12]
340119a6:	68bb      	ldr	r3, [r7, #8]
340119a8:	fbb2 f3f3 	udiv	r3, r2, r3
340119ac:	60fb      	str	r3, [r7, #12]
              break;
340119ae:	e01b      	b.n	340119e8 <RCCEx_GetCLKPCLKFreq+0x2ac>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340119b0:	f7ff fb06 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
340119b4:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340119b6:	68fa      	ldr	r2, [r7, #12]
340119b8:	68bb      	ldr	r3, [r7, #8]
340119ba:	fbb2 f3f3 	udiv	r3, r2, r3
340119be:	60fb      	str	r3, [r7, #12]
              break;
340119c0:	e012      	b.n	340119e8 <RCCEx_GetCLKPCLKFreq+0x2ac>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340119c2:	f7ff fb43 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
340119c6:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340119c8:	68fa      	ldr	r2, [r7, #12]
340119ca:	68bb      	ldr	r3, [r7, #8]
340119cc:	fbb2 f3f3 	udiv	r3, r2, r3
340119d0:	60fb      	str	r3, [r7, #12]
              break;
340119d2:	e009      	b.n	340119e8 <RCCEx_GetCLKPCLKFreq+0x2ac>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340119d4:	f7ff fb80 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
340119d8:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340119da:	68fa      	ldr	r2, [r7, #12]
340119dc:	68bb      	ldr	r3, [r7, #8]
340119de:	fbb2 f3f3 	udiv	r3, r2, r3
340119e2:	60fb      	str	r3, [r7, #12]
              break;
340119e4:	e000      	b.n	340119e8 <RCCEx_GetCLKPCLKFreq+0x2ac>
              break;
340119e6:	bf00      	nop
          }
        }
        break;
340119e8:	e056      	b.n	34011a98 <RCCEx_GetCLKPCLKFreq+0x35c>

      case LL_RCC_CLKP_CLKSOURCE_IC20:
        if (LL_RCC_IC20_IsEnabled() != 0U)
340119ea:	f7f8 f965 	bl	34009cb8 <LL_RCC_IC20_IsEnabled>
340119ee:	4603      	mov	r3, r0
340119f0:	2b00      	cmp	r3, #0
340119f2:	d053      	beq.n	34011a9c <RCCEx_GetCLKPCLKFreq+0x360>
        {
          ic_divider = LL_RCC_IC20_GetDivider();
340119f4:	f7f8 f982 	bl	34009cfc <LL_RCC_IC20_GetDivider>
340119f8:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC20_GetSource())
340119fa:	f7f8 f971 	bl	34009ce0 <LL_RCC_IC20_GetSource>
340119fe:	4603      	mov	r3, r0
34011a00:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011a04:	d02f      	beq.n	34011a66 <RCCEx_GetCLKPCLKFreq+0x32a>
34011a06:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011a0a:	d835      	bhi.n	34011a78 <RCCEx_GetCLKPCLKFreq+0x33c>
34011a0c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011a10:	d020      	beq.n	34011a54 <RCCEx_GetCLKPCLKFreq+0x318>
34011a12:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011a16:	d82f      	bhi.n	34011a78 <RCCEx_GetCLKPCLKFreq+0x33c>
34011a18:	2b00      	cmp	r3, #0
34011a1a:	d009      	beq.n	34011a30 <RCCEx_GetCLKPCLKFreq+0x2f4>
34011a1c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011a20:	d00f      	beq.n	34011a42 <RCCEx_GetCLKPCLKFreq+0x306>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
34011a22:	e029      	b.n	34011a78 <RCCEx_GetCLKPCLKFreq+0x33c>
34011a24:	03d09000 	.word	0x03d09000
34011a28:	003d0900 	.word	0x003d0900
34011a2c:	02dc6c00 	.word	0x02dc6c00
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34011a30:	f7ff fa80 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34011a34:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34011a36:	68fa      	ldr	r2, [r7, #12]
34011a38:	68bb      	ldr	r3, [r7, #8]
34011a3a:	fbb2 f3f3 	udiv	r3, r2, r3
34011a3e:	60fb      	str	r3, [r7, #12]
              break;
34011a40:	e01b      	b.n	34011a7a <RCCEx_GetCLKPCLKFreq+0x33e>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34011a42:	f7ff fabd 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34011a46:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34011a48:	68fa      	ldr	r2, [r7, #12]
34011a4a:	68bb      	ldr	r3, [r7, #8]
34011a4c:	fbb2 f3f3 	udiv	r3, r2, r3
34011a50:	60fb      	str	r3, [r7, #12]
              break;
34011a52:	e012      	b.n	34011a7a <RCCEx_GetCLKPCLKFreq+0x33e>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34011a54:	f7ff fafa 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34011a58:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34011a5a:	68fa      	ldr	r2, [r7, #12]
34011a5c:	68bb      	ldr	r3, [r7, #8]
34011a5e:	fbb2 f3f3 	udiv	r3, r2, r3
34011a62:	60fb      	str	r3, [r7, #12]
              break;
34011a64:	e009      	b.n	34011a7a <RCCEx_GetCLKPCLKFreq+0x33e>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34011a66:	f7ff fb37 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34011a6a:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34011a6c:	68fa      	ldr	r2, [r7, #12]
34011a6e:	68bb      	ldr	r3, [r7, #8]
34011a70:	fbb2 f3f3 	udiv	r3, r2, r3
34011a74:	60fb      	str	r3, [r7, #12]
              break;
34011a76:	e000      	b.n	34011a7a <RCCEx_GetCLKPCLKFreq+0x33e>
              break;
34011a78:	bf00      	nop
          }
        }
        break;
34011a7a:	e00f      	b.n	34011a9c <RCCEx_GetCLKPCLKFreq+0x360>

      default:
        /* Unexpected case */
        break;
34011a7c:	bf00      	nop
34011a7e:	e00e      	b.n	34011a9e <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34011a80:	bf00      	nop
34011a82:	e00c      	b.n	34011a9e <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34011a84:	bf00      	nop
34011a86:	e00a      	b.n	34011a9e <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34011a88:	bf00      	nop
34011a8a:	e008      	b.n	34011a9e <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34011a8c:	bf00      	nop
34011a8e:	e006      	b.n	34011a9e <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34011a90:	bf00      	nop
34011a92:	e004      	b.n	34011a9e <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34011a94:	bf00      	nop
34011a96:	e002      	b.n	34011a9e <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34011a98:	bf00      	nop
34011a9a:	e000      	b.n	34011a9e <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34011a9c:	bf00      	nop
    }
  }

  return clkp_frequency;
34011a9e:	68fb      	ldr	r3, [r7, #12]
}
34011aa0:	4618      	mov	r0, r3
34011aa2:	3710      	adds	r7, #16
34011aa4:	46bd      	mov	sp, r7
34011aa6:	bd80      	pop	{r7, pc}

34011aa8 <RCCEx_GetCSICLKFreq>:
  * @brief  Return CSI clock frequency
  * @retval CLKP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetCSICLKFreq(void)
{
34011aa8:	b580      	push	{r7, lr}
34011aaa:	b082      	sub	sp, #8
34011aac:	af00      	add	r7, sp, #0
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
34011aae:	2300      	movs	r3, #0
34011ab0:	607b      	str	r3, [r7, #4]

  if (LL_RCC_IC18_IsEnabled() != 0U)
34011ab2:	f7f8 f881 	bl	34009bb8 <LL_RCC_IC18_IsEnabled>
34011ab6:	4603      	mov	r3, r0
34011ab8:	2b00      	cmp	r3, #0
34011aba:	d03c      	beq.n	34011b36 <RCCEx_GetCSICLKFreq+0x8e>
  {
    uint32_t ic_divider = LL_RCC_IC18_GetDivider();
34011abc:	f7f8 f89e 	bl	34009bfc <LL_RCC_IC18_GetDivider>
34011ac0:	6038      	str	r0, [r7, #0]
    switch (LL_RCC_IC18_GetSource())
34011ac2:	f7f8 f88d 	bl	34009be0 <LL_RCC_IC18_GetSource>
34011ac6:	4603      	mov	r3, r0
34011ac8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011acc:	d029      	beq.n	34011b22 <RCCEx_GetCSICLKFreq+0x7a>
34011ace:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011ad2:	d82f      	bhi.n	34011b34 <RCCEx_GetCSICLKFreq+0x8c>
34011ad4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011ad8:	d01a      	beq.n	34011b10 <RCCEx_GetCSICLKFreq+0x68>
34011ada:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011ade:	d829      	bhi.n	34011b34 <RCCEx_GetCSICLKFreq+0x8c>
34011ae0:	2b00      	cmp	r3, #0
34011ae2:	d003      	beq.n	34011aec <RCCEx_GetCSICLKFreq+0x44>
34011ae4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011ae8:	d009      	beq.n	34011afe <RCCEx_GetCSICLKFreq+0x56>
        clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
        clkp_frequency = clkp_frequency / ic_divider;
        break;
      default:
        /* Unexpected case */
        break;
34011aea:	e023      	b.n	34011b34 <RCCEx_GetCSICLKFreq+0x8c>
        clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34011aec:	f7ff fa22 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34011af0:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
34011af2:	687a      	ldr	r2, [r7, #4]
34011af4:	683b      	ldr	r3, [r7, #0]
34011af6:	fbb2 f3f3 	udiv	r3, r2, r3
34011afa:	607b      	str	r3, [r7, #4]
        break;
34011afc:	e01b      	b.n	34011b36 <RCCEx_GetCSICLKFreq+0x8e>
        clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34011afe:	f7ff fa5f 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34011b02:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
34011b04:	687a      	ldr	r2, [r7, #4]
34011b06:	683b      	ldr	r3, [r7, #0]
34011b08:	fbb2 f3f3 	udiv	r3, r2, r3
34011b0c:	607b      	str	r3, [r7, #4]
        break;
34011b0e:	e012      	b.n	34011b36 <RCCEx_GetCSICLKFreq+0x8e>
        clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34011b10:	f7ff fa9c 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34011b14:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
34011b16:	687a      	ldr	r2, [r7, #4]
34011b18:	683b      	ldr	r3, [r7, #0]
34011b1a:	fbb2 f3f3 	udiv	r3, r2, r3
34011b1e:	607b      	str	r3, [r7, #4]
        break;
34011b20:	e009      	b.n	34011b36 <RCCEx_GetCSICLKFreq+0x8e>
        clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34011b22:	f7ff fad9 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34011b26:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
34011b28:	687a      	ldr	r2, [r7, #4]
34011b2a:	683b      	ldr	r3, [r7, #0]
34011b2c:	fbb2 f3f3 	udiv	r3, r2, r3
34011b30:	607b      	str	r3, [r7, #4]
        break;
34011b32:	e000      	b.n	34011b36 <RCCEx_GetCSICLKFreq+0x8e>
        break;
34011b34:	bf00      	nop
    }
  }

  return clkp_frequency;
34011b36:	687b      	ldr	r3, [r7, #4]
}
34011b38:	4618      	mov	r0, r3
34011b3a:	3708      	adds	r7, #8
34011b3c:	46bd      	mov	sp, r7
34011b3e:	bd80      	pop	{r7, pc}

34011b40 <RCCEx_GetDCMIPPCLKFreq>:
  *         @arg @ref RCCEx_DCMIPP_Clock_Source
  * @retval DCMIPP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetDCMIPPCLKFreq(uint32_t DCMIPPxSource)
{
34011b40:	b580      	push	{r7, lr}
34011b42:	b084      	sub	sp, #16
34011b44:	af00      	add	r7, sp, #0
34011b46:	6078      	str	r0, [r7, #4]
  uint32_t dcmipp_frequency = RCC_PERIPH_FREQUENCY_NO;
34011b48:	2300      	movs	r3, #0
34011b4a:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetDCMIPPClockSource(DCMIPPxSource))
34011b4c:	6878      	ldr	r0, [r7, #4]
34011b4e:	f7f7 f8fb 	bl	34008d48 <LL_RCC_GetDCMIPPClockSource>
34011b52:	4603      	mov	r3, r0
34011b54:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34011b58:	d062      	beq.n	34011c20 <RCCEx_GetDCMIPPCLKFreq+0xe0>
34011b5a:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34011b5e:	d86d      	bhi.n	34011c3c <RCCEx_GetDCMIPPCLKFreq+0xfc>
34011b60:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34011b64:	d019      	beq.n	34011b9a <RCCEx_GetDCMIPPCLKFreq+0x5a>
34011b66:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34011b6a:	d867      	bhi.n	34011c3c <RCCEx_GetDCMIPPCLKFreq+0xfc>
34011b6c:	2b00      	cmp	r3, #0
34011b6e:	d003      	beq.n	34011b78 <RCCEx_GetDCMIPPCLKFreq+0x38>
34011b70:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34011b74:	d00c      	beq.n	34011b90 <RCCEx_GetDCMIPPCLKFreq+0x50>
      }
      break;

    default:
      /* Unexpected case */
      break;
34011b76:	e061      	b.n	34011c3c <RCCEx_GetDCMIPPCLKFreq+0xfc>
      dcmipp_frequency = RCCEx_GetPCLK5Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34011b78:	f7f6 f9fc 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34011b7c:	4603      	mov	r3, r0
34011b7e:	4618      	mov	r0, r3
34011b80:	f7ff faf0 	bl	34011164 <RCCEx_GetHCLKFreq>
34011b84:	4603      	mov	r3, r0
34011b86:	4618      	mov	r0, r3
34011b88:	f7ff fb2f 	bl	340111ea <RCCEx_GetPCLK5Freq>
34011b8c:	60f8      	str	r0, [r7, #12]
      break;
34011b8e:	e05a      	b.n	34011c46 <RCCEx_GetDCMIPPCLKFreq+0x106>
      dcmipp_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34011b90:	2007      	movs	r0, #7
34011b92:	f7ff fdd3 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
34011b96:	60f8      	str	r0, [r7, #12]
      break;
34011b98:	e055      	b.n	34011c46 <RCCEx_GetDCMIPPCLKFreq+0x106>
      if (LL_RCC_IC17_IsEnabled() != 0U)
34011b9a:	f7f7 ffcd 	bl	34009b38 <LL_RCC_IC17_IsEnabled>
34011b9e:	4603      	mov	r3, r0
34011ba0:	2b00      	cmp	r3, #0
34011ba2:	d04d      	beq.n	34011c40 <RCCEx_GetDCMIPPCLKFreq+0x100>
        ic_divider = LL_RCC_IC17_GetDivider();
34011ba4:	f7f7 ffea 	bl	34009b7c <LL_RCC_IC17_GetDivider>
34011ba8:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC17_GetSource())
34011baa:	f7f7 ffd9 	bl	34009b60 <LL_RCC_IC17_GetSource>
34011bae:	4603      	mov	r3, r0
34011bb0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011bb4:	d029      	beq.n	34011c0a <RCCEx_GetDCMIPPCLKFreq+0xca>
34011bb6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011bba:	d82f      	bhi.n	34011c1c <RCCEx_GetDCMIPPCLKFreq+0xdc>
34011bbc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011bc0:	d01a      	beq.n	34011bf8 <RCCEx_GetDCMIPPCLKFreq+0xb8>
34011bc2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011bc6:	d829      	bhi.n	34011c1c <RCCEx_GetDCMIPPCLKFreq+0xdc>
34011bc8:	2b00      	cmp	r3, #0
34011bca:	d003      	beq.n	34011bd4 <RCCEx_GetDCMIPPCLKFreq+0x94>
34011bcc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011bd0:	d009      	beq.n	34011be6 <RCCEx_GetDCMIPPCLKFreq+0xa6>
            break;
34011bd2:	e023      	b.n	34011c1c <RCCEx_GetDCMIPPCLKFreq+0xdc>
            dcmipp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34011bd4:	f7ff f9ae 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34011bd8:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
34011bda:	68fa      	ldr	r2, [r7, #12]
34011bdc:	68bb      	ldr	r3, [r7, #8]
34011bde:	fbb2 f3f3 	udiv	r3, r2, r3
34011be2:	60fb      	str	r3, [r7, #12]
            break;
34011be4:	e01b      	b.n	34011c1e <RCCEx_GetDCMIPPCLKFreq+0xde>
            dcmipp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34011be6:	f7ff f9eb 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34011bea:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
34011bec:	68fa      	ldr	r2, [r7, #12]
34011bee:	68bb      	ldr	r3, [r7, #8]
34011bf0:	fbb2 f3f3 	udiv	r3, r2, r3
34011bf4:	60fb      	str	r3, [r7, #12]
            break;
34011bf6:	e012      	b.n	34011c1e <RCCEx_GetDCMIPPCLKFreq+0xde>
            dcmipp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34011bf8:	f7ff fa28 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34011bfc:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
34011bfe:	68fa      	ldr	r2, [r7, #12]
34011c00:	68bb      	ldr	r3, [r7, #8]
34011c02:	fbb2 f3f3 	udiv	r3, r2, r3
34011c06:	60fb      	str	r3, [r7, #12]
            break;
34011c08:	e009      	b.n	34011c1e <RCCEx_GetDCMIPPCLKFreq+0xde>
            dcmipp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34011c0a:	f7ff fa65 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34011c0e:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
34011c10:	68fa      	ldr	r2, [r7, #12]
34011c12:	68bb      	ldr	r3, [r7, #8]
34011c14:	fbb2 f3f3 	udiv	r3, r2, r3
34011c18:	60fb      	str	r3, [r7, #12]
            break;
34011c1a:	e000      	b.n	34011c1e <RCCEx_GetDCMIPPCLKFreq+0xde>
            break;
34011c1c:	bf00      	nop
      break;
34011c1e:	e00f      	b.n	34011c40 <RCCEx_GetDCMIPPCLKFreq+0x100>
      if (LL_RCC_HSI_IsReady() != 0U)
34011c20:	f7f6 fda6 	bl	34008770 <LL_RCC_HSI_IsReady>
34011c24:	4603      	mov	r3, r0
34011c26:	2b00      	cmp	r3, #0
34011c28:	d00c      	beq.n	34011c44 <RCCEx_GetDCMIPPCLKFreq+0x104>
        dcmipp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34011c2a:	f7f6 fdb3 	bl	34008794 <LL_RCC_HSI_GetDivider>
34011c2e:	4603      	mov	r3, r0
34011c30:	09db      	lsrs	r3, r3, #7
34011c32:	4a07      	ldr	r2, [pc, #28]	@ (34011c50 <RCCEx_GetDCMIPPCLKFreq+0x110>)
34011c34:	fa22 f303 	lsr.w	r3, r2, r3
34011c38:	60fb      	str	r3, [r7, #12]
      break;
34011c3a:	e003      	b.n	34011c44 <RCCEx_GetDCMIPPCLKFreq+0x104>
      break;
34011c3c:	bf00      	nop
34011c3e:	e002      	b.n	34011c46 <RCCEx_GetDCMIPPCLKFreq+0x106>
      break;
34011c40:	bf00      	nop
34011c42:	e000      	b.n	34011c46 <RCCEx_GetDCMIPPCLKFreq+0x106>
      break;
34011c44:	bf00      	nop
  }

  return dcmipp_frequency;
34011c46:	68fb      	ldr	r3, [r7, #12]
}
34011c48:	4618      	mov	r0, r3
34011c4a:	3710      	adds	r7, #16
34011c4c:	46bd      	mov	sp, r7
34011c4e:	bd80      	pop	{r7, pc}
34011c50:	03d09000 	.word	0x03d09000

34011c54 <RCCEx_GetETH1CLKFreq>:
  *         @arg @ref RCCEx_ETH1_Clock_Source
  * @retval ETH1 clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetETH1CLKFreq(uint32_t ETH1xSource)
{
34011c54:	b580      	push	{r7, lr}
34011c56:	b084      	sub	sp, #16
34011c58:	af00      	add	r7, sp, #0
34011c5a:	6078      	str	r0, [r7, #4]
  uint32_t eth1_frequency = RCC_PERIPH_FREQUENCY_NO;
34011c5c:	2300      	movs	r3, #0
34011c5e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetETHClockSource(ETH1xSource))
34011c60:	6878      	ldr	r0, [r7, #4]
34011c62:	f7f7 f883 	bl	34008d6c <LL_RCC_GetETHClockSource>
34011c66:	4603      	mov	r3, r0
34011c68:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
34011c6c:	d05e      	beq.n	34011d2c <RCCEx_GetETH1CLKFreq+0xd8>
34011c6e:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
34011c72:	d863      	bhi.n	34011d3c <RCCEx_GetETH1CLKFreq+0xe8>
34011c74:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34011c78:	d015      	beq.n	34011ca6 <RCCEx_GetETH1CLKFreq+0x52>
34011c7a:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34011c7e:	d85d      	bhi.n	34011d3c <RCCEx_GetETH1CLKFreq+0xe8>
34011c80:	2b00      	cmp	r3, #0
34011c82:	d003      	beq.n	34011c8c <RCCEx_GetETH1CLKFreq+0x38>
34011c84:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34011c88:	d008      	beq.n	34011c9c <RCCEx_GetETH1CLKFreq+0x48>
      }
      break;

    default:
      /* Unexpected case */
      break;
34011c8a:	e057      	b.n	34011d3c <RCCEx_GetETH1CLKFreq+0xe8>
      eth1_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34011c8c:	f7f6 f972 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34011c90:	4603      	mov	r3, r0
34011c92:	4618      	mov	r0, r3
34011c94:	f7ff fa66 	bl	34011164 <RCCEx_GetHCLKFreq>
34011c98:	60f8      	str	r0, [r7, #12]
      break;
34011c9a:	e054      	b.n	34011d46 <RCCEx_GetETH1CLKFreq+0xf2>
      eth1_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34011c9c:	2007      	movs	r0, #7
34011c9e:	f7ff fd4d 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
34011ca2:	60f8      	str	r0, [r7, #12]
      break;
34011ca4:	e04f      	b.n	34011d46 <RCCEx_GetETH1CLKFreq+0xf2>
      if (LL_RCC_IC12_IsEnabled() != 0U)
34011ca6:	f7f7 fe07 	bl	340098b8 <LL_RCC_IC12_IsEnabled>
34011caa:	4603      	mov	r3, r0
34011cac:	2b00      	cmp	r3, #0
34011cae:	d047      	beq.n	34011d40 <RCCEx_GetETH1CLKFreq+0xec>
        ic_divider = LL_RCC_IC12_GetDivider();
34011cb0:	f7f7 fe24 	bl	340098fc <LL_RCC_IC12_GetDivider>
34011cb4:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC12_GetSource())
34011cb6:	f7f7 fe13 	bl	340098e0 <LL_RCC_IC12_GetSource>
34011cba:	4603      	mov	r3, r0
34011cbc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011cc0:	d029      	beq.n	34011d16 <RCCEx_GetETH1CLKFreq+0xc2>
34011cc2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011cc6:	d82f      	bhi.n	34011d28 <RCCEx_GetETH1CLKFreq+0xd4>
34011cc8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011ccc:	d01a      	beq.n	34011d04 <RCCEx_GetETH1CLKFreq+0xb0>
34011cce:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011cd2:	d829      	bhi.n	34011d28 <RCCEx_GetETH1CLKFreq+0xd4>
34011cd4:	2b00      	cmp	r3, #0
34011cd6:	d003      	beq.n	34011ce0 <RCCEx_GetETH1CLKFreq+0x8c>
34011cd8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011cdc:	d009      	beq.n	34011cf2 <RCCEx_GetETH1CLKFreq+0x9e>
            break;
34011cde:	e023      	b.n	34011d28 <RCCEx_GetETH1CLKFreq+0xd4>
            eth1_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34011ce0:	f7ff f928 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34011ce4:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
34011ce6:	68fa      	ldr	r2, [r7, #12]
34011ce8:	68bb      	ldr	r3, [r7, #8]
34011cea:	fbb2 f3f3 	udiv	r3, r2, r3
34011cee:	60fb      	str	r3, [r7, #12]
            break;
34011cf0:	e01b      	b.n	34011d2a <RCCEx_GetETH1CLKFreq+0xd6>
            eth1_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34011cf2:	f7ff f965 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34011cf6:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
34011cf8:	68fa      	ldr	r2, [r7, #12]
34011cfa:	68bb      	ldr	r3, [r7, #8]
34011cfc:	fbb2 f3f3 	udiv	r3, r2, r3
34011d00:	60fb      	str	r3, [r7, #12]
            break;
34011d02:	e012      	b.n	34011d2a <RCCEx_GetETH1CLKFreq+0xd6>
            eth1_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34011d04:	f7ff f9a2 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34011d08:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
34011d0a:	68fa      	ldr	r2, [r7, #12]
34011d0c:	68bb      	ldr	r3, [r7, #8]
34011d0e:	fbb2 f3f3 	udiv	r3, r2, r3
34011d12:	60fb      	str	r3, [r7, #12]
            break;
34011d14:	e009      	b.n	34011d2a <RCCEx_GetETH1CLKFreq+0xd6>
            eth1_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34011d16:	f7ff f9df 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34011d1a:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
34011d1c:	68fa      	ldr	r2, [r7, #12]
34011d1e:	68bb      	ldr	r3, [r7, #8]
34011d20:	fbb2 f3f3 	udiv	r3, r2, r3
34011d24:	60fb      	str	r3, [r7, #12]
            break;
34011d26:	e000      	b.n	34011d2a <RCCEx_GetETH1CLKFreq+0xd6>
            break;
34011d28:	bf00      	nop
      break;
34011d2a:	e009      	b.n	34011d40 <RCCEx_GetETH1CLKFreq+0xec>
      if (LL_RCC_HSE_IsReady() != 0U)
34011d2c:	f7f6 fd0e 	bl	3400874c <LL_RCC_HSE_IsReady>
34011d30:	4603      	mov	r3, r0
34011d32:	2b00      	cmp	r3, #0
34011d34:	d006      	beq.n	34011d44 <RCCEx_GetETH1CLKFreq+0xf0>
        eth1_frequency = HSE_VALUE;
34011d36:	4b06      	ldr	r3, [pc, #24]	@ (34011d50 <RCCEx_GetETH1CLKFreq+0xfc>)
34011d38:	60fb      	str	r3, [r7, #12]
      break;
34011d3a:	e003      	b.n	34011d44 <RCCEx_GetETH1CLKFreq+0xf0>
      break;
34011d3c:	bf00      	nop
34011d3e:	e002      	b.n	34011d46 <RCCEx_GetETH1CLKFreq+0xf2>
      break;
34011d40:	bf00      	nop
34011d42:	e000      	b.n	34011d46 <RCCEx_GetETH1CLKFreq+0xf2>
      break;
34011d44:	bf00      	nop
  }

  return eth1_frequency;
34011d46:	68fb      	ldr	r3, [r7, #12]
}
34011d48:	4618      	mov	r0, r3
34011d4a:	3710      	adds	r7, #16
34011d4c:	46bd      	mov	sp, r7
34011d4e:	bd80      	pop	{r7, pc}
34011d50:	02dc6c00 	.word	0x02dc6c00

34011d54 <RCCEx_GetETH1PTPCLKFreq>:
  *         @arg @ref RCCEx_ETH1_PTP_Clock_Source
  * @retval ETH1PTP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetETH1PTPCLKFreq(uint32_t ETH1PTPxSource)
{
34011d54:	b580      	push	{r7, lr}
34011d56:	b084      	sub	sp, #16
34011d58:	af00      	add	r7, sp, #0
34011d5a:	6078      	str	r0, [r7, #4]
  uint32_t eth1ptp_frequency = RCC_PERIPH_FREQUENCY_NO;
34011d5c:	2300      	movs	r3, #0
34011d5e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetETHPTPClockSource(ETH1PTPxSource))
34011d60:	6878      	ldr	r0, [r7, #4]
34011d62:	f7f7 f815 	bl	34008d90 <LL_RCC_GetETHPTPClockSource>
34011d66:	4603      	mov	r3, r0
34011d68:	2b03      	cmp	r3, #3
34011d6a:	d863      	bhi.n	34011e34 <RCCEx_GetETH1PTPCLKFreq+0xe0>
34011d6c:	a201      	add	r2, pc, #4	@ (adr r2, 34011d74 <RCCEx_GetETH1PTPCLKFreq+0x20>)
34011d6e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34011d72:	bf00      	nop
34011d74:	34011d85 	.word	0x34011d85
34011d78:	34011d95 	.word	0x34011d95
34011d7c:	34011d9f 	.word	0x34011d9f
34011d80:	34011e25 	.word	0x34011e25
  {
    case LL_RCC_ETH1PTP_CLKSOURCE_HCLK:
      eth1ptp_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34011d84:	f7f6 f8f6 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34011d88:	4603      	mov	r3, r0
34011d8a:	4618      	mov	r0, r3
34011d8c:	f7ff f9ea 	bl	34011164 <RCCEx_GetHCLKFreq>
34011d90:	60f8      	str	r0, [r7, #12]
      break;
34011d92:	e054      	b.n	34011e3e <RCCEx_GetETH1PTPCLKFreq+0xea>

    case LL_RCC_ETH1PTP_CLKSOURCE_CLKP:
      eth1ptp_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34011d94:	2007      	movs	r0, #7
34011d96:	f7ff fcd1 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
34011d9a:	60f8      	str	r0, [r7, #12]
      break;
34011d9c:	e04f      	b.n	34011e3e <RCCEx_GetETH1PTPCLKFreq+0xea>

    case LL_RCC_ETH1PTP_CLKSOURCE_IC13:
      if (LL_RCC_IC13_IsEnabled() != 0U)
34011d9e:	f7f7 fdcb 	bl	34009938 <LL_RCC_IC13_IsEnabled>
34011da2:	4603      	mov	r3, r0
34011da4:	2b00      	cmp	r3, #0
34011da6:	d047      	beq.n	34011e38 <RCCEx_GetETH1PTPCLKFreq+0xe4>
      {
        ic_divider = LL_RCC_IC13_GetDivider();
34011da8:	f7f7 fde8 	bl	3400997c <LL_RCC_IC13_GetDivider>
34011dac:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC13_GetSource())
34011dae:	f7f7 fdd7 	bl	34009960 <LL_RCC_IC13_GetSource>
34011db2:	4603      	mov	r3, r0
34011db4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011db8:	d029      	beq.n	34011e0e <RCCEx_GetETH1PTPCLKFreq+0xba>
34011dba:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011dbe:	d82f      	bhi.n	34011e20 <RCCEx_GetETH1PTPCLKFreq+0xcc>
34011dc0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011dc4:	d01a      	beq.n	34011dfc <RCCEx_GetETH1PTPCLKFreq+0xa8>
34011dc6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011dca:	d829      	bhi.n	34011e20 <RCCEx_GetETH1PTPCLKFreq+0xcc>
34011dcc:	2b00      	cmp	r3, #0
34011dce:	d003      	beq.n	34011dd8 <RCCEx_GetETH1PTPCLKFreq+0x84>
34011dd0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011dd4:	d009      	beq.n	34011dea <RCCEx_GetETH1PTPCLKFreq+0x96>
            eth1ptp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34011dd6:	e023      	b.n	34011e20 <RCCEx_GetETH1PTPCLKFreq+0xcc>
            eth1ptp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34011dd8:	f7ff f8ac 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34011ddc:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
34011dde:	68fa      	ldr	r2, [r7, #12]
34011de0:	68bb      	ldr	r3, [r7, #8]
34011de2:	fbb2 f3f3 	udiv	r3, r2, r3
34011de6:	60fb      	str	r3, [r7, #12]
            break;
34011de8:	e01b      	b.n	34011e22 <RCCEx_GetETH1PTPCLKFreq+0xce>
            eth1ptp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34011dea:	f7ff f8e9 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34011dee:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
34011df0:	68fa      	ldr	r2, [r7, #12]
34011df2:	68bb      	ldr	r3, [r7, #8]
34011df4:	fbb2 f3f3 	udiv	r3, r2, r3
34011df8:	60fb      	str	r3, [r7, #12]
            break;
34011dfa:	e012      	b.n	34011e22 <RCCEx_GetETH1PTPCLKFreq+0xce>
            eth1ptp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34011dfc:	f7ff f926 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34011e00:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
34011e02:	68fa      	ldr	r2, [r7, #12]
34011e04:	68bb      	ldr	r3, [r7, #8]
34011e06:	fbb2 f3f3 	udiv	r3, r2, r3
34011e0a:	60fb      	str	r3, [r7, #12]
            break;
34011e0c:	e009      	b.n	34011e22 <RCCEx_GetETH1PTPCLKFreq+0xce>
            eth1ptp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34011e0e:	f7ff f963 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34011e12:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
34011e14:	68fa      	ldr	r2, [r7, #12]
34011e16:	68bb      	ldr	r3, [r7, #8]
34011e18:	fbb2 f3f3 	udiv	r3, r2, r3
34011e1c:	60fb      	str	r3, [r7, #12]
            break;
34011e1e:	e000      	b.n	34011e22 <RCCEx_GetETH1PTPCLKFreq+0xce>
            break;
34011e20:	bf00      	nop
        }
      }
      break;
34011e22:	e009      	b.n	34011e38 <RCCEx_GetETH1PTPCLKFreq+0xe4>

    case LL_RCC_ETH1PTP_CLKSOURCE_HSE:
      if (LL_RCC_HSE_IsReady() != 0U)
34011e24:	f7f6 fc92 	bl	3400874c <LL_RCC_HSE_IsReady>
34011e28:	4603      	mov	r3, r0
34011e2a:	2b00      	cmp	r3, #0
34011e2c:	d006      	beq.n	34011e3c <RCCEx_GetETH1PTPCLKFreq+0xe8>
      {
        eth1ptp_frequency = HSE_VALUE;
34011e2e:	4b0a      	ldr	r3, [pc, #40]	@ (34011e58 <RCCEx_GetETH1PTPCLKFreq+0x104>)
34011e30:	60fb      	str	r3, [r7, #12]
      }
      break;
34011e32:	e003      	b.n	34011e3c <RCCEx_GetETH1PTPCLKFreq+0xe8>

    default:
      /* Unexpected case */
      break;
34011e34:	bf00      	nop
34011e36:	e002      	b.n	34011e3e <RCCEx_GetETH1PTPCLKFreq+0xea>
      break;
34011e38:	bf00      	nop
34011e3a:	e000      	b.n	34011e3e <RCCEx_GetETH1PTPCLKFreq+0xea>
      break;
34011e3c:	bf00      	nop
  }

  return (eth1ptp_frequency / __HAL_RCC_GET_ETH1PTP_DIVIDER());
34011e3e:	f7f6 fde3 	bl	34008a08 <LL_RCC_GetETH1PTPDivider>
34011e42:	4603      	mov	r3, r0
34011e44:	091b      	lsrs	r3, r3, #4
34011e46:	3301      	adds	r3, #1
34011e48:	68fa      	ldr	r2, [r7, #12]
34011e4a:	fbb2 f3f3 	udiv	r3, r2, r3
}
34011e4e:	4618      	mov	r0, r3
34011e50:	3710      	adds	r7, #16
34011e52:	46bd      	mov	sp, r7
34011e54:	bd80      	pop	{r7, pc}
34011e56:	bf00      	nop
34011e58:	02dc6c00 	.word	0x02dc6c00

34011e5c <RCCEx_GetFDCANCLKFreq>:
  *         @arg @ref RCCEx_FDCAN_Clock_Source
  * @retval FDCAN clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetFDCANCLKFreq(uint32_t FDCANxSource)
{
34011e5c:	b580      	push	{r7, lr}
34011e5e:	b084      	sub	sp, #16
34011e60:	af00      	add	r7, sp, #0
34011e62:	6078      	str	r0, [r7, #4]
  uint32_t fdcan_frequency = RCC_PERIPH_FREQUENCY_NO;
34011e64:	2300      	movs	r3, #0
34011e66:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetFDCANClockSource(FDCANxSource))
34011e68:	6878      	ldr	r0, [r7, #4]
34011e6a:	f7f6 ffa3 	bl	34008db4 <LL_RCC_GetFDCANClockSource>
34011e6e:	4603      	mov	r3, r0
34011e70:	2b03      	cmp	r3, #3
34011e72:	d867      	bhi.n	34011f44 <RCCEx_GetFDCANCLKFreq+0xe8>
34011e74:	a201      	add	r2, pc, #4	@ (adr r2, 34011e7c <RCCEx_GetFDCANCLKFreq+0x20>)
34011e76:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34011e7a:	bf00      	nop
34011e7c:	34011e8d 	.word	0x34011e8d
34011e80:	34011ea5 	.word	0x34011ea5
34011e84:	34011eaf 	.word	0x34011eaf
34011e88:	34011f35 	.word	0x34011f35
  {
    case LL_RCC_FDCAN_CLKSOURCE_PCLK1:
      fdcan_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34011e8c:	f7f6 f872 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34011e90:	4603      	mov	r3, r0
34011e92:	4618      	mov	r0, r3
34011e94:	f7ff f966 	bl	34011164 <RCCEx_GetHCLKFreq>
34011e98:	4603      	mov	r3, r0
34011e9a:	4618      	mov	r0, r3
34011e9c:	f7ff f973 	bl	34011186 <RCCEx_GetPCLK1Freq>
34011ea0:	60f8      	str	r0, [r7, #12]
      break;
34011ea2:	e054      	b.n	34011f4e <RCCEx_GetFDCANCLKFreq+0xf2>

    case LL_RCC_FDCAN_CLKSOURCE_CLKP:
      fdcan_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34011ea4:	2007      	movs	r0, #7
34011ea6:	f7ff fc49 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
34011eaa:	60f8      	str	r0, [r7, #12]
      break;
34011eac:	e04f      	b.n	34011f4e <RCCEx_GetFDCANCLKFreq+0xf2>

    case LL_RCC_FDCAN_CLKSOURCE_IC19:
      if (LL_RCC_IC19_IsEnabled() != 0U)
34011eae:	f7f7 fec3 	bl	34009c38 <LL_RCC_IC19_IsEnabled>
34011eb2:	4603      	mov	r3, r0
34011eb4:	2b00      	cmp	r3, #0
34011eb6:	d047      	beq.n	34011f48 <RCCEx_GetFDCANCLKFreq+0xec>
      {
        ic_divider = LL_RCC_IC19_GetDivider();
34011eb8:	f7f7 fee0 	bl	34009c7c <LL_RCC_IC19_GetDivider>
34011ebc:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC19_GetSource())
34011ebe:	f7f7 fecf 	bl	34009c60 <LL_RCC_IC19_GetSource>
34011ec2:	4603      	mov	r3, r0
34011ec4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011ec8:	d029      	beq.n	34011f1e <RCCEx_GetFDCANCLKFreq+0xc2>
34011eca:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011ece:	d82f      	bhi.n	34011f30 <RCCEx_GetFDCANCLKFreq+0xd4>
34011ed0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011ed4:	d01a      	beq.n	34011f0c <RCCEx_GetFDCANCLKFreq+0xb0>
34011ed6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011eda:	d829      	bhi.n	34011f30 <RCCEx_GetFDCANCLKFreq+0xd4>
34011edc:	2b00      	cmp	r3, #0
34011ede:	d003      	beq.n	34011ee8 <RCCEx_GetFDCANCLKFreq+0x8c>
34011ee0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011ee4:	d009      	beq.n	34011efa <RCCEx_GetFDCANCLKFreq+0x9e>
            fdcan_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            fdcan_frequency = fdcan_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34011ee6:	e023      	b.n	34011f30 <RCCEx_GetFDCANCLKFreq+0xd4>
            fdcan_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34011ee8:	f7ff f824 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34011eec:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
34011eee:	68fa      	ldr	r2, [r7, #12]
34011ef0:	68bb      	ldr	r3, [r7, #8]
34011ef2:	fbb2 f3f3 	udiv	r3, r2, r3
34011ef6:	60fb      	str	r3, [r7, #12]
            break;
34011ef8:	e01b      	b.n	34011f32 <RCCEx_GetFDCANCLKFreq+0xd6>
            fdcan_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34011efa:	f7ff f861 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34011efe:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
34011f00:	68fa      	ldr	r2, [r7, #12]
34011f02:	68bb      	ldr	r3, [r7, #8]
34011f04:	fbb2 f3f3 	udiv	r3, r2, r3
34011f08:	60fb      	str	r3, [r7, #12]
            break;
34011f0a:	e012      	b.n	34011f32 <RCCEx_GetFDCANCLKFreq+0xd6>
            fdcan_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34011f0c:	f7ff f89e 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34011f10:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
34011f12:	68fa      	ldr	r2, [r7, #12]
34011f14:	68bb      	ldr	r3, [r7, #8]
34011f16:	fbb2 f3f3 	udiv	r3, r2, r3
34011f1a:	60fb      	str	r3, [r7, #12]
            break;
34011f1c:	e009      	b.n	34011f32 <RCCEx_GetFDCANCLKFreq+0xd6>
            fdcan_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34011f1e:	f7ff f8db 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34011f22:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
34011f24:	68fa      	ldr	r2, [r7, #12]
34011f26:	68bb      	ldr	r3, [r7, #8]
34011f28:	fbb2 f3f3 	udiv	r3, r2, r3
34011f2c:	60fb      	str	r3, [r7, #12]
            break;
34011f2e:	e000      	b.n	34011f32 <RCCEx_GetFDCANCLKFreq+0xd6>
            break;
34011f30:	bf00      	nop
        }
      }
      break;
34011f32:	e009      	b.n	34011f48 <RCCEx_GetFDCANCLKFreq+0xec>

    case LL_RCC_FDCAN_CLKSOURCE_HSE:
      if (LL_RCC_HSE_IsReady() != 0U)
34011f34:	f7f6 fc0a 	bl	3400874c <LL_RCC_HSE_IsReady>
34011f38:	4603      	mov	r3, r0
34011f3a:	2b00      	cmp	r3, #0
34011f3c:	d006      	beq.n	34011f4c <RCCEx_GetFDCANCLKFreq+0xf0>
      {
        fdcan_frequency = HSE_VALUE;
34011f3e:	4b06      	ldr	r3, [pc, #24]	@ (34011f58 <RCCEx_GetFDCANCLKFreq+0xfc>)
34011f40:	60fb      	str	r3, [r7, #12]
      }
      break;
34011f42:	e003      	b.n	34011f4c <RCCEx_GetFDCANCLKFreq+0xf0>

    default:
      /* Unexpected case */
      break;
34011f44:	bf00      	nop
34011f46:	e002      	b.n	34011f4e <RCCEx_GetFDCANCLKFreq+0xf2>
      break;
34011f48:	bf00      	nop
34011f4a:	e000      	b.n	34011f4e <RCCEx_GetFDCANCLKFreq+0xf2>
      break;
34011f4c:	bf00      	nop
  }

  return fdcan_frequency;
34011f4e:	68fb      	ldr	r3, [r7, #12]
}
34011f50:	4618      	mov	r0, r3
34011f52:	3710      	adds	r7, #16
34011f54:	46bd      	mov	sp, r7
34011f56:	bd80      	pop	{r7, pc}
34011f58:	02dc6c00 	.word	0x02dc6c00

34011f5c <RCCEx_GetFMCCLKFreq>:
  *         @arg @ref RCCEx_FMC_Clock_Source
  * @retval FMC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetFMCCLKFreq(uint32_t FMCxSource)
{
34011f5c:	b580      	push	{r7, lr}
34011f5e:	b084      	sub	sp, #16
34011f60:	af00      	add	r7, sp, #0
34011f62:	6078      	str	r0, [r7, #4]
  uint32_t fmc_frequency = RCC_PERIPH_FREQUENCY_NO;
34011f64:	2300      	movs	r3, #0
34011f66:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetFMCClockSource(FMCxSource))
34011f68:	6878      	ldr	r0, [r7, #4]
34011f6a:	f7f6 ff35 	bl	34008dd8 <LL_RCC_GetFMCClockSource>
34011f6e:	4603      	mov	r3, r0
34011f70:	2b30      	cmp	r3, #48	@ 0x30
34011f72:	d05d      	beq.n	34012030 <RCCEx_GetFMCCLKFreq+0xd4>
34011f74:	2b30      	cmp	r3, #48	@ 0x30
34011f76:	f200 809e 	bhi.w	340120b6 <RCCEx_GetFMCCLKFreq+0x15a>
34011f7a:	2b20      	cmp	r3, #32
34011f7c:	d014      	beq.n	34011fa8 <RCCEx_GetFMCCLKFreq+0x4c>
34011f7e:	2b20      	cmp	r3, #32
34011f80:	f200 8099 	bhi.w	340120b6 <RCCEx_GetFMCCLKFreq+0x15a>
34011f84:	2b00      	cmp	r3, #0
34011f86:	d002      	beq.n	34011f8e <RCCEx_GetFMCCLKFreq+0x32>
34011f88:	2b10      	cmp	r3, #16
34011f8a:	d008      	beq.n	34011f9e <RCCEx_GetFMCCLKFreq+0x42>
      }
      break;

    default:
      /* Unexpected case */
      break;
34011f8c:	e093      	b.n	340120b6 <RCCEx_GetFMCCLKFreq+0x15a>
      fmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34011f8e:	f7f5 fff1 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34011f92:	4603      	mov	r3, r0
34011f94:	4618      	mov	r0, r3
34011f96:	f7ff f8e5 	bl	34011164 <RCCEx_GetHCLKFreq>
34011f9a:	60f8      	str	r0, [r7, #12]
      break;
34011f9c:	e090      	b.n	340120c0 <RCCEx_GetFMCCLKFreq+0x164>
      fmc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34011f9e:	2007      	movs	r0, #7
34011fa0:	f7ff fbcc 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
34011fa4:	60f8      	str	r0, [r7, #12]
      break;
34011fa6:	e08b      	b.n	340120c0 <RCCEx_GetFMCCLKFreq+0x164>
      if (LL_RCC_IC3_IsEnabled() != 0U)
34011fa8:	f7f7 fac6 	bl	34009538 <LL_RCC_IC3_IsEnabled>
34011fac:	4603      	mov	r3, r0
34011fae:	2b00      	cmp	r3, #0
34011fb0:	f000 8083 	beq.w	340120ba <RCCEx_GetFMCCLKFreq+0x15e>
        ic_divider = LL_RCC_IC3_GetDivider();
34011fb4:	f7f7 fae2 	bl	3400957c <LL_RCC_IC3_GetDivider>
34011fb8:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC3_GetSource())
34011fba:	f7f7 fad1 	bl	34009560 <LL_RCC_IC3_GetSource>
34011fbe:	4603      	mov	r3, r0
34011fc0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011fc4:	d029      	beq.n	3401201a <RCCEx_GetFMCCLKFreq+0xbe>
34011fc6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011fca:	d82f      	bhi.n	3401202c <RCCEx_GetFMCCLKFreq+0xd0>
34011fcc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011fd0:	d01a      	beq.n	34012008 <RCCEx_GetFMCCLKFreq+0xac>
34011fd2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011fd6:	d829      	bhi.n	3401202c <RCCEx_GetFMCCLKFreq+0xd0>
34011fd8:	2b00      	cmp	r3, #0
34011fda:	d003      	beq.n	34011fe4 <RCCEx_GetFMCCLKFreq+0x88>
34011fdc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011fe0:	d009      	beq.n	34011ff6 <RCCEx_GetFMCCLKFreq+0x9a>
            break;
34011fe2:	e023      	b.n	3401202c <RCCEx_GetFMCCLKFreq+0xd0>
            fmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34011fe4:	f7fe ffa6 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34011fe8:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34011fea:	68fa      	ldr	r2, [r7, #12]
34011fec:	68bb      	ldr	r3, [r7, #8]
34011fee:	fbb2 f3f3 	udiv	r3, r2, r3
34011ff2:	60fb      	str	r3, [r7, #12]
            break;
34011ff4:	e01b      	b.n	3401202e <RCCEx_GetFMCCLKFreq+0xd2>
            fmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34011ff6:	f7fe ffe3 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34011ffa:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34011ffc:	68fa      	ldr	r2, [r7, #12]
34011ffe:	68bb      	ldr	r3, [r7, #8]
34012000:	fbb2 f3f3 	udiv	r3, r2, r3
34012004:	60fb      	str	r3, [r7, #12]
            break;
34012006:	e012      	b.n	3401202e <RCCEx_GetFMCCLKFreq+0xd2>
            fmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34012008:	f7ff f820 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
3401200c:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
3401200e:	68fa      	ldr	r2, [r7, #12]
34012010:	68bb      	ldr	r3, [r7, #8]
34012012:	fbb2 f3f3 	udiv	r3, r2, r3
34012016:	60fb      	str	r3, [r7, #12]
            break;
34012018:	e009      	b.n	3401202e <RCCEx_GetFMCCLKFreq+0xd2>
            fmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401201a:	f7ff f85d 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
3401201e:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34012020:	68fa      	ldr	r2, [r7, #12]
34012022:	68bb      	ldr	r3, [r7, #8]
34012024:	fbb2 f3f3 	udiv	r3, r2, r3
34012028:	60fb      	str	r3, [r7, #12]
            break;
3401202a:	e000      	b.n	3401202e <RCCEx_GetFMCCLKFreq+0xd2>
            break;
3401202c:	bf00      	nop
      break;
3401202e:	e044      	b.n	340120ba <RCCEx_GetFMCCLKFreq+0x15e>
      if (LL_RCC_IC4_IsEnabled() != 0U)
34012030:	f7f7 fac2 	bl	340095b8 <LL_RCC_IC4_IsEnabled>
34012034:	4603      	mov	r3, r0
34012036:	2b00      	cmp	r3, #0
34012038:	d041      	beq.n	340120be <RCCEx_GetFMCCLKFreq+0x162>
        ic_divider = LL_RCC_IC4_GetDivider();
3401203a:	f7f7 fadf 	bl	340095fc <LL_RCC_IC4_GetDivider>
3401203e:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC4_GetSource())
34012040:	f7f7 face 	bl	340095e0 <LL_RCC_IC4_GetSource>
34012044:	4603      	mov	r3, r0
34012046:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401204a:	d029      	beq.n	340120a0 <RCCEx_GetFMCCLKFreq+0x144>
3401204c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012050:	d82f      	bhi.n	340120b2 <RCCEx_GetFMCCLKFreq+0x156>
34012052:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012056:	d01a      	beq.n	3401208e <RCCEx_GetFMCCLKFreq+0x132>
34012058:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401205c:	d829      	bhi.n	340120b2 <RCCEx_GetFMCCLKFreq+0x156>
3401205e:	2b00      	cmp	r3, #0
34012060:	d003      	beq.n	3401206a <RCCEx_GetFMCCLKFreq+0x10e>
34012062:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34012066:	d009      	beq.n	3401207c <RCCEx_GetFMCCLKFreq+0x120>
            break;
34012068:	e023      	b.n	340120b2 <RCCEx_GetFMCCLKFreq+0x156>
            fmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3401206a:	f7fe ff63 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
3401206e:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34012070:	68fa      	ldr	r2, [r7, #12]
34012072:	68bb      	ldr	r3, [r7, #8]
34012074:	fbb2 f3f3 	udiv	r3, r2, r3
34012078:	60fb      	str	r3, [r7, #12]
            break;
3401207a:	e01b      	b.n	340120b4 <RCCEx_GetFMCCLKFreq+0x158>
            fmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3401207c:	f7fe ffa0 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34012080:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34012082:	68fa      	ldr	r2, [r7, #12]
34012084:	68bb      	ldr	r3, [r7, #8]
34012086:	fbb2 f3f3 	udiv	r3, r2, r3
3401208a:	60fb      	str	r3, [r7, #12]
            break;
3401208c:	e012      	b.n	340120b4 <RCCEx_GetFMCCLKFreq+0x158>
            fmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401208e:	f7fe ffdd 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34012092:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34012094:	68fa      	ldr	r2, [r7, #12]
34012096:	68bb      	ldr	r3, [r7, #8]
34012098:	fbb2 f3f3 	udiv	r3, r2, r3
3401209c:	60fb      	str	r3, [r7, #12]
            break;
3401209e:	e009      	b.n	340120b4 <RCCEx_GetFMCCLKFreq+0x158>
            fmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340120a0:	f7ff f81a 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
340120a4:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
340120a6:	68fa      	ldr	r2, [r7, #12]
340120a8:	68bb      	ldr	r3, [r7, #8]
340120aa:	fbb2 f3f3 	udiv	r3, r2, r3
340120ae:	60fb      	str	r3, [r7, #12]
            break;
340120b0:	e000      	b.n	340120b4 <RCCEx_GetFMCCLKFreq+0x158>
            break;
340120b2:	bf00      	nop
      break;
340120b4:	e003      	b.n	340120be <RCCEx_GetFMCCLKFreq+0x162>
      break;
340120b6:	bf00      	nop
340120b8:	e002      	b.n	340120c0 <RCCEx_GetFMCCLKFreq+0x164>
      break;
340120ba:	bf00      	nop
340120bc:	e000      	b.n	340120c0 <RCCEx_GetFMCCLKFreq+0x164>
      break;
340120be:	bf00      	nop
  }

  return fmc_frequency;
340120c0:	68fb      	ldr	r3, [r7, #12]
}
340120c2:	4618      	mov	r0, r3
340120c4:	3710      	adds	r7, #16
340120c6:	46bd      	mov	sp, r7
340120c8:	bd80      	pop	{r7, pc}
	...

340120cc <RCCEx_GetI2CCLKFreq>:
  *         @arg @ref RCCEx_I2C4_Clock_Source
  * @retval I2C clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetI2CCLKFreq(uint32_t I2CxSource)
{
340120cc:	b580      	push	{r7, lr}
340120ce:	b084      	sub	sp, #16
340120d0:	af00      	add	r7, sp, #0
340120d2:	6078      	str	r0, [r7, #4]
  uint32_t i2c_frequency = RCC_PERIPH_FREQUENCY_NO;
340120d4:	2300      	movs	r3, #0
340120d6:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetI2CClockSource(I2CxSource))
340120d8:	6878      	ldr	r0, [r7, #4]
340120da:	f7f6 fe8f 	bl	34008dfc <LL_RCC_GetI2CClockSource>
340120de:	4603      	mov	r3, r0
340120e0:	4aa2      	ldr	r2, [pc, #648]	@ (3401236c <RCCEx_GetI2CCLKFreq+0x2a0>)
340120e2:	4293      	cmp	r3, r2
340120e4:	f000 8172 	beq.w	340123cc <RCCEx_GetI2CCLKFreq+0x300>
340120e8:	4aa0      	ldr	r2, [pc, #640]	@ (3401236c <RCCEx_GetI2CCLKFreq+0x2a0>)
340120ea:	4293      	cmp	r3, r2
340120ec:	f200 8184 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
340120f0:	4a9f      	ldr	r2, [pc, #636]	@ (34012370 <RCCEx_GetI2CCLKFreq+0x2a4>)
340120f2:	4293      	cmp	r3, r2
340120f4:	f000 816a 	beq.w	340123cc <RCCEx_GetI2CCLKFreq+0x300>
340120f8:	4a9d      	ldr	r2, [pc, #628]	@ (34012370 <RCCEx_GetI2CCLKFreq+0x2a4>)
340120fa:	4293      	cmp	r3, r2
340120fc:	f200 817c 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
34012100:	4a9c      	ldr	r2, [pc, #624]	@ (34012374 <RCCEx_GetI2CCLKFreq+0x2a8>)
34012102:	4293      	cmp	r3, r2
34012104:	f000 8162 	beq.w	340123cc <RCCEx_GetI2CCLKFreq+0x300>
34012108:	4a9a      	ldr	r2, [pc, #616]	@ (34012374 <RCCEx_GetI2CCLKFreq+0x2a8>)
3401210a:	4293      	cmp	r3, r2
3401210c:	f200 8174 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
34012110:	4a99      	ldr	r2, [pc, #612]	@ (34012378 <RCCEx_GetI2CCLKFreq+0x2ac>)
34012112:	4293      	cmp	r3, r2
34012114:	f000 815a 	beq.w	340123cc <RCCEx_GetI2CCLKFreq+0x300>
34012118:	4a97      	ldr	r2, [pc, #604]	@ (34012378 <RCCEx_GetI2CCLKFreq+0x2ac>)
3401211a:	4293      	cmp	r3, r2
3401211c:	f200 816c 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
34012120:	4a96      	ldr	r2, [pc, #600]	@ (3401237c <RCCEx_GetI2CCLKFreq+0x2b0>)
34012122:	4293      	cmp	r3, r2
34012124:	f000 8160 	beq.w	340123e8 <RCCEx_GetI2CCLKFreq+0x31c>
34012128:	4a94      	ldr	r2, [pc, #592]	@ (3401237c <RCCEx_GetI2CCLKFreq+0x2b0>)
3401212a:	4293      	cmp	r3, r2
3401212c:	f200 8164 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
34012130:	4a93      	ldr	r2, [pc, #588]	@ (34012380 <RCCEx_GetI2CCLKFreq+0x2b4>)
34012132:	4293      	cmp	r3, r2
34012134:	f000 8158 	beq.w	340123e8 <RCCEx_GetI2CCLKFreq+0x31c>
34012138:	4a91      	ldr	r2, [pc, #580]	@ (34012380 <RCCEx_GetI2CCLKFreq+0x2b4>)
3401213a:	4293      	cmp	r3, r2
3401213c:	f200 815c 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
34012140:	4a90      	ldr	r2, [pc, #576]	@ (34012384 <RCCEx_GetI2CCLKFreq+0x2b8>)
34012142:	4293      	cmp	r3, r2
34012144:	f000 8150 	beq.w	340123e8 <RCCEx_GetI2CCLKFreq+0x31c>
34012148:	4a8e      	ldr	r2, [pc, #568]	@ (34012384 <RCCEx_GetI2CCLKFreq+0x2b8>)
3401214a:	4293      	cmp	r3, r2
3401214c:	f200 8154 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
34012150:	4a8d      	ldr	r2, [pc, #564]	@ (34012388 <RCCEx_GetI2CCLKFreq+0x2bc>)
34012152:	4293      	cmp	r3, r2
34012154:	f000 8148 	beq.w	340123e8 <RCCEx_GetI2CCLKFreq+0x31c>
34012158:	4a8b      	ldr	r2, [pc, #556]	@ (34012388 <RCCEx_GetI2CCLKFreq+0x2bc>)
3401215a:	4293      	cmp	r3, r2
3401215c:	f200 814c 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
34012160:	4a8a      	ldr	r2, [pc, #552]	@ (3401238c <RCCEx_GetI2CCLKFreq+0x2c0>)
34012162:	4293      	cmp	r3, r2
34012164:	f000 80be 	beq.w	340122e4 <RCCEx_GetI2CCLKFreq+0x218>
34012168:	4a88      	ldr	r2, [pc, #544]	@ (3401238c <RCCEx_GetI2CCLKFreq+0x2c0>)
3401216a:	4293      	cmp	r3, r2
3401216c:	f200 8144 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
34012170:	4a87      	ldr	r2, [pc, #540]	@ (34012390 <RCCEx_GetI2CCLKFreq+0x2c4>)
34012172:	4293      	cmp	r3, r2
34012174:	f000 80b6 	beq.w	340122e4 <RCCEx_GetI2CCLKFreq+0x218>
34012178:	4a85      	ldr	r2, [pc, #532]	@ (34012390 <RCCEx_GetI2CCLKFreq+0x2c4>)
3401217a:	4293      	cmp	r3, r2
3401217c:	f200 813c 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
34012180:	4a84      	ldr	r2, [pc, #528]	@ (34012394 <RCCEx_GetI2CCLKFreq+0x2c8>)
34012182:	4293      	cmp	r3, r2
34012184:	f000 80ae 	beq.w	340122e4 <RCCEx_GetI2CCLKFreq+0x218>
34012188:	4a82      	ldr	r2, [pc, #520]	@ (34012394 <RCCEx_GetI2CCLKFreq+0x2c8>)
3401218a:	4293      	cmp	r3, r2
3401218c:	f200 8134 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
34012190:	4a81      	ldr	r2, [pc, #516]	@ (34012398 <RCCEx_GetI2CCLKFreq+0x2cc>)
34012192:	4293      	cmp	r3, r2
34012194:	f000 80a6 	beq.w	340122e4 <RCCEx_GetI2CCLKFreq+0x218>
34012198:	4a7f      	ldr	r2, [pc, #508]	@ (34012398 <RCCEx_GetI2CCLKFreq+0x2cc>)
3401219a:	4293      	cmp	r3, r2
3401219c:	f200 812c 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
340121a0:	4a7e      	ldr	r2, [pc, #504]	@ (3401239c <RCCEx_GetI2CCLKFreq+0x2d0>)
340121a2:	4293      	cmp	r3, r2
340121a4:	d05a      	beq.n	3401225c <RCCEx_GetI2CCLKFreq+0x190>
340121a6:	4a7d      	ldr	r2, [pc, #500]	@ (3401239c <RCCEx_GetI2CCLKFreq+0x2d0>)
340121a8:	4293      	cmp	r3, r2
340121aa:	f200 8125 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
340121ae:	4a7c      	ldr	r2, [pc, #496]	@ (340123a0 <RCCEx_GetI2CCLKFreq+0x2d4>)
340121b0:	4293      	cmp	r3, r2
340121b2:	d053      	beq.n	3401225c <RCCEx_GetI2CCLKFreq+0x190>
340121b4:	4a7a      	ldr	r2, [pc, #488]	@ (340123a0 <RCCEx_GetI2CCLKFreq+0x2d4>)
340121b6:	4293      	cmp	r3, r2
340121b8:	f200 811e 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
340121bc:	4a79      	ldr	r2, [pc, #484]	@ (340123a4 <RCCEx_GetI2CCLKFreq+0x2d8>)
340121be:	4293      	cmp	r3, r2
340121c0:	d04c      	beq.n	3401225c <RCCEx_GetI2CCLKFreq+0x190>
340121c2:	4a78      	ldr	r2, [pc, #480]	@ (340123a4 <RCCEx_GetI2CCLKFreq+0x2d8>)
340121c4:	4293      	cmp	r3, r2
340121c6:	f200 8117 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
340121ca:	4a77      	ldr	r2, [pc, #476]	@ (340123a8 <RCCEx_GetI2CCLKFreq+0x2dc>)
340121cc:	4293      	cmp	r3, r2
340121ce:	d045      	beq.n	3401225c <RCCEx_GetI2CCLKFreq+0x190>
340121d0:	4a75      	ldr	r2, [pc, #468]	@ (340123a8 <RCCEx_GetI2CCLKFreq+0x2dc>)
340121d2:	4293      	cmp	r3, r2
340121d4:	f200 8110 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
340121d8:	4a74      	ldr	r2, [pc, #464]	@ (340123ac <RCCEx_GetI2CCLKFreq+0x2e0>)
340121da:	4293      	cmp	r3, r2
340121dc:	d039      	beq.n	34012252 <RCCEx_GetI2CCLKFreq+0x186>
340121de:	4a73      	ldr	r2, [pc, #460]	@ (340123ac <RCCEx_GetI2CCLKFreq+0x2e0>)
340121e0:	4293      	cmp	r3, r2
340121e2:	f200 8109 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
340121e6:	4a72      	ldr	r2, [pc, #456]	@ (340123b0 <RCCEx_GetI2CCLKFreq+0x2e4>)
340121e8:	4293      	cmp	r3, r2
340121ea:	d032      	beq.n	34012252 <RCCEx_GetI2CCLKFreq+0x186>
340121ec:	4a70      	ldr	r2, [pc, #448]	@ (340123b0 <RCCEx_GetI2CCLKFreq+0x2e4>)
340121ee:	4293      	cmp	r3, r2
340121f0:	f200 8102 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
340121f4:	4a6f      	ldr	r2, [pc, #444]	@ (340123b4 <RCCEx_GetI2CCLKFreq+0x2e8>)
340121f6:	4293      	cmp	r3, r2
340121f8:	d02b      	beq.n	34012252 <RCCEx_GetI2CCLKFreq+0x186>
340121fa:	4a6e      	ldr	r2, [pc, #440]	@ (340123b4 <RCCEx_GetI2CCLKFreq+0x2e8>)
340121fc:	4293      	cmp	r3, r2
340121fe:	f200 80fb 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
34012202:	4a6d      	ldr	r2, [pc, #436]	@ (340123b8 <RCCEx_GetI2CCLKFreq+0x2ec>)
34012204:	4293      	cmp	r3, r2
34012206:	d024      	beq.n	34012252 <RCCEx_GetI2CCLKFreq+0x186>
34012208:	4a6b      	ldr	r2, [pc, #428]	@ (340123b8 <RCCEx_GetI2CCLKFreq+0x2ec>)
3401220a:	4293      	cmp	r3, r2
3401220c:	f200 80f4 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
34012210:	4a6a      	ldr	r2, [pc, #424]	@ (340123bc <RCCEx_GetI2CCLKFreq+0x2f0>)
34012212:	4293      	cmp	r3, r2
34012214:	d011      	beq.n	3401223a <RCCEx_GetI2CCLKFreq+0x16e>
34012216:	4a69      	ldr	r2, [pc, #420]	@ (340123bc <RCCEx_GetI2CCLKFreq+0x2f0>)
34012218:	4293      	cmp	r3, r2
3401221a:	f200 80ed 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
3401221e:	4a68      	ldr	r2, [pc, #416]	@ (340123c0 <RCCEx_GetI2CCLKFreq+0x2f4>)
34012220:	4293      	cmp	r3, r2
34012222:	d00a      	beq.n	3401223a <RCCEx_GetI2CCLKFreq+0x16e>
34012224:	4a66      	ldr	r2, [pc, #408]	@ (340123c0 <RCCEx_GetI2CCLKFreq+0x2f4>)
34012226:	4293      	cmp	r3, r2
34012228:	f200 80e6 	bhi.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
3401222c:	4a65      	ldr	r2, [pc, #404]	@ (340123c4 <RCCEx_GetI2CCLKFreq+0x2f8>)
3401222e:	4293      	cmp	r3, r2
34012230:	d003      	beq.n	3401223a <RCCEx_GetI2CCLKFreq+0x16e>
34012232:	4a65      	ldr	r2, [pc, #404]	@ (340123c8 <RCCEx_GetI2CCLKFreq+0x2fc>)
34012234:	4293      	cmp	r3, r2
34012236:	f040 80df 	bne.w	340123f8 <RCCEx_GetI2CCLKFreq+0x32c>
  {
    case LL_RCC_I2C1_CLKSOURCE_PCLK1:
    case LL_RCC_I2C2_CLKSOURCE_PCLK1:
    case LL_RCC_I2C3_CLKSOURCE_PCLK1:
    case LL_RCC_I2C4_CLKSOURCE_PCLK1:
      i2c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3401223a:	f7f5 fe9b 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
3401223e:	4603      	mov	r3, r0
34012240:	4618      	mov	r0, r3
34012242:	f7fe ff8f 	bl	34011164 <RCCEx_GetHCLKFreq>
34012246:	4603      	mov	r3, r0
34012248:	4618      	mov	r0, r3
3401224a:	f7fe ff9c 	bl	34011186 <RCCEx_GetPCLK1Freq>
3401224e:	60f8      	str	r0, [r7, #12]
      break;
34012250:	e0db      	b.n	3401240a <RCCEx_GetI2CCLKFreq+0x33e>

    case LL_RCC_I2C1_CLKSOURCE_CLKP:
    case LL_RCC_I2C2_CLKSOURCE_CLKP:
    case LL_RCC_I2C3_CLKSOURCE_CLKP:
    case LL_RCC_I2C4_CLKSOURCE_CLKP:
      i2c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34012252:	2007      	movs	r0, #7
34012254:	f7ff fa72 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
34012258:	60f8      	str	r0, [r7, #12]
      break;
3401225a:	e0d6      	b.n	3401240a <RCCEx_GetI2CCLKFreq+0x33e>

    case LL_RCC_I2C1_CLKSOURCE_IC10:
    case LL_RCC_I2C2_CLKSOURCE_IC10:
    case LL_RCC_I2C3_CLKSOURCE_IC10:
    case LL_RCC_I2C4_CLKSOURCE_IC10:
      if (LL_RCC_IC10_IsEnabled() != 0U)
3401225c:	f7f7 faec 	bl	34009838 <LL_RCC_IC10_IsEnabled>
34012260:	4603      	mov	r3, r0
34012262:	2b00      	cmp	r3, #0
34012264:	f000 80ca 	beq.w	340123fc <RCCEx_GetI2CCLKFreq+0x330>
      {
        ic_divider = LL_RCC_IC10_GetDivider();
34012268:	f7f7 fb08 	bl	3400987c <LL_RCC_IC10_GetDivider>
3401226c:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC10_GetSource())
3401226e:	f7f7 faf7 	bl	34009860 <LL_RCC_IC10_GetSource>
34012272:	4603      	mov	r3, r0
34012274:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012278:	d029      	beq.n	340122ce <RCCEx_GetI2CCLKFreq+0x202>
3401227a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401227e:	d82f      	bhi.n	340122e0 <RCCEx_GetI2CCLKFreq+0x214>
34012280:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012284:	d01a      	beq.n	340122bc <RCCEx_GetI2CCLKFreq+0x1f0>
34012286:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401228a:	d829      	bhi.n	340122e0 <RCCEx_GetI2CCLKFreq+0x214>
3401228c:	2b00      	cmp	r3, #0
3401228e:	d003      	beq.n	34012298 <RCCEx_GetI2CCLKFreq+0x1cc>
34012290:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34012294:	d009      	beq.n	340122aa <RCCEx_GetI2CCLKFreq+0x1de>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i2c_frequency = i2c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34012296:	e023      	b.n	340122e0 <RCCEx_GetI2CCLKFreq+0x214>
            i2c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34012298:	f7fe fe4c 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
3401229c:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
3401229e:	68fa      	ldr	r2, [r7, #12]
340122a0:	68bb      	ldr	r3, [r7, #8]
340122a2:	fbb2 f3f3 	udiv	r3, r2, r3
340122a6:	60fb      	str	r3, [r7, #12]
            break;
340122a8:	e01b      	b.n	340122e2 <RCCEx_GetI2CCLKFreq+0x216>
            i2c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340122aa:	f7fe fe89 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
340122ae:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
340122b0:	68fa      	ldr	r2, [r7, #12]
340122b2:	68bb      	ldr	r3, [r7, #8]
340122b4:	fbb2 f3f3 	udiv	r3, r2, r3
340122b8:	60fb      	str	r3, [r7, #12]
            break;
340122ba:	e012      	b.n	340122e2 <RCCEx_GetI2CCLKFreq+0x216>
            i2c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340122bc:	f7fe fec6 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
340122c0:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
340122c2:	68fa      	ldr	r2, [r7, #12]
340122c4:	68bb      	ldr	r3, [r7, #8]
340122c6:	fbb2 f3f3 	udiv	r3, r2, r3
340122ca:	60fb      	str	r3, [r7, #12]
            break;
340122cc:	e009      	b.n	340122e2 <RCCEx_GetI2CCLKFreq+0x216>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340122ce:	f7fe ff03 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
340122d2:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
340122d4:	68fa      	ldr	r2, [r7, #12]
340122d6:	68bb      	ldr	r3, [r7, #8]
340122d8:	fbb2 f3f3 	udiv	r3, r2, r3
340122dc:	60fb      	str	r3, [r7, #12]
            break;
340122de:	e000      	b.n	340122e2 <RCCEx_GetI2CCLKFreq+0x216>
            break;
340122e0:	bf00      	nop
        }
      }
      break;
340122e2:	e08b      	b.n	340123fc <RCCEx_GetI2CCLKFreq+0x330>

    case LL_RCC_I2C1_CLKSOURCE_IC15:
    case LL_RCC_I2C2_CLKSOURCE_IC15:
    case LL_RCC_I2C3_CLKSOURCE_IC15:
    case LL_RCC_I2C4_CLKSOURCE_IC15:
      if (LL_RCC_IC15_IsEnabled() != 0U)
340122e4:	f7f7 fba8 	bl	34009a38 <LL_RCC_IC15_IsEnabled>
340122e8:	4603      	mov	r3, r0
340122ea:	2b00      	cmp	r3, #0
340122ec:	f000 8088 	beq.w	34012400 <RCCEx_GetI2CCLKFreq+0x334>
      {
        ic_divider = LL_RCC_IC15_GetDivider();
340122f0:	f7f7 fbc4 	bl	34009a7c <LL_RCC_IC15_GetDivider>
340122f4:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
340122f6:	f7f7 fbb3 	bl	34009a60 <LL_RCC_IC15_GetSource>
340122fa:	4603      	mov	r3, r0
340122fc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012300:	d029      	beq.n	34012356 <RCCEx_GetI2CCLKFreq+0x28a>
34012302:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012306:	d82f      	bhi.n	34012368 <RCCEx_GetI2CCLKFreq+0x29c>
34012308:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401230c:	d01a      	beq.n	34012344 <RCCEx_GetI2CCLKFreq+0x278>
3401230e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012312:	d829      	bhi.n	34012368 <RCCEx_GetI2CCLKFreq+0x29c>
34012314:	2b00      	cmp	r3, #0
34012316:	d003      	beq.n	34012320 <RCCEx_GetI2CCLKFreq+0x254>
34012318:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401231c:	d009      	beq.n	34012332 <RCCEx_GetI2CCLKFreq+0x266>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i2c_frequency = i2c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3401231e:	e023      	b.n	34012368 <RCCEx_GetI2CCLKFreq+0x29c>
            i2c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34012320:	f7fe fe08 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34012324:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34012326:	68fa      	ldr	r2, [r7, #12]
34012328:	68bb      	ldr	r3, [r7, #8]
3401232a:	fbb2 f3f3 	udiv	r3, r2, r3
3401232e:	60fb      	str	r3, [r7, #12]
            break;
34012330:	e01b      	b.n	3401236a <RCCEx_GetI2CCLKFreq+0x29e>
            i2c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34012332:	f7fe fe45 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34012336:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34012338:	68fa      	ldr	r2, [r7, #12]
3401233a:	68bb      	ldr	r3, [r7, #8]
3401233c:	fbb2 f3f3 	udiv	r3, r2, r3
34012340:	60fb      	str	r3, [r7, #12]
            break;
34012342:	e012      	b.n	3401236a <RCCEx_GetI2CCLKFreq+0x29e>
            i2c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34012344:	f7fe fe82 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34012348:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
3401234a:	68fa      	ldr	r2, [r7, #12]
3401234c:	68bb      	ldr	r3, [r7, #8]
3401234e:	fbb2 f3f3 	udiv	r3, r2, r3
34012352:	60fb      	str	r3, [r7, #12]
            break;
34012354:	e009      	b.n	3401236a <RCCEx_GetI2CCLKFreq+0x29e>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34012356:	f7fe febf 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
3401235a:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
3401235c:	68fa      	ldr	r2, [r7, #12]
3401235e:	68bb      	ldr	r3, [r7, #8]
34012360:	fbb2 f3f3 	udiv	r3, r2, r3
34012364:	60fb      	str	r3, [r7, #12]
            break;
34012366:	e000      	b.n	3401236a <RCCEx_GetI2CCLKFreq+0x29e>
            break;
34012368:	bf00      	nop
        }
      }
      break;
3401236a:	e049      	b.n	34012400 <RCCEx_GetI2CCLKFreq+0x334>
3401236c:	07050c0c 	.word	0x07050c0c
34012370:	0705080c 	.word	0x0705080c
34012374:	0705040c 	.word	0x0705040c
34012378:	0705000c 	.word	0x0705000c
3401237c:	07040c0c 	.word	0x07040c0c
34012380:	0704080c 	.word	0x0704080c
34012384:	0704040c 	.word	0x0704040c
34012388:	0704000c 	.word	0x0704000c
3401238c:	07030c0c 	.word	0x07030c0c
34012390:	0703080c 	.word	0x0703080c
34012394:	0703040c 	.word	0x0703040c
34012398:	0703000c 	.word	0x0703000c
3401239c:	07020c0c 	.word	0x07020c0c
340123a0:	0702080c 	.word	0x0702080c
340123a4:	0702040c 	.word	0x0702040c
340123a8:	0702000c 	.word	0x0702000c
340123ac:	07010c0c 	.word	0x07010c0c
340123b0:	0701080c 	.word	0x0701080c
340123b4:	0701040c 	.word	0x0701040c
340123b8:	0701000c 	.word	0x0701000c
340123bc:	07000c0c 	.word	0x07000c0c
340123c0:	0700080c 	.word	0x0700080c
340123c4:	0700000c 	.word	0x0700000c
340123c8:	0700040c 	.word	0x0700040c

    case LL_RCC_I2C1_CLKSOURCE_HSI:
    case LL_RCC_I2C2_CLKSOURCE_HSI:
    case LL_RCC_I2C3_CLKSOURCE_HSI:
    case LL_RCC_I2C4_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
340123cc:	f7f6 f9d0 	bl	34008770 <LL_RCC_HSI_IsReady>
340123d0:	4603      	mov	r3, r0
340123d2:	2b00      	cmp	r3, #0
340123d4:	d016      	beq.n	34012404 <RCCEx_GetI2CCLKFreq+0x338>
      {
        i2c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340123d6:	f7f6 f9dd 	bl	34008794 <LL_RCC_HSI_GetDivider>
340123da:	4603      	mov	r3, r0
340123dc:	09db      	lsrs	r3, r3, #7
340123de:	4a0d      	ldr	r2, [pc, #52]	@ (34012414 <RCCEx_GetI2CCLKFreq+0x348>)
340123e0:	fa22 f303 	lsr.w	r3, r2, r3
340123e4:	60fb      	str	r3, [r7, #12]
      }
      break;
340123e6:	e00d      	b.n	34012404 <RCCEx_GetI2CCLKFreq+0x338>

    case LL_RCC_I2C1_CLKSOURCE_MSI:
    case LL_RCC_I2C2_CLKSOURCE_MSI:
    case LL_RCC_I2C3_CLKSOURCE_MSI:
    case LL_RCC_I2C4_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
340123e8:	f7f6 f9e2 	bl	340087b0 <LL_RCC_MSI_IsReady>
340123ec:	4603      	mov	r3, r0
340123ee:	2b00      	cmp	r3, #0
340123f0:	d00a      	beq.n	34012408 <RCCEx_GetI2CCLKFreq+0x33c>
      {
        i2c_frequency = MSI_VALUE;
340123f2:	4b09      	ldr	r3, [pc, #36]	@ (34012418 <RCCEx_GetI2CCLKFreq+0x34c>)
340123f4:	60fb      	str	r3, [r7, #12]
      }
      break;
340123f6:	e007      	b.n	34012408 <RCCEx_GetI2CCLKFreq+0x33c>

    default:
      /* Unexpected case */
      break;
340123f8:	bf00      	nop
340123fa:	e006      	b.n	3401240a <RCCEx_GetI2CCLKFreq+0x33e>
      break;
340123fc:	bf00      	nop
340123fe:	e004      	b.n	3401240a <RCCEx_GetI2CCLKFreq+0x33e>
      break;
34012400:	bf00      	nop
34012402:	e002      	b.n	3401240a <RCCEx_GetI2CCLKFreq+0x33e>
      break;
34012404:	bf00      	nop
34012406:	e000      	b.n	3401240a <RCCEx_GetI2CCLKFreq+0x33e>
      break;
34012408:	bf00      	nop
  }

  return i2c_frequency;
3401240a:	68fb      	ldr	r3, [r7, #12]
}
3401240c:	4618      	mov	r0, r3
3401240e:	3710      	adds	r7, #16
34012410:	46bd      	mov	sp, r7
34012412:	bd80      	pop	{r7, pc}
34012414:	03d09000 	.word	0x03d09000
34012418:	003d0900 	.word	0x003d0900

3401241c <RCCEx_GetI3CCLKFreq>:
  *         @arg @ref RCCEx_I3C2_Clock_Source
  * @retval I3C clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetI3CCLKFreq(uint32_t I3CxSource)
{
3401241c:	b580      	push	{r7, lr}
3401241e:	b084      	sub	sp, #16
34012420:	af00      	add	r7, sp, #0
34012422:	6078      	str	r0, [r7, #4]
  uint32_t i3c_frequency = RCC_PERIPH_FREQUENCY_NO;
34012424:	2300      	movs	r3, #0
34012426:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetI3CClockSource(I3CxSource))
34012428:	6878      	ldr	r0, [r7, #4]
3401242a:	f7f6 fcf3 	bl	34008e14 <LL_RCC_GetI3CClockSource>
3401242e:	4603      	mov	r3, r0
34012430:	4a86      	ldr	r2, [pc, #536]	@ (3401264c <RCCEx_GetI3CCLKFreq+0x230>)
34012432:	4293      	cmp	r3, r2
34012434:	f000 80e6 	beq.w	34012604 <RCCEx_GetI3CCLKFreq+0x1e8>
34012438:	4a84      	ldr	r2, [pc, #528]	@ (3401264c <RCCEx_GetI3CCLKFreq+0x230>)
3401243a:	4293      	cmp	r3, r2
3401243c:	f200 80f8 	bhi.w	34012630 <RCCEx_GetI3CCLKFreq+0x214>
34012440:	4a83      	ldr	r2, [pc, #524]	@ (34012650 <RCCEx_GetI3CCLKFreq+0x234>)
34012442:	4293      	cmp	r3, r2
34012444:	f000 80de 	beq.w	34012604 <RCCEx_GetI3CCLKFreq+0x1e8>
34012448:	4a81      	ldr	r2, [pc, #516]	@ (34012650 <RCCEx_GetI3CCLKFreq+0x234>)
3401244a:	4293      	cmp	r3, r2
3401244c:	f200 80f0 	bhi.w	34012630 <RCCEx_GetI3CCLKFreq+0x214>
34012450:	4a80      	ldr	r2, [pc, #512]	@ (34012654 <RCCEx_GetI3CCLKFreq+0x238>)
34012452:	4293      	cmp	r3, r2
34012454:	f000 80e4 	beq.w	34012620 <RCCEx_GetI3CCLKFreq+0x204>
34012458:	4a7e      	ldr	r2, [pc, #504]	@ (34012654 <RCCEx_GetI3CCLKFreq+0x238>)
3401245a:	4293      	cmp	r3, r2
3401245c:	f200 80e8 	bhi.w	34012630 <RCCEx_GetI3CCLKFreq+0x214>
34012460:	4a7d      	ldr	r2, [pc, #500]	@ (34012658 <RCCEx_GetI3CCLKFreq+0x23c>)
34012462:	4293      	cmp	r3, r2
34012464:	f000 80dc 	beq.w	34012620 <RCCEx_GetI3CCLKFreq+0x204>
34012468:	4a7b      	ldr	r2, [pc, #492]	@ (34012658 <RCCEx_GetI3CCLKFreq+0x23c>)
3401246a:	4293      	cmp	r3, r2
3401246c:	f200 80e0 	bhi.w	34012630 <RCCEx_GetI3CCLKFreq+0x214>
34012470:	4a7a      	ldr	r2, [pc, #488]	@ (3401265c <RCCEx_GetI3CCLKFreq+0x240>)
34012472:	4293      	cmp	r3, r2
34012474:	f000 8083 	beq.w	3401257e <RCCEx_GetI3CCLKFreq+0x162>
34012478:	4a78      	ldr	r2, [pc, #480]	@ (3401265c <RCCEx_GetI3CCLKFreq+0x240>)
3401247a:	4293      	cmp	r3, r2
3401247c:	f200 80d8 	bhi.w	34012630 <RCCEx_GetI3CCLKFreq+0x214>
34012480:	4a77      	ldr	r2, [pc, #476]	@ (34012660 <RCCEx_GetI3CCLKFreq+0x244>)
34012482:	4293      	cmp	r3, r2
34012484:	d07b      	beq.n	3401257e <RCCEx_GetI3CCLKFreq+0x162>
34012486:	4a76      	ldr	r2, [pc, #472]	@ (34012660 <RCCEx_GetI3CCLKFreq+0x244>)
34012488:	4293      	cmp	r3, r2
3401248a:	f200 80d1 	bhi.w	34012630 <RCCEx_GetI3CCLKFreq+0x214>
3401248e:	4a75      	ldr	r2, [pc, #468]	@ (34012664 <RCCEx_GetI3CCLKFreq+0x248>)
34012490:	4293      	cmp	r3, r2
34012492:	d030      	beq.n	340124f6 <RCCEx_GetI3CCLKFreq+0xda>
34012494:	4a73      	ldr	r2, [pc, #460]	@ (34012664 <RCCEx_GetI3CCLKFreq+0x248>)
34012496:	4293      	cmp	r3, r2
34012498:	f200 80ca 	bhi.w	34012630 <RCCEx_GetI3CCLKFreq+0x214>
3401249c:	4a72      	ldr	r2, [pc, #456]	@ (34012668 <RCCEx_GetI3CCLKFreq+0x24c>)
3401249e:	4293      	cmp	r3, r2
340124a0:	d029      	beq.n	340124f6 <RCCEx_GetI3CCLKFreq+0xda>
340124a2:	4a71      	ldr	r2, [pc, #452]	@ (34012668 <RCCEx_GetI3CCLKFreq+0x24c>)
340124a4:	4293      	cmp	r3, r2
340124a6:	f200 80c3 	bhi.w	34012630 <RCCEx_GetI3CCLKFreq+0x214>
340124aa:	4a70      	ldr	r2, [pc, #448]	@ (3401266c <RCCEx_GetI3CCLKFreq+0x250>)
340124ac:	4293      	cmp	r3, r2
340124ae:	d01d      	beq.n	340124ec <RCCEx_GetI3CCLKFreq+0xd0>
340124b0:	4a6e      	ldr	r2, [pc, #440]	@ (3401266c <RCCEx_GetI3CCLKFreq+0x250>)
340124b2:	4293      	cmp	r3, r2
340124b4:	f200 80bc 	bhi.w	34012630 <RCCEx_GetI3CCLKFreq+0x214>
340124b8:	4a6d      	ldr	r2, [pc, #436]	@ (34012670 <RCCEx_GetI3CCLKFreq+0x254>)
340124ba:	4293      	cmp	r3, r2
340124bc:	d016      	beq.n	340124ec <RCCEx_GetI3CCLKFreq+0xd0>
340124be:	4a6c      	ldr	r2, [pc, #432]	@ (34012670 <RCCEx_GetI3CCLKFreq+0x254>)
340124c0:	4293      	cmp	r3, r2
340124c2:	f200 80b5 	bhi.w	34012630 <RCCEx_GetI3CCLKFreq+0x214>
340124c6:	4a6b      	ldr	r2, [pc, #428]	@ (34012674 <RCCEx_GetI3CCLKFreq+0x258>)
340124c8:	4293      	cmp	r3, r2
340124ca:	d003      	beq.n	340124d4 <RCCEx_GetI3CCLKFreq+0xb8>
340124cc:	4a6a      	ldr	r2, [pc, #424]	@ (34012678 <RCCEx_GetI3CCLKFreq+0x25c>)
340124ce:	4293      	cmp	r3, r2
340124d0:	f040 80ae 	bne.w	34012630 <RCCEx_GetI3CCLKFreq+0x214>
  {
    case LL_RCC_I3C1_CLKSOURCE_PCLK1:
    case LL_RCC_I3C2_CLKSOURCE_PCLK1:
      i3c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340124d4:	f7f5 fd4e 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
340124d8:	4603      	mov	r3, r0
340124da:	4618      	mov	r0, r3
340124dc:	f7fe fe42 	bl	34011164 <RCCEx_GetHCLKFreq>
340124e0:	4603      	mov	r3, r0
340124e2:	4618      	mov	r0, r3
340124e4:	f7fe fe4f 	bl	34011186 <RCCEx_GetPCLK1Freq>
340124e8:	60f8      	str	r0, [r7, #12]
      break;
340124ea:	e0aa      	b.n	34012642 <RCCEx_GetI3CCLKFreq+0x226>

    case LL_RCC_I3C1_CLKSOURCE_CLKP:
    case LL_RCC_I3C2_CLKSOURCE_CLKP:
      i3c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340124ec:	2007      	movs	r0, #7
340124ee:	f7ff f925 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
340124f2:	60f8      	str	r0, [r7, #12]
      break;
340124f4:	e0a5      	b.n	34012642 <RCCEx_GetI3CCLKFreq+0x226>

    case LL_RCC_I3C1_CLKSOURCE_IC10:
    case LL_RCC_I3C2_CLKSOURCE_IC10:
      if (LL_RCC_IC10_IsEnabled() != 0U)
340124f6:	f7f7 f99f 	bl	34009838 <LL_RCC_IC10_IsEnabled>
340124fa:	4603      	mov	r3, r0
340124fc:	2b00      	cmp	r3, #0
340124fe:	f000 8099 	beq.w	34012634 <RCCEx_GetI3CCLKFreq+0x218>
      {
        ic_divider = LL_RCC_IC10_GetDivider();
34012502:	f7f7 f9bb 	bl	3400987c <LL_RCC_IC10_GetDivider>
34012506:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC10_GetSource())
34012508:	f7f7 f9aa 	bl	34009860 <LL_RCC_IC10_GetSource>
3401250c:	4603      	mov	r3, r0
3401250e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012512:	d029      	beq.n	34012568 <RCCEx_GetI3CCLKFreq+0x14c>
34012514:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012518:	d82f      	bhi.n	3401257a <RCCEx_GetI3CCLKFreq+0x15e>
3401251a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401251e:	d01a      	beq.n	34012556 <RCCEx_GetI3CCLKFreq+0x13a>
34012520:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012524:	d829      	bhi.n	3401257a <RCCEx_GetI3CCLKFreq+0x15e>
34012526:	2b00      	cmp	r3, #0
34012528:	d003      	beq.n	34012532 <RCCEx_GetI3CCLKFreq+0x116>
3401252a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401252e:	d009      	beq.n	34012544 <RCCEx_GetI3CCLKFreq+0x128>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i3c_frequency = i3c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34012530:	e023      	b.n	3401257a <RCCEx_GetI3CCLKFreq+0x15e>
            i3c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34012532:	f7fe fcff 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34012536:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34012538:	68fa      	ldr	r2, [r7, #12]
3401253a:	68bb      	ldr	r3, [r7, #8]
3401253c:	fbb2 f3f3 	udiv	r3, r2, r3
34012540:	60fb      	str	r3, [r7, #12]
            break;
34012542:	e01b      	b.n	3401257c <RCCEx_GetI3CCLKFreq+0x160>
            i3c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34012544:	f7fe fd3c 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34012548:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
3401254a:	68fa      	ldr	r2, [r7, #12]
3401254c:	68bb      	ldr	r3, [r7, #8]
3401254e:	fbb2 f3f3 	udiv	r3, r2, r3
34012552:	60fb      	str	r3, [r7, #12]
            break;
34012554:	e012      	b.n	3401257c <RCCEx_GetI3CCLKFreq+0x160>
            i3c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34012556:	f7fe fd79 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
3401255a:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
3401255c:	68fa      	ldr	r2, [r7, #12]
3401255e:	68bb      	ldr	r3, [r7, #8]
34012560:	fbb2 f3f3 	udiv	r3, r2, r3
34012564:	60fb      	str	r3, [r7, #12]
            break;
34012566:	e009      	b.n	3401257c <RCCEx_GetI3CCLKFreq+0x160>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34012568:	f7fe fdb6 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
3401256c:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
3401256e:	68fa      	ldr	r2, [r7, #12]
34012570:	68bb      	ldr	r3, [r7, #8]
34012572:	fbb2 f3f3 	udiv	r3, r2, r3
34012576:	60fb      	str	r3, [r7, #12]
            break;
34012578:	e000      	b.n	3401257c <RCCEx_GetI3CCLKFreq+0x160>
            break;
3401257a:	bf00      	nop
        }
      }
      break;
3401257c:	e05a      	b.n	34012634 <RCCEx_GetI3CCLKFreq+0x218>

    case LL_RCC_I3C1_CLKSOURCE_IC15:
    case LL_RCC_I3C2_CLKSOURCE_IC15:
      if (LL_RCC_IC15_IsEnabled() != 0U)
3401257e:	f7f7 fa5b 	bl	34009a38 <LL_RCC_IC15_IsEnabled>
34012582:	4603      	mov	r3, r0
34012584:	2b00      	cmp	r3, #0
34012586:	d057      	beq.n	34012638 <RCCEx_GetI3CCLKFreq+0x21c>
      {
        ic_divider = LL_RCC_IC15_GetDivider();
34012588:	f7f7 fa78 	bl	34009a7c <LL_RCC_IC15_GetDivider>
3401258c:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
3401258e:	f7f7 fa67 	bl	34009a60 <LL_RCC_IC15_GetSource>
34012592:	4603      	mov	r3, r0
34012594:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012598:	d029      	beq.n	340125ee <RCCEx_GetI3CCLKFreq+0x1d2>
3401259a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401259e:	d82f      	bhi.n	34012600 <RCCEx_GetI3CCLKFreq+0x1e4>
340125a0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340125a4:	d01a      	beq.n	340125dc <RCCEx_GetI3CCLKFreq+0x1c0>
340125a6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340125aa:	d829      	bhi.n	34012600 <RCCEx_GetI3CCLKFreq+0x1e4>
340125ac:	2b00      	cmp	r3, #0
340125ae:	d003      	beq.n	340125b8 <RCCEx_GetI3CCLKFreq+0x19c>
340125b0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340125b4:	d009      	beq.n	340125ca <RCCEx_GetI3CCLKFreq+0x1ae>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i3c_frequency = i3c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
340125b6:	e023      	b.n	34012600 <RCCEx_GetI3CCLKFreq+0x1e4>
            i3c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340125b8:	f7fe fcbc 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
340125bc:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
340125be:	68fa      	ldr	r2, [r7, #12]
340125c0:	68bb      	ldr	r3, [r7, #8]
340125c2:	fbb2 f3f3 	udiv	r3, r2, r3
340125c6:	60fb      	str	r3, [r7, #12]
            break;
340125c8:	e01b      	b.n	34012602 <RCCEx_GetI3CCLKFreq+0x1e6>
            i3c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340125ca:	f7fe fcf9 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
340125ce:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
340125d0:	68fa      	ldr	r2, [r7, #12]
340125d2:	68bb      	ldr	r3, [r7, #8]
340125d4:	fbb2 f3f3 	udiv	r3, r2, r3
340125d8:	60fb      	str	r3, [r7, #12]
            break;
340125da:	e012      	b.n	34012602 <RCCEx_GetI3CCLKFreq+0x1e6>
            i3c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340125dc:	f7fe fd36 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
340125e0:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
340125e2:	68fa      	ldr	r2, [r7, #12]
340125e4:	68bb      	ldr	r3, [r7, #8]
340125e6:	fbb2 f3f3 	udiv	r3, r2, r3
340125ea:	60fb      	str	r3, [r7, #12]
            break;
340125ec:	e009      	b.n	34012602 <RCCEx_GetI3CCLKFreq+0x1e6>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340125ee:	f7fe fd73 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
340125f2:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
340125f4:	68fa      	ldr	r2, [r7, #12]
340125f6:	68bb      	ldr	r3, [r7, #8]
340125f8:	fbb2 f3f3 	udiv	r3, r2, r3
340125fc:	60fb      	str	r3, [r7, #12]
            break;
340125fe:	e000      	b.n	34012602 <RCCEx_GetI3CCLKFreq+0x1e6>
            break;
34012600:	bf00      	nop
        }
      }
      break;
34012602:	e019      	b.n	34012638 <RCCEx_GetI3CCLKFreq+0x21c>

    case LL_RCC_I3C1_CLKSOURCE_HSI:
    case LL_RCC_I3C2_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34012604:	f7f6 f8b4 	bl	34008770 <LL_RCC_HSI_IsReady>
34012608:	4603      	mov	r3, r0
3401260a:	2b00      	cmp	r3, #0
3401260c:	d016      	beq.n	3401263c <RCCEx_GetI3CCLKFreq+0x220>
      {
        i3c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3401260e:	f7f6 f8c1 	bl	34008794 <LL_RCC_HSI_GetDivider>
34012612:	4603      	mov	r3, r0
34012614:	09db      	lsrs	r3, r3, #7
34012616:	4a19      	ldr	r2, [pc, #100]	@ (3401267c <RCCEx_GetI3CCLKFreq+0x260>)
34012618:	fa22 f303 	lsr.w	r3, r2, r3
3401261c:	60fb      	str	r3, [r7, #12]
      }
      break;
3401261e:	e00d      	b.n	3401263c <RCCEx_GetI3CCLKFreq+0x220>

    case LL_RCC_I3C1_CLKSOURCE_MSI:
    case LL_RCC_I3C2_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34012620:	f7f6 f8c6 	bl	340087b0 <LL_RCC_MSI_IsReady>
34012624:	4603      	mov	r3, r0
34012626:	2b00      	cmp	r3, #0
34012628:	d00a      	beq.n	34012640 <RCCEx_GetI3CCLKFreq+0x224>
      {
        i3c_frequency = MSI_VALUE;
3401262a:	4b15      	ldr	r3, [pc, #84]	@ (34012680 <RCCEx_GetI3CCLKFreq+0x264>)
3401262c:	60fb      	str	r3, [r7, #12]
      }
      break;
3401262e:	e007      	b.n	34012640 <RCCEx_GetI3CCLKFreq+0x224>

    default:
      /* Unexpected case */
      break;
34012630:	bf00      	nop
34012632:	e006      	b.n	34012642 <RCCEx_GetI3CCLKFreq+0x226>
      break;
34012634:	bf00      	nop
34012636:	e004      	b.n	34012642 <RCCEx_GetI3CCLKFreq+0x226>
      break;
34012638:	bf00      	nop
3401263a:	e002      	b.n	34012642 <RCCEx_GetI3CCLKFreq+0x226>
      break;
3401263c:	bf00      	nop
3401263e:	e000      	b.n	34012642 <RCCEx_GetI3CCLKFreq+0x226>
      break;
34012640:	bf00      	nop
  }

  return i3c_frequency;
34012642:	68fb      	ldr	r3, [r7, #12]
}
34012644:	4618      	mov	r0, r3
34012646:	3710      	adds	r7, #16
34012648:	46bd      	mov	sp, r7
3401264a:	bd80      	pop	{r7, pc}
3401264c:	0705140c 	.word	0x0705140c
34012650:	0705100c 	.word	0x0705100c
34012654:	0704140c 	.word	0x0704140c
34012658:	0704100c 	.word	0x0704100c
3401265c:	0703140c 	.word	0x0703140c
34012660:	0703100c 	.word	0x0703100c
34012664:	0702140c 	.word	0x0702140c
34012668:	0702100c 	.word	0x0702100c
3401266c:	0701140c 	.word	0x0701140c
34012670:	0701100c 	.word	0x0701100c
34012674:	0700100c 	.word	0x0700100c
34012678:	0700140c 	.word	0x0700140c
3401267c:	03d09000 	.word	0x03d09000
34012680:	003d0900 	.word	0x003d0900

34012684 <RCCEx_GetLPTIMCLKFreq>:
  *         @arg @ref RCCEx_LPTIM5_Clock_Source
  * @retval LPTIM clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetLPTIMCLKFreq(uint32_t LPTIMxSource)
{
34012684:	b590      	push	{r4, r7, lr}
34012686:	b085      	sub	sp, #20
34012688:	af00      	add	r7, sp, #0
3401268a:	6078      	str	r0, [r7, #4]
  uint32_t lptim_frequency = RCC_PERIPH_FREQUENCY_NO;
3401268c:	2300      	movs	r3, #0
3401268e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
34012690:	6878      	ldr	r0, [r7, #4]
34012692:	f7f6 fbcb 	bl	34008e2c <LL_RCC_GetLPTIMClockSource>
34012696:	4603      	mov	r3, r0
34012698:	4aa1      	ldr	r2, [pc, #644]	@ (34012920 <RCCEx_GetLPTIMCLKFreq+0x29c>)
3401269a:	4293      	cmp	r3, r2
3401269c:	f000 8185 	beq.w	340129aa <RCCEx_GetLPTIMCLKFreq+0x326>
340126a0:	4a9f      	ldr	r2, [pc, #636]	@ (34012920 <RCCEx_GetLPTIMCLKFreq+0x29c>)
340126a2:	4293      	cmp	r3, r2
340126a4:	f200 818b 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
340126a8:	4a9e      	ldr	r2, [pc, #632]	@ (34012924 <RCCEx_GetLPTIMCLKFreq+0x2a0>)
340126aa:	4293      	cmp	r3, r2
340126ac:	f000 817d 	beq.w	340129aa <RCCEx_GetLPTIMCLKFreq+0x326>
340126b0:	4a9c      	ldr	r2, [pc, #624]	@ (34012924 <RCCEx_GetLPTIMCLKFreq+0x2a0>)
340126b2:	4293      	cmp	r3, r2
340126b4:	f200 8183 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
340126b8:	4a9b      	ldr	r2, [pc, #620]	@ (34012928 <RCCEx_GetLPTIMCLKFreq+0x2a4>)
340126ba:	4293      	cmp	r3, r2
340126bc:	f000 8175 	beq.w	340129aa <RCCEx_GetLPTIMCLKFreq+0x326>
340126c0:	4a99      	ldr	r2, [pc, #612]	@ (34012928 <RCCEx_GetLPTIMCLKFreq+0x2a4>)
340126c2:	4293      	cmp	r3, r2
340126c4:	f200 817b 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
340126c8:	4a98      	ldr	r2, [pc, #608]	@ (3401292c <RCCEx_GetLPTIMCLKFreq+0x2a8>)
340126ca:	4293      	cmp	r3, r2
340126cc:	f000 816d 	beq.w	340129aa <RCCEx_GetLPTIMCLKFreq+0x326>
340126d0:	4a96      	ldr	r2, [pc, #600]	@ (3401292c <RCCEx_GetLPTIMCLKFreq+0x2a8>)
340126d2:	4293      	cmp	r3, r2
340126d4:	f200 8173 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
340126d8:	4a95      	ldr	r2, [pc, #596]	@ (34012930 <RCCEx_GetLPTIMCLKFreq+0x2ac>)
340126da:	4293      	cmp	r3, r2
340126dc:	f000 8165 	beq.w	340129aa <RCCEx_GetLPTIMCLKFreq+0x326>
340126e0:	4a93      	ldr	r2, [pc, #588]	@ (34012930 <RCCEx_GetLPTIMCLKFreq+0x2ac>)
340126e2:	4293      	cmp	r3, r2
340126e4:	f200 816b 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
340126e8:	4a92      	ldr	r2, [pc, #584]	@ (34012934 <RCCEx_GetLPTIMCLKFreq+0x2b0>)
340126ea:	4293      	cmp	r3, r2
340126ec:	f000 8154 	beq.w	34012998 <RCCEx_GetLPTIMCLKFreq+0x314>
340126f0:	4a90      	ldr	r2, [pc, #576]	@ (34012934 <RCCEx_GetLPTIMCLKFreq+0x2b0>)
340126f2:	4293      	cmp	r3, r2
340126f4:	f200 8163 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
340126f8:	4a8f      	ldr	r2, [pc, #572]	@ (34012938 <RCCEx_GetLPTIMCLKFreq+0x2b4>)
340126fa:	4293      	cmp	r3, r2
340126fc:	f000 814c 	beq.w	34012998 <RCCEx_GetLPTIMCLKFreq+0x314>
34012700:	4a8d      	ldr	r2, [pc, #564]	@ (34012938 <RCCEx_GetLPTIMCLKFreq+0x2b4>)
34012702:	4293      	cmp	r3, r2
34012704:	f200 815b 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
34012708:	4a8c      	ldr	r2, [pc, #560]	@ (3401293c <RCCEx_GetLPTIMCLKFreq+0x2b8>)
3401270a:	4293      	cmp	r3, r2
3401270c:	f000 8144 	beq.w	34012998 <RCCEx_GetLPTIMCLKFreq+0x314>
34012710:	4a8a      	ldr	r2, [pc, #552]	@ (3401293c <RCCEx_GetLPTIMCLKFreq+0x2b8>)
34012712:	4293      	cmp	r3, r2
34012714:	f200 8153 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
34012718:	4a89      	ldr	r2, [pc, #548]	@ (34012940 <RCCEx_GetLPTIMCLKFreq+0x2bc>)
3401271a:	4293      	cmp	r3, r2
3401271c:	f000 813c 	beq.w	34012998 <RCCEx_GetLPTIMCLKFreq+0x314>
34012720:	4a87      	ldr	r2, [pc, #540]	@ (34012940 <RCCEx_GetLPTIMCLKFreq+0x2bc>)
34012722:	4293      	cmp	r3, r2
34012724:	f200 814b 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
34012728:	4a86      	ldr	r2, [pc, #536]	@ (34012944 <RCCEx_GetLPTIMCLKFreq+0x2c0>)
3401272a:	4293      	cmp	r3, r2
3401272c:	f000 8134 	beq.w	34012998 <RCCEx_GetLPTIMCLKFreq+0x314>
34012730:	4a84      	ldr	r2, [pc, #528]	@ (34012944 <RCCEx_GetLPTIMCLKFreq+0x2c0>)
34012732:	4293      	cmp	r3, r2
34012734:	f200 8143 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
34012738:	4a83      	ldr	r2, [pc, #524]	@ (34012948 <RCCEx_GetLPTIMCLKFreq+0x2c4>)
3401273a:	4293      	cmp	r3, r2
3401273c:	f000 80e7 	beq.w	3401290e <RCCEx_GetLPTIMCLKFreq+0x28a>
34012740:	4a81      	ldr	r2, [pc, #516]	@ (34012948 <RCCEx_GetLPTIMCLKFreq+0x2c4>)
34012742:	4293      	cmp	r3, r2
34012744:	f200 813b 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
34012748:	4a80      	ldr	r2, [pc, #512]	@ (3401294c <RCCEx_GetLPTIMCLKFreq+0x2c8>)
3401274a:	4293      	cmp	r3, r2
3401274c:	f000 80df 	beq.w	3401290e <RCCEx_GetLPTIMCLKFreq+0x28a>
34012750:	4a7e      	ldr	r2, [pc, #504]	@ (3401294c <RCCEx_GetLPTIMCLKFreq+0x2c8>)
34012752:	4293      	cmp	r3, r2
34012754:	f200 8133 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
34012758:	4a7d      	ldr	r2, [pc, #500]	@ (34012950 <RCCEx_GetLPTIMCLKFreq+0x2cc>)
3401275a:	4293      	cmp	r3, r2
3401275c:	f000 80d7 	beq.w	3401290e <RCCEx_GetLPTIMCLKFreq+0x28a>
34012760:	4a7b      	ldr	r2, [pc, #492]	@ (34012950 <RCCEx_GetLPTIMCLKFreq+0x2cc>)
34012762:	4293      	cmp	r3, r2
34012764:	f200 812b 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
34012768:	4a7a      	ldr	r2, [pc, #488]	@ (34012954 <RCCEx_GetLPTIMCLKFreq+0x2d0>)
3401276a:	4293      	cmp	r3, r2
3401276c:	f000 80cf 	beq.w	3401290e <RCCEx_GetLPTIMCLKFreq+0x28a>
34012770:	4a78      	ldr	r2, [pc, #480]	@ (34012954 <RCCEx_GetLPTIMCLKFreq+0x2d0>)
34012772:	4293      	cmp	r3, r2
34012774:	f200 8123 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
34012778:	4a77      	ldr	r2, [pc, #476]	@ (34012958 <RCCEx_GetLPTIMCLKFreq+0x2d4>)
3401277a:	4293      	cmp	r3, r2
3401277c:	f000 80c7 	beq.w	3401290e <RCCEx_GetLPTIMCLKFreq+0x28a>
34012780:	4a75      	ldr	r2, [pc, #468]	@ (34012958 <RCCEx_GetLPTIMCLKFreq+0x2d4>)
34012782:	4293      	cmp	r3, r2
34012784:	f200 811b 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
34012788:	4a74      	ldr	r2, [pc, #464]	@ (3401295c <RCCEx_GetLPTIMCLKFreq+0x2d8>)
3401278a:	4293      	cmp	r3, r2
3401278c:	d07b      	beq.n	34012886 <RCCEx_GetLPTIMCLKFreq+0x202>
3401278e:	4a73      	ldr	r2, [pc, #460]	@ (3401295c <RCCEx_GetLPTIMCLKFreq+0x2d8>)
34012790:	4293      	cmp	r3, r2
34012792:	f200 8114 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
34012796:	4a72      	ldr	r2, [pc, #456]	@ (34012960 <RCCEx_GetLPTIMCLKFreq+0x2dc>)
34012798:	4293      	cmp	r3, r2
3401279a:	d074      	beq.n	34012886 <RCCEx_GetLPTIMCLKFreq+0x202>
3401279c:	4a70      	ldr	r2, [pc, #448]	@ (34012960 <RCCEx_GetLPTIMCLKFreq+0x2dc>)
3401279e:	4293      	cmp	r3, r2
340127a0:	f200 810d 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
340127a4:	4a6f      	ldr	r2, [pc, #444]	@ (34012964 <RCCEx_GetLPTIMCLKFreq+0x2e0>)
340127a6:	4293      	cmp	r3, r2
340127a8:	d06d      	beq.n	34012886 <RCCEx_GetLPTIMCLKFreq+0x202>
340127aa:	4a6e      	ldr	r2, [pc, #440]	@ (34012964 <RCCEx_GetLPTIMCLKFreq+0x2e0>)
340127ac:	4293      	cmp	r3, r2
340127ae:	f200 8106 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
340127b2:	4a6d      	ldr	r2, [pc, #436]	@ (34012968 <RCCEx_GetLPTIMCLKFreq+0x2e4>)
340127b4:	4293      	cmp	r3, r2
340127b6:	d066      	beq.n	34012886 <RCCEx_GetLPTIMCLKFreq+0x202>
340127b8:	4a6b      	ldr	r2, [pc, #428]	@ (34012968 <RCCEx_GetLPTIMCLKFreq+0x2e4>)
340127ba:	4293      	cmp	r3, r2
340127bc:	f200 80ff 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
340127c0:	4a6a      	ldr	r2, [pc, #424]	@ (3401296c <RCCEx_GetLPTIMCLKFreq+0x2e8>)
340127c2:	4293      	cmp	r3, r2
340127c4:	d05f      	beq.n	34012886 <RCCEx_GetLPTIMCLKFreq+0x202>
340127c6:	4a69      	ldr	r2, [pc, #420]	@ (3401296c <RCCEx_GetLPTIMCLKFreq+0x2e8>)
340127c8:	4293      	cmp	r3, r2
340127ca:	f200 80f8 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
340127ce:	4a68      	ldr	r2, [pc, #416]	@ (34012970 <RCCEx_GetLPTIMCLKFreq+0x2ec>)
340127d0:	4293      	cmp	r3, r2
340127d2:	d053      	beq.n	3401287c <RCCEx_GetLPTIMCLKFreq+0x1f8>
340127d4:	4a66      	ldr	r2, [pc, #408]	@ (34012970 <RCCEx_GetLPTIMCLKFreq+0x2ec>)
340127d6:	4293      	cmp	r3, r2
340127d8:	f200 80f1 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
340127dc:	4a65      	ldr	r2, [pc, #404]	@ (34012974 <RCCEx_GetLPTIMCLKFreq+0x2f0>)
340127de:	4293      	cmp	r3, r2
340127e0:	d04c      	beq.n	3401287c <RCCEx_GetLPTIMCLKFreq+0x1f8>
340127e2:	4a64      	ldr	r2, [pc, #400]	@ (34012974 <RCCEx_GetLPTIMCLKFreq+0x2f0>)
340127e4:	4293      	cmp	r3, r2
340127e6:	f200 80ea 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
340127ea:	4a63      	ldr	r2, [pc, #396]	@ (34012978 <RCCEx_GetLPTIMCLKFreq+0x2f4>)
340127ec:	4293      	cmp	r3, r2
340127ee:	d045      	beq.n	3401287c <RCCEx_GetLPTIMCLKFreq+0x1f8>
340127f0:	4a61      	ldr	r2, [pc, #388]	@ (34012978 <RCCEx_GetLPTIMCLKFreq+0x2f4>)
340127f2:	4293      	cmp	r3, r2
340127f4:	f200 80e3 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
340127f8:	4a60      	ldr	r2, [pc, #384]	@ (3401297c <RCCEx_GetLPTIMCLKFreq+0x2f8>)
340127fa:	4293      	cmp	r3, r2
340127fc:	d03e      	beq.n	3401287c <RCCEx_GetLPTIMCLKFreq+0x1f8>
340127fe:	4a5f      	ldr	r2, [pc, #380]	@ (3401297c <RCCEx_GetLPTIMCLKFreq+0x2f8>)
34012800:	4293      	cmp	r3, r2
34012802:	f200 80dc 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
34012806:	4a5e      	ldr	r2, [pc, #376]	@ (34012980 <RCCEx_GetLPTIMCLKFreq+0x2fc>)
34012808:	4293      	cmp	r3, r2
3401280a:	d037      	beq.n	3401287c <RCCEx_GetLPTIMCLKFreq+0x1f8>
3401280c:	4a5c      	ldr	r2, [pc, #368]	@ (34012980 <RCCEx_GetLPTIMCLKFreq+0x2fc>)
3401280e:	4293      	cmp	r3, r2
34012810:	f200 80d5 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
34012814:	4a5b      	ldr	r2, [pc, #364]	@ (34012984 <RCCEx_GetLPTIMCLKFreq+0x300>)
34012816:	4293      	cmp	r3, r2
34012818:	d024      	beq.n	34012864 <RCCEx_GetLPTIMCLKFreq+0x1e0>
3401281a:	4a5a      	ldr	r2, [pc, #360]	@ (34012984 <RCCEx_GetLPTIMCLKFreq+0x300>)
3401281c:	4293      	cmp	r3, r2
3401281e:	f200 80ce 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
34012822:	4a59      	ldr	r2, [pc, #356]	@ (34012988 <RCCEx_GetLPTIMCLKFreq+0x304>)
34012824:	4293      	cmp	r3, r2
34012826:	d01d      	beq.n	34012864 <RCCEx_GetLPTIMCLKFreq+0x1e0>
34012828:	4a57      	ldr	r2, [pc, #348]	@ (34012988 <RCCEx_GetLPTIMCLKFreq+0x304>)
3401282a:	4293      	cmp	r3, r2
3401282c:	f200 80c7 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
34012830:	4a56      	ldr	r2, [pc, #344]	@ (3401298c <RCCEx_GetLPTIMCLKFreq+0x308>)
34012832:	4293      	cmp	r3, r2
34012834:	d016      	beq.n	34012864 <RCCEx_GetLPTIMCLKFreq+0x1e0>
34012836:	4a55      	ldr	r2, [pc, #340]	@ (3401298c <RCCEx_GetLPTIMCLKFreq+0x308>)
34012838:	4293      	cmp	r3, r2
3401283a:	f200 80c0 	bhi.w	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
3401283e:	4a54      	ldr	r2, [pc, #336]	@ (34012990 <RCCEx_GetLPTIMCLKFreq+0x30c>)
34012840:	4293      	cmp	r3, r2
34012842:	d003      	beq.n	3401284c <RCCEx_GetLPTIMCLKFreq+0x1c8>
34012844:	4a53      	ldr	r2, [pc, #332]	@ (34012994 <RCCEx_GetLPTIMCLKFreq+0x310>)
34012846:	4293      	cmp	r3, r2
34012848:	d00c      	beq.n	34012864 <RCCEx_GetLPTIMCLKFreq+0x1e0>
      lptim_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
      break;

    default:
      /* Unexpected case */
      break;
3401284a:	e0b8      	b.n	340129be <RCCEx_GetLPTIMCLKFreq+0x33a>
      lptim_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3401284c:	f7f5 fb92 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34012850:	4603      	mov	r3, r0
34012852:	4618      	mov	r0, r3
34012854:	f7fe fc86 	bl	34011164 <RCCEx_GetHCLKFreq>
34012858:	4603      	mov	r3, r0
3401285a:	4618      	mov	r0, r3
3401285c:	f7fe fc93 	bl	34011186 <RCCEx_GetPCLK1Freq>
34012860:	60f8      	str	r0, [r7, #12]
      break;
34012862:	e0b3      	b.n	340129cc <RCCEx_GetLPTIMCLKFreq+0x348>
      lptim_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34012864:	f7f5 fb86 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34012868:	4603      	mov	r3, r0
3401286a:	4618      	mov	r0, r3
3401286c:	f7fe fc7a 	bl	34011164 <RCCEx_GetHCLKFreq>
34012870:	4603      	mov	r3, r0
34012872:	4618      	mov	r0, r3
34012874:	f7fe fca8 	bl	340111c8 <RCCEx_GetPCLK4Freq>
34012878:	60f8      	str	r0, [r7, #12]
      break;
3401287a:	e0a7      	b.n	340129cc <RCCEx_GetLPTIMCLKFreq+0x348>
      lptim_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3401287c:	2007      	movs	r0, #7
3401287e:	f7fe ff5d 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
34012882:	60f8      	str	r0, [r7, #12]
      break;
34012884:	e0a2      	b.n	340129cc <RCCEx_GetLPTIMCLKFreq+0x348>
      if (LL_RCC_IC15_IsEnabled() != 0U)
34012886:	f7f7 f8d7 	bl	34009a38 <LL_RCC_IC15_IsEnabled>
3401288a:	4603      	mov	r3, r0
3401288c:	2b00      	cmp	r3, #0
3401288e:	f000 8098 	beq.w	340129c2 <RCCEx_GetLPTIMCLKFreq+0x33e>
        ic_divider = LL_RCC_IC15_GetDivider();
34012892:	f7f7 f8f3 	bl	34009a7c <LL_RCC_IC15_GetDivider>
34012896:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
34012898:	f7f7 f8e2 	bl	34009a60 <LL_RCC_IC15_GetSource>
3401289c:	4603      	mov	r3, r0
3401289e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340128a2:	d029      	beq.n	340128f8 <RCCEx_GetLPTIMCLKFreq+0x274>
340128a4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340128a8:	d82f      	bhi.n	3401290a <RCCEx_GetLPTIMCLKFreq+0x286>
340128aa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340128ae:	d01a      	beq.n	340128e6 <RCCEx_GetLPTIMCLKFreq+0x262>
340128b0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340128b4:	d829      	bhi.n	3401290a <RCCEx_GetLPTIMCLKFreq+0x286>
340128b6:	2b00      	cmp	r3, #0
340128b8:	d003      	beq.n	340128c2 <RCCEx_GetLPTIMCLKFreq+0x23e>
340128ba:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340128be:	d009      	beq.n	340128d4 <RCCEx_GetLPTIMCLKFreq+0x250>
            break;
340128c0:	e023      	b.n	3401290a <RCCEx_GetLPTIMCLKFreq+0x286>
            lptim_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340128c2:	f7fe fb37 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
340128c6:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
340128c8:	68fa      	ldr	r2, [r7, #12]
340128ca:	68bb      	ldr	r3, [r7, #8]
340128cc:	fbb2 f3f3 	udiv	r3, r2, r3
340128d0:	60fb      	str	r3, [r7, #12]
            break;
340128d2:	e01b      	b.n	3401290c <RCCEx_GetLPTIMCLKFreq+0x288>
            lptim_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340128d4:	f7fe fb74 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
340128d8:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
340128da:	68fa      	ldr	r2, [r7, #12]
340128dc:	68bb      	ldr	r3, [r7, #8]
340128de:	fbb2 f3f3 	udiv	r3, r2, r3
340128e2:	60fb      	str	r3, [r7, #12]
            break;
340128e4:	e012      	b.n	3401290c <RCCEx_GetLPTIMCLKFreq+0x288>
            lptim_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340128e6:	f7fe fbb1 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
340128ea:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
340128ec:	68fa      	ldr	r2, [r7, #12]
340128ee:	68bb      	ldr	r3, [r7, #8]
340128f0:	fbb2 f3f3 	udiv	r3, r2, r3
340128f4:	60fb      	str	r3, [r7, #12]
            break;
340128f6:	e009      	b.n	3401290c <RCCEx_GetLPTIMCLKFreq+0x288>
            lptim_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340128f8:	f7fe fbee 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
340128fc:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
340128fe:	68fa      	ldr	r2, [r7, #12]
34012900:	68bb      	ldr	r3, [r7, #8]
34012902:	fbb2 f3f3 	udiv	r3, r2, r3
34012906:	60fb      	str	r3, [r7, #12]
            break;
34012908:	e000      	b.n	3401290c <RCCEx_GetLPTIMCLKFreq+0x288>
            break;
3401290a:	bf00      	nop
      break;
3401290c:	e059      	b.n	340129c2 <RCCEx_GetLPTIMCLKFreq+0x33e>
      if (LL_RCC_LSE_IsReady() != 0U)
3401290e:	f7f5 ff6f 	bl	340087f0 <LL_RCC_LSE_IsReady>
34012912:	4603      	mov	r3, r0
34012914:	2b00      	cmp	r3, #0
34012916:	d056      	beq.n	340129c6 <RCCEx_GetLPTIMCLKFreq+0x342>
        lptim_frequency = LSE_VALUE;
34012918:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
3401291c:	60fb      	str	r3, [r7, #12]
      break;
3401291e:	e052      	b.n	340129c6 <RCCEx_GetLPTIMCLKFreq+0x342>
34012920:	0705182c 	.word	0x0705182c
34012924:	0705142c 	.word	0x0705142c
34012928:	0705102c 	.word	0x0705102c
3401292c:	07050c2c 	.word	0x07050c2c
34012930:	0705082c 	.word	0x0705082c
34012934:	0704182c 	.word	0x0704182c
34012938:	0704142c 	.word	0x0704142c
3401293c:	0704102c 	.word	0x0704102c
34012940:	07040c2c 	.word	0x07040c2c
34012944:	0704082c 	.word	0x0704082c
34012948:	0703182c 	.word	0x0703182c
3401294c:	0703142c 	.word	0x0703142c
34012950:	0703102c 	.word	0x0703102c
34012954:	07030c2c 	.word	0x07030c2c
34012958:	0703082c 	.word	0x0703082c
3401295c:	0702182c 	.word	0x0702182c
34012960:	0702142c 	.word	0x0702142c
34012964:	0702102c 	.word	0x0702102c
34012968:	07020c2c 	.word	0x07020c2c
3401296c:	0702082c 	.word	0x0702082c
34012970:	0701182c 	.word	0x0701182c
34012974:	0701142c 	.word	0x0701142c
34012978:	0701102c 	.word	0x0701102c
3401297c:	07010c2c 	.word	0x07010c2c
34012980:	0701082c 	.word	0x0701082c
34012984:	0700182c 	.word	0x0700182c
34012988:	0700142c 	.word	0x0700142c
3401298c:	0700102c 	.word	0x0700102c
34012990:	0700082c 	.word	0x0700082c
34012994:	07000c2c 	.word	0x07000c2c
      if (LL_RCC_LSI_IsReady() != 0U)
34012998:	f7f5 ff3c 	bl	34008814 <LL_RCC_LSI_IsReady>
3401299c:	4603      	mov	r3, r0
3401299e:	2b00      	cmp	r3, #0
340129a0:	d013      	beq.n	340129ca <RCCEx_GetLPTIMCLKFreq+0x346>
        lptim_frequency = LSI_VALUE;
340129a2:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
340129a6:	60fb      	str	r3, [r7, #12]
      break;
340129a8:	e00f      	b.n	340129ca <RCCEx_GetLPTIMCLKFreq+0x346>
      lptim_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
340129aa:	f7f5 fae3 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
340129ae:	4604      	mov	r4, r0
340129b0:	f7f6 fb46 	bl	34009040 <LL_RCC_GetTIMPrescaler>
340129b4:	4603      	mov	r3, r0
340129b6:	fa24 f303 	lsr.w	r3, r4, r3
340129ba:	60fb      	str	r3, [r7, #12]
      break;
340129bc:	e006      	b.n	340129cc <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
340129be:	bf00      	nop
340129c0:	e004      	b.n	340129cc <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
340129c2:	bf00      	nop
340129c4:	e002      	b.n	340129cc <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
340129c6:	bf00      	nop
340129c8:	e000      	b.n	340129cc <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
340129ca:	bf00      	nop
  }

  return lptim_frequency;
340129cc:	68fb      	ldr	r3, [r7, #12]
}
340129ce:	4618      	mov	r0, r3
340129d0:	3714      	adds	r7, #20
340129d2:	46bd      	mov	sp, r7
340129d4:	bd90      	pop	{r4, r7, pc}
340129d6:	bf00      	nop

340129d8 <RCCEx_GetLPUARTCLKFreq>:
  *         @arg @ref RCCEx_LPUART1_Clock_Source
  * @retval LPUART clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetLPUARTCLKFreq(uint32_t LPUARTxSource)
{
340129d8:	b580      	push	{r7, lr}
340129da:	b084      	sub	sp, #16
340129dc:	af00      	add	r7, sp, #0
340129de:	6078      	str	r0, [r7, #4]
  uint32_t lpuart_frequency = RCC_PERIPH_FREQUENCY_NO;
340129e0:	2300      	movs	r3, #0
340129e2:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetLPUARTClockSource(LPUARTxSource))
340129e4:	6878      	ldr	r0, [r7, #4]
340129e6:	f7f6 fa2d 	bl	34008e44 <LL_RCC_GetLPUARTClockSource>
340129ea:	4603      	mov	r3, r0
340129ec:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
340129f0:	f000 80c0 	beq.w	34012b74 <RCCEx_GetLPUARTCLKFreq+0x19c>
340129f4:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
340129f8:	f200 80db 	bhi.w	34012bb2 <RCCEx_GetLPUARTCLKFreq+0x1da>
340129fc:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
34012a00:	f000 80c6 	beq.w	34012b90 <RCCEx_GetLPUARTCLKFreq+0x1b8>
34012a04:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
34012a08:	f200 80d3 	bhi.w	34012bb2 <RCCEx_GetLPUARTCLKFreq+0x1da>
34012a0c:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
34012a10:	f000 80c6 	beq.w	34012ba0 <RCCEx_GetLPUARTCLKFreq+0x1c8>
34012a14:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
34012a18:	f200 80cb 	bhi.w	34012bb2 <RCCEx_GetLPUARTCLKFreq+0x1da>
34012a1c:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34012a20:	d065      	beq.n	34012aee <RCCEx_GetLPUARTCLKFreq+0x116>
34012a22:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34012a26:	f200 80c4 	bhi.w	34012bb2 <RCCEx_GetLPUARTCLKFreq+0x1da>
34012a2a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34012a2e:	d01a      	beq.n	34012a66 <RCCEx_GetLPUARTCLKFreq+0x8e>
34012a30:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34012a34:	f200 80bd 	bhi.w	34012bb2 <RCCEx_GetLPUARTCLKFreq+0x1da>
34012a38:	2b00      	cmp	r3, #0
34012a3a:	d003      	beq.n	34012a44 <RCCEx_GetLPUARTCLKFreq+0x6c>
34012a3c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34012a40:	d00c      	beq.n	34012a5c <RCCEx_GetLPUARTCLKFreq+0x84>
      }
      break;

    default:
      /* Unexpected case */
      break;
34012a42:	e0b6      	b.n	34012bb2 <RCCEx_GetLPUARTCLKFreq+0x1da>
      lpuart_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34012a44:	f7f5 fa96 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34012a48:	4603      	mov	r3, r0
34012a4a:	4618      	mov	r0, r3
34012a4c:	f7fe fb8a 	bl	34011164 <RCCEx_GetHCLKFreq>
34012a50:	4603      	mov	r3, r0
34012a52:	4618      	mov	r0, r3
34012a54:	f7fe fbb8 	bl	340111c8 <RCCEx_GetPCLK4Freq>
34012a58:	60f8      	str	r0, [r7, #12]
      break;
34012a5a:	e0b5      	b.n	34012bc8 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      lpuart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34012a5c:	2007      	movs	r0, #7
34012a5e:	f7fe fe6d 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
34012a62:	60f8      	str	r0, [r7, #12]
      break;
34012a64:	e0b0      	b.n	34012bc8 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      if (LL_RCC_IC9_IsEnabled() != 0U)
34012a66:	f7f6 fea7 	bl	340097b8 <LL_RCC_IC9_IsEnabled>
34012a6a:	4603      	mov	r3, r0
34012a6c:	2b00      	cmp	r3, #0
34012a6e:	f000 80a2 	beq.w	34012bb6 <RCCEx_GetLPUARTCLKFreq+0x1de>
        ic_divider = LL_RCC_IC9_GetDivider();
34012a72:	f7f6 fec3 	bl	340097fc <LL_RCC_IC9_GetDivider>
34012a76:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
34012a78:	f7f6 feb2 	bl	340097e0 <LL_RCC_IC9_GetSource>
34012a7c:	4603      	mov	r3, r0
34012a7e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012a82:	d029      	beq.n	34012ad8 <RCCEx_GetLPUARTCLKFreq+0x100>
34012a84:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012a88:	d82f      	bhi.n	34012aea <RCCEx_GetLPUARTCLKFreq+0x112>
34012a8a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012a8e:	d01a      	beq.n	34012ac6 <RCCEx_GetLPUARTCLKFreq+0xee>
34012a90:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012a94:	d829      	bhi.n	34012aea <RCCEx_GetLPUARTCLKFreq+0x112>
34012a96:	2b00      	cmp	r3, #0
34012a98:	d003      	beq.n	34012aa2 <RCCEx_GetLPUARTCLKFreq+0xca>
34012a9a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34012a9e:	d009      	beq.n	34012ab4 <RCCEx_GetLPUARTCLKFreq+0xdc>
            break;
34012aa0:	e023      	b.n	34012aea <RCCEx_GetLPUARTCLKFreq+0x112>
            lpuart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34012aa2:	f7fe fa47 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34012aa6:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34012aa8:	68fa      	ldr	r2, [r7, #12]
34012aaa:	68bb      	ldr	r3, [r7, #8]
34012aac:	fbb2 f3f3 	udiv	r3, r2, r3
34012ab0:	60fb      	str	r3, [r7, #12]
            break;
34012ab2:	e01b      	b.n	34012aec <RCCEx_GetLPUARTCLKFreq+0x114>
            lpuart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34012ab4:	f7fe fa84 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34012ab8:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34012aba:	68fa      	ldr	r2, [r7, #12]
34012abc:	68bb      	ldr	r3, [r7, #8]
34012abe:	fbb2 f3f3 	udiv	r3, r2, r3
34012ac2:	60fb      	str	r3, [r7, #12]
            break;
34012ac4:	e012      	b.n	34012aec <RCCEx_GetLPUARTCLKFreq+0x114>
            lpuart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34012ac6:	f7fe fac1 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34012aca:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34012acc:	68fa      	ldr	r2, [r7, #12]
34012ace:	68bb      	ldr	r3, [r7, #8]
34012ad0:	fbb2 f3f3 	udiv	r3, r2, r3
34012ad4:	60fb      	str	r3, [r7, #12]
            break;
34012ad6:	e009      	b.n	34012aec <RCCEx_GetLPUARTCLKFreq+0x114>
            lpuart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34012ad8:	f7fe fafe 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34012adc:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34012ade:	68fa      	ldr	r2, [r7, #12]
34012ae0:	68bb      	ldr	r3, [r7, #8]
34012ae2:	fbb2 f3f3 	udiv	r3, r2, r3
34012ae6:	60fb      	str	r3, [r7, #12]
            break;
34012ae8:	e000      	b.n	34012aec <RCCEx_GetLPUARTCLKFreq+0x114>
            break;
34012aea:	bf00      	nop
      break;
34012aec:	e063      	b.n	34012bb6 <RCCEx_GetLPUARTCLKFreq+0x1de>
      if (LL_RCC_IC14_IsEnabled() != 0U)
34012aee:	f7f6 ff63 	bl	340099b8 <LL_RCC_IC14_IsEnabled>
34012af2:	4603      	mov	r3, r0
34012af4:	2b00      	cmp	r3, #0
34012af6:	d060      	beq.n	34012bba <RCCEx_GetLPUARTCLKFreq+0x1e2>
        ic_divider = LL_RCC_IC14_GetDivider();
34012af8:	f7f6 ff80 	bl	340099fc <LL_RCC_IC14_GetDivider>
34012afc:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
34012afe:	f7f6 ff6f 	bl	340099e0 <LL_RCC_IC14_GetSource>
34012b02:	4603      	mov	r3, r0
34012b04:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012b08:	d029      	beq.n	34012b5e <RCCEx_GetLPUARTCLKFreq+0x186>
34012b0a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012b0e:	d82f      	bhi.n	34012b70 <RCCEx_GetLPUARTCLKFreq+0x198>
34012b10:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012b14:	d01a      	beq.n	34012b4c <RCCEx_GetLPUARTCLKFreq+0x174>
34012b16:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012b1a:	d829      	bhi.n	34012b70 <RCCEx_GetLPUARTCLKFreq+0x198>
34012b1c:	2b00      	cmp	r3, #0
34012b1e:	d003      	beq.n	34012b28 <RCCEx_GetLPUARTCLKFreq+0x150>
34012b20:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34012b24:	d009      	beq.n	34012b3a <RCCEx_GetLPUARTCLKFreq+0x162>
            break;
34012b26:	e023      	b.n	34012b70 <RCCEx_GetLPUARTCLKFreq+0x198>
            lpuart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34012b28:	f7fe fa04 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34012b2c:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34012b2e:	68fa      	ldr	r2, [r7, #12]
34012b30:	68bb      	ldr	r3, [r7, #8]
34012b32:	fbb2 f3f3 	udiv	r3, r2, r3
34012b36:	60fb      	str	r3, [r7, #12]
            break;
34012b38:	e01b      	b.n	34012b72 <RCCEx_GetLPUARTCLKFreq+0x19a>
            lpuart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34012b3a:	f7fe fa41 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34012b3e:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34012b40:	68fa      	ldr	r2, [r7, #12]
34012b42:	68bb      	ldr	r3, [r7, #8]
34012b44:	fbb2 f3f3 	udiv	r3, r2, r3
34012b48:	60fb      	str	r3, [r7, #12]
            break;
34012b4a:	e012      	b.n	34012b72 <RCCEx_GetLPUARTCLKFreq+0x19a>
            lpuart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34012b4c:	f7fe fa7e 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34012b50:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34012b52:	68fa      	ldr	r2, [r7, #12]
34012b54:	68bb      	ldr	r3, [r7, #8]
34012b56:	fbb2 f3f3 	udiv	r3, r2, r3
34012b5a:	60fb      	str	r3, [r7, #12]
            break;
34012b5c:	e009      	b.n	34012b72 <RCCEx_GetLPUARTCLKFreq+0x19a>
            lpuart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34012b5e:	f7fe fabb 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34012b62:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34012b64:	68fa      	ldr	r2, [r7, #12]
34012b66:	68bb      	ldr	r3, [r7, #8]
34012b68:	fbb2 f3f3 	udiv	r3, r2, r3
34012b6c:	60fb      	str	r3, [r7, #12]
            break;
34012b6e:	e000      	b.n	34012b72 <RCCEx_GetLPUARTCLKFreq+0x19a>
            break;
34012b70:	bf00      	nop
      break;
34012b72:	e022      	b.n	34012bba <RCCEx_GetLPUARTCLKFreq+0x1e2>
      if (LL_RCC_HSI_IsReady() != 0U)
34012b74:	f7f5 fdfc 	bl	34008770 <LL_RCC_HSI_IsReady>
34012b78:	4603      	mov	r3, r0
34012b7a:	2b00      	cmp	r3, #0
34012b7c:	d01f      	beq.n	34012bbe <RCCEx_GetLPUARTCLKFreq+0x1e6>
        lpuart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34012b7e:	f7f5 fe09 	bl	34008794 <LL_RCC_HSI_GetDivider>
34012b82:	4603      	mov	r3, r0
34012b84:	09db      	lsrs	r3, r3, #7
34012b86:	4a13      	ldr	r2, [pc, #76]	@ (34012bd4 <RCCEx_GetLPUARTCLKFreq+0x1fc>)
34012b88:	fa22 f303 	lsr.w	r3, r2, r3
34012b8c:	60fb      	str	r3, [r7, #12]
      break;
34012b8e:	e016      	b.n	34012bbe <RCCEx_GetLPUARTCLKFreq+0x1e6>
      if (LL_RCC_MSI_IsReady() != 0U)
34012b90:	f7f5 fe0e 	bl	340087b0 <LL_RCC_MSI_IsReady>
34012b94:	4603      	mov	r3, r0
34012b96:	2b00      	cmp	r3, #0
34012b98:	d013      	beq.n	34012bc2 <RCCEx_GetLPUARTCLKFreq+0x1ea>
        lpuart_frequency = MSI_VALUE;
34012b9a:	4b0f      	ldr	r3, [pc, #60]	@ (34012bd8 <RCCEx_GetLPUARTCLKFreq+0x200>)
34012b9c:	60fb      	str	r3, [r7, #12]
      break;
34012b9e:	e010      	b.n	34012bc2 <RCCEx_GetLPUARTCLKFreq+0x1ea>
      if (LL_RCC_LSE_IsReady() != 0U)
34012ba0:	f7f5 fe26 	bl	340087f0 <LL_RCC_LSE_IsReady>
34012ba4:	4603      	mov	r3, r0
34012ba6:	2b00      	cmp	r3, #0
34012ba8:	d00d      	beq.n	34012bc6 <RCCEx_GetLPUARTCLKFreq+0x1ee>
        lpuart_frequency = LSE_VALUE;
34012baa:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34012bae:	60fb      	str	r3, [r7, #12]
      break;
34012bb0:	e009      	b.n	34012bc6 <RCCEx_GetLPUARTCLKFreq+0x1ee>
      break;
34012bb2:	bf00      	nop
34012bb4:	e008      	b.n	34012bc8 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
34012bb6:	bf00      	nop
34012bb8:	e006      	b.n	34012bc8 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
34012bba:	bf00      	nop
34012bbc:	e004      	b.n	34012bc8 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
34012bbe:	bf00      	nop
34012bc0:	e002      	b.n	34012bc8 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
34012bc2:	bf00      	nop
34012bc4:	e000      	b.n	34012bc8 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
34012bc6:	bf00      	nop
  }

  return lpuart_frequency;
34012bc8:	68fb      	ldr	r3, [r7, #12]
}
34012bca:	4618      	mov	r0, r3
34012bcc:	3710      	adds	r7, #16
34012bce:	46bd      	mov	sp, r7
34012bd0:	bd80      	pop	{r7, pc}
34012bd2:	bf00      	nop
34012bd4:	03d09000 	.word	0x03d09000
34012bd8:	003d0900 	.word	0x003d0900

34012bdc <RCCEx_GetLTDCCLKFreq>:
  *         @arg @ref RCCEx_LTDC_Clock_Source
  * @retval LTDC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetLTDCCLKFreq(uint32_t LTDCxSource)
{
34012bdc:	b580      	push	{r7, lr}
34012bde:	b084      	sub	sp, #16
34012be0:	af00      	add	r7, sp, #0
34012be2:	6078      	str	r0, [r7, #4]
  uint32_t ltdc_frequency = RCC_PERIPH_FREQUENCY_NO;
34012be4:	2300      	movs	r3, #0
34012be6:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetLTDCClockSource(LTDCxSource))
34012be8:	6878      	ldr	r0, [r7, #4]
34012bea:	f7f6 f93d 	bl	34008e68 <LL_RCC_GetLTDCClockSource>
34012bee:	4603      	mov	r3, r0
34012bf0:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
34012bf4:	d062      	beq.n	34012cbc <RCCEx_GetLTDCCLKFreq+0xe0>
34012bf6:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
34012bfa:	d86d      	bhi.n	34012cd8 <RCCEx_GetLTDCCLKFreq+0xfc>
34012bfc:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34012c00:	d019      	beq.n	34012c36 <RCCEx_GetLTDCCLKFreq+0x5a>
34012c02:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34012c06:	d867      	bhi.n	34012cd8 <RCCEx_GetLTDCCLKFreq+0xfc>
34012c08:	2b00      	cmp	r3, #0
34012c0a:	d003      	beq.n	34012c14 <RCCEx_GetLTDCCLKFreq+0x38>
34012c0c:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34012c10:	d00c      	beq.n	34012c2c <RCCEx_GetLTDCCLKFreq+0x50>
      }
      break;

    default:
      /* Unexpected case */
      break;
34012c12:	e061      	b.n	34012cd8 <RCCEx_GetLTDCCLKFreq+0xfc>
      ltdc_frequency = RCCEx_GetPCLK5Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34012c14:	f7f5 f9ae 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34012c18:	4603      	mov	r3, r0
34012c1a:	4618      	mov	r0, r3
34012c1c:	f7fe faa2 	bl	34011164 <RCCEx_GetHCLKFreq>
34012c20:	4603      	mov	r3, r0
34012c22:	4618      	mov	r0, r3
34012c24:	f7fe fae1 	bl	340111ea <RCCEx_GetPCLK5Freq>
34012c28:	60f8      	str	r0, [r7, #12]
      break;
34012c2a:	e05a      	b.n	34012ce2 <RCCEx_GetLTDCCLKFreq+0x106>
      ltdc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34012c2c:	2007      	movs	r0, #7
34012c2e:	f7fe fd85 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
34012c32:	60f8      	str	r0, [r7, #12]
      break;
34012c34:	e055      	b.n	34012ce2 <RCCEx_GetLTDCCLKFreq+0x106>
      if (LL_RCC_IC16_IsEnabled() != 0U)
34012c36:	f7f6 ff3f 	bl	34009ab8 <LL_RCC_IC16_IsEnabled>
34012c3a:	4603      	mov	r3, r0
34012c3c:	2b00      	cmp	r3, #0
34012c3e:	d04d      	beq.n	34012cdc <RCCEx_GetLTDCCLKFreq+0x100>
        ic_divider = LL_RCC_IC16_GetDivider();
34012c40:	f7f6 ff5c 	bl	34009afc <LL_RCC_IC16_GetDivider>
34012c44:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC16_GetSource())
34012c46:	f7f6 ff4b 	bl	34009ae0 <LL_RCC_IC16_GetSource>
34012c4a:	4603      	mov	r3, r0
34012c4c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012c50:	d029      	beq.n	34012ca6 <RCCEx_GetLTDCCLKFreq+0xca>
34012c52:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012c56:	d82f      	bhi.n	34012cb8 <RCCEx_GetLTDCCLKFreq+0xdc>
34012c58:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012c5c:	d01a      	beq.n	34012c94 <RCCEx_GetLTDCCLKFreq+0xb8>
34012c5e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012c62:	d829      	bhi.n	34012cb8 <RCCEx_GetLTDCCLKFreq+0xdc>
34012c64:	2b00      	cmp	r3, #0
34012c66:	d003      	beq.n	34012c70 <RCCEx_GetLTDCCLKFreq+0x94>
34012c68:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34012c6c:	d009      	beq.n	34012c82 <RCCEx_GetLTDCCLKFreq+0xa6>
            break;
34012c6e:	e023      	b.n	34012cb8 <RCCEx_GetLTDCCLKFreq+0xdc>
            ltdc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34012c70:	f7fe f960 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34012c74:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
34012c76:	68fa      	ldr	r2, [r7, #12]
34012c78:	68bb      	ldr	r3, [r7, #8]
34012c7a:	fbb2 f3f3 	udiv	r3, r2, r3
34012c7e:	60fb      	str	r3, [r7, #12]
            break;
34012c80:	e01b      	b.n	34012cba <RCCEx_GetLTDCCLKFreq+0xde>
            ltdc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34012c82:	f7fe f99d 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34012c86:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
34012c88:	68fa      	ldr	r2, [r7, #12]
34012c8a:	68bb      	ldr	r3, [r7, #8]
34012c8c:	fbb2 f3f3 	udiv	r3, r2, r3
34012c90:	60fb      	str	r3, [r7, #12]
            break;
34012c92:	e012      	b.n	34012cba <RCCEx_GetLTDCCLKFreq+0xde>
            ltdc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34012c94:	f7fe f9da 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34012c98:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
34012c9a:	68fa      	ldr	r2, [r7, #12]
34012c9c:	68bb      	ldr	r3, [r7, #8]
34012c9e:	fbb2 f3f3 	udiv	r3, r2, r3
34012ca2:	60fb      	str	r3, [r7, #12]
            break;
34012ca4:	e009      	b.n	34012cba <RCCEx_GetLTDCCLKFreq+0xde>
            ltdc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34012ca6:	f7fe fa17 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34012caa:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
34012cac:	68fa      	ldr	r2, [r7, #12]
34012cae:	68bb      	ldr	r3, [r7, #8]
34012cb0:	fbb2 f3f3 	udiv	r3, r2, r3
34012cb4:	60fb      	str	r3, [r7, #12]
            break;
34012cb6:	e000      	b.n	34012cba <RCCEx_GetLTDCCLKFreq+0xde>
            break;
34012cb8:	bf00      	nop
      break;
34012cba:	e00f      	b.n	34012cdc <RCCEx_GetLTDCCLKFreq+0x100>
      if (LL_RCC_HSI_IsReady() != 0U)
34012cbc:	f7f5 fd58 	bl	34008770 <LL_RCC_HSI_IsReady>
34012cc0:	4603      	mov	r3, r0
34012cc2:	2b00      	cmp	r3, #0
34012cc4:	d00c      	beq.n	34012ce0 <RCCEx_GetLTDCCLKFreq+0x104>
        ltdc_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34012cc6:	f7f5 fd65 	bl	34008794 <LL_RCC_HSI_GetDivider>
34012cca:	4603      	mov	r3, r0
34012ccc:	09db      	lsrs	r3, r3, #7
34012cce:	4a07      	ldr	r2, [pc, #28]	@ (34012cec <RCCEx_GetLTDCCLKFreq+0x110>)
34012cd0:	fa22 f303 	lsr.w	r3, r2, r3
34012cd4:	60fb      	str	r3, [r7, #12]
      break;
34012cd6:	e003      	b.n	34012ce0 <RCCEx_GetLTDCCLKFreq+0x104>
      break;
34012cd8:	bf00      	nop
34012cda:	e002      	b.n	34012ce2 <RCCEx_GetLTDCCLKFreq+0x106>
      break;
34012cdc:	bf00      	nop
34012cde:	e000      	b.n	34012ce2 <RCCEx_GetLTDCCLKFreq+0x106>
      break;
34012ce0:	bf00      	nop
  }

  return ltdc_frequency;
34012ce2:	68fb      	ldr	r3, [r7, #12]
}
34012ce4:	4618      	mov	r0, r3
34012ce6:	3710      	adds	r7, #16
34012ce8:	46bd      	mov	sp, r7
34012cea:	bd80      	pop	{r7, pc}
34012cec:	03d09000 	.word	0x03d09000

34012cf0 <RCCEx_GetMDFCLKFreq>:
  *         @arg @ref RCCEx_MDF1_Clock_Source
  * @retval MDF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetMDFCLKFreq(uint32_t MDFxSource)
{
34012cf0:	b590      	push	{r4, r7, lr}
34012cf2:	b085      	sub	sp, #20
34012cf4:	af00      	add	r7, sp, #0
34012cf6:	6078      	str	r0, [r7, #4]
  uint32_t adf_frequency = RCC_PERIPH_FREQUENCY_NO;
34012cf8:	2300      	movs	r3, #0
34012cfa:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetMDFClockSource(MDFxSource))
34012cfc:	6878      	ldr	r0, [r7, #4]
34012cfe:	f7f6 f8c5 	bl	34008e8c <LL_RCC_GetMDFClockSource>
34012d02:	4603      	mov	r3, r0
34012d04:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
34012d08:	f000 80dd 	beq.w	34012ec6 <RCCEx_GetMDFCLKFreq+0x1d6>
34012d0c:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
34012d10:	f200 80e3 	bhi.w	34012eda <RCCEx_GetMDFCLKFreq+0x1ea>
34012d14:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
34012d18:	f000 80d2 	beq.w	34012ec0 <RCCEx_GetMDFCLKFreq+0x1d0>
34012d1c:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
34012d20:	f200 80db 	bhi.w	34012eda <RCCEx_GetMDFCLKFreq+0x1ea>
34012d24:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
34012d28:	f000 80b4 	beq.w	34012e94 <RCCEx_GetMDFCLKFreq+0x1a4>
34012d2c:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
34012d30:	f200 80d3 	bhi.w	34012eda <RCCEx_GetMDFCLKFreq+0x1ea>
34012d34:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34012d38:	f000 80ba 	beq.w	34012eb0 <RCCEx_GetMDFCLKFreq+0x1c0>
34012d3c:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34012d40:	f200 80cb 	bhi.w	34012eda <RCCEx_GetMDFCLKFreq+0x1ea>
34012d44:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34012d48:	d061      	beq.n	34012e0e <RCCEx_GetMDFCLKFreq+0x11e>
34012d4a:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34012d4e:	f200 80c4 	bhi.w	34012eda <RCCEx_GetMDFCLKFreq+0x1ea>
34012d52:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34012d56:	d016      	beq.n	34012d86 <RCCEx_GetMDFCLKFreq+0x96>
34012d58:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34012d5c:	f200 80bd 	bhi.w	34012eda <RCCEx_GetMDFCLKFreq+0x1ea>
34012d60:	2b00      	cmp	r3, #0
34012d62:	d003      	beq.n	34012d6c <RCCEx_GetMDFCLKFreq+0x7c>
34012d64:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34012d68:	d008      	beq.n	34012d7c <RCCEx_GetMDFCLKFreq+0x8c>
      adf_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
      break;

    default:
      /* Unexpected case */
      break;
34012d6a:	e0b6      	b.n	34012eda <RCCEx_GetMDFCLKFreq+0x1ea>
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34012d6c:	f7f5 f902 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34012d70:	4603      	mov	r3, r0
34012d72:	4618      	mov	r0, r3
34012d74:	f7fe f9f6 	bl	34011164 <RCCEx_GetHCLKFreq>
34012d78:	60f8      	str	r0, [r7, #12]
      break;
34012d7a:	e0b7      	b.n	34012eec <RCCEx_GetMDFCLKFreq+0x1fc>
      adf_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34012d7c:	2007      	movs	r0, #7
34012d7e:	f7fe fcdd 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
34012d82:	60f8      	str	r0, [r7, #12]
      break;
34012d84:	e0b2      	b.n	34012eec <RCCEx_GetMDFCLKFreq+0x1fc>
      if (LL_RCC_IC7_IsEnabled() != 0U)
34012d86:	f7f6 fc97 	bl	340096b8 <LL_RCC_IC7_IsEnabled>
34012d8a:	4603      	mov	r3, r0
34012d8c:	2b00      	cmp	r3, #0
34012d8e:	f000 80a6 	beq.w	34012ede <RCCEx_GetMDFCLKFreq+0x1ee>
        ic_divider = LL_RCC_IC7_GetDivider();
34012d92:	f7f6 fcb3 	bl	340096fc <LL_RCC_IC7_GetDivider>
34012d96:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34012d98:	f7f6 fca2 	bl	340096e0 <LL_RCC_IC7_GetSource>
34012d9c:	4603      	mov	r3, r0
34012d9e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012da2:	d029      	beq.n	34012df8 <RCCEx_GetMDFCLKFreq+0x108>
34012da4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012da8:	d82f      	bhi.n	34012e0a <RCCEx_GetMDFCLKFreq+0x11a>
34012daa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012dae:	d01a      	beq.n	34012de6 <RCCEx_GetMDFCLKFreq+0xf6>
34012db0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012db4:	d829      	bhi.n	34012e0a <RCCEx_GetMDFCLKFreq+0x11a>
34012db6:	2b00      	cmp	r3, #0
34012db8:	d003      	beq.n	34012dc2 <RCCEx_GetMDFCLKFreq+0xd2>
34012dba:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34012dbe:	d009      	beq.n	34012dd4 <RCCEx_GetMDFCLKFreq+0xe4>
            break;
34012dc0:	e023      	b.n	34012e0a <RCCEx_GetMDFCLKFreq+0x11a>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34012dc2:	f7fe f8b7 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34012dc6:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34012dc8:	68fa      	ldr	r2, [r7, #12]
34012dca:	68bb      	ldr	r3, [r7, #8]
34012dcc:	fbb2 f3f3 	udiv	r3, r2, r3
34012dd0:	60fb      	str	r3, [r7, #12]
            break;
34012dd2:	e01b      	b.n	34012e0c <RCCEx_GetMDFCLKFreq+0x11c>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34012dd4:	f7fe f8f4 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34012dd8:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34012dda:	68fa      	ldr	r2, [r7, #12]
34012ddc:	68bb      	ldr	r3, [r7, #8]
34012dde:	fbb2 f3f3 	udiv	r3, r2, r3
34012de2:	60fb      	str	r3, [r7, #12]
            break;
34012de4:	e012      	b.n	34012e0c <RCCEx_GetMDFCLKFreq+0x11c>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34012de6:	f7fe f931 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34012dea:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34012dec:	68fa      	ldr	r2, [r7, #12]
34012dee:	68bb      	ldr	r3, [r7, #8]
34012df0:	fbb2 f3f3 	udiv	r3, r2, r3
34012df4:	60fb      	str	r3, [r7, #12]
            break;
34012df6:	e009      	b.n	34012e0c <RCCEx_GetMDFCLKFreq+0x11c>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34012df8:	f7fe f96e 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34012dfc:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34012dfe:	68fa      	ldr	r2, [r7, #12]
34012e00:	68bb      	ldr	r3, [r7, #8]
34012e02:	fbb2 f3f3 	udiv	r3, r2, r3
34012e06:	60fb      	str	r3, [r7, #12]
            break;
34012e08:	e000      	b.n	34012e0c <RCCEx_GetMDFCLKFreq+0x11c>
            break;
34012e0a:	bf00      	nop
      break;
34012e0c:	e067      	b.n	34012ede <RCCEx_GetMDFCLKFreq+0x1ee>
      if (LL_RCC_IC8_IsEnabled() != 0U)
34012e0e:	f7f6 fc93 	bl	34009738 <LL_RCC_IC8_IsEnabled>
34012e12:	4603      	mov	r3, r0
34012e14:	2b00      	cmp	r3, #0
34012e16:	d064      	beq.n	34012ee2 <RCCEx_GetMDFCLKFreq+0x1f2>
        ic_divider = LL_RCC_IC8_GetDivider();
34012e18:	f7f6 fcb0 	bl	3400977c <LL_RCC_IC8_GetDivider>
34012e1c:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34012e1e:	f7f6 fc9f 	bl	34009760 <LL_RCC_IC8_GetSource>
34012e22:	4603      	mov	r3, r0
34012e24:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012e28:	d029      	beq.n	34012e7e <RCCEx_GetMDFCLKFreq+0x18e>
34012e2a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012e2e:	d82f      	bhi.n	34012e90 <RCCEx_GetMDFCLKFreq+0x1a0>
34012e30:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012e34:	d01a      	beq.n	34012e6c <RCCEx_GetMDFCLKFreq+0x17c>
34012e36:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012e3a:	d829      	bhi.n	34012e90 <RCCEx_GetMDFCLKFreq+0x1a0>
34012e3c:	2b00      	cmp	r3, #0
34012e3e:	d003      	beq.n	34012e48 <RCCEx_GetMDFCLKFreq+0x158>
34012e40:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34012e44:	d009      	beq.n	34012e5a <RCCEx_GetMDFCLKFreq+0x16a>
            break;
34012e46:	e023      	b.n	34012e90 <RCCEx_GetMDFCLKFreq+0x1a0>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34012e48:	f7fe f874 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34012e4c:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34012e4e:	68fa      	ldr	r2, [r7, #12]
34012e50:	68bb      	ldr	r3, [r7, #8]
34012e52:	fbb2 f3f3 	udiv	r3, r2, r3
34012e56:	60fb      	str	r3, [r7, #12]
            break;
34012e58:	e01b      	b.n	34012e92 <RCCEx_GetMDFCLKFreq+0x1a2>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34012e5a:	f7fe f8b1 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34012e5e:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34012e60:	68fa      	ldr	r2, [r7, #12]
34012e62:	68bb      	ldr	r3, [r7, #8]
34012e64:	fbb2 f3f3 	udiv	r3, r2, r3
34012e68:	60fb      	str	r3, [r7, #12]
            break;
34012e6a:	e012      	b.n	34012e92 <RCCEx_GetMDFCLKFreq+0x1a2>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34012e6c:	f7fe f8ee 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34012e70:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34012e72:	68fa      	ldr	r2, [r7, #12]
34012e74:	68bb      	ldr	r3, [r7, #8]
34012e76:	fbb2 f3f3 	udiv	r3, r2, r3
34012e7a:	60fb      	str	r3, [r7, #12]
            break;
34012e7c:	e009      	b.n	34012e92 <RCCEx_GetMDFCLKFreq+0x1a2>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34012e7e:	f7fe f92b 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34012e82:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34012e84:	68fa      	ldr	r2, [r7, #12]
34012e86:	68bb      	ldr	r3, [r7, #8]
34012e88:	fbb2 f3f3 	udiv	r3, r2, r3
34012e8c:	60fb      	str	r3, [r7, #12]
            break;
34012e8e:	e000      	b.n	34012e92 <RCCEx_GetMDFCLKFreq+0x1a2>
            break;
34012e90:	bf00      	nop
      break;
34012e92:	e026      	b.n	34012ee2 <RCCEx_GetMDFCLKFreq+0x1f2>
      if (LL_RCC_HSI_IsReady() != 0U)
34012e94:	f7f5 fc6c 	bl	34008770 <LL_RCC_HSI_IsReady>
34012e98:	4603      	mov	r3, r0
34012e9a:	2b00      	cmp	r3, #0
34012e9c:	d023      	beq.n	34012ee6 <RCCEx_GetMDFCLKFreq+0x1f6>
        adf_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34012e9e:	f7f5 fc79 	bl	34008794 <LL_RCC_HSI_GetDivider>
34012ea2:	4603      	mov	r3, r0
34012ea4:	09db      	lsrs	r3, r3, #7
34012ea6:	4a14      	ldr	r2, [pc, #80]	@ (34012ef8 <RCCEx_GetMDFCLKFreq+0x208>)
34012ea8:	fa22 f303 	lsr.w	r3, r2, r3
34012eac:	60fb      	str	r3, [r7, #12]
      break;
34012eae:	e01a      	b.n	34012ee6 <RCCEx_GetMDFCLKFreq+0x1f6>
      if (LL_RCC_MSI_IsReady() != 0U)
34012eb0:	f7f5 fc7e 	bl	340087b0 <LL_RCC_MSI_IsReady>
34012eb4:	4603      	mov	r3, r0
34012eb6:	2b00      	cmp	r3, #0
34012eb8:	d017      	beq.n	34012eea <RCCEx_GetMDFCLKFreq+0x1fa>
        adf_frequency = MSI_VALUE;
34012eba:	4b10      	ldr	r3, [pc, #64]	@ (34012efc <RCCEx_GetMDFCLKFreq+0x20c>)
34012ebc:	60fb      	str	r3, [r7, #12]
      break;
34012ebe:	e014      	b.n	34012eea <RCCEx_GetMDFCLKFreq+0x1fa>
      adf_frequency = EXTERNAL_CLOCK_VALUE;
34012ec0:	4b0f      	ldr	r3, [pc, #60]	@ (34012f00 <RCCEx_GetMDFCLKFreq+0x210>)
34012ec2:	60fb      	str	r3, [r7, #12]
      break;
34012ec4:	e012      	b.n	34012eec <RCCEx_GetMDFCLKFreq+0x1fc>
      adf_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
34012ec6:	f7f5 f855 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34012eca:	4604      	mov	r4, r0
34012ecc:	f7f6 f8b8 	bl	34009040 <LL_RCC_GetTIMPrescaler>
34012ed0:	4603      	mov	r3, r0
34012ed2:	fa24 f303 	lsr.w	r3, r4, r3
34012ed6:	60fb      	str	r3, [r7, #12]
      break;
34012ed8:	e008      	b.n	34012eec <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34012eda:	bf00      	nop
34012edc:	e006      	b.n	34012eec <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34012ede:	bf00      	nop
34012ee0:	e004      	b.n	34012eec <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34012ee2:	bf00      	nop
34012ee4:	e002      	b.n	34012eec <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34012ee6:	bf00      	nop
34012ee8:	e000      	b.n	34012eec <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34012eea:	bf00      	nop
  }

  return adf_frequency;
34012eec:	68fb      	ldr	r3, [r7, #12]
}
34012eee:	4618      	mov	r0, r3
34012ef0:	3714      	adds	r7, #20
34012ef2:	46bd      	mov	sp, r7
34012ef4:	bd90      	pop	{r4, r7, pc}
34012ef6:	bf00      	nop
34012ef8:	03d09000 	.word	0x03d09000
34012efc:	003d0900 	.word	0x003d0900
34012f00:	00bb8000 	.word	0x00bb8000

34012f04 <RCCEx_GetPSSICLKFreq>:
  *         @arg @ref RCCEx_PSSI_Clock_Source
  * @retval PSSI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetPSSICLKFreq(uint32_t PSSIxSource)
{
34012f04:	b580      	push	{r7, lr}
34012f06:	b084      	sub	sp, #16
34012f08:	af00      	add	r7, sp, #0
34012f0a:	6078      	str	r0, [r7, #4]
  uint32_t pssi_frequency = RCC_PERIPH_FREQUENCY_NO;
34012f0c:	2300      	movs	r3, #0
34012f0e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetPSSIClockSource(PSSIxSource))
34012f10:	6878      	ldr	r0, [r7, #4]
34012f12:	f7f5 ffcd 	bl	34008eb0 <LL_RCC_GetPSSIClockSource>
34012f16:	4603      	mov	r3, r0
34012f18:	2b30      	cmp	r3, #48	@ 0x30
34012f1a:	d05a      	beq.n	34012fd2 <RCCEx_GetPSSICLKFreq+0xce>
34012f1c:	2b30      	cmp	r3, #48	@ 0x30
34012f1e:	d866      	bhi.n	34012fee <RCCEx_GetPSSICLKFreq+0xea>
34012f20:	2b20      	cmp	r3, #32
34012f22:	d013      	beq.n	34012f4c <RCCEx_GetPSSICLKFreq+0x48>
34012f24:	2b20      	cmp	r3, #32
34012f26:	d862      	bhi.n	34012fee <RCCEx_GetPSSICLKFreq+0xea>
34012f28:	2b00      	cmp	r3, #0
34012f2a:	d002      	beq.n	34012f32 <RCCEx_GetPSSICLKFreq+0x2e>
34012f2c:	2b10      	cmp	r3, #16
34012f2e:	d008      	beq.n	34012f42 <RCCEx_GetPSSICLKFreq+0x3e>
      }
      break;

    default:
      /* Unexpected case */
      break;
34012f30:	e05d      	b.n	34012fee <RCCEx_GetPSSICLKFreq+0xea>
      pssi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34012f32:	f7f5 f81f 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34012f36:	4603      	mov	r3, r0
34012f38:	4618      	mov	r0, r3
34012f3a:	f7fe f913 	bl	34011164 <RCCEx_GetHCLKFreq>
34012f3e:	60f8      	str	r0, [r7, #12]
      break;
34012f40:	e05a      	b.n	34012ff8 <RCCEx_GetPSSICLKFreq+0xf4>
      pssi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34012f42:	2007      	movs	r0, #7
34012f44:	f7fe fbfa 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
34012f48:	60f8      	str	r0, [r7, #12]
      break;
34012f4a:	e055      	b.n	34012ff8 <RCCEx_GetPSSICLKFreq+0xf4>
      if (LL_RCC_IC20_IsEnabled() != 0U)
34012f4c:	f7f6 feb4 	bl	34009cb8 <LL_RCC_IC20_IsEnabled>
34012f50:	4603      	mov	r3, r0
34012f52:	2b00      	cmp	r3, #0
34012f54:	d04d      	beq.n	34012ff2 <RCCEx_GetPSSICLKFreq+0xee>
        ic_divider = LL_RCC_IC20_GetDivider();
34012f56:	f7f6 fed1 	bl	34009cfc <LL_RCC_IC20_GetDivider>
34012f5a:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC20_GetSource())
34012f5c:	f7f6 fec0 	bl	34009ce0 <LL_RCC_IC20_GetSource>
34012f60:	4603      	mov	r3, r0
34012f62:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012f66:	d029      	beq.n	34012fbc <RCCEx_GetPSSICLKFreq+0xb8>
34012f68:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012f6c:	d82f      	bhi.n	34012fce <RCCEx_GetPSSICLKFreq+0xca>
34012f6e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012f72:	d01a      	beq.n	34012faa <RCCEx_GetPSSICLKFreq+0xa6>
34012f74:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012f78:	d829      	bhi.n	34012fce <RCCEx_GetPSSICLKFreq+0xca>
34012f7a:	2b00      	cmp	r3, #0
34012f7c:	d003      	beq.n	34012f86 <RCCEx_GetPSSICLKFreq+0x82>
34012f7e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34012f82:	d009      	beq.n	34012f98 <RCCEx_GetPSSICLKFreq+0x94>
            break;
34012f84:	e023      	b.n	34012fce <RCCEx_GetPSSICLKFreq+0xca>
            pssi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34012f86:	f7fd ffd5 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34012f8a:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
34012f8c:	68fa      	ldr	r2, [r7, #12]
34012f8e:	68bb      	ldr	r3, [r7, #8]
34012f90:	fbb2 f3f3 	udiv	r3, r2, r3
34012f94:	60fb      	str	r3, [r7, #12]
            break;
34012f96:	e01b      	b.n	34012fd0 <RCCEx_GetPSSICLKFreq+0xcc>
            pssi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34012f98:	f7fe f812 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34012f9c:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
34012f9e:	68fa      	ldr	r2, [r7, #12]
34012fa0:	68bb      	ldr	r3, [r7, #8]
34012fa2:	fbb2 f3f3 	udiv	r3, r2, r3
34012fa6:	60fb      	str	r3, [r7, #12]
            break;
34012fa8:	e012      	b.n	34012fd0 <RCCEx_GetPSSICLKFreq+0xcc>
            pssi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34012faa:	f7fe f84f 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34012fae:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
34012fb0:	68fa      	ldr	r2, [r7, #12]
34012fb2:	68bb      	ldr	r3, [r7, #8]
34012fb4:	fbb2 f3f3 	udiv	r3, r2, r3
34012fb8:	60fb      	str	r3, [r7, #12]
            break;
34012fba:	e009      	b.n	34012fd0 <RCCEx_GetPSSICLKFreq+0xcc>
            pssi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34012fbc:	f7fe f88c 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34012fc0:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
34012fc2:	68fa      	ldr	r2, [r7, #12]
34012fc4:	68bb      	ldr	r3, [r7, #8]
34012fc6:	fbb2 f3f3 	udiv	r3, r2, r3
34012fca:	60fb      	str	r3, [r7, #12]
            break;
34012fcc:	e000      	b.n	34012fd0 <RCCEx_GetPSSICLKFreq+0xcc>
            break;
34012fce:	bf00      	nop
      break;
34012fd0:	e00f      	b.n	34012ff2 <RCCEx_GetPSSICLKFreq+0xee>
      if (LL_RCC_HSI_IsReady() != 0U)
34012fd2:	f7f5 fbcd 	bl	34008770 <LL_RCC_HSI_IsReady>
34012fd6:	4603      	mov	r3, r0
34012fd8:	2b00      	cmp	r3, #0
34012fda:	d00c      	beq.n	34012ff6 <RCCEx_GetPSSICLKFreq+0xf2>
        pssi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34012fdc:	f7f5 fbda 	bl	34008794 <LL_RCC_HSI_GetDivider>
34012fe0:	4603      	mov	r3, r0
34012fe2:	09db      	lsrs	r3, r3, #7
34012fe4:	4a07      	ldr	r2, [pc, #28]	@ (34013004 <RCCEx_GetPSSICLKFreq+0x100>)
34012fe6:	fa22 f303 	lsr.w	r3, r2, r3
34012fea:	60fb      	str	r3, [r7, #12]
      break;
34012fec:	e003      	b.n	34012ff6 <RCCEx_GetPSSICLKFreq+0xf2>
      break;
34012fee:	bf00      	nop
34012ff0:	e002      	b.n	34012ff8 <RCCEx_GetPSSICLKFreq+0xf4>
      break;
34012ff2:	bf00      	nop
34012ff4:	e000      	b.n	34012ff8 <RCCEx_GetPSSICLKFreq+0xf4>
      break;
34012ff6:	bf00      	nop
  }

  return pssi_frequency;
34012ff8:	68fb      	ldr	r3, [r7, #12]
}
34012ffa:	4618      	mov	r0, r3
34012ffc:	3710      	adds	r7, #16
34012ffe:	46bd      	mov	sp, r7
34013000:	bd80      	pop	{r7, pc}
34013002:	bf00      	nop
34013004:	03d09000 	.word	0x03d09000

34013008 <RCCEx_GetRTCCLKFreq>:
  * @brief  Return RTC clock frequency
  * @retval RTC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetRTCCLKFreq()
{
34013008:	b580      	push	{r7, lr}
3401300a:	b082      	sub	sp, #8
3401300c:	af00      	add	r7, sp, #0
  uint32_t rtc_frequency = RCC_PERIPH_FREQUENCY_NO;
3401300e:	2300      	movs	r3, #0
34013010:	607b      	str	r3, [r7, #4]

  switch (LL_RCC_GetRTCClockSource())
34013012:	f7f5 ffdb 	bl	34008fcc <LL_RCC_GetRTCClockSource>
34013016:	4603      	mov	r3, r0
34013018:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3401301c:	d020      	beq.n	34013060 <RCCEx_GetRTCCLKFreq+0x58>
3401301e:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34013022:	d830      	bhi.n	34013086 <RCCEx_GetRTCCLKFreq+0x7e>
34013024:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34013028:	d011      	beq.n	3401304e <RCCEx_GetRTCCLKFreq+0x46>
3401302a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3401302e:	d82a      	bhi.n	34013086 <RCCEx_GetRTCCLKFreq+0x7e>
34013030:	2b00      	cmp	r3, #0
34013032:	d02a      	beq.n	3401308a <RCCEx_GetRTCCLKFreq+0x82>
34013034:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34013038:	d000      	beq.n	3401303c <RCCEx_GetRTCCLKFreq+0x34>
      }
      break;

    default:
      /* Unexpected case */
      break;
3401303a:	e024      	b.n	34013086 <RCCEx_GetRTCCLKFreq+0x7e>
      if (LL_RCC_LSE_IsReady() != 0U)
3401303c:	f7f5 fbd8 	bl	340087f0 <LL_RCC_LSE_IsReady>
34013040:	4603      	mov	r3, r0
34013042:	2b00      	cmp	r3, #0
34013044:	d023      	beq.n	3401308e <RCCEx_GetRTCCLKFreq+0x86>
        rtc_frequency = LSE_VALUE;
34013046:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
3401304a:	607b      	str	r3, [r7, #4]
      break;
3401304c:	e01f      	b.n	3401308e <RCCEx_GetRTCCLKFreq+0x86>
      if (LL_RCC_LSI_IsReady() != 0U)
3401304e:	f7f5 fbe1 	bl	34008814 <LL_RCC_LSI_IsReady>
34013052:	4603      	mov	r3, r0
34013054:	2b00      	cmp	r3, #0
34013056:	d01c      	beq.n	34013092 <RCCEx_GetRTCCLKFreq+0x8a>
        rtc_frequency = LSI_VALUE;
34013058:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
3401305c:	607b      	str	r3, [r7, #4]
      break;
3401305e:	e018      	b.n	34013092 <RCCEx_GetRTCCLKFreq+0x8a>
      if (LL_RCC_HSE_IsReady() != 0U)
34013060:	f7f5 fb74 	bl	3400874c <LL_RCC_HSE_IsReady>
34013064:	4603      	mov	r3, r0
34013066:	2b00      	cmp	r3, #0
34013068:	d015      	beq.n	34013096 <RCCEx_GetRTCCLKFreq+0x8e>
        uint32_t prescaler = (READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCPRE) >> RCC_CCIPR7_RTCPRE_Pos) + 1U;
3401306a:	4b0e      	ldr	r3, [pc, #56]	@ (340130a4 <RCCEx_GetRTCCLKFreq+0x9c>)
3401306c:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34013070:	0b1b      	lsrs	r3, r3, #12
34013072:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34013076:	3301      	adds	r3, #1
34013078:	603b      	str	r3, [r7, #0]
        rtc_frequency = HSE_VALUE / prescaler;
3401307a:	4a0b      	ldr	r2, [pc, #44]	@ (340130a8 <RCCEx_GetRTCCLKFreq+0xa0>)
3401307c:	683b      	ldr	r3, [r7, #0]
3401307e:	fbb2 f3f3 	udiv	r3, r2, r3
34013082:	607b      	str	r3, [r7, #4]
      break;
34013084:	e007      	b.n	34013096 <RCCEx_GetRTCCLKFreq+0x8e>
      break;
34013086:	bf00      	nop
34013088:	e006      	b.n	34013098 <RCCEx_GetRTCCLKFreq+0x90>
      break;
3401308a:	bf00      	nop
3401308c:	e004      	b.n	34013098 <RCCEx_GetRTCCLKFreq+0x90>
      break;
3401308e:	bf00      	nop
34013090:	e002      	b.n	34013098 <RCCEx_GetRTCCLKFreq+0x90>
      break;
34013092:	bf00      	nop
34013094:	e000      	b.n	34013098 <RCCEx_GetRTCCLKFreq+0x90>
      break;
34013096:	bf00      	nop
  }

  return rtc_frequency;
34013098:	687b      	ldr	r3, [r7, #4]
}
3401309a:	4618      	mov	r0, r3
3401309c:	3708      	adds	r7, #8
3401309e:	46bd      	mov	sp, r7
340130a0:	bd80      	pop	{r7, pc}
340130a2:	bf00      	nop
340130a4:	56028000 	.word	0x56028000
340130a8:	02dc6c00 	.word	0x02dc6c00

340130ac <RCCEx_GetSAICLKFreq>:
  *         @arg @ref RCCEx_SAI2_Clock_Source
  * @retval SAI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSAICLKFreq(uint32_t SAIxSource)
{
340130ac:	b580      	push	{r7, lr}
340130ae:	b084      	sub	sp, #16
340130b0:	af00      	add	r7, sp, #0
340130b2:	6078      	str	r0, [r7, #4]
  uint32_t sai_frequency = RCC_PERIPH_FREQUENCY_NO;
340130b4:	2300      	movs	r3, #0
340130b6:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSAIClockSource(SAIxSource))
340130b8:	6878      	ldr	r0, [r7, #4]
340130ba:	f7f5 ff0b 	bl	34008ed4 <LL_RCC_GetSAIClockSource>
340130be:	4603      	mov	r3, r0
340130c0:	4a9a      	ldr	r2, [pc, #616]	@ (3401332c <RCCEx_GetSAICLKFreq+0x280>)
340130c2:	4293      	cmp	r3, r2
340130c4:	f000 811f 	beq.w	34013306 <RCCEx_GetSAICLKFreq+0x25a>
340130c8:	4a98      	ldr	r2, [pc, #608]	@ (3401332c <RCCEx_GetSAICLKFreq+0x280>)
340130ca:	4293      	cmp	r3, r2
340130cc:	f200 8120 	bhi.w	34013310 <RCCEx_GetSAICLKFreq+0x264>
340130d0:	4a97      	ldr	r2, [pc, #604]	@ (34013330 <RCCEx_GetSAICLKFreq+0x284>)
340130d2:	4293      	cmp	r3, r2
340130d4:	f000 8117 	beq.w	34013306 <RCCEx_GetSAICLKFreq+0x25a>
340130d8:	4a95      	ldr	r2, [pc, #596]	@ (34013330 <RCCEx_GetSAICLKFreq+0x284>)
340130da:	4293      	cmp	r3, r2
340130dc:	f200 8118 	bhi.w	34013310 <RCCEx_GetSAICLKFreq+0x264>
340130e0:	4a94      	ldr	r2, [pc, #592]	@ (34013334 <RCCEx_GetSAICLKFreq+0x288>)
340130e2:	4293      	cmp	r3, r2
340130e4:	f000 810c 	beq.w	34013300 <RCCEx_GetSAICLKFreq+0x254>
340130e8:	4a92      	ldr	r2, [pc, #584]	@ (34013334 <RCCEx_GetSAICLKFreq+0x288>)
340130ea:	4293      	cmp	r3, r2
340130ec:	f200 8110 	bhi.w	34013310 <RCCEx_GetSAICLKFreq+0x264>
340130f0:	4a91      	ldr	r2, [pc, #580]	@ (34013338 <RCCEx_GetSAICLKFreq+0x28c>)
340130f2:	4293      	cmp	r3, r2
340130f4:	f000 8104 	beq.w	34013300 <RCCEx_GetSAICLKFreq+0x254>
340130f8:	4a8f      	ldr	r2, [pc, #572]	@ (34013338 <RCCEx_GetSAICLKFreq+0x28c>)
340130fa:	4293      	cmp	r3, r2
340130fc:	f200 8108 	bhi.w	34013310 <RCCEx_GetSAICLKFreq+0x264>
34013100:	4a8e      	ldr	r2, [pc, #568]	@ (3401333c <RCCEx_GetSAICLKFreq+0x290>)
34013102:	4293      	cmp	r3, r2
34013104:	f000 80e6 	beq.w	340132d4 <RCCEx_GetSAICLKFreq+0x228>
34013108:	4a8c      	ldr	r2, [pc, #560]	@ (3401333c <RCCEx_GetSAICLKFreq+0x290>)
3401310a:	4293      	cmp	r3, r2
3401310c:	f200 8100 	bhi.w	34013310 <RCCEx_GetSAICLKFreq+0x264>
34013110:	4a8b      	ldr	r2, [pc, #556]	@ (34013340 <RCCEx_GetSAICLKFreq+0x294>)
34013112:	4293      	cmp	r3, r2
34013114:	f000 80de 	beq.w	340132d4 <RCCEx_GetSAICLKFreq+0x228>
34013118:	4a89      	ldr	r2, [pc, #548]	@ (34013340 <RCCEx_GetSAICLKFreq+0x294>)
3401311a:	4293      	cmp	r3, r2
3401311c:	f200 80f8 	bhi.w	34013310 <RCCEx_GetSAICLKFreq+0x264>
34013120:	4a88      	ldr	r2, [pc, #544]	@ (34013344 <RCCEx_GetSAICLKFreq+0x298>)
34013122:	4293      	cmp	r3, r2
34013124:	f000 80e4 	beq.w	340132f0 <RCCEx_GetSAICLKFreq+0x244>
34013128:	4a86      	ldr	r2, [pc, #536]	@ (34013344 <RCCEx_GetSAICLKFreq+0x298>)
3401312a:	4293      	cmp	r3, r2
3401312c:	f200 80f0 	bhi.w	34013310 <RCCEx_GetSAICLKFreq+0x264>
34013130:	4a85      	ldr	r2, [pc, #532]	@ (34013348 <RCCEx_GetSAICLKFreq+0x29c>)
34013132:	4293      	cmp	r3, r2
34013134:	f000 80dc 	beq.w	340132f0 <RCCEx_GetSAICLKFreq+0x244>
34013138:	4a83      	ldr	r2, [pc, #524]	@ (34013348 <RCCEx_GetSAICLKFreq+0x29c>)
3401313a:	4293      	cmp	r3, r2
3401313c:	f200 80e8 	bhi.w	34013310 <RCCEx_GetSAICLKFreq+0x264>
34013140:	4a82      	ldr	r2, [pc, #520]	@ (3401334c <RCCEx_GetSAICLKFreq+0x2a0>)
34013142:	4293      	cmp	r3, r2
34013144:	f000 8083 	beq.w	3401324e <RCCEx_GetSAICLKFreq+0x1a2>
34013148:	4a80      	ldr	r2, [pc, #512]	@ (3401334c <RCCEx_GetSAICLKFreq+0x2a0>)
3401314a:	4293      	cmp	r3, r2
3401314c:	f200 80e0 	bhi.w	34013310 <RCCEx_GetSAICLKFreq+0x264>
34013150:	4a7f      	ldr	r2, [pc, #508]	@ (34013350 <RCCEx_GetSAICLKFreq+0x2a4>)
34013152:	4293      	cmp	r3, r2
34013154:	d07b      	beq.n	3401324e <RCCEx_GetSAICLKFreq+0x1a2>
34013156:	4a7e      	ldr	r2, [pc, #504]	@ (34013350 <RCCEx_GetSAICLKFreq+0x2a4>)
34013158:	4293      	cmp	r3, r2
3401315a:	f200 80d9 	bhi.w	34013310 <RCCEx_GetSAICLKFreq+0x264>
3401315e:	4a7d      	ldr	r2, [pc, #500]	@ (34013354 <RCCEx_GetSAICLKFreq+0x2a8>)
34013160:	4293      	cmp	r3, r2
34013162:	d030      	beq.n	340131c6 <RCCEx_GetSAICLKFreq+0x11a>
34013164:	4a7b      	ldr	r2, [pc, #492]	@ (34013354 <RCCEx_GetSAICLKFreq+0x2a8>)
34013166:	4293      	cmp	r3, r2
34013168:	f200 80d2 	bhi.w	34013310 <RCCEx_GetSAICLKFreq+0x264>
3401316c:	4a7a      	ldr	r2, [pc, #488]	@ (34013358 <RCCEx_GetSAICLKFreq+0x2ac>)
3401316e:	4293      	cmp	r3, r2
34013170:	d029      	beq.n	340131c6 <RCCEx_GetSAICLKFreq+0x11a>
34013172:	4a79      	ldr	r2, [pc, #484]	@ (34013358 <RCCEx_GetSAICLKFreq+0x2ac>)
34013174:	4293      	cmp	r3, r2
34013176:	f200 80cb 	bhi.w	34013310 <RCCEx_GetSAICLKFreq+0x264>
3401317a:	4a78      	ldr	r2, [pc, #480]	@ (3401335c <RCCEx_GetSAICLKFreq+0x2b0>)
3401317c:	4293      	cmp	r3, r2
3401317e:	d01d      	beq.n	340131bc <RCCEx_GetSAICLKFreq+0x110>
34013180:	4a76      	ldr	r2, [pc, #472]	@ (3401335c <RCCEx_GetSAICLKFreq+0x2b0>)
34013182:	4293      	cmp	r3, r2
34013184:	f200 80c4 	bhi.w	34013310 <RCCEx_GetSAICLKFreq+0x264>
34013188:	4a75      	ldr	r2, [pc, #468]	@ (34013360 <RCCEx_GetSAICLKFreq+0x2b4>)
3401318a:	4293      	cmp	r3, r2
3401318c:	d016      	beq.n	340131bc <RCCEx_GetSAICLKFreq+0x110>
3401318e:	4a74      	ldr	r2, [pc, #464]	@ (34013360 <RCCEx_GetSAICLKFreq+0x2b4>)
34013190:	4293      	cmp	r3, r2
34013192:	f200 80bd 	bhi.w	34013310 <RCCEx_GetSAICLKFreq+0x264>
34013196:	4a73      	ldr	r2, [pc, #460]	@ (34013364 <RCCEx_GetSAICLKFreq+0x2b8>)
34013198:	4293      	cmp	r3, r2
3401319a:	d003      	beq.n	340131a4 <RCCEx_GetSAICLKFreq+0xf8>
3401319c:	4a72      	ldr	r2, [pc, #456]	@ (34013368 <RCCEx_GetSAICLKFreq+0x2bc>)
3401319e:	4293      	cmp	r3, r2
340131a0:	f040 80b6 	bne.w	34013310 <RCCEx_GetSAICLKFreq+0x264>
  {
    case LL_RCC_SAI1_CLKSOURCE_PCLK2:
    case LL_RCC_SAI2_CLKSOURCE_PCLK2:
      sai_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340131a4:	f7f4 fee6 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
340131a8:	4603      	mov	r3, r0
340131aa:	4618      	mov	r0, r3
340131ac:	f7fd ffda 	bl	34011164 <RCCEx_GetHCLKFreq>
340131b0:	4603      	mov	r3, r0
340131b2:	4618      	mov	r0, r3
340131b4:	f7fd fff7 	bl	340111a6 <RCCEx_GetPCLK2Freq>
340131b8:	60f8      	str	r0, [r7, #12]
      break;
340131ba:	e0b2      	b.n	34013322 <RCCEx_GetSAICLKFreq+0x276>

    case LL_RCC_SAI1_CLKSOURCE_CLKP:
    case LL_RCC_SAI2_CLKSOURCE_CLKP:
      sai_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340131bc:	2007      	movs	r0, #7
340131be:	f7fe fabd 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
340131c2:	60f8      	str	r0, [r7, #12]
      break;
340131c4:	e0ad      	b.n	34013322 <RCCEx_GetSAICLKFreq+0x276>

    case LL_RCC_SAI1_CLKSOURCE_IC7:
    case LL_RCC_SAI2_CLKSOURCE_IC7:
      if (LL_RCC_IC7_IsEnabled() != 0U)
340131c6:	f7f6 fa77 	bl	340096b8 <LL_RCC_IC7_IsEnabled>
340131ca:	4603      	mov	r3, r0
340131cc:	2b00      	cmp	r3, #0
340131ce:	f000 80a1 	beq.w	34013314 <RCCEx_GetSAICLKFreq+0x268>
      {
        ic_divider = LL_RCC_IC7_GetDivider();
340131d2:	f7f6 fa93 	bl	340096fc <LL_RCC_IC7_GetDivider>
340131d6:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
340131d8:	f7f6 fa82 	bl	340096e0 <LL_RCC_IC7_GetSource>
340131dc:	4603      	mov	r3, r0
340131de:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340131e2:	d029      	beq.n	34013238 <RCCEx_GetSAICLKFreq+0x18c>
340131e4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340131e8:	d82f      	bhi.n	3401324a <RCCEx_GetSAICLKFreq+0x19e>
340131ea:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340131ee:	d01a      	beq.n	34013226 <RCCEx_GetSAICLKFreq+0x17a>
340131f0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340131f4:	d829      	bhi.n	3401324a <RCCEx_GetSAICLKFreq+0x19e>
340131f6:	2b00      	cmp	r3, #0
340131f8:	d003      	beq.n	34013202 <RCCEx_GetSAICLKFreq+0x156>
340131fa:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340131fe:	d009      	beq.n	34013214 <RCCEx_GetSAICLKFreq+0x168>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sai_frequency = sai_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34013200:	e023      	b.n	3401324a <RCCEx_GetSAICLKFreq+0x19e>
            sai_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34013202:	f7fd fe97 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34013206:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34013208:	68fa      	ldr	r2, [r7, #12]
3401320a:	68bb      	ldr	r3, [r7, #8]
3401320c:	fbb2 f3f3 	udiv	r3, r2, r3
34013210:	60fb      	str	r3, [r7, #12]
            break;
34013212:	e01b      	b.n	3401324c <RCCEx_GetSAICLKFreq+0x1a0>
            sai_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34013214:	f7fd fed4 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34013218:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
3401321a:	68fa      	ldr	r2, [r7, #12]
3401321c:	68bb      	ldr	r3, [r7, #8]
3401321e:	fbb2 f3f3 	udiv	r3, r2, r3
34013222:	60fb      	str	r3, [r7, #12]
            break;
34013224:	e012      	b.n	3401324c <RCCEx_GetSAICLKFreq+0x1a0>
            sai_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34013226:	f7fd ff11 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
3401322a:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
3401322c:	68fa      	ldr	r2, [r7, #12]
3401322e:	68bb      	ldr	r3, [r7, #8]
34013230:	fbb2 f3f3 	udiv	r3, r2, r3
34013234:	60fb      	str	r3, [r7, #12]
            break;
34013236:	e009      	b.n	3401324c <RCCEx_GetSAICLKFreq+0x1a0>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34013238:	f7fd ff4e 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
3401323c:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
3401323e:	68fa      	ldr	r2, [r7, #12]
34013240:	68bb      	ldr	r3, [r7, #8]
34013242:	fbb2 f3f3 	udiv	r3, r2, r3
34013246:	60fb      	str	r3, [r7, #12]
            break;
34013248:	e000      	b.n	3401324c <RCCEx_GetSAICLKFreq+0x1a0>
            break;
3401324a:	bf00      	nop
        }
      }
      break;
3401324c:	e062      	b.n	34013314 <RCCEx_GetSAICLKFreq+0x268>

    case LL_RCC_SAI1_CLKSOURCE_IC8:
    case LL_RCC_SAI2_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
3401324e:	f7f6 fa73 	bl	34009738 <LL_RCC_IC8_IsEnabled>
34013252:	4603      	mov	r3, r0
34013254:	2b00      	cmp	r3, #0
34013256:	d05f      	beq.n	34013318 <RCCEx_GetSAICLKFreq+0x26c>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
34013258:	f7f6 fa90 	bl	3400977c <LL_RCC_IC8_GetDivider>
3401325c:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
3401325e:	f7f6 fa7f 	bl	34009760 <LL_RCC_IC8_GetSource>
34013262:	4603      	mov	r3, r0
34013264:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013268:	d029      	beq.n	340132be <RCCEx_GetSAICLKFreq+0x212>
3401326a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401326e:	d82f      	bhi.n	340132d0 <RCCEx_GetSAICLKFreq+0x224>
34013270:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013274:	d01a      	beq.n	340132ac <RCCEx_GetSAICLKFreq+0x200>
34013276:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401327a:	d829      	bhi.n	340132d0 <RCCEx_GetSAICLKFreq+0x224>
3401327c:	2b00      	cmp	r3, #0
3401327e:	d003      	beq.n	34013288 <RCCEx_GetSAICLKFreq+0x1dc>
34013280:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013284:	d009      	beq.n	3401329a <RCCEx_GetSAICLKFreq+0x1ee>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sai_frequency = sai_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34013286:	e023      	b.n	340132d0 <RCCEx_GetSAICLKFreq+0x224>
            sai_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34013288:	f7fd fe54 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
3401328c:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
3401328e:	68fa      	ldr	r2, [r7, #12]
34013290:	68bb      	ldr	r3, [r7, #8]
34013292:	fbb2 f3f3 	udiv	r3, r2, r3
34013296:	60fb      	str	r3, [r7, #12]
            break;
34013298:	e01b      	b.n	340132d2 <RCCEx_GetSAICLKFreq+0x226>
            sai_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3401329a:	f7fd fe91 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
3401329e:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
340132a0:	68fa      	ldr	r2, [r7, #12]
340132a2:	68bb      	ldr	r3, [r7, #8]
340132a4:	fbb2 f3f3 	udiv	r3, r2, r3
340132a8:	60fb      	str	r3, [r7, #12]
            break;
340132aa:	e012      	b.n	340132d2 <RCCEx_GetSAICLKFreq+0x226>
            sai_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340132ac:	f7fd fece 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
340132b0:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
340132b2:	68fa      	ldr	r2, [r7, #12]
340132b4:	68bb      	ldr	r3, [r7, #8]
340132b6:	fbb2 f3f3 	udiv	r3, r2, r3
340132ba:	60fb      	str	r3, [r7, #12]
            break;
340132bc:	e009      	b.n	340132d2 <RCCEx_GetSAICLKFreq+0x226>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340132be:	f7fd ff0b 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
340132c2:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
340132c4:	68fa      	ldr	r2, [r7, #12]
340132c6:	68bb      	ldr	r3, [r7, #8]
340132c8:	fbb2 f3f3 	udiv	r3, r2, r3
340132cc:	60fb      	str	r3, [r7, #12]
            break;
340132ce:	e000      	b.n	340132d2 <RCCEx_GetSAICLKFreq+0x226>
            break;
340132d0:	bf00      	nop
        }
      }
      break;
340132d2:	e021      	b.n	34013318 <RCCEx_GetSAICLKFreq+0x26c>

    case LL_RCC_SAI1_CLKSOURCE_HSI:
    case LL_RCC_SAI2_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
340132d4:	f7f5 fa4c 	bl	34008770 <LL_RCC_HSI_IsReady>
340132d8:	4603      	mov	r3, r0
340132da:	2b00      	cmp	r3, #0
340132dc:	d01e      	beq.n	3401331c <RCCEx_GetSAICLKFreq+0x270>
      {
        sai_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340132de:	f7f5 fa59 	bl	34008794 <LL_RCC_HSI_GetDivider>
340132e2:	4603      	mov	r3, r0
340132e4:	09db      	lsrs	r3, r3, #7
340132e6:	4a21      	ldr	r2, [pc, #132]	@ (3401336c <RCCEx_GetSAICLKFreq+0x2c0>)
340132e8:	fa22 f303 	lsr.w	r3, r2, r3
340132ec:	60fb      	str	r3, [r7, #12]
      }
      break;
340132ee:	e015      	b.n	3401331c <RCCEx_GetSAICLKFreq+0x270>

    case LL_RCC_SAI1_CLKSOURCE_MSI:
    case LL_RCC_SAI2_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
340132f0:	f7f5 fa5e 	bl	340087b0 <LL_RCC_MSI_IsReady>
340132f4:	4603      	mov	r3, r0
340132f6:	2b00      	cmp	r3, #0
340132f8:	d012      	beq.n	34013320 <RCCEx_GetSAICLKFreq+0x274>
      {
        sai_frequency = MSI_VALUE;
340132fa:	4b1d      	ldr	r3, [pc, #116]	@ (34013370 <RCCEx_GetSAICLKFreq+0x2c4>)
340132fc:	60fb      	str	r3, [r7, #12]
      }
      break;
340132fe:	e00f      	b.n	34013320 <RCCEx_GetSAICLKFreq+0x274>

    case LL_RCC_SAI1_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SAI2_CLKSOURCE_I2S_CKIN:
      sai_frequency = EXTERNAL_CLOCK_VALUE;
34013300:	4b1c      	ldr	r3, [pc, #112]	@ (34013374 <RCCEx_GetSAICLKFreq+0x2c8>)
34013302:	60fb      	str	r3, [r7, #12]
      break;
34013304:	e00d      	b.n	34013322 <RCCEx_GetSAICLKFreq+0x276>

    case LL_RCC_SAI1_CLKSOURCE_SPDIFRX1:
    case LL_RCC_SAI2_CLKSOURCE_SPDIFRX1:
      sai_frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
34013306:	2007      	movs	r0, #7
34013308:	f000 f920 	bl	3401354c <RCCEx_GetSPDIFRXCLKFreq>
3401330c:	60f8      	str	r0, [r7, #12]
      break;
3401330e:	e008      	b.n	34013322 <RCCEx_GetSAICLKFreq+0x276>

    default:
      /* Unexpected case */
      break;
34013310:	bf00      	nop
34013312:	e006      	b.n	34013322 <RCCEx_GetSAICLKFreq+0x276>
      break;
34013314:	bf00      	nop
34013316:	e004      	b.n	34013322 <RCCEx_GetSAICLKFreq+0x276>
      break;
34013318:	bf00      	nop
3401331a:	e002      	b.n	34013322 <RCCEx_GetSAICLKFreq+0x276>
      break;
3401331c:	bf00      	nop
3401331e:	e000      	b.n	34013322 <RCCEx_GetSAICLKFreq+0x276>
      break;
34013320:	bf00      	nop
  }

  return sai_frequency;
34013322:	68fb      	ldr	r3, [r7, #12]
}
34013324:	4618      	mov	r0, r3
34013326:	3710      	adds	r7, #16
34013328:	46bd      	mov	sp, r7
3401332a:	bd80      	pop	{r7, pc}
3401332c:	07071818 	.word	0x07071818
34013330:	07071418 	.word	0x07071418
34013334:	07061818 	.word	0x07061818
34013338:	07061418 	.word	0x07061418
3401333c:	07051818 	.word	0x07051818
34013340:	07051418 	.word	0x07051418
34013344:	07041818 	.word	0x07041818
34013348:	07041418 	.word	0x07041418
3401334c:	07031818 	.word	0x07031818
34013350:	07031418 	.word	0x07031418
34013354:	07021818 	.word	0x07021818
34013358:	07021418 	.word	0x07021418
3401335c:	07011818 	.word	0x07011818
34013360:	07011418 	.word	0x07011418
34013364:	07001418 	.word	0x07001418
34013368:	07001818 	.word	0x07001818
3401336c:	03d09000 	.word	0x03d09000
34013370:	003d0900 	.word	0x003d0900
34013374:	00bb8000 	.word	0x00bb8000

34013378 <RCCEx_GetSDMMCCLKFreq>:
  *         @arg @ref RCCEx_SDMMC2_Clock_Source
  * @retval SDMMC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSDMMCCLKFreq(uint32_t SDMMCxSource)
{
34013378:	b580      	push	{r7, lr}
3401337a:	b084      	sub	sp, #16
3401337c:	af00      	add	r7, sp, #0
3401337e:	6078      	str	r0, [r7, #4]
  uint32_t sdmmc_frequency = RCC_PERIPH_FREQUENCY_NO;
34013380:	2300      	movs	r3, #0
34013382:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
34013384:	6878      	ldr	r0, [r7, #4]
34013386:	f7f5 fdb1 	bl	34008eec <LL_RCC_GetSDMMCClockSource>
3401338a:	4603      	mov	r3, r0
3401338c:	4a67      	ldr	r2, [pc, #412]	@ (3401352c <RCCEx_GetSDMMCCLKFreq+0x1b4>)
3401338e:	4293      	cmp	r3, r2
34013390:	d07e      	beq.n	34013490 <RCCEx_GetSDMMCCLKFreq+0x118>
34013392:	4a66      	ldr	r2, [pc, #408]	@ (3401352c <RCCEx_GetSDMMCCLKFreq+0x1b4>)
34013394:	4293      	cmp	r3, r2
34013396:	f200 80be 	bhi.w	34013516 <RCCEx_GetSDMMCCLKFreq+0x19e>
3401339a:	4a65      	ldr	r2, [pc, #404]	@ (34013530 <RCCEx_GetSDMMCCLKFreq+0x1b8>)
3401339c:	4293      	cmp	r3, r2
3401339e:	d077      	beq.n	34013490 <RCCEx_GetSDMMCCLKFreq+0x118>
340133a0:	4a63      	ldr	r2, [pc, #396]	@ (34013530 <RCCEx_GetSDMMCCLKFreq+0x1b8>)
340133a2:	4293      	cmp	r3, r2
340133a4:	f200 80b7 	bhi.w	34013516 <RCCEx_GetSDMMCCLKFreq+0x19e>
340133a8:	4a62      	ldr	r2, [pc, #392]	@ (34013534 <RCCEx_GetSDMMCCLKFreq+0x1bc>)
340133aa:	4293      	cmp	r3, r2
340133ac:	d02c      	beq.n	34013408 <RCCEx_GetSDMMCCLKFreq+0x90>
340133ae:	4a61      	ldr	r2, [pc, #388]	@ (34013534 <RCCEx_GetSDMMCCLKFreq+0x1bc>)
340133b0:	4293      	cmp	r3, r2
340133b2:	f200 80b0 	bhi.w	34013516 <RCCEx_GetSDMMCCLKFreq+0x19e>
340133b6:	4a60      	ldr	r2, [pc, #384]	@ (34013538 <RCCEx_GetSDMMCCLKFreq+0x1c0>)
340133b8:	4293      	cmp	r3, r2
340133ba:	d025      	beq.n	34013408 <RCCEx_GetSDMMCCLKFreq+0x90>
340133bc:	4a5e      	ldr	r2, [pc, #376]	@ (34013538 <RCCEx_GetSDMMCCLKFreq+0x1c0>)
340133be:	4293      	cmp	r3, r2
340133c0:	f200 80a9 	bhi.w	34013516 <RCCEx_GetSDMMCCLKFreq+0x19e>
340133c4:	4a5d      	ldr	r2, [pc, #372]	@ (3401353c <RCCEx_GetSDMMCCLKFreq+0x1c4>)
340133c6:	4293      	cmp	r3, r2
340133c8:	d019      	beq.n	340133fe <RCCEx_GetSDMMCCLKFreq+0x86>
340133ca:	4a5c      	ldr	r2, [pc, #368]	@ (3401353c <RCCEx_GetSDMMCCLKFreq+0x1c4>)
340133cc:	4293      	cmp	r3, r2
340133ce:	f200 80a2 	bhi.w	34013516 <RCCEx_GetSDMMCCLKFreq+0x19e>
340133d2:	4a5b      	ldr	r2, [pc, #364]	@ (34013540 <RCCEx_GetSDMMCCLKFreq+0x1c8>)
340133d4:	4293      	cmp	r3, r2
340133d6:	d012      	beq.n	340133fe <RCCEx_GetSDMMCCLKFreq+0x86>
340133d8:	4a59      	ldr	r2, [pc, #356]	@ (34013540 <RCCEx_GetSDMMCCLKFreq+0x1c8>)
340133da:	4293      	cmp	r3, r2
340133dc:	f200 809b 	bhi.w	34013516 <RCCEx_GetSDMMCCLKFreq+0x19e>
340133e0:	4a58      	ldr	r2, [pc, #352]	@ (34013544 <RCCEx_GetSDMMCCLKFreq+0x1cc>)
340133e2:	4293      	cmp	r3, r2
340133e4:	d003      	beq.n	340133ee <RCCEx_GetSDMMCCLKFreq+0x76>
340133e6:	4a58      	ldr	r2, [pc, #352]	@ (34013548 <RCCEx_GetSDMMCCLKFreq+0x1d0>)
340133e8:	4293      	cmp	r3, r2
340133ea:	f040 8094 	bne.w	34013516 <RCCEx_GetSDMMCCLKFreq+0x19e>
  {
    case LL_RCC_SDMMC1_CLKSOURCE_HCLK:
    case LL_RCC_SDMMC2_CLKSOURCE_HCLK:
      sdmmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
340133ee:	f7f4 fdc1 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
340133f2:	4603      	mov	r3, r0
340133f4:	4618      	mov	r0, r3
340133f6:	f7fd feb5 	bl	34011164 <RCCEx_GetHCLKFreq>
340133fa:	60f8      	str	r0, [r7, #12]
      break;
340133fc:	e090      	b.n	34013520 <RCCEx_GetSDMMCCLKFreq+0x1a8>

    case LL_RCC_SDMMC1_CLKSOURCE_CLKP:
    case LL_RCC_SDMMC2_CLKSOURCE_CLKP:
      sdmmc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340133fe:	2007      	movs	r0, #7
34013400:	f7fe f99c 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
34013404:	60f8      	str	r0, [r7, #12]
      break;
34013406:	e08b      	b.n	34013520 <RCCEx_GetSDMMCCLKFreq+0x1a8>

    case LL_RCC_SDMMC1_CLKSOURCE_IC4:
    case LL_RCC_SDMMC2_CLKSOURCE_IC4:
      if (LL_RCC_IC4_IsEnabled() != 0U)
34013408:	f7f6 f8d6 	bl	340095b8 <LL_RCC_IC4_IsEnabled>
3401340c:	4603      	mov	r3, r0
3401340e:	2b00      	cmp	r3, #0
34013410:	f000 8083 	beq.w	3401351a <RCCEx_GetSDMMCCLKFreq+0x1a2>
      {
        ic_divider = LL_RCC_IC4_GetDivider();
34013414:	f7f6 f8f2 	bl	340095fc <LL_RCC_IC4_GetDivider>
34013418:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC4_GetSource())
3401341a:	f7f6 f8e1 	bl	340095e0 <LL_RCC_IC4_GetSource>
3401341e:	4603      	mov	r3, r0
34013420:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013424:	d029      	beq.n	3401347a <RCCEx_GetSDMMCCLKFreq+0x102>
34013426:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401342a:	d82f      	bhi.n	3401348c <RCCEx_GetSDMMCCLKFreq+0x114>
3401342c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013430:	d01a      	beq.n	34013468 <RCCEx_GetSDMMCCLKFreq+0xf0>
34013432:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013436:	d829      	bhi.n	3401348c <RCCEx_GetSDMMCCLKFreq+0x114>
34013438:	2b00      	cmp	r3, #0
3401343a:	d003      	beq.n	34013444 <RCCEx_GetSDMMCCLKFreq+0xcc>
3401343c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013440:	d009      	beq.n	34013456 <RCCEx_GetSDMMCCLKFreq+0xde>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sdmmc_frequency = sdmmc_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34013442:	e023      	b.n	3401348c <RCCEx_GetSDMMCCLKFreq+0x114>
            sdmmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34013444:	f7fd fd76 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34013448:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
3401344a:	68fa      	ldr	r2, [r7, #12]
3401344c:	68bb      	ldr	r3, [r7, #8]
3401344e:	fbb2 f3f3 	udiv	r3, r2, r3
34013452:	60fb      	str	r3, [r7, #12]
            break;
34013454:	e01b      	b.n	3401348e <RCCEx_GetSDMMCCLKFreq+0x116>
            sdmmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34013456:	f7fd fdb3 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
3401345a:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
3401345c:	68fa      	ldr	r2, [r7, #12]
3401345e:	68bb      	ldr	r3, [r7, #8]
34013460:	fbb2 f3f3 	udiv	r3, r2, r3
34013464:	60fb      	str	r3, [r7, #12]
            break;
34013466:	e012      	b.n	3401348e <RCCEx_GetSDMMCCLKFreq+0x116>
            sdmmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34013468:	f7fd fdf0 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
3401346c:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
3401346e:	68fa      	ldr	r2, [r7, #12]
34013470:	68bb      	ldr	r3, [r7, #8]
34013472:	fbb2 f3f3 	udiv	r3, r2, r3
34013476:	60fb      	str	r3, [r7, #12]
            break;
34013478:	e009      	b.n	3401348e <RCCEx_GetSDMMCCLKFreq+0x116>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401347a:	f7fd fe2d 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
3401347e:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34013480:	68fa      	ldr	r2, [r7, #12]
34013482:	68bb      	ldr	r3, [r7, #8]
34013484:	fbb2 f3f3 	udiv	r3, r2, r3
34013488:	60fb      	str	r3, [r7, #12]
            break;
3401348a:	e000      	b.n	3401348e <RCCEx_GetSDMMCCLKFreq+0x116>
            break;
3401348c:	bf00      	nop
        }
      }
      break;
3401348e:	e044      	b.n	3401351a <RCCEx_GetSDMMCCLKFreq+0x1a2>

    case LL_RCC_SDMMC1_CLKSOURCE_IC5:
    case LL_RCC_SDMMC2_CLKSOURCE_IC5:
      if (LL_RCC_IC5_IsEnabled() != 0U)
34013490:	f7f6 f8d2 	bl	34009638 <LL_RCC_IC5_IsEnabled>
34013494:	4603      	mov	r3, r0
34013496:	2b00      	cmp	r3, #0
34013498:	d041      	beq.n	3401351e <RCCEx_GetSDMMCCLKFreq+0x1a6>
      {
        ic_divider = LL_RCC_IC5_GetDivider();
3401349a:	f7f6 f8ef 	bl	3400967c <LL_RCC_IC5_GetDivider>
3401349e:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC5_GetSource())
340134a0:	f7f6 f8de 	bl	34009660 <LL_RCC_IC5_GetSource>
340134a4:	4603      	mov	r3, r0
340134a6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340134aa:	d029      	beq.n	34013500 <RCCEx_GetSDMMCCLKFreq+0x188>
340134ac:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340134b0:	d82f      	bhi.n	34013512 <RCCEx_GetSDMMCCLKFreq+0x19a>
340134b2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340134b6:	d01a      	beq.n	340134ee <RCCEx_GetSDMMCCLKFreq+0x176>
340134b8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340134bc:	d829      	bhi.n	34013512 <RCCEx_GetSDMMCCLKFreq+0x19a>
340134be:	2b00      	cmp	r3, #0
340134c0:	d003      	beq.n	340134ca <RCCEx_GetSDMMCCLKFreq+0x152>
340134c2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340134c6:	d009      	beq.n	340134dc <RCCEx_GetSDMMCCLKFreq+0x164>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sdmmc_frequency = sdmmc_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
340134c8:	e023      	b.n	34013512 <RCCEx_GetSDMMCCLKFreq+0x19a>
            sdmmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340134ca:	f7fd fd33 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
340134ce:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
340134d0:	68fa      	ldr	r2, [r7, #12]
340134d2:	68bb      	ldr	r3, [r7, #8]
340134d4:	fbb2 f3f3 	udiv	r3, r2, r3
340134d8:	60fb      	str	r3, [r7, #12]
            break;
340134da:	e01b      	b.n	34013514 <RCCEx_GetSDMMCCLKFreq+0x19c>
            sdmmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340134dc:	f7fd fd70 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
340134e0:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
340134e2:	68fa      	ldr	r2, [r7, #12]
340134e4:	68bb      	ldr	r3, [r7, #8]
340134e6:	fbb2 f3f3 	udiv	r3, r2, r3
340134ea:	60fb      	str	r3, [r7, #12]
            break;
340134ec:	e012      	b.n	34013514 <RCCEx_GetSDMMCCLKFreq+0x19c>
            sdmmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340134ee:	f7fd fdad 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
340134f2:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
340134f4:	68fa      	ldr	r2, [r7, #12]
340134f6:	68bb      	ldr	r3, [r7, #8]
340134f8:	fbb2 f3f3 	udiv	r3, r2, r3
340134fc:	60fb      	str	r3, [r7, #12]
            break;
340134fe:	e009      	b.n	34013514 <RCCEx_GetSDMMCCLKFreq+0x19c>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34013500:	f7fd fdea 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34013504:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34013506:	68fa      	ldr	r2, [r7, #12]
34013508:	68bb      	ldr	r3, [r7, #8]
3401350a:	fbb2 f3f3 	udiv	r3, r2, r3
3401350e:	60fb      	str	r3, [r7, #12]
            break;
34013510:	e000      	b.n	34013514 <RCCEx_GetSDMMCCLKFreq+0x19c>
            break;
34013512:	bf00      	nop
        }
      }
      break;
34013514:	e003      	b.n	3401351e <RCCEx_GetSDMMCCLKFreq+0x1a6>

    default:
      /* Unexpected case */
      break;
34013516:	bf00      	nop
34013518:	e002      	b.n	34013520 <RCCEx_GetSDMMCCLKFreq+0x1a8>
      break;
3401351a:	bf00      	nop
3401351c:	e000      	b.n	34013520 <RCCEx_GetSDMMCCLKFreq+0x1a8>
      break;
3401351e:	bf00      	nop
  }

  return sdmmc_frequency;
34013520:	68fb      	ldr	r3, [r7, #12]
}
34013522:	4618      	mov	r0, r3
34013524:	3710      	adds	r7, #16
34013526:	46bd      	mov	sp, r7
34013528:	bd80      	pop	{r7, pc}
3401352a:	bf00      	nop
3401352c:	0303041c 	.word	0x0303041c
34013530:	0303001c 	.word	0x0303001c
34013534:	0302041c 	.word	0x0302041c
34013538:	0302001c 	.word	0x0302001c
3401353c:	0301041c 	.word	0x0301041c
34013540:	0301001c 	.word	0x0301001c
34013544:	0300001c 	.word	0x0300001c
34013548:	0300041c 	.word	0x0300041c

3401354c <RCCEx_GetSPDIFRXCLKFreq>:
  *         @arg @ref RCCEx_SPDIFRX1_Clock_Source
  * @retval SPDIF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSPDIFRXCLKFreq(uint32_t SPDIFRXxSource)
{
3401354c:	b580      	push	{r7, lr}
3401354e:	b084      	sub	sp, #16
34013550:	af00      	add	r7, sp, #0
34013552:	6078      	str	r0, [r7, #4]
  uint32_t spdifrx_frequency = RCC_PERIPH_FREQUENCY_NO;
34013554:	2300      	movs	r3, #0
34013556:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSPDIFRXClockSource(SPDIFRXxSource))
34013558:	6878      	ldr	r0, [r7, #4]
3401355a:	f7f5 fcd3 	bl	34008f04 <LL_RCC_GetSPDIFRXClockSource>
3401355e:	4603      	mov	r3, r0
34013560:	2b06      	cmp	r3, #6
34013562:	f200 80c2 	bhi.w	340136ea <RCCEx_GetSPDIFRXCLKFreq+0x19e>
34013566:	a201      	add	r2, pc, #4	@ (adr r2, 3401356c <RCCEx_GetSPDIFRXCLKFreq+0x20>)
34013568:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3401356c:	34013589 	.word	0x34013589
34013570:	340135a1 	.word	0x340135a1
34013574:	340135ab 	.word	0x340135ab
34013578:	34013633 	.word	0x34013633
3401357c:	340136d5 	.word	0x340136d5
34013580:	340136b9 	.word	0x340136b9
34013584:	340136e5 	.word	0x340136e5
  {
    case LL_RCC_SPDIFRX1_CLKSOURCE_PCLK1:
      spdifrx_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34013588:	f7f4 fcf4 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
3401358c:	4603      	mov	r3, r0
3401358e:	4618      	mov	r0, r3
34013590:	f7fd fde8 	bl	34011164 <RCCEx_GetHCLKFreq>
34013594:	4603      	mov	r3, r0
34013596:	4618      	mov	r0, r3
34013598:	f7fd fdf5 	bl	34011186 <RCCEx_GetPCLK1Freq>
3401359c:	60f8      	str	r0, [r7, #12]
      break;
3401359e:	e0ad      	b.n	340136fc <RCCEx_GetSPDIFRXCLKFreq+0x1b0>

    case LL_RCC_SPDIFRX1_CLKSOURCE_CLKP:
      spdifrx_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340135a0:	2007      	movs	r0, #7
340135a2:	f7fe f8cb 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
340135a6:	60f8      	str	r0, [r7, #12]
      break;
340135a8:	e0a8      	b.n	340136fc <RCCEx_GetSPDIFRXCLKFreq+0x1b0>

    case LL_RCC_SPDIFRX1_CLKSOURCE_IC7:
      if (LL_RCC_IC7_IsEnabled() != 0U)
340135aa:	f7f6 f885 	bl	340096b8 <LL_RCC_IC7_IsEnabled>
340135ae:	4603      	mov	r3, r0
340135b0:	2b00      	cmp	r3, #0
340135b2:	f000 809c 	beq.w	340136ee <RCCEx_GetSPDIFRXCLKFreq+0x1a2>
      {
        ic_divider = LL_RCC_IC7_GetDivider();
340135b6:	f7f6 f8a1 	bl	340096fc <LL_RCC_IC7_GetDivider>
340135ba:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
340135bc:	f7f6 f890 	bl	340096e0 <LL_RCC_IC7_GetSource>
340135c0:	4603      	mov	r3, r0
340135c2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340135c6:	d029      	beq.n	3401361c <RCCEx_GetSPDIFRXCLKFreq+0xd0>
340135c8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340135cc:	d82f      	bhi.n	3401362e <RCCEx_GetSPDIFRXCLKFreq+0xe2>
340135ce:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340135d2:	d01a      	beq.n	3401360a <RCCEx_GetSPDIFRXCLKFreq+0xbe>
340135d4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340135d8:	d829      	bhi.n	3401362e <RCCEx_GetSPDIFRXCLKFreq+0xe2>
340135da:	2b00      	cmp	r3, #0
340135dc:	d003      	beq.n	340135e6 <RCCEx_GetSPDIFRXCLKFreq+0x9a>
340135de:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340135e2:	d009      	beq.n	340135f8 <RCCEx_GetSPDIFRXCLKFreq+0xac>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spdifrx_frequency = spdifrx_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
340135e4:	e023      	b.n	3401362e <RCCEx_GetSPDIFRXCLKFreq+0xe2>
            spdifrx_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340135e6:	f7fd fca5 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
340135ea:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
340135ec:	68fa      	ldr	r2, [r7, #12]
340135ee:	68bb      	ldr	r3, [r7, #8]
340135f0:	fbb2 f3f3 	udiv	r3, r2, r3
340135f4:	60fb      	str	r3, [r7, #12]
            break;
340135f6:	e01b      	b.n	34013630 <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            spdifrx_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340135f8:	f7fd fce2 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
340135fc:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
340135fe:	68fa      	ldr	r2, [r7, #12]
34013600:	68bb      	ldr	r3, [r7, #8]
34013602:	fbb2 f3f3 	udiv	r3, r2, r3
34013606:	60fb      	str	r3, [r7, #12]
            break;
34013608:	e012      	b.n	34013630 <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            spdifrx_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401360a:	f7fd fd1f 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
3401360e:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34013610:	68fa      	ldr	r2, [r7, #12]
34013612:	68bb      	ldr	r3, [r7, #8]
34013614:	fbb2 f3f3 	udiv	r3, r2, r3
34013618:	60fb      	str	r3, [r7, #12]
            break;
3401361a:	e009      	b.n	34013630 <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401361c:	f7fd fd5c 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34013620:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34013622:	68fa      	ldr	r2, [r7, #12]
34013624:	68bb      	ldr	r3, [r7, #8]
34013626:	fbb2 f3f3 	udiv	r3, r2, r3
3401362a:	60fb      	str	r3, [r7, #12]
            break;
3401362c:	e000      	b.n	34013630 <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            break;
3401362e:	bf00      	nop
        }
      }
      break;
34013630:	e05d      	b.n	340136ee <RCCEx_GetSPDIFRXCLKFreq+0x1a2>

    case LL_RCC_SPDIFRX1_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
34013632:	f7f6 f881 	bl	34009738 <LL_RCC_IC8_IsEnabled>
34013636:	4603      	mov	r3, r0
34013638:	2b00      	cmp	r3, #0
3401363a:	d05a      	beq.n	340136f2 <RCCEx_GetSPDIFRXCLKFreq+0x1a6>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
3401363c:	f7f6 f89e 	bl	3400977c <LL_RCC_IC8_GetDivider>
34013640:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34013642:	f7f6 f88d 	bl	34009760 <LL_RCC_IC8_GetSource>
34013646:	4603      	mov	r3, r0
34013648:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401364c:	d029      	beq.n	340136a2 <RCCEx_GetSPDIFRXCLKFreq+0x156>
3401364e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013652:	d82f      	bhi.n	340136b4 <RCCEx_GetSPDIFRXCLKFreq+0x168>
34013654:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013658:	d01a      	beq.n	34013690 <RCCEx_GetSPDIFRXCLKFreq+0x144>
3401365a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401365e:	d829      	bhi.n	340136b4 <RCCEx_GetSPDIFRXCLKFreq+0x168>
34013660:	2b00      	cmp	r3, #0
34013662:	d003      	beq.n	3401366c <RCCEx_GetSPDIFRXCLKFreq+0x120>
34013664:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013668:	d009      	beq.n	3401367e <RCCEx_GetSPDIFRXCLKFreq+0x132>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spdifrx_frequency = spdifrx_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3401366a:	e023      	b.n	340136b4 <RCCEx_GetSPDIFRXCLKFreq+0x168>
            spdifrx_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3401366c:	f7fd fc62 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34013670:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34013672:	68fa      	ldr	r2, [r7, #12]
34013674:	68bb      	ldr	r3, [r7, #8]
34013676:	fbb2 f3f3 	udiv	r3, r2, r3
3401367a:	60fb      	str	r3, [r7, #12]
            break;
3401367c:	e01b      	b.n	340136b6 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            spdifrx_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3401367e:	f7fd fc9f 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34013682:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34013684:	68fa      	ldr	r2, [r7, #12]
34013686:	68bb      	ldr	r3, [r7, #8]
34013688:	fbb2 f3f3 	udiv	r3, r2, r3
3401368c:	60fb      	str	r3, [r7, #12]
            break;
3401368e:	e012      	b.n	340136b6 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            spdifrx_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34013690:	f7fd fcdc 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34013694:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34013696:	68fa      	ldr	r2, [r7, #12]
34013698:	68bb      	ldr	r3, [r7, #8]
3401369a:	fbb2 f3f3 	udiv	r3, r2, r3
3401369e:	60fb      	str	r3, [r7, #12]
            break;
340136a0:	e009      	b.n	340136b6 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340136a2:	f7fd fd19 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
340136a6:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
340136a8:	68fa      	ldr	r2, [r7, #12]
340136aa:	68bb      	ldr	r3, [r7, #8]
340136ac:	fbb2 f3f3 	udiv	r3, r2, r3
340136b0:	60fb      	str	r3, [r7, #12]
            break;
340136b2:	e000      	b.n	340136b6 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            break;
340136b4:	bf00      	nop
        }
      }
      break;
340136b6:	e01c      	b.n	340136f2 <RCCEx_GetSPDIFRXCLKFreq+0x1a6>

    case LL_RCC_SPDIFRX1_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
340136b8:	f7f5 f85a 	bl	34008770 <LL_RCC_HSI_IsReady>
340136bc:	4603      	mov	r3, r0
340136be:	2b00      	cmp	r3, #0
340136c0:	d019      	beq.n	340136f6 <RCCEx_GetSPDIFRXCLKFreq+0x1aa>
      {
        spdifrx_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340136c2:	f7f5 f867 	bl	34008794 <LL_RCC_HSI_GetDivider>
340136c6:	4603      	mov	r3, r0
340136c8:	09db      	lsrs	r3, r3, #7
340136ca:	4a0f      	ldr	r2, [pc, #60]	@ (34013708 <RCCEx_GetSPDIFRXCLKFreq+0x1bc>)
340136cc:	fa22 f303 	lsr.w	r3, r2, r3
340136d0:	60fb      	str	r3, [r7, #12]
      }
      break;
340136d2:	e010      	b.n	340136f6 <RCCEx_GetSPDIFRXCLKFreq+0x1aa>

    case LL_RCC_SPDIFRX1_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
340136d4:	f7f5 f86c 	bl	340087b0 <LL_RCC_MSI_IsReady>
340136d8:	4603      	mov	r3, r0
340136da:	2b00      	cmp	r3, #0
340136dc:	d00d      	beq.n	340136fa <RCCEx_GetSPDIFRXCLKFreq+0x1ae>
      {
        spdifrx_frequency = MSI_VALUE;
340136de:	4b0b      	ldr	r3, [pc, #44]	@ (3401370c <RCCEx_GetSPDIFRXCLKFreq+0x1c0>)
340136e0:	60fb      	str	r3, [r7, #12]
      }
      break;
340136e2:	e00a      	b.n	340136fa <RCCEx_GetSPDIFRXCLKFreq+0x1ae>

    case LL_RCC_SPDIFRX1_CLKSOURCE_I2S_CKIN:
      spdifrx_frequency = EXTERNAL_CLOCK_VALUE;
340136e4:	4b0a      	ldr	r3, [pc, #40]	@ (34013710 <RCCEx_GetSPDIFRXCLKFreq+0x1c4>)
340136e6:	60fb      	str	r3, [r7, #12]
      break;
340136e8:	e008      	b.n	340136fc <RCCEx_GetSPDIFRXCLKFreq+0x1b0>

    default:
      /* Unexpected case */
      break;
340136ea:	bf00      	nop
340136ec:	e006      	b.n	340136fc <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
340136ee:	bf00      	nop
340136f0:	e004      	b.n	340136fc <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
340136f2:	bf00      	nop
340136f4:	e002      	b.n	340136fc <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
340136f6:	bf00      	nop
340136f8:	e000      	b.n	340136fc <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
340136fa:	bf00      	nop
  }

  return spdifrx_frequency;
340136fc:	68fb      	ldr	r3, [r7, #12]
}
340136fe:	4618      	mov	r0, r3
34013700:	3710      	adds	r7, #16
34013702:	46bd      	mov	sp, r7
34013704:	bd80      	pop	{r7, pc}
34013706:	bf00      	nop
34013708:	03d09000 	.word	0x03d09000
3401370c:	003d0900 	.word	0x003d0900
34013710:	00bb8000 	.word	0x00bb8000

34013714 <RCCEx_GetSPICLKFreq>:
  *         @arg @ref RCCEx_SPI6_Clock_Source
  * @retval SPI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSPICLKFreq(uint32_t SPIxSource)
{
34013714:	b580      	push	{r7, lr}
34013716:	b084      	sub	sp, #16
34013718:	af00      	add	r7, sp, #0
3401371a:	6078      	str	r0, [r7, #4]
  uint32_t spi_frequency = RCC_PERIPH_FREQUENCY_NO;
3401371c:	2300      	movs	r3, #0
3401371e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSPIClockSource(SPIxSource))
34013720:	6878      	ldr	r0, [r7, #4]
34013722:	f7f5 fc01 	bl	34008f28 <LL_RCC_GetSPIClockSource>
34013726:	4603      	mov	r3, r0
34013728:	4aa7      	ldr	r2, [pc, #668]	@ (340139c8 <RCCEx_GetSPICLKFreq+0x2b4>)
3401372a:	4293      	cmp	r3, r2
3401372c:	f000 829e 	beq.w	34013c6c <RCCEx_GetSPICLKFreq+0x558>
34013730:	4aa5      	ldr	r2, [pc, #660]	@ (340139c8 <RCCEx_GetSPICLKFreq+0x2b4>)
34013732:	4293      	cmp	r3, r2
34013734:	f200 82a5 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013738:	4aa4      	ldr	r2, [pc, #656]	@ (340139cc <RCCEx_GetSPICLKFreq+0x2b8>)
3401373a:	4293      	cmp	r3, r2
3401373c:	f000 8299 	beq.w	34013c72 <RCCEx_GetSPICLKFreq+0x55e>
34013740:	4aa2      	ldr	r2, [pc, #648]	@ (340139cc <RCCEx_GetSPICLKFreq+0x2b8>)
34013742:	4293      	cmp	r3, r2
34013744:	f200 829d 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013748:	4aa1      	ldr	r2, [pc, #644]	@ (340139d0 <RCCEx_GetSPICLKFreq+0x2bc>)
3401374a:	4293      	cmp	r3, r2
3401374c:	f000 8291 	beq.w	34013c72 <RCCEx_GetSPICLKFreq+0x55e>
34013750:	4a9f      	ldr	r2, [pc, #636]	@ (340139d0 <RCCEx_GetSPICLKFreq+0x2bc>)
34013752:	4293      	cmp	r3, r2
34013754:	f200 8295 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013758:	4a9e      	ldr	r2, [pc, #632]	@ (340139d4 <RCCEx_GetSPICLKFreq+0x2c0>)
3401375a:	4293      	cmp	r3, r2
3401375c:	f000 8286 	beq.w	34013c6c <RCCEx_GetSPICLKFreq+0x558>
34013760:	4a9c      	ldr	r2, [pc, #624]	@ (340139d4 <RCCEx_GetSPICLKFreq+0x2c0>)
34013762:	4293      	cmp	r3, r2
34013764:	f200 828d 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013768:	4a9b      	ldr	r2, [pc, #620]	@ (340139d8 <RCCEx_GetSPICLKFreq+0x2c4>)
3401376a:	4293      	cmp	r3, r2
3401376c:	f000 827e 	beq.w	34013c6c <RCCEx_GetSPICLKFreq+0x558>
34013770:	4a99      	ldr	r2, [pc, #612]	@ (340139d8 <RCCEx_GetSPICLKFreq+0x2c4>)
34013772:	4293      	cmp	r3, r2
34013774:	f200 8285 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013778:	4a98      	ldr	r2, [pc, #608]	@ (340139dc <RCCEx_GetSPICLKFreq+0x2c8>)
3401377a:	4293      	cmp	r3, r2
3401377c:	f000 8276 	beq.w	34013c6c <RCCEx_GetSPICLKFreq+0x558>
34013780:	4a96      	ldr	r2, [pc, #600]	@ (340139dc <RCCEx_GetSPICLKFreq+0x2c8>)
34013782:	4293      	cmp	r3, r2
34013784:	f200 827d 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013788:	4a95      	ldr	r2, [pc, #596]	@ (340139e0 <RCCEx_GetSPICLKFreq+0x2cc>)
3401378a:	4293      	cmp	r3, r2
3401378c:	f000 8258 	beq.w	34013c40 <RCCEx_GetSPICLKFreq+0x52c>
34013790:	4a93      	ldr	r2, [pc, #588]	@ (340139e0 <RCCEx_GetSPICLKFreq+0x2cc>)
34013792:	4293      	cmp	r3, r2
34013794:	f200 8275 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013798:	4a92      	ldr	r2, [pc, #584]	@ (340139e4 <RCCEx_GetSPICLKFreq+0x2d0>)
3401379a:	4293      	cmp	r3, r2
3401379c:	f000 8250 	beq.w	34013c40 <RCCEx_GetSPICLKFreq+0x52c>
340137a0:	4a90      	ldr	r2, [pc, #576]	@ (340139e4 <RCCEx_GetSPICLKFreq+0x2d0>)
340137a2:	4293      	cmp	r3, r2
340137a4:	f200 826d 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
340137a8:	4a8f      	ldr	r2, [pc, #572]	@ (340139e8 <RCCEx_GetSPICLKFreq+0x2d4>)
340137aa:	4293      	cmp	r3, r2
340137ac:	f000 8248 	beq.w	34013c40 <RCCEx_GetSPICLKFreq+0x52c>
340137b0:	4a8d      	ldr	r2, [pc, #564]	@ (340139e8 <RCCEx_GetSPICLKFreq+0x2d4>)
340137b2:	4293      	cmp	r3, r2
340137b4:	f200 8265 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
340137b8:	4a8c      	ldr	r2, [pc, #560]	@ (340139ec <RCCEx_GetSPICLKFreq+0x2d8>)
340137ba:	4293      	cmp	r3, r2
340137bc:	f000 8240 	beq.w	34013c40 <RCCEx_GetSPICLKFreq+0x52c>
340137c0:	4a8a      	ldr	r2, [pc, #552]	@ (340139ec <RCCEx_GetSPICLKFreq+0x2d8>)
340137c2:	4293      	cmp	r3, r2
340137c4:	f200 825d 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
340137c8:	4a89      	ldr	r2, [pc, #548]	@ (340139f0 <RCCEx_GetSPICLKFreq+0x2dc>)
340137ca:	4293      	cmp	r3, r2
340137cc:	f000 8238 	beq.w	34013c40 <RCCEx_GetSPICLKFreq+0x52c>
340137d0:	4a87      	ldr	r2, [pc, #540]	@ (340139f0 <RCCEx_GetSPICLKFreq+0x2dc>)
340137d2:	4293      	cmp	r3, r2
340137d4:	f200 8255 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
340137d8:	4a86      	ldr	r2, [pc, #536]	@ (340139f4 <RCCEx_GetSPICLKFreq+0x2e0>)
340137da:	4293      	cmp	r3, r2
340137dc:	f000 8230 	beq.w	34013c40 <RCCEx_GetSPICLKFreq+0x52c>
340137e0:	4a84      	ldr	r2, [pc, #528]	@ (340139f4 <RCCEx_GetSPICLKFreq+0x2e0>)
340137e2:	4293      	cmp	r3, r2
340137e4:	f200 824d 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
340137e8:	4a83      	ldr	r2, [pc, #524]	@ (340139f8 <RCCEx_GetSPICLKFreq+0x2e4>)
340137ea:	4293      	cmp	r3, r2
340137ec:	f000 8236 	beq.w	34013c5c <RCCEx_GetSPICLKFreq+0x548>
340137f0:	4a81      	ldr	r2, [pc, #516]	@ (340139f8 <RCCEx_GetSPICLKFreq+0x2e4>)
340137f2:	4293      	cmp	r3, r2
340137f4:	f200 8245 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
340137f8:	4a80      	ldr	r2, [pc, #512]	@ (340139fc <RCCEx_GetSPICLKFreq+0x2e8>)
340137fa:	4293      	cmp	r3, r2
340137fc:	f000 822e 	beq.w	34013c5c <RCCEx_GetSPICLKFreq+0x548>
34013800:	4a7e      	ldr	r2, [pc, #504]	@ (340139fc <RCCEx_GetSPICLKFreq+0x2e8>)
34013802:	4293      	cmp	r3, r2
34013804:	f200 823d 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013808:	4a7d      	ldr	r2, [pc, #500]	@ (34013a00 <RCCEx_GetSPICLKFreq+0x2ec>)
3401380a:	4293      	cmp	r3, r2
3401380c:	f000 8226 	beq.w	34013c5c <RCCEx_GetSPICLKFreq+0x548>
34013810:	4a7b      	ldr	r2, [pc, #492]	@ (34013a00 <RCCEx_GetSPICLKFreq+0x2ec>)
34013812:	4293      	cmp	r3, r2
34013814:	f200 8235 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013818:	4a7a      	ldr	r2, [pc, #488]	@ (34013a04 <RCCEx_GetSPICLKFreq+0x2f0>)
3401381a:	4293      	cmp	r3, r2
3401381c:	f000 821e 	beq.w	34013c5c <RCCEx_GetSPICLKFreq+0x548>
34013820:	4a78      	ldr	r2, [pc, #480]	@ (34013a04 <RCCEx_GetSPICLKFreq+0x2f0>)
34013822:	4293      	cmp	r3, r2
34013824:	f200 822d 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013828:	4a77      	ldr	r2, [pc, #476]	@ (34013a08 <RCCEx_GetSPICLKFreq+0x2f4>)
3401382a:	4293      	cmp	r3, r2
3401382c:	f000 8216 	beq.w	34013c5c <RCCEx_GetSPICLKFreq+0x548>
34013830:	4a75      	ldr	r2, [pc, #468]	@ (34013a08 <RCCEx_GetSPICLKFreq+0x2f4>)
34013832:	4293      	cmp	r3, r2
34013834:	f200 8225 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013838:	4a74      	ldr	r2, [pc, #464]	@ (34013a0c <RCCEx_GetSPICLKFreq+0x2f8>)
3401383a:	4293      	cmp	r3, r2
3401383c:	f000 820e 	beq.w	34013c5c <RCCEx_GetSPICLKFreq+0x548>
34013840:	4a72      	ldr	r2, [pc, #456]	@ (34013a0c <RCCEx_GetSPICLKFreq+0x2f8>)
34013842:	4293      	cmp	r3, r2
34013844:	f200 821d 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013848:	4a71      	ldr	r2, [pc, #452]	@ (34013a10 <RCCEx_GetSPICLKFreq+0x2fc>)
3401384a:	4293      	cmp	r3, r2
3401384c:	f000 8171 	beq.w	34013b32 <RCCEx_GetSPICLKFreq+0x41e>
34013850:	4a6f      	ldr	r2, [pc, #444]	@ (34013a10 <RCCEx_GetSPICLKFreq+0x2fc>)
34013852:	4293      	cmp	r3, r2
34013854:	f200 8215 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013858:	4a6e      	ldr	r2, [pc, #440]	@ (34013a14 <RCCEx_GetSPICLKFreq+0x300>)
3401385a:	4293      	cmp	r3, r2
3401385c:	f000 81ad 	beq.w	34013bba <RCCEx_GetSPICLKFreq+0x4a6>
34013860:	4a6c      	ldr	r2, [pc, #432]	@ (34013a14 <RCCEx_GetSPICLKFreq+0x300>)
34013862:	4293      	cmp	r3, r2
34013864:	f200 820d 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013868:	4a6b      	ldr	r2, [pc, #428]	@ (34013a18 <RCCEx_GetSPICLKFreq+0x304>)
3401386a:	4293      	cmp	r3, r2
3401386c:	f000 81a5 	beq.w	34013bba <RCCEx_GetSPICLKFreq+0x4a6>
34013870:	4a69      	ldr	r2, [pc, #420]	@ (34013a18 <RCCEx_GetSPICLKFreq+0x304>)
34013872:	4293      	cmp	r3, r2
34013874:	f200 8205 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013878:	4a68      	ldr	r2, [pc, #416]	@ (34013a1c <RCCEx_GetSPICLKFreq+0x308>)
3401387a:	4293      	cmp	r3, r2
3401387c:	f000 8159 	beq.w	34013b32 <RCCEx_GetSPICLKFreq+0x41e>
34013880:	4a66      	ldr	r2, [pc, #408]	@ (34013a1c <RCCEx_GetSPICLKFreq+0x308>)
34013882:	4293      	cmp	r3, r2
34013884:	f200 81fd 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013888:	4a65      	ldr	r2, [pc, #404]	@ (34013a20 <RCCEx_GetSPICLKFreq+0x30c>)
3401388a:	4293      	cmp	r3, r2
3401388c:	f000 8151 	beq.w	34013b32 <RCCEx_GetSPICLKFreq+0x41e>
34013890:	4a63      	ldr	r2, [pc, #396]	@ (34013a20 <RCCEx_GetSPICLKFreq+0x30c>)
34013892:	4293      	cmp	r3, r2
34013894:	f200 81f5 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013898:	4a62      	ldr	r2, [pc, #392]	@ (34013a24 <RCCEx_GetSPICLKFreq+0x310>)
3401389a:	4293      	cmp	r3, r2
3401389c:	f000 8149 	beq.w	34013b32 <RCCEx_GetSPICLKFreq+0x41e>
340138a0:	4a60      	ldr	r2, [pc, #384]	@ (34013a24 <RCCEx_GetSPICLKFreq+0x310>)
340138a2:	4293      	cmp	r3, r2
340138a4:	f200 81ed 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
340138a8:	4a5f      	ldr	r2, [pc, #380]	@ (34013a28 <RCCEx_GetSPICLKFreq+0x314>)
340138aa:	4293      	cmp	r3, r2
340138ac:	f000 80fd 	beq.w	34013aaa <RCCEx_GetSPICLKFreq+0x396>
340138b0:	4a5d      	ldr	r2, [pc, #372]	@ (34013a28 <RCCEx_GetSPICLKFreq+0x314>)
340138b2:	4293      	cmp	r3, r2
340138b4:	f200 81e5 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
340138b8:	4a5c      	ldr	r2, [pc, #368]	@ (34013a2c <RCCEx_GetSPICLKFreq+0x318>)
340138ba:	4293      	cmp	r3, r2
340138bc:	f000 8139 	beq.w	34013b32 <RCCEx_GetSPICLKFreq+0x41e>
340138c0:	4a5a      	ldr	r2, [pc, #360]	@ (34013a2c <RCCEx_GetSPICLKFreq+0x318>)
340138c2:	4293      	cmp	r3, r2
340138c4:	f200 81dd 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
340138c8:	4a59      	ldr	r2, [pc, #356]	@ (34013a30 <RCCEx_GetSPICLKFreq+0x31c>)
340138ca:	4293      	cmp	r3, r2
340138cc:	f000 8131 	beq.w	34013b32 <RCCEx_GetSPICLKFreq+0x41e>
340138d0:	4a57      	ldr	r2, [pc, #348]	@ (34013a30 <RCCEx_GetSPICLKFreq+0x31c>)
340138d2:	4293      	cmp	r3, r2
340138d4:	f200 81d5 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
340138d8:	4a56      	ldr	r2, [pc, #344]	@ (34013a34 <RCCEx_GetSPICLKFreq+0x320>)
340138da:	4293      	cmp	r3, r2
340138dc:	f000 80e5 	beq.w	34013aaa <RCCEx_GetSPICLKFreq+0x396>
340138e0:	4a54      	ldr	r2, [pc, #336]	@ (34013a34 <RCCEx_GetSPICLKFreq+0x320>)
340138e2:	4293      	cmp	r3, r2
340138e4:	f200 81cd 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
340138e8:	4a53      	ldr	r2, [pc, #332]	@ (34013a38 <RCCEx_GetSPICLKFreq+0x324>)
340138ea:	4293      	cmp	r3, r2
340138ec:	f000 80dd 	beq.w	34013aaa <RCCEx_GetSPICLKFreq+0x396>
340138f0:	4a51      	ldr	r2, [pc, #324]	@ (34013a38 <RCCEx_GetSPICLKFreq+0x324>)
340138f2:	4293      	cmp	r3, r2
340138f4:	f200 81c5 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
340138f8:	4a50      	ldr	r2, [pc, #320]	@ (34013a3c <RCCEx_GetSPICLKFreq+0x328>)
340138fa:	4293      	cmp	r3, r2
340138fc:	f000 80d5 	beq.w	34013aaa <RCCEx_GetSPICLKFreq+0x396>
34013900:	4a4e      	ldr	r2, [pc, #312]	@ (34013a3c <RCCEx_GetSPICLKFreq+0x328>)
34013902:	4293      	cmp	r3, r2
34013904:	f200 81bd 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013908:	4a4d      	ldr	r2, [pc, #308]	@ (34013a40 <RCCEx_GetSPICLKFreq+0x32c>)
3401390a:	4293      	cmp	r3, r2
3401390c:	f000 80c8 	beq.w	34013aa0 <RCCEx_GetSPICLKFreq+0x38c>
34013910:	4a4b      	ldr	r2, [pc, #300]	@ (34013a40 <RCCEx_GetSPICLKFreq+0x32c>)
34013912:	4293      	cmp	r3, r2
34013914:	f200 81b5 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013918:	4a4a      	ldr	r2, [pc, #296]	@ (34013a44 <RCCEx_GetSPICLKFreq+0x330>)
3401391a:	4293      	cmp	r3, r2
3401391c:	f000 80c0 	beq.w	34013aa0 <RCCEx_GetSPICLKFreq+0x38c>
34013920:	4a48      	ldr	r2, [pc, #288]	@ (34013a44 <RCCEx_GetSPICLKFreq+0x330>)
34013922:	4293      	cmp	r3, r2
34013924:	f200 81ad 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013928:	4a47      	ldr	r2, [pc, #284]	@ (34013a48 <RCCEx_GetSPICLKFreq+0x334>)
3401392a:	4293      	cmp	r3, r2
3401392c:	f000 80b8 	beq.w	34013aa0 <RCCEx_GetSPICLKFreq+0x38c>
34013930:	4a45      	ldr	r2, [pc, #276]	@ (34013a48 <RCCEx_GetSPICLKFreq+0x334>)
34013932:	4293      	cmp	r3, r2
34013934:	f200 81a5 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013938:	4a44      	ldr	r2, [pc, #272]	@ (34013a4c <RCCEx_GetSPICLKFreq+0x338>)
3401393a:	4293      	cmp	r3, r2
3401393c:	f000 80b0 	beq.w	34013aa0 <RCCEx_GetSPICLKFreq+0x38c>
34013940:	4a42      	ldr	r2, [pc, #264]	@ (34013a4c <RCCEx_GetSPICLKFreq+0x338>)
34013942:	4293      	cmp	r3, r2
34013944:	f200 819d 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013948:	4a41      	ldr	r2, [pc, #260]	@ (34013a50 <RCCEx_GetSPICLKFreq+0x33c>)
3401394a:	4293      	cmp	r3, r2
3401394c:	f000 80a8 	beq.w	34013aa0 <RCCEx_GetSPICLKFreq+0x38c>
34013950:	4a3f      	ldr	r2, [pc, #252]	@ (34013a50 <RCCEx_GetSPICLKFreq+0x33c>)
34013952:	4293      	cmp	r3, r2
34013954:	f200 8195 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013958:	4a3e      	ldr	r2, [pc, #248]	@ (34013a54 <RCCEx_GetSPICLKFreq+0x340>)
3401395a:	4293      	cmp	r3, r2
3401395c:	f000 80a0 	beq.w	34013aa0 <RCCEx_GetSPICLKFreq+0x38c>
34013960:	4a3c      	ldr	r2, [pc, #240]	@ (34013a54 <RCCEx_GetSPICLKFreq+0x340>)
34013962:	4293      	cmp	r3, r2
34013964:	f200 818d 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013968:	4a3b      	ldr	r2, [pc, #236]	@ (34013a58 <RCCEx_GetSPICLKFreq+0x344>)
3401396a:	4293      	cmp	r3, r2
3401396c:	f000 808c 	beq.w	34013a88 <RCCEx_GetSPICLKFreq+0x374>
34013970:	4a39      	ldr	r2, [pc, #228]	@ (34013a58 <RCCEx_GetSPICLKFreq+0x344>)
34013972:	4293      	cmp	r3, r2
34013974:	f200 8185 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013978:	4a38      	ldr	r2, [pc, #224]	@ (34013a5c <RCCEx_GetSPICLKFreq+0x348>)
3401397a:	4293      	cmp	r3, r2
3401397c:	d078      	beq.n	34013a70 <RCCEx_GetSPICLKFreq+0x35c>
3401397e:	4a37      	ldr	r2, [pc, #220]	@ (34013a5c <RCCEx_GetSPICLKFreq+0x348>)
34013980:	4293      	cmp	r3, r2
34013982:	f200 817e 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013986:	4a36      	ldr	r2, [pc, #216]	@ (34013a60 <RCCEx_GetSPICLKFreq+0x34c>)
34013988:	4293      	cmp	r3, r2
3401398a:	d071      	beq.n	34013a70 <RCCEx_GetSPICLKFreq+0x35c>
3401398c:	4a34      	ldr	r2, [pc, #208]	@ (34013a60 <RCCEx_GetSPICLKFreq+0x34c>)
3401398e:	4293      	cmp	r3, r2
34013990:	f200 8177 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
34013994:	4a33      	ldr	r2, [pc, #204]	@ (34013a64 <RCCEx_GetSPICLKFreq+0x350>)
34013996:	4293      	cmp	r3, r2
34013998:	d00a      	beq.n	340139b0 <RCCEx_GetSPICLKFreq+0x29c>
3401399a:	4a32      	ldr	r2, [pc, #200]	@ (34013a64 <RCCEx_GetSPICLKFreq+0x350>)
3401399c:	4293      	cmp	r3, r2
3401399e:	f200 8170 	bhi.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
340139a2:	4a31      	ldr	r2, [pc, #196]	@ (34013a68 <RCCEx_GetSPICLKFreq+0x354>)
340139a4:	4293      	cmp	r3, r2
340139a6:	d063      	beq.n	34013a70 <RCCEx_GetSPICLKFreq+0x35c>
340139a8:	4a30      	ldr	r2, [pc, #192]	@ (34013a6c <RCCEx_GetSPICLKFreq+0x358>)
340139aa:	4293      	cmp	r3, r2
340139ac:	f040 8169 	bne.w	34013c82 <RCCEx_GetSPICLKFreq+0x56e>
  {
    case LL_RCC_SPI2_CLKSOURCE_PCLK1:
    case LL_RCC_SPI3_CLKSOURCE_PCLK1:
      spi_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340139b0:	f7f4 fae0 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
340139b4:	4603      	mov	r3, r0
340139b6:	4618      	mov	r0, r3
340139b8:	f7fd fbd4 	bl	34011164 <RCCEx_GetHCLKFreq>
340139bc:	4603      	mov	r3, r0
340139be:	4618      	mov	r0, r3
340139c0:	f7fd fbe1 	bl	34011186 <RCCEx_GetPCLK1Freq>
340139c4:	60f8      	str	r0, [r7, #12]
      break;
340139c6:	e169      	b.n	34013c9c <RCCEx_GetSPICLKFreq+0x588>
340139c8:	07061820 	.word	0x07061820
340139cc:	07061420 	.word	0x07061420
340139d0:	07061020 	.word	0x07061020
340139d4:	07060c20 	.word	0x07060c20
340139d8:	07060820 	.word	0x07060820
340139dc:	07060420 	.word	0x07060420
340139e0:	07051820 	.word	0x07051820
340139e4:	07051420 	.word	0x07051420
340139e8:	07051020 	.word	0x07051020
340139ec:	07050c20 	.word	0x07050c20
340139f0:	07050820 	.word	0x07050820
340139f4:	07050420 	.word	0x07050420
340139f8:	07041820 	.word	0x07041820
340139fc:	07041420 	.word	0x07041420
34013a00:	07041020 	.word	0x07041020
34013a04:	07040c20 	.word	0x07040c20
34013a08:	07040820 	.word	0x07040820
34013a0c:	07040420 	.word	0x07040420
34013a10:	07031820 	.word	0x07031820
34013a14:	07031420 	.word	0x07031420
34013a18:	07031020 	.word	0x07031020
34013a1c:	07030c20 	.word	0x07030c20
34013a20:	07030820 	.word	0x07030820
34013a24:	07030420 	.word	0x07030420
34013a28:	07021820 	.word	0x07021820
34013a2c:	07021420 	.word	0x07021420
34013a30:	07021020 	.word	0x07021020
34013a34:	07020c20 	.word	0x07020c20
34013a38:	07020820 	.word	0x07020820
34013a3c:	07020420 	.word	0x07020420
34013a40:	07011820 	.word	0x07011820
34013a44:	07011420 	.word	0x07011420
34013a48:	07011020 	.word	0x07011020
34013a4c:	07010c20 	.word	0x07010c20
34013a50:	07010820 	.word	0x07010820
34013a54:	07010420 	.word	0x07010420
34013a58:	07001820 	.word	0x07001820
34013a5c:	07001420 	.word	0x07001420
34013a60:	07001020 	.word	0x07001020
34013a64:	07000c20 	.word	0x07000c20
34013a68:	07000420 	.word	0x07000420
34013a6c:	07000820 	.word	0x07000820

    case LL_RCC_SPI1_CLKSOURCE_PCLK2:
    case LL_RCC_SPI4_CLKSOURCE_PCLK2:
    case LL_RCC_SPI5_CLKSOURCE_PCLK2:
      spi_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34013a70:	f7f4 fa80 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34013a74:	4603      	mov	r3, r0
34013a76:	4618      	mov	r0, r3
34013a78:	f7fd fb74 	bl	34011164 <RCCEx_GetHCLKFreq>
34013a7c:	4603      	mov	r3, r0
34013a7e:	4618      	mov	r0, r3
34013a80:	f7fd fb91 	bl	340111a6 <RCCEx_GetPCLK2Freq>
34013a84:	60f8      	str	r0, [r7, #12]
      break;
34013a86:	e109      	b.n	34013c9c <RCCEx_GetSPICLKFreq+0x588>

    case LL_RCC_SPI6_CLKSOURCE_PCLK4:
      spi_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34013a88:	f7f4 fa74 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34013a8c:	4603      	mov	r3, r0
34013a8e:	4618      	mov	r0, r3
34013a90:	f7fd fb68 	bl	34011164 <RCCEx_GetHCLKFreq>
34013a94:	4603      	mov	r3, r0
34013a96:	4618      	mov	r0, r3
34013a98:	f7fd fb96 	bl	340111c8 <RCCEx_GetPCLK4Freq>
34013a9c:	60f8      	str	r0, [r7, #12]
      break;
34013a9e:	e0fd      	b.n	34013c9c <RCCEx_GetSPICLKFreq+0x588>
    case LL_RCC_SPI2_CLKSOURCE_CLKP:
    case LL_RCC_SPI3_CLKSOURCE_CLKP:
    case LL_RCC_SPI4_CLKSOURCE_CLKP:
    case LL_RCC_SPI5_CLKSOURCE_CLKP:
    case LL_RCC_SPI6_CLKSOURCE_CLKP:
      spi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34013aa0:	2007      	movs	r0, #7
34013aa2:	f7fd fe4b 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
34013aa6:	60f8      	str	r0, [r7, #12]
      break;
34013aa8:	e0f8      	b.n	34013c9c <RCCEx_GetSPICLKFreq+0x588>

    case LL_RCC_SPI1_CLKSOURCE_IC8:
    case LL_RCC_SPI2_CLKSOURCE_IC8:
    case LL_RCC_SPI3_CLKSOURCE_IC8:
    case LL_RCC_SPI6_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
34013aaa:	f7f5 fe45 	bl	34009738 <LL_RCC_IC8_IsEnabled>
34013aae:	4603      	mov	r3, r0
34013ab0:	2b00      	cmp	r3, #0
34013ab2:	f000 80e8 	beq.w	34013c86 <RCCEx_GetSPICLKFreq+0x572>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
34013ab6:	f7f5 fe61 	bl	3400977c <LL_RCC_IC8_GetDivider>
34013aba:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34013abc:	f7f5 fe50 	bl	34009760 <LL_RCC_IC8_GetSource>
34013ac0:	4603      	mov	r3, r0
34013ac2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013ac6:	d029      	beq.n	34013b1c <RCCEx_GetSPICLKFreq+0x408>
34013ac8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013acc:	d82f      	bhi.n	34013b2e <RCCEx_GetSPICLKFreq+0x41a>
34013ace:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013ad2:	d01a      	beq.n	34013b0a <RCCEx_GetSPICLKFreq+0x3f6>
34013ad4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013ad8:	d829      	bhi.n	34013b2e <RCCEx_GetSPICLKFreq+0x41a>
34013ada:	2b00      	cmp	r3, #0
34013adc:	d003      	beq.n	34013ae6 <RCCEx_GetSPICLKFreq+0x3d2>
34013ade:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013ae2:	d009      	beq.n	34013af8 <RCCEx_GetSPICLKFreq+0x3e4>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spi_frequency = spi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34013ae4:	e023      	b.n	34013b2e <RCCEx_GetSPICLKFreq+0x41a>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34013ae6:	f7fd fa25 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34013aea:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34013aec:	68fa      	ldr	r2, [r7, #12]
34013aee:	68bb      	ldr	r3, [r7, #8]
34013af0:	fbb2 f3f3 	udiv	r3, r2, r3
34013af4:	60fb      	str	r3, [r7, #12]
            break;
34013af6:	e01b      	b.n	34013b30 <RCCEx_GetSPICLKFreq+0x41c>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34013af8:	f7fd fa62 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34013afc:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34013afe:	68fa      	ldr	r2, [r7, #12]
34013b00:	68bb      	ldr	r3, [r7, #8]
34013b02:	fbb2 f3f3 	udiv	r3, r2, r3
34013b06:	60fb      	str	r3, [r7, #12]
            break;
34013b08:	e012      	b.n	34013b30 <RCCEx_GetSPICLKFreq+0x41c>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34013b0a:	f7fd fa9f 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34013b0e:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34013b10:	68fa      	ldr	r2, [r7, #12]
34013b12:	68bb      	ldr	r3, [r7, #8]
34013b14:	fbb2 f3f3 	udiv	r3, r2, r3
34013b18:	60fb      	str	r3, [r7, #12]
            break;
34013b1a:	e009      	b.n	34013b30 <RCCEx_GetSPICLKFreq+0x41c>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34013b1c:	f7fd fadc 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34013b20:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34013b22:	68fa      	ldr	r2, [r7, #12]
34013b24:	68bb      	ldr	r3, [r7, #8]
34013b26:	fbb2 f3f3 	udiv	r3, r2, r3
34013b2a:	60fb      	str	r3, [r7, #12]
            break;
34013b2c:	e000      	b.n	34013b30 <RCCEx_GetSPICLKFreq+0x41c>
            break;
34013b2e:	bf00      	nop
        }
      }
      break;
34013b30:	e0a9      	b.n	34013c86 <RCCEx_GetSPICLKFreq+0x572>
    case LL_RCC_SPI2_CLKSOURCE_IC9:
    case LL_RCC_SPI3_CLKSOURCE_IC9:
    case LL_RCC_SPI4_CLKSOURCE_IC9:
    case LL_RCC_SPI5_CLKSOURCE_IC9:
    case LL_RCC_SPI6_CLKSOURCE_IC9:
      if (LL_RCC_IC9_IsEnabled() != 0U)
34013b32:	f7f5 fe41 	bl	340097b8 <LL_RCC_IC9_IsEnabled>
34013b36:	4603      	mov	r3, r0
34013b38:	2b00      	cmp	r3, #0
34013b3a:	f000 80a6 	beq.w	34013c8a <RCCEx_GetSPICLKFreq+0x576>
      {
        ic_divider = LL_RCC_IC9_GetDivider();
34013b3e:	f7f5 fe5d 	bl	340097fc <LL_RCC_IC9_GetDivider>
34013b42:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
34013b44:	f7f5 fe4c 	bl	340097e0 <LL_RCC_IC9_GetSource>
34013b48:	4603      	mov	r3, r0
34013b4a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013b4e:	d029      	beq.n	34013ba4 <RCCEx_GetSPICLKFreq+0x490>
34013b50:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013b54:	d82f      	bhi.n	34013bb6 <RCCEx_GetSPICLKFreq+0x4a2>
34013b56:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013b5a:	d01a      	beq.n	34013b92 <RCCEx_GetSPICLKFreq+0x47e>
34013b5c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013b60:	d829      	bhi.n	34013bb6 <RCCEx_GetSPICLKFreq+0x4a2>
34013b62:	2b00      	cmp	r3, #0
34013b64:	d003      	beq.n	34013b6e <RCCEx_GetSPICLKFreq+0x45a>
34013b66:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013b6a:	d009      	beq.n	34013b80 <RCCEx_GetSPICLKFreq+0x46c>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spi_frequency = spi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34013b6c:	e023      	b.n	34013bb6 <RCCEx_GetSPICLKFreq+0x4a2>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34013b6e:	f7fd f9e1 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34013b72:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34013b74:	68fa      	ldr	r2, [r7, #12]
34013b76:	68bb      	ldr	r3, [r7, #8]
34013b78:	fbb2 f3f3 	udiv	r3, r2, r3
34013b7c:	60fb      	str	r3, [r7, #12]
            break;
34013b7e:	e01b      	b.n	34013bb8 <RCCEx_GetSPICLKFreq+0x4a4>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34013b80:	f7fd fa1e 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34013b84:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34013b86:	68fa      	ldr	r2, [r7, #12]
34013b88:	68bb      	ldr	r3, [r7, #8]
34013b8a:	fbb2 f3f3 	udiv	r3, r2, r3
34013b8e:	60fb      	str	r3, [r7, #12]
            break;
34013b90:	e012      	b.n	34013bb8 <RCCEx_GetSPICLKFreq+0x4a4>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34013b92:	f7fd fa5b 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34013b96:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34013b98:	68fa      	ldr	r2, [r7, #12]
34013b9a:	68bb      	ldr	r3, [r7, #8]
34013b9c:	fbb2 f3f3 	udiv	r3, r2, r3
34013ba0:	60fb      	str	r3, [r7, #12]
            break;
34013ba2:	e009      	b.n	34013bb8 <RCCEx_GetSPICLKFreq+0x4a4>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34013ba4:	f7fd fa98 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34013ba8:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34013baa:	68fa      	ldr	r2, [r7, #12]
34013bac:	68bb      	ldr	r3, [r7, #8]
34013bae:	fbb2 f3f3 	udiv	r3, r2, r3
34013bb2:	60fb      	str	r3, [r7, #12]
            break;
34013bb4:	e000      	b.n	34013bb8 <RCCEx_GetSPICLKFreq+0x4a4>
            break;
34013bb6:	bf00      	nop
        }
      }
      break;
34013bb8:	e067      	b.n	34013c8a <RCCEx_GetSPICLKFreq+0x576>

    case LL_RCC_SPI4_CLKSOURCE_IC14:
    case LL_RCC_SPI5_CLKSOURCE_IC14:
      if (LL_RCC_IC14_IsEnabled() != 0U)
34013bba:	f7f5 fefd 	bl	340099b8 <LL_RCC_IC14_IsEnabled>
34013bbe:	4603      	mov	r3, r0
34013bc0:	2b00      	cmp	r3, #0
34013bc2:	d064      	beq.n	34013c8e <RCCEx_GetSPICLKFreq+0x57a>
      {
        ic_divider = LL_RCC_IC14_GetDivider();
34013bc4:	f7f5 ff1a 	bl	340099fc <LL_RCC_IC14_GetDivider>
34013bc8:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
34013bca:	f7f5 ff09 	bl	340099e0 <LL_RCC_IC14_GetSource>
34013bce:	4603      	mov	r3, r0
34013bd0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013bd4:	d029      	beq.n	34013c2a <RCCEx_GetSPICLKFreq+0x516>
34013bd6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013bda:	d82f      	bhi.n	34013c3c <RCCEx_GetSPICLKFreq+0x528>
34013bdc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013be0:	d01a      	beq.n	34013c18 <RCCEx_GetSPICLKFreq+0x504>
34013be2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013be6:	d829      	bhi.n	34013c3c <RCCEx_GetSPICLKFreq+0x528>
34013be8:	2b00      	cmp	r3, #0
34013bea:	d003      	beq.n	34013bf4 <RCCEx_GetSPICLKFreq+0x4e0>
34013bec:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013bf0:	d009      	beq.n	34013c06 <RCCEx_GetSPICLKFreq+0x4f2>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spi_frequency = spi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34013bf2:	e023      	b.n	34013c3c <RCCEx_GetSPICLKFreq+0x528>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34013bf4:	f7fd f99e 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34013bf8:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34013bfa:	68fa      	ldr	r2, [r7, #12]
34013bfc:	68bb      	ldr	r3, [r7, #8]
34013bfe:	fbb2 f3f3 	udiv	r3, r2, r3
34013c02:	60fb      	str	r3, [r7, #12]
            break;
34013c04:	e01b      	b.n	34013c3e <RCCEx_GetSPICLKFreq+0x52a>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34013c06:	f7fd f9db 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34013c0a:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34013c0c:	68fa      	ldr	r2, [r7, #12]
34013c0e:	68bb      	ldr	r3, [r7, #8]
34013c10:	fbb2 f3f3 	udiv	r3, r2, r3
34013c14:	60fb      	str	r3, [r7, #12]
            break;
34013c16:	e012      	b.n	34013c3e <RCCEx_GetSPICLKFreq+0x52a>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34013c18:	f7fd fa18 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34013c1c:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34013c1e:	68fa      	ldr	r2, [r7, #12]
34013c20:	68bb      	ldr	r3, [r7, #8]
34013c22:	fbb2 f3f3 	udiv	r3, r2, r3
34013c26:	60fb      	str	r3, [r7, #12]
            break;
34013c28:	e009      	b.n	34013c3e <RCCEx_GetSPICLKFreq+0x52a>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34013c2a:	f7fd fa55 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34013c2e:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34013c30:	68fa      	ldr	r2, [r7, #12]
34013c32:	68bb      	ldr	r3, [r7, #8]
34013c34:	fbb2 f3f3 	udiv	r3, r2, r3
34013c38:	60fb      	str	r3, [r7, #12]
            break;
34013c3a:	e000      	b.n	34013c3e <RCCEx_GetSPICLKFreq+0x52a>
            break;
34013c3c:	bf00      	nop
        }
      }
      break;
34013c3e:	e026      	b.n	34013c8e <RCCEx_GetSPICLKFreq+0x57a>
    case LL_RCC_SPI2_CLKSOURCE_HSI:
    case LL_RCC_SPI3_CLKSOURCE_HSI:
    case LL_RCC_SPI4_CLKSOURCE_HSI:
    case LL_RCC_SPI5_CLKSOURCE_HSI:
    case LL_RCC_SPI6_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34013c40:	f7f4 fd96 	bl	34008770 <LL_RCC_HSI_IsReady>
34013c44:	4603      	mov	r3, r0
34013c46:	2b00      	cmp	r3, #0
34013c48:	d023      	beq.n	34013c92 <RCCEx_GetSPICLKFreq+0x57e>
      {
        spi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34013c4a:	f7f4 fda3 	bl	34008794 <LL_RCC_HSI_GetDivider>
34013c4e:	4603      	mov	r3, r0
34013c50:	09db      	lsrs	r3, r3, #7
34013c52:	4a15      	ldr	r2, [pc, #84]	@ (34013ca8 <RCCEx_GetSPICLKFreq+0x594>)
34013c54:	fa22 f303 	lsr.w	r3, r2, r3
34013c58:	60fb      	str	r3, [r7, #12]
      }
      break;
34013c5a:	e01a      	b.n	34013c92 <RCCEx_GetSPICLKFreq+0x57e>
    case LL_RCC_SPI2_CLKSOURCE_MSI:
    case LL_RCC_SPI3_CLKSOURCE_MSI:
    case LL_RCC_SPI4_CLKSOURCE_MSI:
    case LL_RCC_SPI5_CLKSOURCE_MSI:
    case LL_RCC_SPI6_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34013c5c:	f7f4 fda8 	bl	340087b0 <LL_RCC_MSI_IsReady>
34013c60:	4603      	mov	r3, r0
34013c62:	2b00      	cmp	r3, #0
34013c64:	d017      	beq.n	34013c96 <RCCEx_GetSPICLKFreq+0x582>
      {
        spi_frequency = MSI_VALUE;
34013c66:	4b11      	ldr	r3, [pc, #68]	@ (34013cac <RCCEx_GetSPICLKFreq+0x598>)
34013c68:	60fb      	str	r3, [r7, #12]
      }
      break;
34013c6a:	e014      	b.n	34013c96 <RCCEx_GetSPICLKFreq+0x582>

    case LL_RCC_SPI1_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SPI2_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SPI3_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SPI6_CLKSOURCE_I2S_CKIN:
      spi_frequency = EXTERNAL_CLOCK_VALUE;
34013c6c:	4b10      	ldr	r3, [pc, #64]	@ (34013cb0 <RCCEx_GetSPICLKFreq+0x59c>)
34013c6e:	60fb      	str	r3, [r7, #12]
      break;
34013c70:	e014      	b.n	34013c9c <RCCEx_GetSPICLKFreq+0x588>

    case LL_RCC_SPI4_CLKSOURCE_HSE:
    case LL_RCC_SPI5_CLKSOURCE_HSE:
      if (LL_RCC_HSE_IsReady() != 0U)
34013c72:	f7f4 fd6b 	bl	3400874c <LL_RCC_HSE_IsReady>
34013c76:	4603      	mov	r3, r0
34013c78:	2b00      	cmp	r3, #0
34013c7a:	d00e      	beq.n	34013c9a <RCCEx_GetSPICLKFreq+0x586>
      {
        spi_frequency = HSE_VALUE;
34013c7c:	4b0d      	ldr	r3, [pc, #52]	@ (34013cb4 <RCCEx_GetSPICLKFreq+0x5a0>)
34013c7e:	60fb      	str	r3, [r7, #12]
      }
      break;
34013c80:	e00b      	b.n	34013c9a <RCCEx_GetSPICLKFreq+0x586>

    default:
      /* Unexpected case */
      break;
34013c82:	bf00      	nop
34013c84:	e00a      	b.n	34013c9c <RCCEx_GetSPICLKFreq+0x588>
      break;
34013c86:	bf00      	nop
34013c88:	e008      	b.n	34013c9c <RCCEx_GetSPICLKFreq+0x588>
      break;
34013c8a:	bf00      	nop
34013c8c:	e006      	b.n	34013c9c <RCCEx_GetSPICLKFreq+0x588>
      break;
34013c8e:	bf00      	nop
34013c90:	e004      	b.n	34013c9c <RCCEx_GetSPICLKFreq+0x588>
      break;
34013c92:	bf00      	nop
34013c94:	e002      	b.n	34013c9c <RCCEx_GetSPICLKFreq+0x588>
      break;
34013c96:	bf00      	nop
34013c98:	e000      	b.n	34013c9c <RCCEx_GetSPICLKFreq+0x588>
      break;
34013c9a:	bf00      	nop
  }

  return spi_frequency;
34013c9c:	68fb      	ldr	r3, [r7, #12]
}
34013c9e:	4618      	mov	r0, r3
34013ca0:	3710      	adds	r7, #16
34013ca2:	46bd      	mov	sp, r7
34013ca4:	bd80      	pop	{r7, pc}
34013ca6:	bf00      	nop
34013ca8:	03d09000 	.word	0x03d09000
34013cac:	003d0900 	.word	0x003d0900
34013cb0:	00bb8000 	.word	0x00bb8000
34013cb4:	02dc6c00 	.word	0x02dc6c00

34013cb8 <RCCEx_GetUARTCLKFreq>:
  *         @arg @ref RCCEx_UART9_Clock_Source
  * @retval USART clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetUARTCLKFreq(uint32_t UARTxSource)
{
34013cb8:	b580      	push	{r7, lr}
34013cba:	b084      	sub	sp, #16
34013cbc:	af00      	add	r7, sp, #0
34013cbe:	6078      	str	r0, [r7, #4]
  uint32_t uart_frequency = RCC_PERIPH_FREQUENCY_NO;
34013cc0:	2300      	movs	r3, #0
34013cc2:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetUARTClockSource(UARTxSource))
34013cc4:	6878      	ldr	r0, [r7, #4]
34013cc6:	f7f5 f947 	bl	34008f58 <LL_RCC_GetUARTClockSource>
34013cca:	4603      	mov	r3, r0
34013ccc:	4aa2      	ldr	r2, [pc, #648]	@ (34013f58 <RCCEx_GetUARTCLKFreq+0x2a0>)
34013cce:	4293      	cmp	r3, r2
34013cd0:	f000 81e8 	beq.w	340140a4 <RCCEx_GetUARTCLKFreq+0x3ec>
34013cd4:	4aa0      	ldr	r2, [pc, #640]	@ (34013f58 <RCCEx_GetUARTCLKFreq+0x2a0>)
34013cd6:	4293      	cmp	r3, r2
34013cd8:	f200 8203 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013cdc:	4a9f      	ldr	r2, [pc, #636]	@ (34013f5c <RCCEx_GetUARTCLKFreq+0x2a4>)
34013cde:	4293      	cmp	r3, r2
34013ce0:	f000 81e0 	beq.w	340140a4 <RCCEx_GetUARTCLKFreq+0x3ec>
34013ce4:	4a9d      	ldr	r2, [pc, #628]	@ (34013f5c <RCCEx_GetUARTCLKFreq+0x2a4>)
34013ce6:	4293      	cmp	r3, r2
34013ce8:	f200 81fb 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013cec:	4a9c      	ldr	r2, [pc, #624]	@ (34013f60 <RCCEx_GetUARTCLKFreq+0x2a8>)
34013cee:	4293      	cmp	r3, r2
34013cf0:	f000 81d8 	beq.w	340140a4 <RCCEx_GetUARTCLKFreq+0x3ec>
34013cf4:	4a9a      	ldr	r2, [pc, #616]	@ (34013f60 <RCCEx_GetUARTCLKFreq+0x2a8>)
34013cf6:	4293      	cmp	r3, r2
34013cf8:	f200 81f3 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013cfc:	4a99      	ldr	r2, [pc, #612]	@ (34013f64 <RCCEx_GetUARTCLKFreq+0x2ac>)
34013cfe:	4293      	cmp	r3, r2
34013d00:	f000 81d0 	beq.w	340140a4 <RCCEx_GetUARTCLKFreq+0x3ec>
34013d04:	4a97      	ldr	r2, [pc, #604]	@ (34013f64 <RCCEx_GetUARTCLKFreq+0x2ac>)
34013d06:	4293      	cmp	r3, r2
34013d08:	f200 81eb 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013d0c:	4a96      	ldr	r2, [pc, #600]	@ (34013f68 <RCCEx_GetUARTCLKFreq+0x2b0>)
34013d0e:	4293      	cmp	r3, r2
34013d10:	f000 81c8 	beq.w	340140a4 <RCCEx_GetUARTCLKFreq+0x3ec>
34013d14:	4a94      	ldr	r2, [pc, #592]	@ (34013f68 <RCCEx_GetUARTCLKFreq+0x2b0>)
34013d16:	4293      	cmp	r3, r2
34013d18:	f200 81e3 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013d1c:	4a93      	ldr	r2, [pc, #588]	@ (34013f6c <RCCEx_GetUARTCLKFreq+0x2b4>)
34013d1e:	4293      	cmp	r3, r2
34013d20:	f000 81ce 	beq.w	340140c0 <RCCEx_GetUARTCLKFreq+0x408>
34013d24:	4a91      	ldr	r2, [pc, #580]	@ (34013f6c <RCCEx_GetUARTCLKFreq+0x2b4>)
34013d26:	4293      	cmp	r3, r2
34013d28:	f200 81db 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013d2c:	4a90      	ldr	r2, [pc, #576]	@ (34013f70 <RCCEx_GetUARTCLKFreq+0x2b8>)
34013d2e:	4293      	cmp	r3, r2
34013d30:	f000 81c6 	beq.w	340140c0 <RCCEx_GetUARTCLKFreq+0x408>
34013d34:	4a8e      	ldr	r2, [pc, #568]	@ (34013f70 <RCCEx_GetUARTCLKFreq+0x2b8>)
34013d36:	4293      	cmp	r3, r2
34013d38:	f200 81d3 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013d3c:	4a8d      	ldr	r2, [pc, #564]	@ (34013f74 <RCCEx_GetUARTCLKFreq+0x2bc>)
34013d3e:	4293      	cmp	r3, r2
34013d40:	f000 81be 	beq.w	340140c0 <RCCEx_GetUARTCLKFreq+0x408>
34013d44:	4a8b      	ldr	r2, [pc, #556]	@ (34013f74 <RCCEx_GetUARTCLKFreq+0x2bc>)
34013d46:	4293      	cmp	r3, r2
34013d48:	f200 81cb 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013d4c:	4a8a      	ldr	r2, [pc, #552]	@ (34013f78 <RCCEx_GetUARTCLKFreq+0x2c0>)
34013d4e:	4293      	cmp	r3, r2
34013d50:	f000 81b6 	beq.w	340140c0 <RCCEx_GetUARTCLKFreq+0x408>
34013d54:	4a88      	ldr	r2, [pc, #544]	@ (34013f78 <RCCEx_GetUARTCLKFreq+0x2c0>)
34013d56:	4293      	cmp	r3, r2
34013d58:	f200 81c3 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013d5c:	4a87      	ldr	r2, [pc, #540]	@ (34013f7c <RCCEx_GetUARTCLKFreq+0x2c4>)
34013d5e:	4293      	cmp	r3, r2
34013d60:	f000 81ae 	beq.w	340140c0 <RCCEx_GetUARTCLKFreq+0x408>
34013d64:	4a85      	ldr	r2, [pc, #532]	@ (34013f7c <RCCEx_GetUARTCLKFreq+0x2c4>)
34013d66:	4293      	cmp	r3, r2
34013d68:	f200 81bb 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013d6c:	4a84      	ldr	r2, [pc, #528]	@ (34013f80 <RCCEx_GetUARTCLKFreq+0x2c8>)
34013d6e:	4293      	cmp	r3, r2
34013d70:	f000 81ae 	beq.w	340140d0 <RCCEx_GetUARTCLKFreq+0x418>
34013d74:	4a82      	ldr	r2, [pc, #520]	@ (34013f80 <RCCEx_GetUARTCLKFreq+0x2c8>)
34013d76:	4293      	cmp	r3, r2
34013d78:	f200 81b3 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013d7c:	4a81      	ldr	r2, [pc, #516]	@ (34013f84 <RCCEx_GetUARTCLKFreq+0x2cc>)
34013d7e:	4293      	cmp	r3, r2
34013d80:	f000 81a6 	beq.w	340140d0 <RCCEx_GetUARTCLKFreq+0x418>
34013d84:	4a7f      	ldr	r2, [pc, #508]	@ (34013f84 <RCCEx_GetUARTCLKFreq+0x2cc>)
34013d86:	4293      	cmp	r3, r2
34013d88:	f200 81ab 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013d8c:	4a7e      	ldr	r2, [pc, #504]	@ (34013f88 <RCCEx_GetUARTCLKFreq+0x2d0>)
34013d8e:	4293      	cmp	r3, r2
34013d90:	f000 819e 	beq.w	340140d0 <RCCEx_GetUARTCLKFreq+0x418>
34013d94:	4a7c      	ldr	r2, [pc, #496]	@ (34013f88 <RCCEx_GetUARTCLKFreq+0x2d0>)
34013d96:	4293      	cmp	r3, r2
34013d98:	f200 81a3 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013d9c:	4a7b      	ldr	r2, [pc, #492]	@ (34013f8c <RCCEx_GetUARTCLKFreq+0x2d4>)
34013d9e:	4293      	cmp	r3, r2
34013da0:	f000 8196 	beq.w	340140d0 <RCCEx_GetUARTCLKFreq+0x418>
34013da4:	4a79      	ldr	r2, [pc, #484]	@ (34013f8c <RCCEx_GetUARTCLKFreq+0x2d4>)
34013da6:	4293      	cmp	r3, r2
34013da8:	f200 819b 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013dac:	4a78      	ldr	r2, [pc, #480]	@ (34013f90 <RCCEx_GetUARTCLKFreq+0x2d8>)
34013dae:	4293      	cmp	r3, r2
34013db0:	f000 818e 	beq.w	340140d0 <RCCEx_GetUARTCLKFreq+0x418>
34013db4:	4a76      	ldr	r2, [pc, #472]	@ (34013f90 <RCCEx_GetUARTCLKFreq+0x2d8>)
34013db6:	4293      	cmp	r3, r2
34013db8:	f200 8193 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013dbc:	4a75      	ldr	r2, [pc, #468]	@ (34013f94 <RCCEx_GetUARTCLKFreq+0x2dc>)
34013dbe:	4293      	cmp	r3, r2
34013dc0:	f000 812d 	beq.w	3401401e <RCCEx_GetUARTCLKFreq+0x366>
34013dc4:	4a73      	ldr	r2, [pc, #460]	@ (34013f94 <RCCEx_GetUARTCLKFreq+0x2dc>)
34013dc6:	4293      	cmp	r3, r2
34013dc8:	f200 818b 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013dcc:	4a72      	ldr	r2, [pc, #456]	@ (34013f98 <RCCEx_GetUARTCLKFreq+0x2e0>)
34013dce:	4293      	cmp	r3, r2
34013dd0:	f000 8125 	beq.w	3401401e <RCCEx_GetUARTCLKFreq+0x366>
34013dd4:	4a70      	ldr	r2, [pc, #448]	@ (34013f98 <RCCEx_GetUARTCLKFreq+0x2e0>)
34013dd6:	4293      	cmp	r3, r2
34013dd8:	f200 8183 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013ddc:	4a6f      	ldr	r2, [pc, #444]	@ (34013f9c <RCCEx_GetUARTCLKFreq+0x2e4>)
34013dde:	4293      	cmp	r3, r2
34013de0:	f000 811d 	beq.w	3401401e <RCCEx_GetUARTCLKFreq+0x366>
34013de4:	4a6d      	ldr	r2, [pc, #436]	@ (34013f9c <RCCEx_GetUARTCLKFreq+0x2e4>)
34013de6:	4293      	cmp	r3, r2
34013de8:	f200 817b 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013dec:	4a6c      	ldr	r2, [pc, #432]	@ (34013fa0 <RCCEx_GetUARTCLKFreq+0x2e8>)
34013dee:	4293      	cmp	r3, r2
34013df0:	f000 8115 	beq.w	3401401e <RCCEx_GetUARTCLKFreq+0x366>
34013df4:	4a6a      	ldr	r2, [pc, #424]	@ (34013fa0 <RCCEx_GetUARTCLKFreq+0x2e8>)
34013df6:	4293      	cmp	r3, r2
34013df8:	f200 8173 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013dfc:	4a69      	ldr	r2, [pc, #420]	@ (34013fa4 <RCCEx_GetUARTCLKFreq+0x2ec>)
34013dfe:	4293      	cmp	r3, r2
34013e00:	f000 810d 	beq.w	3401401e <RCCEx_GetUARTCLKFreq+0x366>
34013e04:	4a67      	ldr	r2, [pc, #412]	@ (34013fa4 <RCCEx_GetUARTCLKFreq+0x2ec>)
34013e06:	4293      	cmp	r3, r2
34013e08:	f200 816b 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013e0c:	4a66      	ldr	r2, [pc, #408]	@ (34013fa8 <RCCEx_GetUARTCLKFreq+0x2f0>)
34013e0e:	4293      	cmp	r3, r2
34013e10:	d07b      	beq.n	34013f0a <RCCEx_GetUARTCLKFreq+0x252>
34013e12:	4a65      	ldr	r2, [pc, #404]	@ (34013fa8 <RCCEx_GetUARTCLKFreq+0x2f0>)
34013e14:	4293      	cmp	r3, r2
34013e16:	f200 8164 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013e1a:	4a64      	ldr	r2, [pc, #400]	@ (34013fac <RCCEx_GetUARTCLKFreq+0x2f4>)
34013e1c:	4293      	cmp	r3, r2
34013e1e:	d074      	beq.n	34013f0a <RCCEx_GetUARTCLKFreq+0x252>
34013e20:	4a62      	ldr	r2, [pc, #392]	@ (34013fac <RCCEx_GetUARTCLKFreq+0x2f4>)
34013e22:	4293      	cmp	r3, r2
34013e24:	f200 815d 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013e28:	4a61      	ldr	r2, [pc, #388]	@ (34013fb0 <RCCEx_GetUARTCLKFreq+0x2f8>)
34013e2a:	4293      	cmp	r3, r2
34013e2c:	d06d      	beq.n	34013f0a <RCCEx_GetUARTCLKFreq+0x252>
34013e2e:	4a60      	ldr	r2, [pc, #384]	@ (34013fb0 <RCCEx_GetUARTCLKFreq+0x2f8>)
34013e30:	4293      	cmp	r3, r2
34013e32:	f200 8156 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013e36:	4a5f      	ldr	r2, [pc, #380]	@ (34013fb4 <RCCEx_GetUARTCLKFreq+0x2fc>)
34013e38:	4293      	cmp	r3, r2
34013e3a:	d066      	beq.n	34013f0a <RCCEx_GetUARTCLKFreq+0x252>
34013e3c:	4a5d      	ldr	r2, [pc, #372]	@ (34013fb4 <RCCEx_GetUARTCLKFreq+0x2fc>)
34013e3e:	4293      	cmp	r3, r2
34013e40:	f200 814f 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013e44:	4a5c      	ldr	r2, [pc, #368]	@ (34013fb8 <RCCEx_GetUARTCLKFreq+0x300>)
34013e46:	4293      	cmp	r3, r2
34013e48:	d05f      	beq.n	34013f0a <RCCEx_GetUARTCLKFreq+0x252>
34013e4a:	4a5b      	ldr	r2, [pc, #364]	@ (34013fb8 <RCCEx_GetUARTCLKFreq+0x300>)
34013e4c:	4293      	cmp	r3, r2
34013e4e:	f200 8148 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013e52:	4a5a      	ldr	r2, [pc, #360]	@ (34013fbc <RCCEx_GetUARTCLKFreq+0x304>)
34013e54:	4293      	cmp	r3, r2
34013e56:	d053      	beq.n	34013f00 <RCCEx_GetUARTCLKFreq+0x248>
34013e58:	4a58      	ldr	r2, [pc, #352]	@ (34013fbc <RCCEx_GetUARTCLKFreq+0x304>)
34013e5a:	4293      	cmp	r3, r2
34013e5c:	f200 8141 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013e60:	4a57      	ldr	r2, [pc, #348]	@ (34013fc0 <RCCEx_GetUARTCLKFreq+0x308>)
34013e62:	4293      	cmp	r3, r2
34013e64:	d04c      	beq.n	34013f00 <RCCEx_GetUARTCLKFreq+0x248>
34013e66:	4a56      	ldr	r2, [pc, #344]	@ (34013fc0 <RCCEx_GetUARTCLKFreq+0x308>)
34013e68:	4293      	cmp	r3, r2
34013e6a:	f200 813a 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013e6e:	4a55      	ldr	r2, [pc, #340]	@ (34013fc4 <RCCEx_GetUARTCLKFreq+0x30c>)
34013e70:	4293      	cmp	r3, r2
34013e72:	d045      	beq.n	34013f00 <RCCEx_GetUARTCLKFreq+0x248>
34013e74:	4a53      	ldr	r2, [pc, #332]	@ (34013fc4 <RCCEx_GetUARTCLKFreq+0x30c>)
34013e76:	4293      	cmp	r3, r2
34013e78:	f200 8133 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013e7c:	4a52      	ldr	r2, [pc, #328]	@ (34013fc8 <RCCEx_GetUARTCLKFreq+0x310>)
34013e7e:	4293      	cmp	r3, r2
34013e80:	d03e      	beq.n	34013f00 <RCCEx_GetUARTCLKFreq+0x248>
34013e82:	4a51      	ldr	r2, [pc, #324]	@ (34013fc8 <RCCEx_GetUARTCLKFreq+0x310>)
34013e84:	4293      	cmp	r3, r2
34013e86:	f200 812c 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013e8a:	4a50      	ldr	r2, [pc, #320]	@ (34013fcc <RCCEx_GetUARTCLKFreq+0x314>)
34013e8c:	4293      	cmp	r3, r2
34013e8e:	d037      	beq.n	34013f00 <RCCEx_GetUARTCLKFreq+0x248>
34013e90:	4a4e      	ldr	r2, [pc, #312]	@ (34013fcc <RCCEx_GetUARTCLKFreq+0x314>)
34013e92:	4293      	cmp	r3, r2
34013e94:	f200 8125 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013e98:	4a4d      	ldr	r2, [pc, #308]	@ (34013fd0 <RCCEx_GetUARTCLKFreq+0x318>)
34013e9a:	4293      	cmp	r3, r2
34013e9c:	d018      	beq.n	34013ed0 <RCCEx_GetUARTCLKFreq+0x218>
34013e9e:	4a4c      	ldr	r2, [pc, #304]	@ (34013fd0 <RCCEx_GetUARTCLKFreq+0x318>)
34013ea0:	4293      	cmp	r3, r2
34013ea2:	f200 811e 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013ea6:	4a4b      	ldr	r2, [pc, #300]	@ (34013fd4 <RCCEx_GetUARTCLKFreq+0x31c>)
34013ea8:	4293      	cmp	r3, r2
34013eaa:	d011      	beq.n	34013ed0 <RCCEx_GetUARTCLKFreq+0x218>
34013eac:	4a49      	ldr	r2, [pc, #292]	@ (34013fd4 <RCCEx_GetUARTCLKFreq+0x31c>)
34013eae:	4293      	cmp	r3, r2
34013eb0:	f200 8117 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013eb4:	4a48      	ldr	r2, [pc, #288]	@ (34013fd8 <RCCEx_GetUARTCLKFreq+0x320>)
34013eb6:	4293      	cmp	r3, r2
34013eb8:	d00a      	beq.n	34013ed0 <RCCEx_GetUARTCLKFreq+0x218>
34013eba:	4a47      	ldr	r2, [pc, #284]	@ (34013fd8 <RCCEx_GetUARTCLKFreq+0x320>)
34013ebc:	4293      	cmp	r3, r2
34013ebe:	f200 8110 	bhi.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
34013ec2:	4a46      	ldr	r2, [pc, #280]	@ (34013fdc <RCCEx_GetUARTCLKFreq+0x324>)
34013ec4:	4293      	cmp	r3, r2
34013ec6:	d00f      	beq.n	34013ee8 <RCCEx_GetUARTCLKFreq+0x230>
34013ec8:	4a45      	ldr	r2, [pc, #276]	@ (34013fe0 <RCCEx_GetUARTCLKFreq+0x328>)
34013eca:	4293      	cmp	r3, r2
34013ecc:	f040 8109 	bne.w	340140e2 <RCCEx_GetUARTCLKFreq+0x42a>
  {
    case LL_RCC_UART4_CLKSOURCE_PCLK1:
    case LL_RCC_UART5_CLKSOURCE_PCLK1:
    case LL_RCC_UART7_CLKSOURCE_PCLK1:
    case LL_RCC_UART8_CLKSOURCE_PCLK1:
      uart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34013ed0:	f7f4 f850 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34013ed4:	4603      	mov	r3, r0
34013ed6:	4618      	mov	r0, r3
34013ed8:	f7fd f944 	bl	34011164 <RCCEx_GetHCLKFreq>
34013edc:	4603      	mov	r3, r0
34013ede:	4618      	mov	r0, r3
34013ee0:	f7fd f951 	bl	34011186 <RCCEx_GetPCLK1Freq>
34013ee4:	60f8      	str	r0, [r7, #12]
      break;
34013ee6:	e107      	b.n	340140f8 <RCCEx_GetUARTCLKFreq+0x440>

    case LL_RCC_UART9_CLKSOURCE_PCLK2:
      uart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34013ee8:	f7f4 f844 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34013eec:	4603      	mov	r3, r0
34013eee:	4618      	mov	r0, r3
34013ef0:	f7fd f938 	bl	34011164 <RCCEx_GetHCLKFreq>
34013ef4:	4603      	mov	r3, r0
34013ef6:	4618      	mov	r0, r3
34013ef8:	f7fd f955 	bl	340111a6 <RCCEx_GetPCLK2Freq>
34013efc:	60f8      	str	r0, [r7, #12]
      break;
34013efe:	e0fb      	b.n	340140f8 <RCCEx_GetUARTCLKFreq+0x440>
    case LL_RCC_UART4_CLKSOURCE_CLKP:
    case LL_RCC_UART5_CLKSOURCE_CLKP:
    case LL_RCC_UART7_CLKSOURCE_CLKP:
    case LL_RCC_UART8_CLKSOURCE_CLKP:
    case LL_RCC_UART9_CLKSOURCE_CLKP:
      uart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34013f00:	2007      	movs	r0, #7
34013f02:	f7fd fc1b 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
34013f06:	60f8      	str	r0, [r7, #12]
      break;
34013f08:	e0f6      	b.n	340140f8 <RCCEx_GetUARTCLKFreq+0x440>
    case LL_RCC_UART4_CLKSOURCE_IC9:
    case LL_RCC_UART5_CLKSOURCE_IC9:
    case LL_RCC_UART7_CLKSOURCE_IC9:
    case LL_RCC_UART8_CLKSOURCE_IC9:
    case LL_RCC_UART9_CLKSOURCE_IC9:
      if (LL_RCC_IC9_IsEnabled() != 0U)
34013f0a:	f7f5 fc55 	bl	340097b8 <LL_RCC_IC9_IsEnabled>
34013f0e:	4603      	mov	r3, r0
34013f10:	2b00      	cmp	r3, #0
34013f12:	f000 80e8 	beq.w	340140e6 <RCCEx_GetUARTCLKFreq+0x42e>
      {
        ic_divider = LL_RCC_IC9_GetDivider();
34013f16:	f7f5 fc71 	bl	340097fc <LL_RCC_IC9_GetDivider>
34013f1a:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
34013f1c:	f7f5 fc60 	bl	340097e0 <LL_RCC_IC9_GetSource>
34013f20:	4603      	mov	r3, r0
34013f22:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013f26:	d06f      	beq.n	34014008 <RCCEx_GetUARTCLKFreq+0x350>
34013f28:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013f2c:	d875      	bhi.n	3401401a <RCCEx_GetUARTCLKFreq+0x362>
34013f2e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013f32:	d060      	beq.n	34013ff6 <RCCEx_GetUARTCLKFreq+0x33e>
34013f34:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013f38:	d86f      	bhi.n	3401401a <RCCEx_GetUARTCLKFreq+0x362>
34013f3a:	2b00      	cmp	r3, #0
34013f3c:	d003      	beq.n	34013f46 <RCCEx_GetUARTCLKFreq+0x28e>
34013f3e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013f42:	d04f      	beq.n	34013fe4 <RCCEx_GetUARTCLKFreq+0x32c>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            uart_frequency = uart_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34013f44:	e069      	b.n	3401401a <RCCEx_GetUARTCLKFreq+0x362>
            uart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34013f46:	f7fc fff5 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34013f4a:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34013f4c:	68fa      	ldr	r2, [r7, #12]
34013f4e:	68bb      	ldr	r3, [r7, #8]
34013f50:	fbb2 f3f3 	udiv	r3, r2, r3
34013f54:	60fb      	str	r3, [r7, #12]
            break;
34013f56:	e061      	b.n	3401401c <RCCEx_GetUARTCLKFreq+0x364>
34013f58:	07061c30 	.word	0x07061c30
34013f5c:	07061830 	.word	0x07061830
34013f60:	07061030 	.word	0x07061030
34013f64:	07060c30 	.word	0x07060c30
34013f68:	07060034 	.word	0x07060034
34013f6c:	07051c30 	.word	0x07051c30
34013f70:	07051830 	.word	0x07051830
34013f74:	07051030 	.word	0x07051030
34013f78:	07050c30 	.word	0x07050c30
34013f7c:	07050034 	.word	0x07050034
34013f80:	07041c30 	.word	0x07041c30
34013f84:	07041830 	.word	0x07041830
34013f88:	07041030 	.word	0x07041030
34013f8c:	07040c30 	.word	0x07040c30
34013f90:	07040034 	.word	0x07040034
34013f94:	07031c30 	.word	0x07031c30
34013f98:	07031830 	.word	0x07031830
34013f9c:	07031030 	.word	0x07031030
34013fa0:	07030c30 	.word	0x07030c30
34013fa4:	07030034 	.word	0x07030034
34013fa8:	07021c30 	.word	0x07021c30
34013fac:	07021830 	.word	0x07021830
34013fb0:	07021030 	.word	0x07021030
34013fb4:	07020c30 	.word	0x07020c30
34013fb8:	07020034 	.word	0x07020034
34013fbc:	07011c30 	.word	0x07011c30
34013fc0:	07011830 	.word	0x07011830
34013fc4:	07011030 	.word	0x07011030
34013fc8:	07010c30 	.word	0x07010c30
34013fcc:	07010034 	.word	0x07010034
34013fd0:	07001c30 	.word	0x07001c30
34013fd4:	07001830 	.word	0x07001830
34013fd8:	07001030 	.word	0x07001030
34013fdc:	07000034 	.word	0x07000034
34013fe0:	07000c30 	.word	0x07000c30
            uart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34013fe4:	f7fc ffec 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34013fe8:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34013fea:	68fa      	ldr	r2, [r7, #12]
34013fec:	68bb      	ldr	r3, [r7, #8]
34013fee:	fbb2 f3f3 	udiv	r3, r2, r3
34013ff2:	60fb      	str	r3, [r7, #12]
            break;
34013ff4:	e012      	b.n	3401401c <RCCEx_GetUARTCLKFreq+0x364>
            uart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34013ff6:	f7fd f829 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34013ffa:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34013ffc:	68fa      	ldr	r2, [r7, #12]
34013ffe:	68bb      	ldr	r3, [r7, #8]
34014000:	fbb2 f3f3 	udiv	r3, r2, r3
34014004:	60fb      	str	r3, [r7, #12]
            break;
34014006:	e009      	b.n	3401401c <RCCEx_GetUARTCLKFreq+0x364>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34014008:	f7fd f866 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
3401400c:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
3401400e:	68fa      	ldr	r2, [r7, #12]
34014010:	68bb      	ldr	r3, [r7, #8]
34014012:	fbb2 f3f3 	udiv	r3, r2, r3
34014016:	60fb      	str	r3, [r7, #12]
            break;
34014018:	e000      	b.n	3401401c <RCCEx_GetUARTCLKFreq+0x364>
            break;
3401401a:	bf00      	nop
        }
      }
      break;
3401401c:	e063      	b.n	340140e6 <RCCEx_GetUARTCLKFreq+0x42e>
    case LL_RCC_UART4_CLKSOURCE_IC14:
    case LL_RCC_UART5_CLKSOURCE_IC14:
    case LL_RCC_UART7_CLKSOURCE_IC14:
    case LL_RCC_UART8_CLKSOURCE_IC14:
    case LL_RCC_UART9_CLKSOURCE_IC14:
      if (LL_RCC_IC14_IsEnabled() != 0U)
3401401e:	f7f5 fccb 	bl	340099b8 <LL_RCC_IC14_IsEnabled>
34014022:	4603      	mov	r3, r0
34014024:	2b00      	cmp	r3, #0
34014026:	d060      	beq.n	340140ea <RCCEx_GetUARTCLKFreq+0x432>
      {
        ic_divider = LL_RCC_IC14_GetDivider();
34014028:	f7f5 fce8 	bl	340099fc <LL_RCC_IC14_GetDivider>
3401402c:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
3401402e:	f7f5 fcd7 	bl	340099e0 <LL_RCC_IC14_GetSource>
34014032:	4603      	mov	r3, r0
34014034:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014038:	d029      	beq.n	3401408e <RCCEx_GetUARTCLKFreq+0x3d6>
3401403a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401403e:	d82f      	bhi.n	340140a0 <RCCEx_GetUARTCLKFreq+0x3e8>
34014040:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014044:	d01a      	beq.n	3401407c <RCCEx_GetUARTCLKFreq+0x3c4>
34014046:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401404a:	d829      	bhi.n	340140a0 <RCCEx_GetUARTCLKFreq+0x3e8>
3401404c:	2b00      	cmp	r3, #0
3401404e:	d003      	beq.n	34014058 <RCCEx_GetUARTCLKFreq+0x3a0>
34014050:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014054:	d009      	beq.n	3401406a <RCCEx_GetUARTCLKFreq+0x3b2>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            uart_frequency = uart_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34014056:	e023      	b.n	340140a0 <RCCEx_GetUARTCLKFreq+0x3e8>
            uart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34014058:	f7fc ff6c 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
3401405c:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
3401405e:	68fa      	ldr	r2, [r7, #12]
34014060:	68bb      	ldr	r3, [r7, #8]
34014062:	fbb2 f3f3 	udiv	r3, r2, r3
34014066:	60fb      	str	r3, [r7, #12]
            break;
34014068:	e01b      	b.n	340140a2 <RCCEx_GetUARTCLKFreq+0x3ea>
            uart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3401406a:	f7fc ffa9 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
3401406e:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34014070:	68fa      	ldr	r2, [r7, #12]
34014072:	68bb      	ldr	r3, [r7, #8]
34014074:	fbb2 f3f3 	udiv	r3, r2, r3
34014078:	60fb      	str	r3, [r7, #12]
            break;
3401407a:	e012      	b.n	340140a2 <RCCEx_GetUARTCLKFreq+0x3ea>
            uart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401407c:	f7fc ffe6 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34014080:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34014082:	68fa      	ldr	r2, [r7, #12]
34014084:	68bb      	ldr	r3, [r7, #8]
34014086:	fbb2 f3f3 	udiv	r3, r2, r3
3401408a:	60fb      	str	r3, [r7, #12]
            break;
3401408c:	e009      	b.n	340140a2 <RCCEx_GetUARTCLKFreq+0x3ea>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401408e:	f7fd f823 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34014092:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34014094:	68fa      	ldr	r2, [r7, #12]
34014096:	68bb      	ldr	r3, [r7, #8]
34014098:	fbb2 f3f3 	udiv	r3, r2, r3
3401409c:	60fb      	str	r3, [r7, #12]
            break;
3401409e:	e000      	b.n	340140a2 <RCCEx_GetUARTCLKFreq+0x3ea>
            break;
340140a0:	bf00      	nop
        }
      }
      break;
340140a2:	e022      	b.n	340140ea <RCCEx_GetUARTCLKFreq+0x432>
    case LL_RCC_UART4_CLKSOURCE_HSI:
    case LL_RCC_UART5_CLKSOURCE_HSI:
    case LL_RCC_UART7_CLKSOURCE_HSI:
    case LL_RCC_UART8_CLKSOURCE_HSI:
    case LL_RCC_UART9_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
340140a4:	f7f4 fb64 	bl	34008770 <LL_RCC_HSI_IsReady>
340140a8:	4603      	mov	r3, r0
340140aa:	2b00      	cmp	r3, #0
340140ac:	d01f      	beq.n	340140ee <RCCEx_GetUARTCLKFreq+0x436>
      {
        uart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340140ae:	f7f4 fb71 	bl	34008794 <LL_RCC_HSI_GetDivider>
340140b2:	4603      	mov	r3, r0
340140b4:	09db      	lsrs	r3, r3, #7
340140b6:	4a13      	ldr	r2, [pc, #76]	@ (34014104 <RCCEx_GetUARTCLKFreq+0x44c>)
340140b8:	fa22 f303 	lsr.w	r3, r2, r3
340140bc:	60fb      	str	r3, [r7, #12]
      }
      break;
340140be:	e016      	b.n	340140ee <RCCEx_GetUARTCLKFreq+0x436>
    case LL_RCC_UART4_CLKSOURCE_MSI:
    case LL_RCC_UART5_CLKSOURCE_MSI:
    case LL_RCC_UART7_CLKSOURCE_MSI:
    case LL_RCC_UART8_CLKSOURCE_MSI:
    case LL_RCC_UART9_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
340140c0:	f7f4 fb76 	bl	340087b0 <LL_RCC_MSI_IsReady>
340140c4:	4603      	mov	r3, r0
340140c6:	2b00      	cmp	r3, #0
340140c8:	d013      	beq.n	340140f2 <RCCEx_GetUARTCLKFreq+0x43a>
      {
        uart_frequency = MSI_VALUE;
340140ca:	4b0f      	ldr	r3, [pc, #60]	@ (34014108 <RCCEx_GetUARTCLKFreq+0x450>)
340140cc:	60fb      	str	r3, [r7, #12]
      }
      break;
340140ce:	e010      	b.n	340140f2 <RCCEx_GetUARTCLKFreq+0x43a>
    case LL_RCC_UART4_CLKSOURCE_LSE:
    case LL_RCC_UART5_CLKSOURCE_LSE:
    case LL_RCC_UART7_CLKSOURCE_LSE:
    case LL_RCC_UART8_CLKSOURCE_LSE:
    case LL_RCC_UART9_CLKSOURCE_LSE:
      if (LL_RCC_LSE_IsReady() != 0U)
340140d0:	f7f4 fb8e 	bl	340087f0 <LL_RCC_LSE_IsReady>
340140d4:	4603      	mov	r3, r0
340140d6:	2b00      	cmp	r3, #0
340140d8:	d00d      	beq.n	340140f6 <RCCEx_GetUARTCLKFreq+0x43e>
      {
        uart_frequency = LSE_VALUE;
340140da:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
340140de:	60fb      	str	r3, [r7, #12]
      }
      break;
340140e0:	e009      	b.n	340140f6 <RCCEx_GetUARTCLKFreq+0x43e>

    default:
      /* Unexpected case */
      break;
340140e2:	bf00      	nop
340140e4:	e008      	b.n	340140f8 <RCCEx_GetUARTCLKFreq+0x440>
      break;
340140e6:	bf00      	nop
340140e8:	e006      	b.n	340140f8 <RCCEx_GetUARTCLKFreq+0x440>
      break;
340140ea:	bf00      	nop
340140ec:	e004      	b.n	340140f8 <RCCEx_GetUARTCLKFreq+0x440>
      break;
340140ee:	bf00      	nop
340140f0:	e002      	b.n	340140f8 <RCCEx_GetUARTCLKFreq+0x440>
      break;
340140f2:	bf00      	nop
340140f4:	e000      	b.n	340140f8 <RCCEx_GetUARTCLKFreq+0x440>
      break;
340140f6:	bf00      	nop
  }

  return uart_frequency;
340140f8:	68fb      	ldr	r3, [r7, #12]
}
340140fa:	4618      	mov	r0, r3
340140fc:	3710      	adds	r7, #16
340140fe:	46bd      	mov	sp, r7
34014100:	bd80      	pop	{r7, pc}
34014102:	bf00      	nop
34014104:	03d09000 	.word	0x03d09000
34014108:	003d0900 	.word	0x003d0900

3401410c <RCCEx_GetUSARTCLKFreq>:
  *         @arg @ref RCCEx_USART10_Clock_Source
  * @retval USART clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetUSARTCLKFreq(uint32_t USARTxSource)
{
3401410c:	b580      	push	{r7, lr}
3401410e:	b084      	sub	sp, #16
34014110:	af00      	add	r7, sp, #0
34014112:	6078      	str	r0, [r7, #4]
  uint32_t usart_frequency = RCC_PERIPH_FREQUENCY_NO;
34014114:	2300      	movs	r3, #0
34014116:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
34014118:	6878      	ldr	r0, [r7, #4]
3401411a:	f7f4 ff11 	bl	34008f40 <LL_RCC_GetUSARTClockSource>
3401411e:	4603      	mov	r3, r0
34014120:	4aa2      	ldr	r2, [pc, #648]	@ (340143ac <RCCEx_GetUSARTCLKFreq+0x2a0>)
34014122:	4293      	cmp	r3, r2
34014124:	f000 81e8 	beq.w	340144f8 <RCCEx_GetUSARTCLKFreq+0x3ec>
34014128:	4aa0      	ldr	r2, [pc, #640]	@ (340143ac <RCCEx_GetUSARTCLKFreq+0x2a0>)
3401412a:	4293      	cmp	r3, r2
3401412c:	f200 8203 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
34014130:	4a9f      	ldr	r2, [pc, #636]	@ (340143b0 <RCCEx_GetUSARTCLKFreq+0x2a4>)
34014132:	4293      	cmp	r3, r2
34014134:	f000 81e0 	beq.w	340144f8 <RCCEx_GetUSARTCLKFreq+0x3ec>
34014138:	4a9d      	ldr	r2, [pc, #628]	@ (340143b0 <RCCEx_GetUSARTCLKFreq+0x2a4>)
3401413a:	4293      	cmp	r3, r2
3401413c:	f200 81fb 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
34014140:	4a9c      	ldr	r2, [pc, #624]	@ (340143b4 <RCCEx_GetUSARTCLKFreq+0x2a8>)
34014142:	4293      	cmp	r3, r2
34014144:	f000 81d8 	beq.w	340144f8 <RCCEx_GetUSARTCLKFreq+0x3ec>
34014148:	4a9a      	ldr	r2, [pc, #616]	@ (340143b4 <RCCEx_GetUSARTCLKFreq+0x2a8>)
3401414a:	4293      	cmp	r3, r2
3401414c:	f200 81f3 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
34014150:	4a99      	ldr	r2, [pc, #612]	@ (340143b8 <RCCEx_GetUSARTCLKFreq+0x2ac>)
34014152:	4293      	cmp	r3, r2
34014154:	f000 81d0 	beq.w	340144f8 <RCCEx_GetUSARTCLKFreq+0x3ec>
34014158:	4a97      	ldr	r2, [pc, #604]	@ (340143b8 <RCCEx_GetUSARTCLKFreq+0x2ac>)
3401415a:	4293      	cmp	r3, r2
3401415c:	f200 81eb 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
34014160:	4a96      	ldr	r2, [pc, #600]	@ (340143bc <RCCEx_GetUSARTCLKFreq+0x2b0>)
34014162:	4293      	cmp	r3, r2
34014164:	f000 81c8 	beq.w	340144f8 <RCCEx_GetUSARTCLKFreq+0x3ec>
34014168:	4a94      	ldr	r2, [pc, #592]	@ (340143bc <RCCEx_GetUSARTCLKFreq+0x2b0>)
3401416a:	4293      	cmp	r3, r2
3401416c:	f200 81e3 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
34014170:	4a93      	ldr	r2, [pc, #588]	@ (340143c0 <RCCEx_GetUSARTCLKFreq+0x2b4>)
34014172:	4293      	cmp	r3, r2
34014174:	f000 81ce 	beq.w	34014514 <RCCEx_GetUSARTCLKFreq+0x408>
34014178:	4a91      	ldr	r2, [pc, #580]	@ (340143c0 <RCCEx_GetUSARTCLKFreq+0x2b4>)
3401417a:	4293      	cmp	r3, r2
3401417c:	f200 81db 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
34014180:	4a90      	ldr	r2, [pc, #576]	@ (340143c4 <RCCEx_GetUSARTCLKFreq+0x2b8>)
34014182:	4293      	cmp	r3, r2
34014184:	f000 81c6 	beq.w	34014514 <RCCEx_GetUSARTCLKFreq+0x408>
34014188:	4a8e      	ldr	r2, [pc, #568]	@ (340143c4 <RCCEx_GetUSARTCLKFreq+0x2b8>)
3401418a:	4293      	cmp	r3, r2
3401418c:	f200 81d3 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
34014190:	4a8d      	ldr	r2, [pc, #564]	@ (340143c8 <RCCEx_GetUSARTCLKFreq+0x2bc>)
34014192:	4293      	cmp	r3, r2
34014194:	f000 81be 	beq.w	34014514 <RCCEx_GetUSARTCLKFreq+0x408>
34014198:	4a8b      	ldr	r2, [pc, #556]	@ (340143c8 <RCCEx_GetUSARTCLKFreq+0x2bc>)
3401419a:	4293      	cmp	r3, r2
3401419c:	f200 81cb 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
340141a0:	4a8a      	ldr	r2, [pc, #552]	@ (340143cc <RCCEx_GetUSARTCLKFreq+0x2c0>)
340141a2:	4293      	cmp	r3, r2
340141a4:	f000 81b6 	beq.w	34014514 <RCCEx_GetUSARTCLKFreq+0x408>
340141a8:	4a88      	ldr	r2, [pc, #544]	@ (340143cc <RCCEx_GetUSARTCLKFreq+0x2c0>)
340141aa:	4293      	cmp	r3, r2
340141ac:	f200 81c3 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
340141b0:	4a87      	ldr	r2, [pc, #540]	@ (340143d0 <RCCEx_GetUSARTCLKFreq+0x2c4>)
340141b2:	4293      	cmp	r3, r2
340141b4:	f000 81ae 	beq.w	34014514 <RCCEx_GetUSARTCLKFreq+0x408>
340141b8:	4a85      	ldr	r2, [pc, #532]	@ (340143d0 <RCCEx_GetUSARTCLKFreq+0x2c4>)
340141ba:	4293      	cmp	r3, r2
340141bc:	f200 81bb 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
340141c0:	4a84      	ldr	r2, [pc, #528]	@ (340143d4 <RCCEx_GetUSARTCLKFreq+0x2c8>)
340141c2:	4293      	cmp	r3, r2
340141c4:	f000 81ae 	beq.w	34014524 <RCCEx_GetUSARTCLKFreq+0x418>
340141c8:	4a82      	ldr	r2, [pc, #520]	@ (340143d4 <RCCEx_GetUSARTCLKFreq+0x2c8>)
340141ca:	4293      	cmp	r3, r2
340141cc:	f200 81b3 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
340141d0:	4a81      	ldr	r2, [pc, #516]	@ (340143d8 <RCCEx_GetUSARTCLKFreq+0x2cc>)
340141d2:	4293      	cmp	r3, r2
340141d4:	f000 81a6 	beq.w	34014524 <RCCEx_GetUSARTCLKFreq+0x418>
340141d8:	4a7f      	ldr	r2, [pc, #508]	@ (340143d8 <RCCEx_GetUSARTCLKFreq+0x2cc>)
340141da:	4293      	cmp	r3, r2
340141dc:	f200 81ab 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
340141e0:	4a7e      	ldr	r2, [pc, #504]	@ (340143dc <RCCEx_GetUSARTCLKFreq+0x2d0>)
340141e2:	4293      	cmp	r3, r2
340141e4:	f000 819e 	beq.w	34014524 <RCCEx_GetUSARTCLKFreq+0x418>
340141e8:	4a7c      	ldr	r2, [pc, #496]	@ (340143dc <RCCEx_GetUSARTCLKFreq+0x2d0>)
340141ea:	4293      	cmp	r3, r2
340141ec:	f200 81a3 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
340141f0:	4a7b      	ldr	r2, [pc, #492]	@ (340143e0 <RCCEx_GetUSARTCLKFreq+0x2d4>)
340141f2:	4293      	cmp	r3, r2
340141f4:	f000 8196 	beq.w	34014524 <RCCEx_GetUSARTCLKFreq+0x418>
340141f8:	4a79      	ldr	r2, [pc, #484]	@ (340143e0 <RCCEx_GetUSARTCLKFreq+0x2d4>)
340141fa:	4293      	cmp	r3, r2
340141fc:	f200 819b 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
34014200:	4a78      	ldr	r2, [pc, #480]	@ (340143e4 <RCCEx_GetUSARTCLKFreq+0x2d8>)
34014202:	4293      	cmp	r3, r2
34014204:	f000 818e 	beq.w	34014524 <RCCEx_GetUSARTCLKFreq+0x418>
34014208:	4a76      	ldr	r2, [pc, #472]	@ (340143e4 <RCCEx_GetUSARTCLKFreq+0x2d8>)
3401420a:	4293      	cmp	r3, r2
3401420c:	f200 8193 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
34014210:	4a75      	ldr	r2, [pc, #468]	@ (340143e8 <RCCEx_GetUSARTCLKFreq+0x2dc>)
34014212:	4293      	cmp	r3, r2
34014214:	f000 812d 	beq.w	34014472 <RCCEx_GetUSARTCLKFreq+0x366>
34014218:	4a73      	ldr	r2, [pc, #460]	@ (340143e8 <RCCEx_GetUSARTCLKFreq+0x2dc>)
3401421a:	4293      	cmp	r3, r2
3401421c:	f200 818b 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
34014220:	4a72      	ldr	r2, [pc, #456]	@ (340143ec <RCCEx_GetUSARTCLKFreq+0x2e0>)
34014222:	4293      	cmp	r3, r2
34014224:	f000 8125 	beq.w	34014472 <RCCEx_GetUSARTCLKFreq+0x366>
34014228:	4a70      	ldr	r2, [pc, #448]	@ (340143ec <RCCEx_GetUSARTCLKFreq+0x2e0>)
3401422a:	4293      	cmp	r3, r2
3401422c:	f200 8183 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
34014230:	4a6f      	ldr	r2, [pc, #444]	@ (340143f0 <RCCEx_GetUSARTCLKFreq+0x2e4>)
34014232:	4293      	cmp	r3, r2
34014234:	f000 811d 	beq.w	34014472 <RCCEx_GetUSARTCLKFreq+0x366>
34014238:	4a6d      	ldr	r2, [pc, #436]	@ (340143f0 <RCCEx_GetUSARTCLKFreq+0x2e4>)
3401423a:	4293      	cmp	r3, r2
3401423c:	f200 817b 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
34014240:	4a6c      	ldr	r2, [pc, #432]	@ (340143f4 <RCCEx_GetUSARTCLKFreq+0x2e8>)
34014242:	4293      	cmp	r3, r2
34014244:	f000 8115 	beq.w	34014472 <RCCEx_GetUSARTCLKFreq+0x366>
34014248:	4a6a      	ldr	r2, [pc, #424]	@ (340143f4 <RCCEx_GetUSARTCLKFreq+0x2e8>)
3401424a:	4293      	cmp	r3, r2
3401424c:	f200 8173 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
34014250:	4a69      	ldr	r2, [pc, #420]	@ (340143f8 <RCCEx_GetUSARTCLKFreq+0x2ec>)
34014252:	4293      	cmp	r3, r2
34014254:	f000 810d 	beq.w	34014472 <RCCEx_GetUSARTCLKFreq+0x366>
34014258:	4a67      	ldr	r2, [pc, #412]	@ (340143f8 <RCCEx_GetUSARTCLKFreq+0x2ec>)
3401425a:	4293      	cmp	r3, r2
3401425c:	f200 816b 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
34014260:	4a66      	ldr	r2, [pc, #408]	@ (340143fc <RCCEx_GetUSARTCLKFreq+0x2f0>)
34014262:	4293      	cmp	r3, r2
34014264:	d07b      	beq.n	3401435e <RCCEx_GetUSARTCLKFreq+0x252>
34014266:	4a65      	ldr	r2, [pc, #404]	@ (340143fc <RCCEx_GetUSARTCLKFreq+0x2f0>)
34014268:	4293      	cmp	r3, r2
3401426a:	f200 8164 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
3401426e:	4a64      	ldr	r2, [pc, #400]	@ (34014400 <RCCEx_GetUSARTCLKFreq+0x2f4>)
34014270:	4293      	cmp	r3, r2
34014272:	d074      	beq.n	3401435e <RCCEx_GetUSARTCLKFreq+0x252>
34014274:	4a62      	ldr	r2, [pc, #392]	@ (34014400 <RCCEx_GetUSARTCLKFreq+0x2f4>)
34014276:	4293      	cmp	r3, r2
34014278:	f200 815d 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
3401427c:	4a61      	ldr	r2, [pc, #388]	@ (34014404 <RCCEx_GetUSARTCLKFreq+0x2f8>)
3401427e:	4293      	cmp	r3, r2
34014280:	d06d      	beq.n	3401435e <RCCEx_GetUSARTCLKFreq+0x252>
34014282:	4a60      	ldr	r2, [pc, #384]	@ (34014404 <RCCEx_GetUSARTCLKFreq+0x2f8>)
34014284:	4293      	cmp	r3, r2
34014286:	f200 8156 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
3401428a:	4a5f      	ldr	r2, [pc, #380]	@ (34014408 <RCCEx_GetUSARTCLKFreq+0x2fc>)
3401428c:	4293      	cmp	r3, r2
3401428e:	d066      	beq.n	3401435e <RCCEx_GetUSARTCLKFreq+0x252>
34014290:	4a5d      	ldr	r2, [pc, #372]	@ (34014408 <RCCEx_GetUSARTCLKFreq+0x2fc>)
34014292:	4293      	cmp	r3, r2
34014294:	f200 814f 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
34014298:	4a5c      	ldr	r2, [pc, #368]	@ (3401440c <RCCEx_GetUSARTCLKFreq+0x300>)
3401429a:	4293      	cmp	r3, r2
3401429c:	d05f      	beq.n	3401435e <RCCEx_GetUSARTCLKFreq+0x252>
3401429e:	4a5b      	ldr	r2, [pc, #364]	@ (3401440c <RCCEx_GetUSARTCLKFreq+0x300>)
340142a0:	4293      	cmp	r3, r2
340142a2:	f200 8148 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
340142a6:	4a5a      	ldr	r2, [pc, #360]	@ (34014410 <RCCEx_GetUSARTCLKFreq+0x304>)
340142a8:	4293      	cmp	r3, r2
340142aa:	d053      	beq.n	34014354 <RCCEx_GetUSARTCLKFreq+0x248>
340142ac:	4a58      	ldr	r2, [pc, #352]	@ (34014410 <RCCEx_GetUSARTCLKFreq+0x304>)
340142ae:	4293      	cmp	r3, r2
340142b0:	f200 8141 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
340142b4:	4a57      	ldr	r2, [pc, #348]	@ (34014414 <RCCEx_GetUSARTCLKFreq+0x308>)
340142b6:	4293      	cmp	r3, r2
340142b8:	d04c      	beq.n	34014354 <RCCEx_GetUSARTCLKFreq+0x248>
340142ba:	4a56      	ldr	r2, [pc, #344]	@ (34014414 <RCCEx_GetUSARTCLKFreq+0x308>)
340142bc:	4293      	cmp	r3, r2
340142be:	f200 813a 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
340142c2:	4a55      	ldr	r2, [pc, #340]	@ (34014418 <RCCEx_GetUSARTCLKFreq+0x30c>)
340142c4:	4293      	cmp	r3, r2
340142c6:	d045      	beq.n	34014354 <RCCEx_GetUSARTCLKFreq+0x248>
340142c8:	4a53      	ldr	r2, [pc, #332]	@ (34014418 <RCCEx_GetUSARTCLKFreq+0x30c>)
340142ca:	4293      	cmp	r3, r2
340142cc:	f200 8133 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
340142d0:	4a52      	ldr	r2, [pc, #328]	@ (3401441c <RCCEx_GetUSARTCLKFreq+0x310>)
340142d2:	4293      	cmp	r3, r2
340142d4:	d03e      	beq.n	34014354 <RCCEx_GetUSARTCLKFreq+0x248>
340142d6:	4a51      	ldr	r2, [pc, #324]	@ (3401441c <RCCEx_GetUSARTCLKFreq+0x310>)
340142d8:	4293      	cmp	r3, r2
340142da:	f200 812c 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
340142de:	4a50      	ldr	r2, [pc, #320]	@ (34014420 <RCCEx_GetUSARTCLKFreq+0x314>)
340142e0:	4293      	cmp	r3, r2
340142e2:	d037      	beq.n	34014354 <RCCEx_GetUSARTCLKFreq+0x248>
340142e4:	4a4e      	ldr	r2, [pc, #312]	@ (34014420 <RCCEx_GetUSARTCLKFreq+0x314>)
340142e6:	4293      	cmp	r3, r2
340142e8:	f200 8125 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
340142ec:	4a4d      	ldr	r2, [pc, #308]	@ (34014424 <RCCEx_GetUSARTCLKFreq+0x318>)
340142ee:	4293      	cmp	r3, r2
340142f0:	d018      	beq.n	34014324 <RCCEx_GetUSARTCLKFreq+0x218>
340142f2:	4a4c      	ldr	r2, [pc, #304]	@ (34014424 <RCCEx_GetUSARTCLKFreq+0x318>)
340142f4:	4293      	cmp	r3, r2
340142f6:	f200 811e 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
340142fa:	4a4b      	ldr	r2, [pc, #300]	@ (34014428 <RCCEx_GetUSARTCLKFreq+0x31c>)
340142fc:	4293      	cmp	r3, r2
340142fe:	d01d      	beq.n	3401433c <RCCEx_GetUSARTCLKFreq+0x230>
34014300:	4a49      	ldr	r2, [pc, #292]	@ (34014428 <RCCEx_GetUSARTCLKFreq+0x31c>)
34014302:	4293      	cmp	r3, r2
34014304:	f200 8117 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
34014308:	4a48      	ldr	r2, [pc, #288]	@ (3401442c <RCCEx_GetUSARTCLKFreq+0x320>)
3401430a:	4293      	cmp	r3, r2
3401430c:	d00a      	beq.n	34014324 <RCCEx_GetUSARTCLKFreq+0x218>
3401430e:	4a47      	ldr	r2, [pc, #284]	@ (3401442c <RCCEx_GetUSARTCLKFreq+0x320>)
34014310:	4293      	cmp	r3, r2
34014312:	f200 8110 	bhi.w	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
34014316:	4a46      	ldr	r2, [pc, #280]	@ (34014430 <RCCEx_GetUSARTCLKFreq+0x324>)
34014318:	4293      	cmp	r3, r2
3401431a:	d003      	beq.n	34014324 <RCCEx_GetUSARTCLKFreq+0x218>
3401431c:	4a45      	ldr	r2, [pc, #276]	@ (34014434 <RCCEx_GetUSARTCLKFreq+0x328>)
3401431e:	4293      	cmp	r3, r2
34014320:	d00c      	beq.n	3401433c <RCCEx_GetUSARTCLKFreq+0x230>
      }
      break;

    default:
      /* Unexpected case */
      break;
34014322:	e108      	b.n	34014536 <RCCEx_GetUSARTCLKFreq+0x42a>
      usart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34014324:	f7f3 fe26 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34014328:	4603      	mov	r3, r0
3401432a:	4618      	mov	r0, r3
3401432c:	f7fc ff1a 	bl	34011164 <RCCEx_GetHCLKFreq>
34014330:	4603      	mov	r3, r0
34014332:	4618      	mov	r0, r3
34014334:	f7fc ff37 	bl	340111a6 <RCCEx_GetPCLK2Freq>
34014338:	60f8      	str	r0, [r7, #12]
      break;
3401433a:	e107      	b.n	3401454c <RCCEx_GetUSARTCLKFreq+0x440>
      usart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3401433c:	f7f3 fe1a 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34014340:	4603      	mov	r3, r0
34014342:	4618      	mov	r0, r3
34014344:	f7fc ff0e 	bl	34011164 <RCCEx_GetHCLKFreq>
34014348:	4603      	mov	r3, r0
3401434a:	4618      	mov	r0, r3
3401434c:	f7fc ff1b 	bl	34011186 <RCCEx_GetPCLK1Freq>
34014350:	60f8      	str	r0, [r7, #12]
      break;
34014352:	e0fb      	b.n	3401454c <RCCEx_GetUSARTCLKFreq+0x440>
      usart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34014354:	2007      	movs	r0, #7
34014356:	f7fd f9f1 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
3401435a:	60f8      	str	r0, [r7, #12]
      break;
3401435c:	e0f6      	b.n	3401454c <RCCEx_GetUSARTCLKFreq+0x440>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3401435e:	f7f5 fa2b 	bl	340097b8 <LL_RCC_IC9_IsEnabled>
34014362:	4603      	mov	r3, r0
34014364:	2b00      	cmp	r3, #0
34014366:	f000 80e8 	beq.w	3401453a <RCCEx_GetUSARTCLKFreq+0x42e>
        ic_divider = LL_RCC_IC9_GetDivider();
3401436a:	f7f5 fa47 	bl	340097fc <LL_RCC_IC9_GetDivider>
3401436e:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
34014370:	f7f5 fa36 	bl	340097e0 <LL_RCC_IC9_GetSource>
34014374:	4603      	mov	r3, r0
34014376:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401437a:	d06f      	beq.n	3401445c <RCCEx_GetUSARTCLKFreq+0x350>
3401437c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014380:	d875      	bhi.n	3401446e <RCCEx_GetUSARTCLKFreq+0x362>
34014382:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014386:	d060      	beq.n	3401444a <RCCEx_GetUSARTCLKFreq+0x33e>
34014388:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401438c:	d86f      	bhi.n	3401446e <RCCEx_GetUSARTCLKFreq+0x362>
3401438e:	2b00      	cmp	r3, #0
34014390:	d003      	beq.n	3401439a <RCCEx_GetUSARTCLKFreq+0x28e>
34014392:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014396:	d04f      	beq.n	34014438 <RCCEx_GetUSARTCLKFreq+0x32c>
            break;
34014398:	e069      	b.n	3401446e <RCCEx_GetUSARTCLKFreq+0x362>
            usart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3401439a:	f7fc fdcb 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
3401439e:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
340143a0:	68fa      	ldr	r2, [r7, #12]
340143a2:	68bb      	ldr	r3, [r7, #8]
340143a4:	fbb2 f3f3 	udiv	r3, r2, r3
340143a8:	60fb      	str	r3, [r7, #12]
            break;
340143aa:	e061      	b.n	34014470 <RCCEx_GetUSARTCLKFreq+0x364>
340143ac:	07061430 	.word	0x07061430
340143b0:	07060830 	.word	0x07060830
340143b4:	07060434 	.word	0x07060434
340143b8:	07060430 	.word	0x07060430
340143bc:	07060030 	.word	0x07060030
340143c0:	07051430 	.word	0x07051430
340143c4:	07050830 	.word	0x07050830
340143c8:	07050434 	.word	0x07050434
340143cc:	07050430 	.word	0x07050430
340143d0:	07050030 	.word	0x07050030
340143d4:	07041430 	.word	0x07041430
340143d8:	07040830 	.word	0x07040830
340143dc:	07040434 	.word	0x07040434
340143e0:	07040430 	.word	0x07040430
340143e4:	07040030 	.word	0x07040030
340143e8:	07031430 	.word	0x07031430
340143ec:	07030830 	.word	0x07030830
340143f0:	07030434 	.word	0x07030434
340143f4:	07030430 	.word	0x07030430
340143f8:	07030030 	.word	0x07030030
340143fc:	07021430 	.word	0x07021430
34014400:	07020830 	.word	0x07020830
34014404:	07020434 	.word	0x07020434
34014408:	07020430 	.word	0x07020430
3401440c:	07020030 	.word	0x07020030
34014410:	07011430 	.word	0x07011430
34014414:	07010830 	.word	0x07010830
34014418:	07010434 	.word	0x07010434
3401441c:	07010430 	.word	0x07010430
34014420:	07010030 	.word	0x07010030
34014424:	07001430 	.word	0x07001430
34014428:	07000830 	.word	0x07000830
3401442c:	07000434 	.word	0x07000434
34014430:	07000030 	.word	0x07000030
34014434:	07000430 	.word	0x07000430
            usart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34014438:	f7fc fdc2 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
3401443c:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
3401443e:	68fa      	ldr	r2, [r7, #12]
34014440:	68bb      	ldr	r3, [r7, #8]
34014442:	fbb2 f3f3 	udiv	r3, r2, r3
34014446:	60fb      	str	r3, [r7, #12]
            break;
34014448:	e012      	b.n	34014470 <RCCEx_GetUSARTCLKFreq+0x364>
            usart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401444a:	f7fc fdff 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
3401444e:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34014450:	68fa      	ldr	r2, [r7, #12]
34014452:	68bb      	ldr	r3, [r7, #8]
34014454:	fbb2 f3f3 	udiv	r3, r2, r3
34014458:	60fb      	str	r3, [r7, #12]
            break;
3401445a:	e009      	b.n	34014470 <RCCEx_GetUSARTCLKFreq+0x364>
            usart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401445c:	f7fc fe3c 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34014460:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34014462:	68fa      	ldr	r2, [r7, #12]
34014464:	68bb      	ldr	r3, [r7, #8]
34014466:	fbb2 f3f3 	udiv	r3, r2, r3
3401446a:	60fb      	str	r3, [r7, #12]
            break;
3401446c:	e000      	b.n	34014470 <RCCEx_GetUSARTCLKFreq+0x364>
            break;
3401446e:	bf00      	nop
      break;
34014470:	e063      	b.n	3401453a <RCCEx_GetUSARTCLKFreq+0x42e>
      if (LL_RCC_IC14_IsEnabled() != 0U)
34014472:	f7f5 faa1 	bl	340099b8 <LL_RCC_IC14_IsEnabled>
34014476:	4603      	mov	r3, r0
34014478:	2b00      	cmp	r3, #0
3401447a:	d060      	beq.n	3401453e <RCCEx_GetUSARTCLKFreq+0x432>
        ic_divider = LL_RCC_IC14_GetDivider();
3401447c:	f7f5 fabe 	bl	340099fc <LL_RCC_IC14_GetDivider>
34014480:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
34014482:	f7f5 faad 	bl	340099e0 <LL_RCC_IC14_GetSource>
34014486:	4603      	mov	r3, r0
34014488:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401448c:	d029      	beq.n	340144e2 <RCCEx_GetUSARTCLKFreq+0x3d6>
3401448e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014492:	d82f      	bhi.n	340144f4 <RCCEx_GetUSARTCLKFreq+0x3e8>
34014494:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014498:	d01a      	beq.n	340144d0 <RCCEx_GetUSARTCLKFreq+0x3c4>
3401449a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401449e:	d829      	bhi.n	340144f4 <RCCEx_GetUSARTCLKFreq+0x3e8>
340144a0:	2b00      	cmp	r3, #0
340144a2:	d003      	beq.n	340144ac <RCCEx_GetUSARTCLKFreq+0x3a0>
340144a4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340144a8:	d009      	beq.n	340144be <RCCEx_GetUSARTCLKFreq+0x3b2>
            break;
340144aa:	e023      	b.n	340144f4 <RCCEx_GetUSARTCLKFreq+0x3e8>
            usart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340144ac:	f7fc fd42 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
340144b0:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
340144b2:	68fa      	ldr	r2, [r7, #12]
340144b4:	68bb      	ldr	r3, [r7, #8]
340144b6:	fbb2 f3f3 	udiv	r3, r2, r3
340144ba:	60fb      	str	r3, [r7, #12]
            break;
340144bc:	e01b      	b.n	340144f6 <RCCEx_GetUSARTCLKFreq+0x3ea>
            usart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340144be:	f7fc fd7f 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
340144c2:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
340144c4:	68fa      	ldr	r2, [r7, #12]
340144c6:	68bb      	ldr	r3, [r7, #8]
340144c8:	fbb2 f3f3 	udiv	r3, r2, r3
340144cc:	60fb      	str	r3, [r7, #12]
            break;
340144ce:	e012      	b.n	340144f6 <RCCEx_GetUSARTCLKFreq+0x3ea>
            usart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340144d0:	f7fc fdbc 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
340144d4:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
340144d6:	68fa      	ldr	r2, [r7, #12]
340144d8:	68bb      	ldr	r3, [r7, #8]
340144da:	fbb2 f3f3 	udiv	r3, r2, r3
340144de:	60fb      	str	r3, [r7, #12]
            break;
340144e0:	e009      	b.n	340144f6 <RCCEx_GetUSARTCLKFreq+0x3ea>
            usart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340144e2:	f7fc fdf9 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
340144e6:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
340144e8:	68fa      	ldr	r2, [r7, #12]
340144ea:	68bb      	ldr	r3, [r7, #8]
340144ec:	fbb2 f3f3 	udiv	r3, r2, r3
340144f0:	60fb      	str	r3, [r7, #12]
            break;
340144f2:	e000      	b.n	340144f6 <RCCEx_GetUSARTCLKFreq+0x3ea>
            break;
340144f4:	bf00      	nop
      break;
340144f6:	e022      	b.n	3401453e <RCCEx_GetUSARTCLKFreq+0x432>
      if (LL_RCC_HSI_IsReady() != 0U)
340144f8:	f7f4 f93a 	bl	34008770 <LL_RCC_HSI_IsReady>
340144fc:	4603      	mov	r3, r0
340144fe:	2b00      	cmp	r3, #0
34014500:	d01f      	beq.n	34014542 <RCCEx_GetUSARTCLKFreq+0x436>
        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34014502:	f7f4 f947 	bl	34008794 <LL_RCC_HSI_GetDivider>
34014506:	4603      	mov	r3, r0
34014508:	09db      	lsrs	r3, r3, #7
3401450a:	4a13      	ldr	r2, [pc, #76]	@ (34014558 <RCCEx_GetUSARTCLKFreq+0x44c>)
3401450c:	fa22 f303 	lsr.w	r3, r2, r3
34014510:	60fb      	str	r3, [r7, #12]
      break;
34014512:	e016      	b.n	34014542 <RCCEx_GetUSARTCLKFreq+0x436>
      if (LL_RCC_MSI_IsReady() != 0U)
34014514:	f7f4 f94c 	bl	340087b0 <LL_RCC_MSI_IsReady>
34014518:	4603      	mov	r3, r0
3401451a:	2b00      	cmp	r3, #0
3401451c:	d013      	beq.n	34014546 <RCCEx_GetUSARTCLKFreq+0x43a>
        usart_frequency = MSI_VALUE;
3401451e:	4b0f      	ldr	r3, [pc, #60]	@ (3401455c <RCCEx_GetUSARTCLKFreq+0x450>)
34014520:	60fb      	str	r3, [r7, #12]
      break;
34014522:	e010      	b.n	34014546 <RCCEx_GetUSARTCLKFreq+0x43a>
      if (LL_RCC_LSE_IsReady() != 0U)
34014524:	f7f4 f964 	bl	340087f0 <LL_RCC_LSE_IsReady>
34014528:	4603      	mov	r3, r0
3401452a:	2b00      	cmp	r3, #0
3401452c:	d00d      	beq.n	3401454a <RCCEx_GetUSARTCLKFreq+0x43e>
        usart_frequency = LSE_VALUE;
3401452e:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34014532:	60fb      	str	r3, [r7, #12]
      break;
34014534:	e009      	b.n	3401454a <RCCEx_GetUSARTCLKFreq+0x43e>
      break;
34014536:	bf00      	nop
34014538:	e008      	b.n	3401454c <RCCEx_GetUSARTCLKFreq+0x440>
      break;
3401453a:	bf00      	nop
3401453c:	e006      	b.n	3401454c <RCCEx_GetUSARTCLKFreq+0x440>
      break;
3401453e:	bf00      	nop
34014540:	e004      	b.n	3401454c <RCCEx_GetUSARTCLKFreq+0x440>
      break;
34014542:	bf00      	nop
34014544:	e002      	b.n	3401454c <RCCEx_GetUSARTCLKFreq+0x440>
      break;
34014546:	bf00      	nop
34014548:	e000      	b.n	3401454c <RCCEx_GetUSARTCLKFreq+0x440>
      break;
3401454a:	bf00      	nop
  }

  return usart_frequency;
3401454c:	68fb      	ldr	r3, [r7, #12]
}
3401454e:	4618      	mov	r0, r3
34014550:	3710      	adds	r7, #16
34014552:	46bd      	mov	sp, r7
34014554:	bd80      	pop	{r7, pc}
34014556:	bf00      	nop
34014558:	03d09000 	.word	0x03d09000
3401455c:	003d0900 	.word	0x003d0900

34014560 <RCCEx_GetOTGPHYCLKFreq>:
  *         @arg @ref RCCEx_USB_OTGHS2_Clock_Source
  * @retval OTGPHY clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready or Disabled
  */
static uint32_t RCCEx_GetOTGPHYCLKFreq(uint32_t OTGPHYxSource)
{
34014560:	b580      	push	{r7, lr}
34014562:	b084      	sub	sp, #16
34014564:	af00      	add	r7, sp, #0
34014566:	6078      	str	r0, [r7, #4]
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
34014568:	2300      	movs	r3, #0
3401456a:	60fb      	str	r3, [r7, #12]

  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
3401456c:	6878      	ldr	r0, [r7, #4]
3401456e:	f7f4 fcff 	bl	34008f70 <LL_RCC_GetUSBClockSource>
34014572:	4603      	mov	r3, r0
34014574:	4a4b      	ldr	r2, [pc, #300]	@ (340146a4 <RCCEx_GetOTGPHYCLKFreq+0x144>)
34014576:	4293      	cmp	r3, r2
34014578:	d035      	beq.n	340145e6 <RCCEx_GetOTGPHYCLKFreq+0x86>
3401457a:	4a4a      	ldr	r2, [pc, #296]	@ (340146a4 <RCCEx_GetOTGPHYCLKFreq+0x144>)
3401457c:	4293      	cmp	r3, r2
3401457e:	f200 8085 	bhi.w	3401468c <RCCEx_GetOTGPHYCLKFreq+0x12c>
34014582:	4a49      	ldr	r2, [pc, #292]	@ (340146a8 <RCCEx_GetOTGPHYCLKFreq+0x148>)
34014584:	4293      	cmp	r3, r2
34014586:	d02e      	beq.n	340145e6 <RCCEx_GetOTGPHYCLKFreq+0x86>
34014588:	4a47      	ldr	r2, [pc, #284]	@ (340146a8 <RCCEx_GetOTGPHYCLKFreq+0x148>)
3401458a:	4293      	cmp	r3, r2
3401458c:	d87e      	bhi.n	3401468c <RCCEx_GetOTGPHYCLKFreq+0x12c>
3401458e:	4a47      	ldr	r2, [pc, #284]	@ (340146ac <RCCEx_GetOTGPHYCLKFreq+0x14c>)
34014590:	4293      	cmp	r3, r2
34014592:	d038      	beq.n	34014606 <RCCEx_GetOTGPHYCLKFreq+0xa6>
34014594:	4a45      	ldr	r2, [pc, #276]	@ (340146ac <RCCEx_GetOTGPHYCLKFreq+0x14c>)
34014596:	4293      	cmp	r3, r2
34014598:	d878      	bhi.n	3401468c <RCCEx_GetOTGPHYCLKFreq+0x12c>
3401459a:	4a45      	ldr	r2, [pc, #276]	@ (340146b0 <RCCEx_GetOTGPHYCLKFreq+0x150>)
3401459c:	4293      	cmp	r3, r2
3401459e:	d032      	beq.n	34014606 <RCCEx_GetOTGPHYCLKFreq+0xa6>
340145a0:	4a43      	ldr	r2, [pc, #268]	@ (340146b0 <RCCEx_GetOTGPHYCLKFreq+0x150>)
340145a2:	4293      	cmp	r3, r2
340145a4:	d872      	bhi.n	3401468c <RCCEx_GetOTGPHYCLKFreq+0x12c>
340145a6:	4a43      	ldr	r2, [pc, #268]	@ (340146b4 <RCCEx_GetOTGPHYCLKFreq+0x154>)
340145a8:	4293      	cmp	r3, r2
340145aa:	d00f      	beq.n	340145cc <RCCEx_GetOTGPHYCLKFreq+0x6c>
340145ac:	4a41      	ldr	r2, [pc, #260]	@ (340146b4 <RCCEx_GetOTGPHYCLKFreq+0x154>)
340145ae:	4293      	cmp	r3, r2
340145b0:	d86c      	bhi.n	3401468c <RCCEx_GetOTGPHYCLKFreq+0x12c>
340145b2:	4a41      	ldr	r2, [pc, #260]	@ (340146b8 <RCCEx_GetOTGPHYCLKFreq+0x158>)
340145b4:	4293      	cmp	r3, r2
340145b6:	d009      	beq.n	340145cc <RCCEx_GetOTGPHYCLKFreq+0x6c>
340145b8:	4a3f      	ldr	r2, [pc, #252]	@ (340146b8 <RCCEx_GetOTGPHYCLKFreq+0x158>)
340145ba:	4293      	cmp	r3, r2
340145bc:	d866      	bhi.n	3401468c <RCCEx_GetOTGPHYCLKFreq+0x12c>
340145be:	4a3f      	ldr	r2, [pc, #252]	@ (340146bc <RCCEx_GetOTGPHYCLKFreq+0x15c>)
340145c0:	4293      	cmp	r3, r2
340145c2:	d008      	beq.n	340145d6 <RCCEx_GetOTGPHYCLKFreq+0x76>
340145c4:	4a3e      	ldr	r2, [pc, #248]	@ (340146c0 <RCCEx_GetOTGPHYCLKFreq+0x160>)
340145c6:	4293      	cmp	r3, r2
340145c8:	d005      	beq.n	340145d6 <RCCEx_GetOTGPHYCLKFreq+0x76>
      }
      break;

    default:
      /* Unexpected case */
      break;
340145ca:	e05f      	b.n	3401468c <RCCEx_GetOTGPHYCLKFreq+0x12c>
      usb_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340145cc:	2007      	movs	r0, #7
340145ce:	f7fd f8b5 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
340145d2:	60f8      	str	r0, [r7, #12]
      break;
340145d4:	e061      	b.n	3401469a <RCCEx_GetOTGPHYCLKFreq+0x13a>
      if (LL_RCC_HSE_IsReady() != 0U)
340145d6:	f7f4 f8b9 	bl	3400874c <LL_RCC_HSE_IsReady>
340145da:	4603      	mov	r3, r0
340145dc:	2b00      	cmp	r3, #0
340145de:	d057      	beq.n	34014690 <RCCEx_GetOTGPHYCLKFreq+0x130>
        usb_frequency = HSE_VALUE / 2U;
340145e0:	4b38      	ldr	r3, [pc, #224]	@ (340146c4 <RCCEx_GetOTGPHYCLKFreq+0x164>)
340145e2:	60fb      	str	r3, [r7, #12]
      break;
340145e4:	e054      	b.n	34014690 <RCCEx_GetOTGPHYCLKFreq+0x130>
      if (LL_RCC_HSE_IsReady() != 0U)
340145e6:	f7f4 f8b1 	bl	3400874c <LL_RCC_HSE_IsReady>
340145ea:	4603      	mov	r3, r0
340145ec:	2b00      	cmp	r3, #0
340145ee:	d051      	beq.n	34014694 <RCCEx_GetOTGPHYCLKFreq+0x134>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
340145f0:	f7f4 f89a 	bl	34008728 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
340145f4:	4603      	mov	r3, r0
340145f6:	2b00      	cmp	r3, #0
340145f8:	d102      	bne.n	34014600 <RCCEx_GetOTGPHYCLKFreq+0xa0>
          usb_frequency = HSE_VALUE;
340145fa:	4b33      	ldr	r3, [pc, #204]	@ (340146c8 <RCCEx_GetOTGPHYCLKFreq+0x168>)
340145fc:	60fb      	str	r3, [r7, #12]
      break;
340145fe:	e049      	b.n	34014694 <RCCEx_GetOTGPHYCLKFreq+0x134>
          usb_frequency = HSE_VALUE / 2U;
34014600:	4b30      	ldr	r3, [pc, #192]	@ (340146c4 <RCCEx_GetOTGPHYCLKFreq+0x164>)
34014602:	60fb      	str	r3, [r7, #12]
      break;
34014604:	e046      	b.n	34014694 <RCCEx_GetOTGPHYCLKFreq+0x134>
      if (LL_RCC_IC15_IsEnabled() != 0U)
34014606:	f7f5 fa17 	bl	34009a38 <LL_RCC_IC15_IsEnabled>
3401460a:	4603      	mov	r3, r0
3401460c:	2b00      	cmp	r3, #0
3401460e:	d043      	beq.n	34014698 <RCCEx_GetOTGPHYCLKFreq+0x138>
        uint32_t ic_divider = LL_RCC_IC15_GetDivider();
34014610:	f7f5 fa34 	bl	34009a7c <LL_RCC_IC15_GetDivider>
34014614:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
34014616:	f7f5 fa23 	bl	34009a60 <LL_RCC_IC15_GetSource>
3401461a:	4603      	mov	r3, r0
3401461c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014620:	d029      	beq.n	34014676 <RCCEx_GetOTGPHYCLKFreq+0x116>
34014622:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014626:	d82f      	bhi.n	34014688 <RCCEx_GetOTGPHYCLKFreq+0x128>
34014628:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401462c:	d01a      	beq.n	34014664 <RCCEx_GetOTGPHYCLKFreq+0x104>
3401462e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014632:	d829      	bhi.n	34014688 <RCCEx_GetOTGPHYCLKFreq+0x128>
34014634:	2b00      	cmp	r3, #0
34014636:	d003      	beq.n	34014640 <RCCEx_GetOTGPHYCLKFreq+0xe0>
34014638:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401463c:	d009      	beq.n	34014652 <RCCEx_GetOTGPHYCLKFreq+0xf2>
            break;
3401463e:	e023      	b.n	34014688 <RCCEx_GetOTGPHYCLKFreq+0x128>
            usb_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34014640:	f7fc fc78 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34014644:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
34014646:	68fa      	ldr	r2, [r7, #12]
34014648:	68bb      	ldr	r3, [r7, #8]
3401464a:	fbb2 f3f3 	udiv	r3, r2, r3
3401464e:	60fb      	str	r3, [r7, #12]
            break;
34014650:	e01b      	b.n	3401468a <RCCEx_GetOTGPHYCLKFreq+0x12a>
            usb_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34014652:	f7fc fcb5 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34014656:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
34014658:	68fa      	ldr	r2, [r7, #12]
3401465a:	68bb      	ldr	r3, [r7, #8]
3401465c:	fbb2 f3f3 	udiv	r3, r2, r3
34014660:	60fb      	str	r3, [r7, #12]
            break;
34014662:	e012      	b.n	3401468a <RCCEx_GetOTGPHYCLKFreq+0x12a>
            usb_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34014664:	f7fc fcf2 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34014668:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
3401466a:	68fa      	ldr	r2, [r7, #12]
3401466c:	68bb      	ldr	r3, [r7, #8]
3401466e:	fbb2 f3f3 	udiv	r3, r2, r3
34014672:	60fb      	str	r3, [r7, #12]
            break;
34014674:	e009      	b.n	3401468a <RCCEx_GetOTGPHYCLKFreq+0x12a>
            usb_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34014676:	f7fc fd2f 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
3401467a:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
3401467c:	68fa      	ldr	r2, [r7, #12]
3401467e:	68bb      	ldr	r3, [r7, #8]
34014680:	fbb2 f3f3 	udiv	r3, r2, r3
34014684:	60fb      	str	r3, [r7, #12]
            break;
34014686:	e000      	b.n	3401468a <RCCEx_GetOTGPHYCLKFreq+0x12a>
            break;
34014688:	bf00      	nop
      break;
3401468a:	e005      	b.n	34014698 <RCCEx_GetOTGPHYCLKFreq+0x138>
      break;
3401468c:	bf00      	nop
3401468e:	e004      	b.n	3401469a <RCCEx_GetOTGPHYCLKFreq+0x13a>
      break;
34014690:	bf00      	nop
34014692:	e002      	b.n	3401469a <RCCEx_GetOTGPHYCLKFreq+0x13a>
      break;
34014694:	bf00      	nop
34014696:	e000      	b.n	3401469a <RCCEx_GetOTGPHYCLKFreq+0x13a>
      break;
34014698:	bf00      	nop
  }

  return usb_frequency;
3401469a:	68fb      	ldr	r3, [r7, #12]
}
3401469c:	4618      	mov	r0, r3
3401469e:	3710      	adds	r7, #16
340146a0:	46bd      	mov	sp, r7
340146a2:	bd80      	pop	{r7, pc}
340146a4:	03031414 	.word	0x03031414
340146a8:	03030c14 	.word	0x03030c14
340146ac:	03021414 	.word	0x03021414
340146b0:	03020c14 	.word	0x03020c14
340146b4:	03011414 	.word	0x03011414
340146b8:	03010c14 	.word	0x03010c14
340146bc:	03000c14 	.word	0x03000c14
340146c0:	03001414 	.word	0x03001414
340146c4:	016e3600 	.word	0x016e3600
340146c8:	02dc6c00 	.word	0x02dc6c00

340146cc <RCCEx_GetOTGPHYCKREFCLKFreq>:
  *         @arg @ref RCCEx_USBPHY2_Clock_Source
  * @retval OTGPHYCKREF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready or Disabled
  */
static uint32_t RCCEx_GetOTGPHYCKREFCLKFreq(uint32_t OTGPHYxCKREFSource)
{
340146cc:	b580      	push	{r7, lr}
340146ce:	b084      	sub	sp, #16
340146d0:	af00      	add	r7, sp, #0
340146d2:	6078      	str	r0, [r7, #4]
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
340146d4:	2300      	movs	r3, #0
340146d6:	60fb      	str	r3, [r7, #12]

  switch (LL_RCC_GetUSBClockSource(OTGPHYxCKREFSource))
340146d8:	6878      	ldr	r0, [r7, #4]
340146da:	f7f4 fc49 	bl	34008f70 <LL_RCC_GetUSBClockSource>
340146de:	4603      	mov	r3, r0
340146e0:	4a1a      	ldr	r2, [pc, #104]	@ (3401474c <RCCEx_GetOTGPHYCKREFCLKFreq+0x80>)
340146e2:	4293      	cmp	r3, r2
340146e4:	d00f      	beq.n	34014706 <RCCEx_GetOTGPHYCKREFCLKFreq+0x3a>
340146e6:	4a19      	ldr	r2, [pc, #100]	@ (3401474c <RCCEx_GetOTGPHYCKREFCLKFreq+0x80>)
340146e8:	4293      	cmp	r3, r2
340146ea:	d826      	bhi.n	3401473a <RCCEx_GetOTGPHYCKREFCLKFreq+0x6e>
340146ec:	4a18      	ldr	r2, [pc, #96]	@ (34014750 <RCCEx_GetOTGPHYCKREFCLKFreq+0x84>)
340146ee:	4293      	cmp	r3, r2
340146f0:	d009      	beq.n	34014706 <RCCEx_GetOTGPHYCKREFCLKFreq+0x3a>
340146f2:	4a17      	ldr	r2, [pc, #92]	@ (34014750 <RCCEx_GetOTGPHYCKREFCLKFreq+0x84>)
340146f4:	4293      	cmp	r3, r2
340146f6:	d820      	bhi.n	3401473a <RCCEx_GetOTGPHYCKREFCLKFreq+0x6e>
340146f8:	4a16      	ldr	r2, [pc, #88]	@ (34014754 <RCCEx_GetOTGPHYCKREFCLKFreq+0x88>)
340146fa:	4293      	cmp	r3, r2
340146fc:	d013      	beq.n	34014726 <RCCEx_GetOTGPHYCKREFCLKFreq+0x5a>
340146fe:	4a16      	ldr	r2, [pc, #88]	@ (34014758 <RCCEx_GetOTGPHYCKREFCLKFreq+0x8c>)
34014700:	4293      	cmp	r3, r2
34014702:	d015      	beq.n	34014730 <RCCEx_GetOTGPHYCKREFCLKFreq+0x64>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
      break;

    default:
      /* Unexpected case */
      break;
34014704:	e019      	b.n	3401473a <RCCEx_GetOTGPHYCKREFCLKFreq+0x6e>
      if (LL_RCC_HSE_IsReady() != 0U)
34014706:	f7f4 f821 	bl	3400874c <LL_RCC_HSE_IsReady>
3401470a:	4603      	mov	r3, r0
3401470c:	2b00      	cmp	r3, #0
3401470e:	d016      	beq.n	3401473e <RCCEx_GetOTGPHYCKREFCLKFreq+0x72>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
34014710:	f7f4 f80a 	bl	34008728 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
34014714:	4603      	mov	r3, r0
34014716:	2b00      	cmp	r3, #0
34014718:	d102      	bne.n	34014720 <RCCEx_GetOTGPHYCKREFCLKFreq+0x54>
          usb_frequency = HSE_VALUE;
3401471a:	4b10      	ldr	r3, [pc, #64]	@ (3401475c <RCCEx_GetOTGPHYCKREFCLKFreq+0x90>)
3401471c:	60fb      	str	r3, [r7, #12]
      break;
3401471e:	e00e      	b.n	3401473e <RCCEx_GetOTGPHYCKREFCLKFreq+0x72>
          usb_frequency = HSE_VALUE / 2U;
34014720:	4b0f      	ldr	r3, [pc, #60]	@ (34014760 <RCCEx_GetOTGPHYCKREFCLKFreq+0x94>)
34014722:	60fb      	str	r3, [r7, #12]
      break;
34014724:	e00b      	b.n	3401473e <RCCEx_GetOTGPHYCKREFCLKFreq+0x72>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
34014726:	480f      	ldr	r0, [pc, #60]	@ (34014764 <RCCEx_GetOTGPHYCKREFCLKFreq+0x98>)
34014728:	f7ff ff1a 	bl	34014560 <RCCEx_GetOTGPHYCLKFreq>
3401472c:	60f8      	str	r0, [r7, #12]
      break;
3401472e:	e007      	b.n	34014740 <RCCEx_GetOTGPHYCKREFCLKFreq+0x74>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
34014730:	480d      	ldr	r0, [pc, #52]	@ (34014768 <RCCEx_GetOTGPHYCKREFCLKFreq+0x9c>)
34014732:	f7ff ff15 	bl	34014560 <RCCEx_GetOTGPHYCLKFreq>
34014736:	60f8      	str	r0, [r7, #12]
      break;
34014738:	e002      	b.n	34014740 <RCCEx_GetOTGPHYCKREFCLKFreq+0x74>
      break;
3401473a:	bf00      	nop
3401473c:	e000      	b.n	34014740 <RCCEx_GetOTGPHYCKREFCLKFreq+0x74>
      break;
3401473e:	bf00      	nop
  }

  return usb_frequency;
34014740:	68fb      	ldr	r3, [r7, #12]
}
34014742:	4618      	mov	r0, r3
34014744:	3710      	adds	r7, #16
34014746:	46bd      	mov	sp, r7
34014748:	bd80      	pop	{r7, pc}
3401474a:	bf00      	nop
3401474c:	01011814 	.word	0x01011814
34014750:	01011014 	.word	0x01011014
34014754:	01001014 	.word	0x01001014
34014758:	01001814 	.word	0x01001814
3401475c:	02dc6c00 	.word	0x02dc6c00
34014760:	016e3600 	.word	0x016e3600
34014764:	03000c14 	.word	0x03000c14
34014768:	03001414 	.word	0x03001414

3401476c <RCCEx_GetXSPICLKFreq>:
  * @retval XSPI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */

static uint32_t RCCEx_GetXSPICLKFreq(uint32_t XSPIxSource)
{
3401476c:	b580      	push	{r7, lr}
3401476e:	b084      	sub	sp, #16
34014770:	af00      	add	r7, sp, #0
34014772:	6078      	str	r0, [r7, #4]
  uint32_t xspi_frequency = RCC_PERIPH_FREQUENCY_NO;
34014774:	2300      	movs	r3, #0
34014776:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
34014778:	6878      	ldr	r0, [r7, #4]
3401477a:	f7f4 fc05 	bl	34008f88 <LL_RCC_GetXSPIClockSource>
3401477e:	4603      	mov	r3, r0
34014780:	4a76      	ldr	r2, [pc, #472]	@ (3401495c <RCCEx_GetXSPICLKFreq+0x1f0>)
34014782:	4293      	cmp	r3, r2
34014784:	f000 809d 	beq.w	340148c2 <RCCEx_GetXSPICLKFreq+0x156>
34014788:	4a74      	ldr	r2, [pc, #464]	@ (3401495c <RCCEx_GetXSPICLKFreq+0x1f0>)
3401478a:	4293      	cmp	r3, r2
3401478c:	f200 80dc 	bhi.w	34014948 <RCCEx_GetXSPICLKFreq+0x1dc>
34014790:	4a73      	ldr	r2, [pc, #460]	@ (34014960 <RCCEx_GetXSPICLKFreq+0x1f4>)
34014792:	4293      	cmp	r3, r2
34014794:	f000 8095 	beq.w	340148c2 <RCCEx_GetXSPICLKFreq+0x156>
34014798:	4a71      	ldr	r2, [pc, #452]	@ (34014960 <RCCEx_GetXSPICLKFreq+0x1f4>)
3401479a:	4293      	cmp	r3, r2
3401479c:	f200 80d4 	bhi.w	34014948 <RCCEx_GetXSPICLKFreq+0x1dc>
340147a0:	4a70      	ldr	r2, [pc, #448]	@ (34014964 <RCCEx_GetXSPICLKFreq+0x1f8>)
340147a2:	4293      	cmp	r3, r2
340147a4:	f000 808d 	beq.w	340148c2 <RCCEx_GetXSPICLKFreq+0x156>
340147a8:	4a6e      	ldr	r2, [pc, #440]	@ (34014964 <RCCEx_GetXSPICLKFreq+0x1f8>)
340147aa:	4293      	cmp	r3, r2
340147ac:	f200 80cc 	bhi.w	34014948 <RCCEx_GetXSPICLKFreq+0x1dc>
340147b0:	4a6d      	ldr	r2, [pc, #436]	@ (34014968 <RCCEx_GetXSPICLKFreq+0x1fc>)
340147b2:	4293      	cmp	r3, r2
340147b4:	d041      	beq.n	3401483a <RCCEx_GetXSPICLKFreq+0xce>
340147b6:	4a6c      	ldr	r2, [pc, #432]	@ (34014968 <RCCEx_GetXSPICLKFreq+0x1fc>)
340147b8:	4293      	cmp	r3, r2
340147ba:	f200 80c5 	bhi.w	34014948 <RCCEx_GetXSPICLKFreq+0x1dc>
340147be:	4a6b      	ldr	r2, [pc, #428]	@ (3401496c <RCCEx_GetXSPICLKFreq+0x200>)
340147c0:	4293      	cmp	r3, r2
340147c2:	d03a      	beq.n	3401483a <RCCEx_GetXSPICLKFreq+0xce>
340147c4:	4a69      	ldr	r2, [pc, #420]	@ (3401496c <RCCEx_GetXSPICLKFreq+0x200>)
340147c6:	4293      	cmp	r3, r2
340147c8:	f200 80be 	bhi.w	34014948 <RCCEx_GetXSPICLKFreq+0x1dc>
340147cc:	4a68      	ldr	r2, [pc, #416]	@ (34014970 <RCCEx_GetXSPICLKFreq+0x204>)
340147ce:	4293      	cmp	r3, r2
340147d0:	d033      	beq.n	3401483a <RCCEx_GetXSPICLKFreq+0xce>
340147d2:	4a67      	ldr	r2, [pc, #412]	@ (34014970 <RCCEx_GetXSPICLKFreq+0x204>)
340147d4:	4293      	cmp	r3, r2
340147d6:	f200 80b7 	bhi.w	34014948 <RCCEx_GetXSPICLKFreq+0x1dc>
340147da:	4a66      	ldr	r2, [pc, #408]	@ (34014974 <RCCEx_GetXSPICLKFreq+0x208>)
340147dc:	4293      	cmp	r3, r2
340147de:	d027      	beq.n	34014830 <RCCEx_GetXSPICLKFreq+0xc4>
340147e0:	4a64      	ldr	r2, [pc, #400]	@ (34014974 <RCCEx_GetXSPICLKFreq+0x208>)
340147e2:	4293      	cmp	r3, r2
340147e4:	f200 80b0 	bhi.w	34014948 <RCCEx_GetXSPICLKFreq+0x1dc>
340147e8:	4a63      	ldr	r2, [pc, #396]	@ (34014978 <RCCEx_GetXSPICLKFreq+0x20c>)
340147ea:	4293      	cmp	r3, r2
340147ec:	d020      	beq.n	34014830 <RCCEx_GetXSPICLKFreq+0xc4>
340147ee:	4a62      	ldr	r2, [pc, #392]	@ (34014978 <RCCEx_GetXSPICLKFreq+0x20c>)
340147f0:	4293      	cmp	r3, r2
340147f2:	f200 80a9 	bhi.w	34014948 <RCCEx_GetXSPICLKFreq+0x1dc>
340147f6:	4a61      	ldr	r2, [pc, #388]	@ (3401497c <RCCEx_GetXSPICLKFreq+0x210>)
340147f8:	4293      	cmp	r3, r2
340147fa:	d019      	beq.n	34014830 <RCCEx_GetXSPICLKFreq+0xc4>
340147fc:	4a5f      	ldr	r2, [pc, #380]	@ (3401497c <RCCEx_GetXSPICLKFreq+0x210>)
340147fe:	4293      	cmp	r3, r2
34014800:	f200 80a2 	bhi.w	34014948 <RCCEx_GetXSPICLKFreq+0x1dc>
34014804:	4a5e      	ldr	r2, [pc, #376]	@ (34014980 <RCCEx_GetXSPICLKFreq+0x214>)
34014806:	4293      	cmp	r3, r2
34014808:	d00a      	beq.n	34014820 <RCCEx_GetXSPICLKFreq+0xb4>
3401480a:	4a5d      	ldr	r2, [pc, #372]	@ (34014980 <RCCEx_GetXSPICLKFreq+0x214>)
3401480c:	4293      	cmp	r3, r2
3401480e:	f200 809b 	bhi.w	34014948 <RCCEx_GetXSPICLKFreq+0x1dc>
34014812:	4a5c      	ldr	r2, [pc, #368]	@ (34014984 <RCCEx_GetXSPICLKFreq+0x218>)
34014814:	4293      	cmp	r3, r2
34014816:	d003      	beq.n	34014820 <RCCEx_GetXSPICLKFreq+0xb4>
34014818:	4a5b      	ldr	r2, [pc, #364]	@ (34014988 <RCCEx_GetXSPICLKFreq+0x21c>)
3401481a:	4293      	cmp	r3, r2
3401481c:	f040 8094 	bne.w	34014948 <RCCEx_GetXSPICLKFreq+0x1dc>
  {
    case LL_RCC_XSPI1_CLKSOURCE_HCLK:
    case LL_RCC_XSPI2_CLKSOURCE_HCLK:
    case LL_RCC_XSPI3_CLKSOURCE_HCLK:
      xspi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34014820:	f7f3 fba8 	bl	34007f74 <HAL_RCC_GetSysClockFreq>
34014824:	4603      	mov	r3, r0
34014826:	4618      	mov	r0, r3
34014828:	f7fc fc9c 	bl	34011164 <RCCEx_GetHCLKFreq>
3401482c:	60f8      	str	r0, [r7, #12]
      break;
3401482e:	e090      	b.n	34014952 <RCCEx_GetXSPICLKFreq+0x1e6>

    case LL_RCC_XSPI1_CLKSOURCE_CLKP:
    case LL_RCC_XSPI2_CLKSOURCE_CLKP:
    case LL_RCC_XSPI3_CLKSOURCE_CLKP:
      xspi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34014830:	2007      	movs	r0, #7
34014832:	f7fc ff83 	bl	3401173c <RCCEx_GetCLKPCLKFreq>
34014836:	60f8      	str	r0, [r7, #12]
      break;
34014838:	e08b      	b.n	34014952 <RCCEx_GetXSPICLKFreq+0x1e6>

    case LL_RCC_XSPI1_CLKSOURCE_IC3:
    case LL_RCC_XSPI2_CLKSOURCE_IC3:
    case LL_RCC_XSPI3_CLKSOURCE_IC3:
      if (LL_RCC_IC3_IsEnabled() != 0U)
3401483a:	f7f4 fe7d 	bl	34009538 <LL_RCC_IC3_IsEnabled>
3401483e:	4603      	mov	r3, r0
34014840:	2b00      	cmp	r3, #0
34014842:	f000 8083 	beq.w	3401494c <RCCEx_GetXSPICLKFreq+0x1e0>
      {
        ic_divider = LL_RCC_IC3_GetDivider();
34014846:	f7f4 fe99 	bl	3400957c <LL_RCC_IC3_GetDivider>
3401484a:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC3_GetSource())
3401484c:	f7f4 fe88 	bl	34009560 <LL_RCC_IC3_GetSource>
34014850:	4603      	mov	r3, r0
34014852:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014856:	d029      	beq.n	340148ac <RCCEx_GetXSPICLKFreq+0x140>
34014858:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401485c:	d82f      	bhi.n	340148be <RCCEx_GetXSPICLKFreq+0x152>
3401485e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014862:	d01a      	beq.n	3401489a <RCCEx_GetXSPICLKFreq+0x12e>
34014864:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014868:	d829      	bhi.n	340148be <RCCEx_GetXSPICLKFreq+0x152>
3401486a:	2b00      	cmp	r3, #0
3401486c:	d003      	beq.n	34014876 <RCCEx_GetXSPICLKFreq+0x10a>
3401486e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014872:	d009      	beq.n	34014888 <RCCEx_GetXSPICLKFreq+0x11c>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            xspi_frequency = xspi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34014874:	e023      	b.n	340148be <RCCEx_GetXSPICLKFreq+0x152>
            xspi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34014876:	f7fc fb5d 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
3401487a:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
3401487c:	68fa      	ldr	r2, [r7, #12]
3401487e:	68bb      	ldr	r3, [r7, #8]
34014880:	fbb2 f3f3 	udiv	r3, r2, r3
34014884:	60fb      	str	r3, [r7, #12]
            break;
34014886:	e01b      	b.n	340148c0 <RCCEx_GetXSPICLKFreq+0x154>
            xspi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34014888:	f7fc fb9a 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
3401488c:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
3401488e:	68fa      	ldr	r2, [r7, #12]
34014890:	68bb      	ldr	r3, [r7, #8]
34014892:	fbb2 f3f3 	udiv	r3, r2, r3
34014896:	60fb      	str	r3, [r7, #12]
            break;
34014898:	e012      	b.n	340148c0 <RCCEx_GetXSPICLKFreq+0x154>
            xspi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401489a:	f7fc fbd7 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
3401489e:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
340148a0:	68fa      	ldr	r2, [r7, #12]
340148a2:	68bb      	ldr	r3, [r7, #8]
340148a4:	fbb2 f3f3 	udiv	r3, r2, r3
340148a8:	60fb      	str	r3, [r7, #12]
            break;
340148aa:	e009      	b.n	340148c0 <RCCEx_GetXSPICLKFreq+0x154>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340148ac:	f7fc fc14 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
340148b0:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
340148b2:	68fa      	ldr	r2, [r7, #12]
340148b4:	68bb      	ldr	r3, [r7, #8]
340148b6:	fbb2 f3f3 	udiv	r3, r2, r3
340148ba:	60fb      	str	r3, [r7, #12]
            break;
340148bc:	e000      	b.n	340148c0 <RCCEx_GetXSPICLKFreq+0x154>
            break;
340148be:	bf00      	nop
        }
      }
      break;
340148c0:	e044      	b.n	3401494c <RCCEx_GetXSPICLKFreq+0x1e0>

    case LL_RCC_XSPI1_CLKSOURCE_IC4:
    case LL_RCC_XSPI2_CLKSOURCE_IC4:
    case LL_RCC_XSPI3_CLKSOURCE_IC4:
      if (LL_RCC_IC4_IsEnabled() != 0U)
340148c2:	f7f4 fe79 	bl	340095b8 <LL_RCC_IC4_IsEnabled>
340148c6:	4603      	mov	r3, r0
340148c8:	2b00      	cmp	r3, #0
340148ca:	d041      	beq.n	34014950 <RCCEx_GetXSPICLKFreq+0x1e4>
      {
        ic_divider = LL_RCC_IC4_GetDivider();
340148cc:	f7f4 fe96 	bl	340095fc <LL_RCC_IC4_GetDivider>
340148d0:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC4_GetSource())
340148d2:	f7f4 fe85 	bl	340095e0 <LL_RCC_IC4_GetSource>
340148d6:	4603      	mov	r3, r0
340148d8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340148dc:	d029      	beq.n	34014932 <RCCEx_GetXSPICLKFreq+0x1c6>
340148de:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340148e2:	d82f      	bhi.n	34014944 <RCCEx_GetXSPICLKFreq+0x1d8>
340148e4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340148e8:	d01a      	beq.n	34014920 <RCCEx_GetXSPICLKFreq+0x1b4>
340148ea:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340148ee:	d829      	bhi.n	34014944 <RCCEx_GetXSPICLKFreq+0x1d8>
340148f0:	2b00      	cmp	r3, #0
340148f2:	d003      	beq.n	340148fc <RCCEx_GetXSPICLKFreq+0x190>
340148f4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340148f8:	d009      	beq.n	3401490e <RCCEx_GetXSPICLKFreq+0x1a2>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            xspi_frequency = xspi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
340148fa:	e023      	b.n	34014944 <RCCEx_GetXSPICLKFreq+0x1d8>
            xspi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340148fc:	f7fc fb1a 	bl	34010f34 <HAL_RCCEx_GetPLL1CLKFreq>
34014900:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34014902:	68fa      	ldr	r2, [r7, #12]
34014904:	68bb      	ldr	r3, [r7, #8]
34014906:	fbb2 f3f3 	udiv	r3, r2, r3
3401490a:	60fb      	str	r3, [r7, #12]
            break;
3401490c:	e01b      	b.n	34014946 <RCCEx_GetXSPICLKFreq+0x1da>
            xspi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3401490e:	f7fc fb57 	bl	34010fc0 <HAL_RCCEx_GetPLL2CLKFreq>
34014912:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34014914:	68fa      	ldr	r2, [r7, #12]
34014916:	68bb      	ldr	r3, [r7, #8]
34014918:	fbb2 f3f3 	udiv	r3, r2, r3
3401491c:	60fb      	str	r3, [r7, #12]
            break;
3401491e:	e012      	b.n	34014946 <RCCEx_GetXSPICLKFreq+0x1da>
            xspi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34014920:	f7fc fb94 	bl	3401104c <HAL_RCCEx_GetPLL3CLKFreq>
34014924:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34014926:	68fa      	ldr	r2, [r7, #12]
34014928:	68bb      	ldr	r3, [r7, #8]
3401492a:	fbb2 f3f3 	udiv	r3, r2, r3
3401492e:	60fb      	str	r3, [r7, #12]
            break;
34014930:	e009      	b.n	34014946 <RCCEx_GetXSPICLKFreq+0x1da>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34014932:	f7fc fbd1 	bl	340110d8 <HAL_RCCEx_GetPLL4CLKFreq>
34014936:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34014938:	68fa      	ldr	r2, [r7, #12]
3401493a:	68bb      	ldr	r3, [r7, #8]
3401493c:	fbb2 f3f3 	udiv	r3, r2, r3
34014940:	60fb      	str	r3, [r7, #12]
            break;
34014942:	e000      	b.n	34014946 <RCCEx_GetXSPICLKFreq+0x1da>
            break;
34014944:	bf00      	nop
        }
      }
      break;
34014946:	e003      	b.n	34014950 <RCCEx_GetXSPICLKFreq+0x1e4>

    default:
      /* Nothing to do */
      break;
34014948:	bf00      	nop
3401494a:	e002      	b.n	34014952 <RCCEx_GetXSPICLKFreq+0x1e6>
      break;
3401494c:	bf00      	nop
3401494e:	e000      	b.n	34014952 <RCCEx_GetXSPICLKFreq+0x1e6>
      break;
34014950:	bf00      	nop
  }

  return xspi_frequency;
34014952:	68fb      	ldr	r3, [r7, #12]
}
34014954:	4618      	mov	r0, r3
34014956:	3710      	adds	r7, #16
34014958:	46bd      	mov	sp, r7
3401495a:	bd80      	pop	{r7, pc}
3401495c:	03030814 	.word	0x03030814
34014960:	03030414 	.word	0x03030414
34014964:	03030014 	.word	0x03030014
34014968:	03020814 	.word	0x03020814
3401496c:	03020414 	.word	0x03020414
34014970:	03020014 	.word	0x03020014
34014974:	03010814 	.word	0x03010814
34014978:	03010414 	.word	0x03010414
3401497c:	03010014 	.word	0x03010014
34014980:	03000814 	.word	0x03000814
34014984:	03000014 	.word	0x03000014
34014988:	03000414 	.word	0x03000414

3401498c <HAL_RIF_RIMC_ConfigMasterAttributes>:
  *         This parameter can be one of @ref RIF_MASTER_INDEX
  * @param  pConfig Pointer on Master Isolation configuration structure
  * @retval None
  */
void HAL_RIF_RIMC_ConfigMasterAttributes(uint32_t MasterId, const RIMC_MasterConfig_t *pConfig)
{
3401498c:	b580      	push	{r7, lr}
3401498e:	b088      	sub	sp, #32
34014990:	af00      	add	r7, sp, #0
34014992:	6078      	str	r0, [r7, #4]
34014994:	6039      	str	r1, [r7, #0]
  uint32_t master_cid;
  uint32_t rimc_attr_val;

  /* Check the parameter */
  assert_param(pConfig != (void *)NULL);
34014996:	683b      	ldr	r3, [r7, #0]
34014998:	2b00      	cmp	r3, #0
3401499a:	d104      	bne.n	340149a6 <HAL_RIF_RIMC_ConfigMasterAttributes+0x1a>
3401499c:	f240 1111 	movw	r1, #273	@ 0x111
340149a0:	484d      	ldr	r0, [pc, #308]	@ (34014ad8 <HAL_RIF_RIMC_ConfigMasterAttributes+0x14c>)
340149a2:	f7ed fb35 	bl	34002010 <assert_failed>
  assert_param(IS_RIF_MASTER_INDEX(MasterId));
340149a6:	687b      	ldr	r3, [r7, #4]
340149a8:	2b00      	cmp	r3, #0
340149aa:	d028      	beq.n	340149fe <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
340149ac:	687b      	ldr	r3, [r7, #4]
340149ae:	2b01      	cmp	r3, #1
340149b0:	d025      	beq.n	340149fe <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
340149b2:	687b      	ldr	r3, [r7, #4]
340149b4:	2b02      	cmp	r3, #2
340149b6:	d022      	beq.n	340149fe <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
340149b8:	687b      	ldr	r3, [r7, #4]
340149ba:	2b03      	cmp	r3, #3
340149bc:	d01f      	beq.n	340149fe <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
340149be:	687b      	ldr	r3, [r7, #4]
340149c0:	2b04      	cmp	r3, #4
340149c2:	d01c      	beq.n	340149fe <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
340149c4:	687b      	ldr	r3, [r7, #4]
340149c6:	2b05      	cmp	r3, #5
340149c8:	d019      	beq.n	340149fe <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
340149ca:	687b      	ldr	r3, [r7, #4]
340149cc:	2b06      	cmp	r3, #6
340149ce:	d016      	beq.n	340149fe <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
340149d0:	687b      	ldr	r3, [r7, #4]
340149d2:	2b07      	cmp	r3, #7
340149d4:	d013      	beq.n	340149fe <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
340149d6:	687b      	ldr	r3, [r7, #4]
340149d8:	2b08      	cmp	r3, #8
340149da:	d010      	beq.n	340149fe <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
340149dc:	687b      	ldr	r3, [r7, #4]
340149de:	2b09      	cmp	r3, #9
340149e0:	d00d      	beq.n	340149fe <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
340149e2:	687b      	ldr	r3, [r7, #4]
340149e4:	2b0a      	cmp	r3, #10
340149e6:	d00a      	beq.n	340149fe <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
340149e8:	687b      	ldr	r3, [r7, #4]
340149ea:	2b0b      	cmp	r3, #11
340149ec:	d007      	beq.n	340149fe <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
340149ee:	687b      	ldr	r3, [r7, #4]
340149f0:	2b0c      	cmp	r3, #12
340149f2:	d004      	beq.n	340149fe <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
340149f4:	f44f 7189 	mov.w	r1, #274	@ 0x112
340149f8:	4837      	ldr	r0, [pc, #220]	@ (34014ad8 <HAL_RIF_RIMC_ConfigMasterAttributes+0x14c>)
340149fa:	f7ed fb09 	bl	34002010 <assert_failed>
  assert_param(IS_RIF_SINGLE_CID(pConfig->MasterCID));
340149fe:	683b      	ldr	r3, [r7, #0]
34014a00:	681b      	ldr	r3, [r3, #0]
34014a02:	2b01      	cmp	r3, #1
34014a04:	d020      	beq.n	34014a48 <HAL_RIF_RIMC_ConfigMasterAttributes+0xbc>
34014a06:	683b      	ldr	r3, [r7, #0]
34014a08:	681b      	ldr	r3, [r3, #0]
34014a0a:	2b02      	cmp	r3, #2
34014a0c:	d01c      	beq.n	34014a48 <HAL_RIF_RIMC_ConfigMasterAttributes+0xbc>
34014a0e:	683b      	ldr	r3, [r7, #0]
34014a10:	681b      	ldr	r3, [r3, #0]
34014a12:	2b04      	cmp	r3, #4
34014a14:	d018      	beq.n	34014a48 <HAL_RIF_RIMC_ConfigMasterAttributes+0xbc>
34014a16:	683b      	ldr	r3, [r7, #0]
34014a18:	681b      	ldr	r3, [r3, #0]
34014a1a:	2b08      	cmp	r3, #8
34014a1c:	d014      	beq.n	34014a48 <HAL_RIF_RIMC_ConfigMasterAttributes+0xbc>
34014a1e:	683b      	ldr	r3, [r7, #0]
34014a20:	681b      	ldr	r3, [r3, #0]
34014a22:	2b10      	cmp	r3, #16
34014a24:	d010      	beq.n	34014a48 <HAL_RIF_RIMC_ConfigMasterAttributes+0xbc>
34014a26:	683b      	ldr	r3, [r7, #0]
34014a28:	681b      	ldr	r3, [r3, #0]
34014a2a:	2b20      	cmp	r3, #32
34014a2c:	d00c      	beq.n	34014a48 <HAL_RIF_RIMC_ConfigMasterAttributes+0xbc>
34014a2e:	683b      	ldr	r3, [r7, #0]
34014a30:	681b      	ldr	r3, [r3, #0]
34014a32:	2b40      	cmp	r3, #64	@ 0x40
34014a34:	d008      	beq.n	34014a48 <HAL_RIF_RIMC_ConfigMasterAttributes+0xbc>
34014a36:	683b      	ldr	r3, [r7, #0]
34014a38:	681b      	ldr	r3, [r3, #0]
34014a3a:	2b80      	cmp	r3, #128	@ 0x80
34014a3c:	d004      	beq.n	34014a48 <HAL_RIF_RIMC_ConfigMasterAttributes+0xbc>
34014a3e:	f240 1113 	movw	r1, #275	@ 0x113
34014a42:	4825      	ldr	r0, [pc, #148]	@ (34014ad8 <HAL_RIF_RIMC_ConfigMasterAttributes+0x14c>)
34014a44:	f7ed fae4 	bl	34002010 <assert_failed>
  assert_param(IS_RIF_MASTER_CID(pConfig->MasterCID));
34014a48:	683b      	ldr	r3, [r7, #0]
34014a4a:	681b      	ldr	r3, [r3, #0]
34014a4c:	2b80      	cmp	r3, #128	@ 0x80
34014a4e:	d003      	beq.n	34014a58 <HAL_RIF_RIMC_ConfigMasterAttributes+0xcc>
34014a50:	683b      	ldr	r3, [r7, #0]
34014a52:	681b      	ldr	r3, [r3, #0]
34014a54:	2bff      	cmp	r3, #255	@ 0xff
34014a56:	d904      	bls.n	34014a62 <HAL_RIF_RIMC_ConfigMasterAttributes+0xd6>
34014a58:	f44f 718a 	mov.w	r1, #276	@ 0x114
34014a5c:	481e      	ldr	r0, [pc, #120]	@ (34014ad8 <HAL_RIF_RIMC_ConfigMasterAttributes+0x14c>)
34014a5e:	f7ed fad7 	bl	34002010 <assert_failed>
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(pConfig->SecPriv));
34014a62:	683b      	ldr	r3, [r7, #0]
34014a64:	685b      	ldr	r3, [r3, #4]
34014a66:	2b03      	cmp	r3, #3
34014a68:	d904      	bls.n	34014a74 <HAL_RIF_RIMC_ConfigMasterAttributes+0xe8>
34014a6a:	f240 1115 	movw	r1, #277	@ 0x115
34014a6e:	481a      	ldr	r0, [pc, #104]	@ (34014ad8 <HAL_RIF_RIMC_ConfigMasterAttributes+0x14c>)
34014a70:	f7ed face 	bl	34002010 <assert_failed>

  master_cid = POSITION_VAL(pConfig->MasterCID);
34014a74:	683b      	ldr	r3, [r7, #0]
34014a76:	681b      	ldr	r3, [r3, #0]
34014a78:	613b      	str	r3, [r7, #16]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
34014a7a:	693b      	ldr	r3, [r7, #16]
34014a7c:	fa93 f3a3 	rbit	r3, r3
34014a80:	60fb      	str	r3, [r7, #12]
  return result;
34014a82:	68fb      	ldr	r3, [r7, #12]
34014a84:	617b      	str	r3, [r7, #20]
  if (value == 0U)
34014a86:	697b      	ldr	r3, [r7, #20]
34014a88:	2b00      	cmp	r3, #0
34014a8a:	d101      	bne.n	34014a90 <HAL_RIF_RIMC_ConfigMasterAttributes+0x104>
    return 32U;
34014a8c:	2320      	movs	r3, #32
34014a8e:	e003      	b.n	34014a98 <HAL_RIF_RIMC_ConfigMasterAttributes+0x10c>
  return __builtin_clz(value);
34014a90:	697b      	ldr	r3, [r7, #20]
34014a92:	fab3 f383 	clz	r3, r3
34014a96:	b2db      	uxtb	r3, r3
34014a98:	61fb      	str	r3, [r7, #28]
  rimc_attr_val = RIFSC->RIMC_ATTRx[MasterId];
34014a9a:	4a10      	ldr	r2, [pc, #64]	@ (34014adc <HAL_RIF_RIMC_ConfigMasterAttributes+0x150>)
34014a9c:	687b      	ldr	r3, [r7, #4]
34014a9e:	f503 7341 	add.w	r3, r3, #772	@ 0x304
34014aa2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34014aa6:	61bb      	str	r3, [r7, #24]
  rimc_attr_val &= (~(RIFSC_RIMC_ATTRx_MCID | RIFSC_RIMC_ATTRx_MPRIV | RIFSC_RIMC_ATTRx_MSEC));
34014aa8:	69bb      	ldr	r3, [r7, #24]
34014aaa:	f423 735c 	bic.w	r3, r3, #880	@ 0x370
34014aae:	61bb      	str	r3, [r7, #24]
  rimc_attr_val |= ((master_cid << RIFSC_RIMC_ATTRx_MCID_Pos) | (pConfig->SecPriv << RIFSC_RIMC_ATTRx_MSEC_Pos));
34014ab0:	69fb      	ldr	r3, [r7, #28]
34014ab2:	011a      	lsls	r2, r3, #4
34014ab4:	683b      	ldr	r3, [r7, #0]
34014ab6:	685b      	ldr	r3, [r3, #4]
34014ab8:	021b      	lsls	r3, r3, #8
34014aba:	4313      	orrs	r3, r2
34014abc:	69ba      	ldr	r2, [r7, #24]
34014abe:	4313      	orrs	r3, r2
34014ac0:	61bb      	str	r3, [r7, #24]
  RIFSC->RIMC_ATTRx[MasterId] = rimc_attr_val;
34014ac2:	4906      	ldr	r1, [pc, #24]	@ (34014adc <HAL_RIF_RIMC_ConfigMasterAttributes+0x150>)
34014ac4:	687b      	ldr	r3, [r7, #4]
34014ac6:	f503 7341 	add.w	r3, r3, #772	@ 0x304
34014aca:	69ba      	ldr	r2, [r7, #24]
34014acc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
34014ad0:	bf00      	nop
34014ad2:	3720      	adds	r7, #32
34014ad4:	46bd      	mov	sp, r7
34014ad6:	bd80      	pop	{r7, pc}
34014ad8:	3401ef0c 	.word	0x3401ef0c
34014adc:	54024000 	.word	0x54024000

34014ae0 <HAL_RIF_RISC_SetSlaveSecureAttributes>:
  * @param  SecPriv specifies the security and privilege attributes of the peripheral.
  *         This parameter can be one or a combination of @ref RIF_SEC_PRIV
  * @retval None
  */
void HAL_RIF_RISC_SetSlaveSecureAttributes(uint32_t PeriphId, uint32_t SecPriv)
{
34014ae0:	b580      	push	{r7, lr}
34014ae2:	b084      	sub	sp, #16
34014ae4:	af00      	add	r7, sp, #0
34014ae6:	6078      	str	r0, [r7, #4]
34014ae8:	6039      	str	r1, [r7, #0]
  __IO uint32_t sec_reg_val;

  assert_param(IS_RIF_RISC_PERIPH_INDEX(PeriphId) || IS_RIF_RCC_PERIPH_INDEX(PeriphId));
34014aea:	687b      	ldr	r3, [r7, #4]
34014aec:	2b00      	cmp	r3, #0
34014aee:	f000 82c6 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014af2:	687b      	ldr	r3, [r7, #4]
34014af4:	2b01      	cmp	r3, #1
34014af6:	f000 82c2 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014afa:	687b      	ldr	r3, [r7, #4]
34014afc:	2b02      	cmp	r3, #2
34014afe:	f000 82be 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b02:	687b      	ldr	r3, [r7, #4]
34014b04:	2b03      	cmp	r3, #3
34014b06:	f000 82ba 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b0a:	687b      	ldr	r3, [r7, #4]
34014b0c:	2b04      	cmp	r3, #4
34014b0e:	f000 82b6 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b12:	687b      	ldr	r3, [r7, #4]
34014b14:	2b05      	cmp	r3, #5
34014b16:	f000 82b2 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b1a:	687b      	ldr	r3, [r7, #4]
34014b1c:	2b06      	cmp	r3, #6
34014b1e:	f000 82ae 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b22:	687b      	ldr	r3, [r7, #4]
34014b24:	2b08      	cmp	r3, #8
34014b26:	f000 82aa 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b2a:	687b      	ldr	r3, [r7, #4]
34014b2c:	2b09      	cmp	r3, #9
34014b2e:	f000 82a6 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b32:	687b      	ldr	r3, [r7, #4]
34014b34:	2b0a      	cmp	r3, #10
34014b36:	f000 82a2 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b3a:	687b      	ldr	r3, [r7, #4]
34014b3c:	2b0b      	cmp	r3, #11
34014b3e:	f000 829e 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b42:	687b      	ldr	r3, [r7, #4]
34014b44:	2b0c      	cmp	r3, #12
34014b46:	f000 829a 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b4a:	687b      	ldr	r3, [r7, #4]
34014b4c:	2b0d      	cmp	r3, #13
34014b4e:	f000 8296 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b52:	687b      	ldr	r3, [r7, #4]
34014b54:	2b0e      	cmp	r3, #14
34014b56:	f000 8292 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b5a:	687b      	ldr	r3, [r7, #4]
34014b5c:	2b0f      	cmp	r3, #15
34014b5e:	f000 828e 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b62:	687b      	ldr	r3, [r7, #4]
34014b64:	2b10      	cmp	r3, #16
34014b66:	f000 828a 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b6a:	687b      	ldr	r3, [r7, #4]
34014b6c:	2b11      	cmp	r3, #17
34014b6e:	f000 8286 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b72:	687b      	ldr	r3, [r7, #4]
34014b74:	2b12      	cmp	r3, #18
34014b76:	f000 8282 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b7a:	687b      	ldr	r3, [r7, #4]
34014b7c:	2b13      	cmp	r3, #19
34014b7e:	f000 827e 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b82:	687b      	ldr	r3, [r7, #4]
34014b84:	2b14      	cmp	r3, #20
34014b86:	f000 827a 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b8a:	687b      	ldr	r3, [r7, #4]
34014b8c:	2b15      	cmp	r3, #21
34014b8e:	f000 8276 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b92:	687b      	ldr	r3, [r7, #4]
34014b94:	2b16      	cmp	r3, #22
34014b96:	f000 8272 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014b9a:	687b      	ldr	r3, [r7, #4]
34014b9c:	2b17      	cmp	r3, #23
34014b9e:	f000 826e 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014ba2:	687b      	ldr	r3, [r7, #4]
34014ba4:	2b18      	cmp	r3, #24
34014ba6:	f000 826a 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014baa:	687b      	ldr	r3, [r7, #4]
34014bac:	2b19      	cmp	r3, #25
34014bae:	f000 8266 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014bb2:	687b      	ldr	r3, [r7, #4]
34014bb4:	2b1a      	cmp	r3, #26
34014bb6:	f000 8262 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014bba:	687b      	ldr	r3, [r7, #4]
34014bbc:	2b1b      	cmp	r3, #27
34014bbe:	f000 825e 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014bc2:	687b      	ldr	r3, [r7, #4]
34014bc4:	2b1c      	cmp	r3, #28
34014bc6:	f000 825a 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014bca:	687b      	ldr	r3, [r7, #4]
34014bcc:	2b1d      	cmp	r3, #29
34014bce:	f000 8256 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014bd2:	687b      	ldr	r3, [r7, #4]
34014bd4:	2b1e      	cmp	r3, #30
34014bd6:	f000 8252 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014bda:	687b      	ldr	r3, [r7, #4]
34014bdc:	2b1f      	cmp	r3, #31
34014bde:	f000 824e 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014be2:	687b      	ldr	r3, [r7, #4]
34014be4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014be8:	f000 8249 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014bec:	687b      	ldr	r3, [r7, #4]
34014bee:	4aa0      	ldr	r2, [pc, #640]	@ (34014e70 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x390>)
34014bf0:	4293      	cmp	r3, r2
34014bf2:	f000 8244 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014bf6:	687b      	ldr	r3, [r7, #4]
34014bf8:	4a9e      	ldr	r2, [pc, #632]	@ (34014e74 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x394>)
34014bfa:	4293      	cmp	r3, r2
34014bfc:	f000 823f 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014c00:	687b      	ldr	r3, [r7, #4]
34014c02:	4a9d      	ldr	r2, [pc, #628]	@ (34014e78 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x398>)
34014c04:	4293      	cmp	r3, r2
34014c06:	f000 823a 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014c0a:	687b      	ldr	r3, [r7, #4]
34014c0c:	4a9b      	ldr	r2, [pc, #620]	@ (34014e7c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x39c>)
34014c0e:	4293      	cmp	r3, r2
34014c10:	f000 8235 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014c14:	687b      	ldr	r3, [r7, #4]
34014c16:	4a9a      	ldr	r2, [pc, #616]	@ (34014e80 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3a0>)
34014c18:	4293      	cmp	r3, r2
34014c1a:	f000 8230 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014c1e:	687b      	ldr	r3, [r7, #4]
34014c20:	4a98      	ldr	r2, [pc, #608]	@ (34014e84 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3a4>)
34014c22:	4293      	cmp	r3, r2
34014c24:	f000 822b 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014c28:	687b      	ldr	r3, [r7, #4]
34014c2a:	4a97      	ldr	r2, [pc, #604]	@ (34014e88 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3a8>)
34014c2c:	4293      	cmp	r3, r2
34014c2e:	f000 8226 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014c32:	687b      	ldr	r3, [r7, #4]
34014c34:	4a95      	ldr	r2, [pc, #596]	@ (34014e8c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3ac>)
34014c36:	4293      	cmp	r3, r2
34014c38:	f000 8221 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014c3c:	687b      	ldr	r3, [r7, #4]
34014c3e:	4a94      	ldr	r2, [pc, #592]	@ (34014e90 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3b0>)
34014c40:	4293      	cmp	r3, r2
34014c42:	f000 821c 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014c46:	687b      	ldr	r3, [r7, #4]
34014c48:	4a92      	ldr	r2, [pc, #584]	@ (34014e94 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3b4>)
34014c4a:	4293      	cmp	r3, r2
34014c4c:	f000 8217 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014c50:	687b      	ldr	r3, [r7, #4]
34014c52:	4a91      	ldr	r2, [pc, #580]	@ (34014e98 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3b8>)
34014c54:	4293      	cmp	r3, r2
34014c56:	f000 8212 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014c5a:	687b      	ldr	r3, [r7, #4]
34014c5c:	4a8f      	ldr	r2, [pc, #572]	@ (34014e9c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3bc>)
34014c5e:	4293      	cmp	r3, r2
34014c60:	f000 820d 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014c64:	687b      	ldr	r3, [r7, #4]
34014c66:	4a8e      	ldr	r2, [pc, #568]	@ (34014ea0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3c0>)
34014c68:	4293      	cmp	r3, r2
34014c6a:	f000 8208 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014c6e:	687b      	ldr	r3, [r7, #4]
34014c70:	4a8c      	ldr	r2, [pc, #560]	@ (34014ea4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3c4>)
34014c72:	4293      	cmp	r3, r2
34014c74:	f000 8203 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014c78:	687b      	ldr	r3, [r7, #4]
34014c7a:	4a8b      	ldr	r2, [pc, #556]	@ (34014ea8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3c8>)
34014c7c:	4293      	cmp	r3, r2
34014c7e:	f000 81fe 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014c82:	687b      	ldr	r3, [r7, #4]
34014c84:	4a89      	ldr	r2, [pc, #548]	@ (34014eac <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3cc>)
34014c86:	4293      	cmp	r3, r2
34014c88:	f000 81f9 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014c8c:	687b      	ldr	r3, [r7, #4]
34014c8e:	4a88      	ldr	r2, [pc, #544]	@ (34014eb0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3d0>)
34014c90:	4293      	cmp	r3, r2
34014c92:	f000 81f4 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014c96:	687b      	ldr	r3, [r7, #4]
34014c98:	4a86      	ldr	r2, [pc, #536]	@ (34014eb4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3d4>)
34014c9a:	4293      	cmp	r3, r2
34014c9c:	f000 81ef 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014ca0:	687b      	ldr	r3, [r7, #4]
34014ca2:	4a85      	ldr	r2, [pc, #532]	@ (34014eb8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3d8>)
34014ca4:	4293      	cmp	r3, r2
34014ca6:	f000 81ea 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014caa:	687b      	ldr	r3, [r7, #4]
34014cac:	4a83      	ldr	r2, [pc, #524]	@ (34014ebc <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3dc>)
34014cae:	4293      	cmp	r3, r2
34014cb0:	f000 81e5 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014cb4:	687b      	ldr	r3, [r7, #4]
34014cb6:	4a82      	ldr	r2, [pc, #520]	@ (34014ec0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3e0>)
34014cb8:	4293      	cmp	r3, r2
34014cba:	f000 81e0 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014cbe:	687b      	ldr	r3, [r7, #4]
34014cc0:	4a80      	ldr	r2, [pc, #512]	@ (34014ec4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3e4>)
34014cc2:	4293      	cmp	r3, r2
34014cc4:	f000 81db 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014cc8:	687b      	ldr	r3, [r7, #4]
34014cca:	4a7f      	ldr	r2, [pc, #508]	@ (34014ec8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3e8>)
34014ccc:	4293      	cmp	r3, r2
34014cce:	f000 81d6 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014cd2:	687b      	ldr	r3, [r7, #4]
34014cd4:	4a7d      	ldr	r2, [pc, #500]	@ (34014ecc <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3ec>)
34014cd6:	4293      	cmp	r3, r2
34014cd8:	f000 81d1 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014cdc:	687b      	ldr	r3, [r7, #4]
34014cde:	4a7c      	ldr	r2, [pc, #496]	@ (34014ed0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3f0>)
34014ce0:	4293      	cmp	r3, r2
34014ce2:	f000 81cc 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014ce6:	687b      	ldr	r3, [r7, #4]
34014ce8:	4a7a      	ldr	r2, [pc, #488]	@ (34014ed4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3f4>)
34014cea:	4293      	cmp	r3, r2
34014cec:	f000 81c7 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014cf0:	687b      	ldr	r3, [r7, #4]
34014cf2:	4a79      	ldr	r2, [pc, #484]	@ (34014ed8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3f8>)
34014cf4:	4293      	cmp	r3, r2
34014cf6:	f000 81c2 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014cfa:	687b      	ldr	r3, [r7, #4]
34014cfc:	4a77      	ldr	r2, [pc, #476]	@ (34014edc <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3fc>)
34014cfe:	4293      	cmp	r3, r2
34014d00:	f000 81bd 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014d04:	687b      	ldr	r3, [r7, #4]
34014d06:	4a76      	ldr	r2, [pc, #472]	@ (34014ee0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x400>)
34014d08:	4293      	cmp	r3, r2
34014d0a:	f000 81b8 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014d0e:	687b      	ldr	r3, [r7, #4]
34014d10:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014d14:	f000 81b3 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014d18:	687b      	ldr	r3, [r7, #4]
34014d1a:	4a72      	ldr	r2, [pc, #456]	@ (34014ee4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x404>)
34014d1c:	4293      	cmp	r3, r2
34014d1e:	f000 81ae 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014d22:	687b      	ldr	r3, [r7, #4]
34014d24:	4a70      	ldr	r2, [pc, #448]	@ (34014ee8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x408>)
34014d26:	4293      	cmp	r3, r2
34014d28:	f000 81a9 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014d2c:	687b      	ldr	r3, [r7, #4]
34014d2e:	4a6f      	ldr	r2, [pc, #444]	@ (34014eec <HAL_RIF_RISC_SetSlaveSecureAttributes+0x40c>)
34014d30:	4293      	cmp	r3, r2
34014d32:	f000 81a4 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014d36:	687b      	ldr	r3, [r7, #4]
34014d38:	4a6d      	ldr	r2, [pc, #436]	@ (34014ef0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x410>)
34014d3a:	4293      	cmp	r3, r2
34014d3c:	f000 819f 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014d40:	687b      	ldr	r3, [r7, #4]
34014d42:	4a6c      	ldr	r2, [pc, #432]	@ (34014ef4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x414>)
34014d44:	4293      	cmp	r3, r2
34014d46:	f000 819a 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014d4a:	687b      	ldr	r3, [r7, #4]
34014d4c:	4a6a      	ldr	r2, [pc, #424]	@ (34014ef8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x418>)
34014d4e:	4293      	cmp	r3, r2
34014d50:	f000 8195 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014d54:	687b      	ldr	r3, [r7, #4]
34014d56:	4a69      	ldr	r2, [pc, #420]	@ (34014efc <HAL_RIF_RISC_SetSlaveSecureAttributes+0x41c>)
34014d58:	4293      	cmp	r3, r2
34014d5a:	f000 8190 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014d5e:	687b      	ldr	r3, [r7, #4]
34014d60:	4a67      	ldr	r2, [pc, #412]	@ (34014f00 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x420>)
34014d62:	4293      	cmp	r3, r2
34014d64:	f000 818b 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014d68:	687b      	ldr	r3, [r7, #4]
34014d6a:	4a66      	ldr	r2, [pc, #408]	@ (34014f04 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x424>)
34014d6c:	4293      	cmp	r3, r2
34014d6e:	f000 8186 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014d72:	687b      	ldr	r3, [r7, #4]
34014d74:	4a64      	ldr	r2, [pc, #400]	@ (34014f08 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x428>)
34014d76:	4293      	cmp	r3, r2
34014d78:	f000 8181 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014d7c:	687b      	ldr	r3, [r7, #4]
34014d7e:	4a63      	ldr	r2, [pc, #396]	@ (34014f0c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x42c>)
34014d80:	4293      	cmp	r3, r2
34014d82:	f000 817c 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014d86:	687b      	ldr	r3, [r7, #4]
34014d88:	4a61      	ldr	r2, [pc, #388]	@ (34014f10 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x430>)
34014d8a:	4293      	cmp	r3, r2
34014d8c:	f000 8177 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014d90:	687b      	ldr	r3, [r7, #4]
34014d92:	4a60      	ldr	r2, [pc, #384]	@ (34014f14 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x434>)
34014d94:	4293      	cmp	r3, r2
34014d96:	f000 8172 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014d9a:	687b      	ldr	r3, [r7, #4]
34014d9c:	4a5e      	ldr	r2, [pc, #376]	@ (34014f18 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x438>)
34014d9e:	4293      	cmp	r3, r2
34014da0:	f000 816d 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014da4:	687b      	ldr	r3, [r7, #4]
34014da6:	4a5d      	ldr	r2, [pc, #372]	@ (34014f1c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x43c>)
34014da8:	4293      	cmp	r3, r2
34014daa:	f000 8168 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014dae:	687b      	ldr	r3, [r7, #4]
34014db0:	4a5b      	ldr	r2, [pc, #364]	@ (34014f20 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x440>)
34014db2:	4293      	cmp	r3, r2
34014db4:	f000 8163 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014db8:	687b      	ldr	r3, [r7, #4]
34014dba:	4a5a      	ldr	r2, [pc, #360]	@ (34014f24 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x444>)
34014dbc:	4293      	cmp	r3, r2
34014dbe:	f000 815e 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014dc2:	687b      	ldr	r3, [r7, #4]
34014dc4:	4a58      	ldr	r2, [pc, #352]	@ (34014f28 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x448>)
34014dc6:	4293      	cmp	r3, r2
34014dc8:	f000 8159 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014dcc:	687b      	ldr	r3, [r7, #4]
34014dce:	4a57      	ldr	r2, [pc, #348]	@ (34014f2c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x44c>)
34014dd0:	4293      	cmp	r3, r2
34014dd2:	f000 8154 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014dd6:	687b      	ldr	r3, [r7, #4]
34014dd8:	4a55      	ldr	r2, [pc, #340]	@ (34014f30 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x450>)
34014dda:	4293      	cmp	r3, r2
34014ddc:	f000 814f 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014de0:	687b      	ldr	r3, [r7, #4]
34014de2:	4a54      	ldr	r2, [pc, #336]	@ (34014f34 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x454>)
34014de4:	4293      	cmp	r3, r2
34014de6:	f000 814a 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014dea:	687b      	ldr	r3, [r7, #4]
34014dec:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014df0:	f000 8145 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014df4:	687b      	ldr	r3, [r7, #4]
34014df6:	4a50      	ldr	r2, [pc, #320]	@ (34014f38 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x458>)
34014df8:	4293      	cmp	r3, r2
34014dfa:	f000 8140 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014dfe:	687b      	ldr	r3, [r7, #4]
34014e00:	4a4e      	ldr	r2, [pc, #312]	@ (34014f3c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x45c>)
34014e02:	4293      	cmp	r3, r2
34014e04:	f000 813b 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014e08:	687b      	ldr	r3, [r7, #4]
34014e0a:	4a4d      	ldr	r2, [pc, #308]	@ (34014f40 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x460>)
34014e0c:	4293      	cmp	r3, r2
34014e0e:	f000 8136 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014e12:	687b      	ldr	r3, [r7, #4]
34014e14:	4a4b      	ldr	r2, [pc, #300]	@ (34014f44 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x464>)
34014e16:	4293      	cmp	r3, r2
34014e18:	f000 8131 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014e1c:	687b      	ldr	r3, [r7, #4]
34014e1e:	4a4a      	ldr	r2, [pc, #296]	@ (34014f48 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x468>)
34014e20:	4293      	cmp	r3, r2
34014e22:	f000 812c 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014e26:	687b      	ldr	r3, [r7, #4]
34014e28:	4a48      	ldr	r2, [pc, #288]	@ (34014f4c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x46c>)
34014e2a:	4293      	cmp	r3, r2
34014e2c:	f000 8127 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014e30:	687b      	ldr	r3, [r7, #4]
34014e32:	4a47      	ldr	r2, [pc, #284]	@ (34014f50 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x470>)
34014e34:	4293      	cmp	r3, r2
34014e36:	f000 8122 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014e3a:	687b      	ldr	r3, [r7, #4]
34014e3c:	4a45      	ldr	r2, [pc, #276]	@ (34014f54 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x474>)
34014e3e:	4293      	cmp	r3, r2
34014e40:	f000 811d 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014e44:	687b      	ldr	r3, [r7, #4]
34014e46:	4a44      	ldr	r2, [pc, #272]	@ (34014f58 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x478>)
34014e48:	4293      	cmp	r3, r2
34014e4a:	f000 8118 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014e4e:	687b      	ldr	r3, [r7, #4]
34014e50:	4a42      	ldr	r2, [pc, #264]	@ (34014f5c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x47c>)
34014e52:	4293      	cmp	r3, r2
34014e54:	f000 8113 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014e58:	687b      	ldr	r3, [r7, #4]
34014e5a:	4a41      	ldr	r2, [pc, #260]	@ (34014f60 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x480>)
34014e5c:	4293      	cmp	r3, r2
34014e5e:	f000 810e 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014e62:	687b      	ldr	r3, [r7, #4]
34014e64:	4a3f      	ldr	r2, [pc, #252]	@ (34014f64 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x484>)
34014e66:	4293      	cmp	r3, r2
34014e68:	f000 8109 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014e6c:	e07c      	b.n	34014f68 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x488>
34014e6e:	bf00      	nop
34014e70:	10000001 	.word	0x10000001
34014e74:	10000002 	.word	0x10000002
34014e78:	10000003 	.word	0x10000003
34014e7c:	10000004 	.word	0x10000004
34014e80:	10000005 	.word	0x10000005
34014e84:	10000006 	.word	0x10000006
34014e88:	10000007 	.word	0x10000007
34014e8c:	10000008 	.word	0x10000008
34014e90:	10000009 	.word	0x10000009
34014e94:	1000000a 	.word	0x1000000a
34014e98:	1000000b 	.word	0x1000000b
34014e9c:	1000000c 	.word	0x1000000c
34014ea0:	1000000d 	.word	0x1000000d
34014ea4:	1000000e 	.word	0x1000000e
34014ea8:	1000000f 	.word	0x1000000f
34014eac:	10000010 	.word	0x10000010
34014eb0:	10000011 	.word	0x10000011
34014eb4:	10000012 	.word	0x10000012
34014eb8:	10000013 	.word	0x10000013
34014ebc:	10000014 	.word	0x10000014
34014ec0:	10000015 	.word	0x10000015
34014ec4:	10000016 	.word	0x10000016
34014ec8:	10000017 	.word	0x10000017
34014ecc:	10000018 	.word	0x10000018
34014ed0:	10000019 	.word	0x10000019
34014ed4:	1000001a 	.word	0x1000001a
34014ed8:	1000001c 	.word	0x1000001c
34014edc:	1000001d 	.word	0x1000001d
34014ee0:	1000001e 	.word	0x1000001e
34014ee4:	20000001 	.word	0x20000001
34014ee8:	20000003 	.word	0x20000003
34014eec:	20000004 	.word	0x20000004
34014ef0:	20000005 	.word	0x20000005
34014ef4:	2000000c 	.word	0x2000000c
34014ef8:	2000000d 	.word	0x2000000d
34014efc:	2000000e 	.word	0x2000000e
34014f00:	2000000f 	.word	0x2000000f
34014f04:	20000010 	.word	0x20000010
34014f08:	20000011 	.word	0x20000011
34014f0c:	20000012 	.word	0x20000012
34014f10:	20000013 	.word	0x20000013
34014f14:	20000014 	.word	0x20000014
34014f18:	20000016 	.word	0x20000016
34014f1c:	20000017 	.word	0x20000017
34014f20:	20000018 	.word	0x20000018
34014f24:	20000019 	.word	0x20000019
34014f28:	2000001a 	.word	0x2000001a
34014f2c:	2000001c 	.word	0x2000001c
34014f30:	2000001d 	.word	0x2000001d
34014f34:	2000001e 	.word	0x2000001e
34014f38:	30000001 	.word	0x30000001
34014f3c:	30000002 	.word	0x30000002
34014f40:	30000003 	.word	0x30000003
34014f44:	30000004 	.word	0x30000004
34014f48:	30000005 	.word	0x30000005
34014f4c:	30000006 	.word	0x30000006
34014f50:	30000007 	.word	0x30000007
34014f54:	30000008 	.word	0x30000008
34014f58:	3000000a 	.word	0x3000000a
34014f5c:	40000002 	.word	0x40000002
34014f60:	40000003 	.word	0x40000003
34014f64:	40000005 	.word	0x40000005
34014f68:	687b      	ldr	r3, [r7, #4]
34014f6a:	4a6d      	ldr	r2, [pc, #436]	@ (34015120 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x640>)
34014f6c:	4293      	cmp	r3, r2
34014f6e:	f000 8086 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014f72:	687b      	ldr	r3, [r7, #4]
34014f74:	4a6b      	ldr	r2, [pc, #428]	@ (34015124 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x644>)
34014f76:	4293      	cmp	r3, r2
34014f78:	f000 8081 	beq.w	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014f7c:	687b      	ldr	r3, [r7, #4]
34014f7e:	4a6a      	ldr	r2, [pc, #424]	@ (34015128 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x648>)
34014f80:	4293      	cmp	r3, r2
34014f82:	d07c      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014f84:	687b      	ldr	r3, [r7, #4]
34014f86:	4a69      	ldr	r2, [pc, #420]	@ (3401512c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x64c>)
34014f88:	4293      	cmp	r3, r2
34014f8a:	d078      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014f8c:	687b      	ldr	r3, [r7, #4]
34014f8e:	4a68      	ldr	r2, [pc, #416]	@ (34015130 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x650>)
34014f90:	4293      	cmp	r3, r2
34014f92:	d074      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014f94:	687b      	ldr	r3, [r7, #4]
34014f96:	4a67      	ldr	r2, [pc, #412]	@ (34015134 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x654>)
34014f98:	4293      	cmp	r3, r2
34014f9a:	d070      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014f9c:	687b      	ldr	r3, [r7, #4]
34014f9e:	4a66      	ldr	r2, [pc, #408]	@ (34015138 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x658>)
34014fa0:	4293      	cmp	r3, r2
34014fa2:	d06c      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014fa4:	687b      	ldr	r3, [r7, #4]
34014fa6:	4a65      	ldr	r2, [pc, #404]	@ (3401513c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x65c>)
34014fa8:	4293      	cmp	r3, r2
34014faa:	d068      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014fac:	687b      	ldr	r3, [r7, #4]
34014fae:	4a64      	ldr	r2, [pc, #400]	@ (34015140 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x660>)
34014fb0:	4293      	cmp	r3, r2
34014fb2:	d064      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014fb4:	687b      	ldr	r3, [r7, #4]
34014fb6:	4a63      	ldr	r2, [pc, #396]	@ (34015144 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x664>)
34014fb8:	4293      	cmp	r3, r2
34014fba:	d060      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014fbc:	687b      	ldr	r3, [r7, #4]
34014fbe:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
34014fc2:	d05c      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014fc4:	687b      	ldr	r3, [r7, #4]
34014fc6:	4a60      	ldr	r2, [pc, #384]	@ (34015148 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x668>)
34014fc8:	4293      	cmp	r3, r2
34014fca:	d058      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014fcc:	687b      	ldr	r3, [r7, #4]
34014fce:	4a5f      	ldr	r2, [pc, #380]	@ (3401514c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x66c>)
34014fd0:	4293      	cmp	r3, r2
34014fd2:	d054      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014fd4:	687b      	ldr	r3, [r7, #4]
34014fd6:	4a5e      	ldr	r2, [pc, #376]	@ (34015150 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x670>)
34014fd8:	4293      	cmp	r3, r2
34014fda:	d050      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014fdc:	687b      	ldr	r3, [r7, #4]
34014fde:	4a5d      	ldr	r2, [pc, #372]	@ (34015154 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x674>)
34014fe0:	4293      	cmp	r3, r2
34014fe2:	d04c      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014fe4:	687b      	ldr	r3, [r7, #4]
34014fe6:	4a5c      	ldr	r2, [pc, #368]	@ (34015158 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x678>)
34014fe8:	4293      	cmp	r3, r2
34014fea:	d048      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014fec:	687b      	ldr	r3, [r7, #4]
34014fee:	4a5b      	ldr	r2, [pc, #364]	@ (3401515c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x67c>)
34014ff0:	4293      	cmp	r3, r2
34014ff2:	d044      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014ff4:	687b      	ldr	r3, [r7, #4]
34014ff6:	4a5a      	ldr	r2, [pc, #360]	@ (34015160 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x680>)
34014ff8:	4293      	cmp	r3, r2
34014ffa:	d040      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34014ffc:	687b      	ldr	r3, [r7, #4]
34014ffe:	4a59      	ldr	r2, [pc, #356]	@ (34015164 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x684>)
34015000:	4293      	cmp	r3, r2
34015002:	d03c      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34015004:	687b      	ldr	r3, [r7, #4]
34015006:	4a58      	ldr	r2, [pc, #352]	@ (34015168 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x688>)
34015008:	4293      	cmp	r3, r2
3401500a:	d038      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401500c:	687b      	ldr	r3, [r7, #4]
3401500e:	4a57      	ldr	r2, [pc, #348]	@ (3401516c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x68c>)
34015010:	4293      	cmp	r3, r2
34015012:	d034      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34015014:	687b      	ldr	r3, [r7, #4]
34015016:	4a56      	ldr	r2, [pc, #344]	@ (34015170 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x690>)
34015018:	4293      	cmp	r3, r2
3401501a:	d030      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401501c:	687b      	ldr	r3, [r7, #4]
3401501e:	4a55      	ldr	r2, [pc, #340]	@ (34015174 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x694>)
34015020:	4293      	cmp	r3, r2
34015022:	d02c      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34015024:	687b      	ldr	r3, [r7, #4]
34015026:	4a54      	ldr	r2, [pc, #336]	@ (34015178 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x698>)
34015028:	4293      	cmp	r3, r2
3401502a:	d028      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401502c:	687b      	ldr	r3, [r7, #4]
3401502e:	4a53      	ldr	r2, [pc, #332]	@ (3401517c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x69c>)
34015030:	4293      	cmp	r3, r2
34015032:	d024      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34015034:	687b      	ldr	r3, [r7, #4]
34015036:	4a52      	ldr	r2, [pc, #328]	@ (34015180 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6a0>)
34015038:	4293      	cmp	r3, r2
3401503a:	d020      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401503c:	687b      	ldr	r3, [r7, #4]
3401503e:	4a51      	ldr	r2, [pc, #324]	@ (34015184 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6a4>)
34015040:	4293      	cmp	r3, r2
34015042:	d01c      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34015044:	687b      	ldr	r3, [r7, #4]
34015046:	4a50      	ldr	r2, [pc, #320]	@ (34015188 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6a8>)
34015048:	4293      	cmp	r3, r2
3401504a:	d018      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401504c:	687b      	ldr	r3, [r7, #4]
3401504e:	4a4f      	ldr	r2, [pc, #316]	@ (3401518c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6ac>)
34015050:	4293      	cmp	r3, r2
34015052:	d014      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34015054:	687b      	ldr	r3, [r7, #4]
34015056:	4a4e      	ldr	r2, [pc, #312]	@ (34015190 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6b0>)
34015058:	4293      	cmp	r3, r2
3401505a:	d010      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401505c:	687b      	ldr	r3, [r7, #4]
3401505e:	4a4d      	ldr	r2, [pc, #308]	@ (34015194 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6b4>)
34015060:	4293      	cmp	r3, r2
34015062:	d00c      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34015064:	687b      	ldr	r3, [r7, #4]
34015066:	4a4c      	ldr	r2, [pc, #304]	@ (34015198 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6b8>)
34015068:	4293      	cmp	r3, r2
3401506a:	d008      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401506c:	687b      	ldr	r3, [r7, #4]
3401506e:	4a4b      	ldr	r2, [pc, #300]	@ (3401519c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6bc>)
34015070:	4293      	cmp	r3, r2
34015072:	d004      	beq.n	3401507e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34015074:	f240 1173 	movw	r1, #371	@ 0x173
34015078:	4849      	ldr	r0, [pc, #292]	@ (340151a0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6c0>)
3401507a:	f7ec ffc9 	bl	34002010 <assert_failed>
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(SecPriv));
3401507e:	683b      	ldr	r3, [r7, #0]
34015080:	2b03      	cmp	r3, #3
34015082:	d904      	bls.n	3401508e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x5ae>
34015084:	f44f 71ba 	mov.w	r1, #372	@ 0x174
34015088:	4845      	ldr	r0, [pc, #276]	@ (340151a0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6c0>)
3401508a:	f7ec ffc1 	bl	34002010 <assert_failed>

  sec_reg_val = RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3401508e:	4a45      	ldr	r2, [pc, #276]	@ (340151a4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6c4>)
34015090:	687b      	ldr	r3, [r7, #4]
34015092:	0f1b      	lsrs	r3, r3, #28
34015094:	3304      	adds	r3, #4
34015096:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3401509a:	60fb      	str	r3, [r7, #12]
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
3401509c:	687b      	ldr	r3, [r7, #4]
3401509e:	f003 031f 	and.w	r3, r3, #31
340150a2:	2201      	movs	r2, #1
340150a4:	fa02 f303 	lsl.w	r3, r2, r3
340150a8:	43da      	mvns	r2, r3
340150aa:	68fb      	ldr	r3, [r7, #12]
340150ac:	4013      	ands	r3, r2
340150ae:	60fb      	str	r3, [r7, #12]
  sec_reg_val |= ((SecPriv & RIF_ATTRIBUTE_SEC) << (PeriphId & RIF_PERIPH_BIT_POSITION));
340150b0:	683b      	ldr	r3, [r7, #0]
340150b2:	f003 0201 	and.w	r2, r3, #1
340150b6:	687b      	ldr	r3, [r7, #4]
340150b8:	f003 031f 	and.w	r3, r3, #31
340150bc:	409a      	lsls	r2, r3
340150be:	68fb      	ldr	r3, [r7, #12]
340150c0:	4313      	orrs	r3, r2
340150c2:	60fb      	str	r3, [r7, #12]
  RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
340150c4:	4937      	ldr	r1, [pc, #220]	@ (340151a4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6c4>)
340150c6:	687b      	ldr	r3, [r7, #4]
340150c8:	0f1b      	lsrs	r3, r3, #28
340150ca:	68fa      	ldr	r2, [r7, #12]
340150cc:	3304      	adds	r3, #4
340150ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

  sec_reg_val = RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
340150d2:	4a34      	ldr	r2, [pc, #208]	@ (340151a4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6c4>)
340150d4:	687b      	ldr	r3, [r7, #4]
340150d6:	0f1b      	lsrs	r3, r3, #28
340150d8:	330c      	adds	r3, #12
340150da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
340150de:	60fb      	str	r3, [r7, #12]
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
340150e0:	687b      	ldr	r3, [r7, #4]
340150e2:	f003 031f 	and.w	r3, r3, #31
340150e6:	2201      	movs	r2, #1
340150e8:	fa02 f303 	lsl.w	r3, r2, r3
340150ec:	43da      	mvns	r2, r3
340150ee:	68fb      	ldr	r3, [r7, #12]
340150f0:	4013      	ands	r3, r2
340150f2:	60fb      	str	r3, [r7, #12]
  sec_reg_val |= (((SecPriv & RIF_ATTRIBUTE_PRIV) >> 1U) << (PeriphId & RIF_PERIPH_BIT_POSITION));
340150f4:	683b      	ldr	r3, [r7, #0]
340150f6:	085b      	lsrs	r3, r3, #1
340150f8:	f003 0201 	and.w	r2, r3, #1
340150fc:	687b      	ldr	r3, [r7, #4]
340150fe:	f003 031f 	and.w	r3, r3, #31
34015102:	409a      	lsls	r2, r3
34015104:	68fb      	ldr	r3, [r7, #12]
34015106:	4313      	orrs	r3, r2
34015108:	60fb      	str	r3, [r7, #12]
  RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
3401510a:	4926      	ldr	r1, [pc, #152]	@ (340151a4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6c4>)
3401510c:	687b      	ldr	r3, [r7, #4]
3401510e:	0f1b      	lsrs	r3, r3, #28
34015110:	68fa      	ldr	r2, [r7, #12]
34015112:	330c      	adds	r3, #12
34015114:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
34015118:	bf00      	nop
3401511a:	3710      	adds	r7, #16
3401511c:	46bd      	mov	sp, r7
3401511e:	bd80      	pop	{r7, pc}
34015120:	4000000c 	.word	0x4000000c
34015124:	4000000d 	.word	0x4000000d
34015128:	40000011 	.word	0x40000011
3401512c:	40000012 	.word	0x40000012
34015130:	40000013 	.word	0x40000013
34015134:	40000019 	.word	0x40000019
34015138:	4000001b 	.word	0x4000001b
3401513c:	4000001c 	.word	0x4000001c
34015140:	4000001d 	.word	0x4000001d
34015144:	4000001f 	.word	0x4000001f
34015148:	50000001 	.word	0x50000001
3401514c:	50000002 	.word	0x50000002
34015150:	50000003 	.word	0x50000003
34015154:	50000004 	.word	0x50000004
34015158:	50000005 	.word	0x50000005
3401515c:	50000006 	.word	0x50000006
34015160:	50000008 	.word	0x50000008
34015164:	50000009 	.word	0x50000009
34015168:	5000000a 	.word	0x5000000a
3401516c:	5000000b 	.word	0x5000000b
34015170:	5000000d 	.word	0x5000000d
34015174:	5000000e 	.word	0x5000000e
34015178:	5000000f 	.word	0x5000000f
3401517c:	50000011 	.word	0x50000011
34015180:	50000012 	.word	0x50000012
34015184:	50000013 	.word	0x50000013
34015188:	50000014 	.word	0x50000014
3401518c:	50000016 	.word	0x50000016
34015190:	50000017 	.word	0x50000017
34015194:	50000018 	.word	0x50000018
34015198:	5000001b 	.word	0x5000001b
3401519c:	5000001e 	.word	0x5000001e
340151a0:	3401ef0c 	.word	0x3401ef0c
340151a4:	54024000 	.word	0x54024000

340151a8 <HAL_SPI_Transmit_DMA>:
  * @param  pData: pointer to data buffer
  * @param  Size : amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, const uint8_t *pData, uint16_t Size)
{
340151a8:	b580      	push	{r7, lr}
340151aa:	b086      	sub	sp, #24
340151ac:	af00      	add	r7, sp, #0
340151ae:	60f8      	str	r0, [r7, #12]
340151b0:	60b9      	str	r1, [r7, #8]
340151b2:	4613      	mov	r3, r2
340151b4:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef status;

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE_2LINES_TXONLY(hspi->Init.Direction));
340151b6:	68fb      	ldr	r3, [r7, #12]
340151b8:	689b      	ldr	r3, [r3, #8]
340151ba:	2b00      	cmp	r3, #0
340151bc:	d00e      	beq.n	340151dc <HAL_SPI_Transmit_DMA+0x34>
340151be:	68fb      	ldr	r3, [r7, #12]
340151c0:	689b      	ldr	r3, [r3, #8]
340151c2:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
340151c6:	d009      	beq.n	340151dc <HAL_SPI_Transmit_DMA+0x34>
340151c8:	68fb      	ldr	r3, [r7, #12]
340151ca:	689b      	ldr	r3, [r3, #8]
340151cc:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
340151d0:	d004      	beq.n	340151dc <HAL_SPI_Transmit_DMA+0x34>
340151d2:	f240 71a5 	movw	r1, #1957	@ 0x7a5
340151d6:	4882      	ldr	r0, [pc, #520]	@ (340153e0 <HAL_SPI_Transmit_DMA+0x238>)
340151d8:	f7ec ff1a 	bl	34002010 <assert_failed>

  if (hspi->State != HAL_SPI_STATE_READY)
340151dc:	68fb      	ldr	r3, [r7, #12]
340151de:	f893 3089 	ldrb.w	r3, [r3, #137]	@ 0x89
340151e2:	b2db      	uxtb	r3, r3
340151e4:	2b01      	cmp	r3, #1
340151e6:	d001      	beq.n	340151ec <HAL_SPI_Transmit_DMA+0x44>
  {
    return HAL_BUSY;
340151e8:	2302      	movs	r3, #2
340151ea:	e1b7      	b.n	3401555c <HAL_SPI_Transmit_DMA+0x3b4>
  }

  if ((pData == NULL) || (Size == 0UL))
340151ec:	68bb      	ldr	r3, [r7, #8]
340151ee:	2b00      	cmp	r3, #0
340151f0:	d002      	beq.n	340151f8 <HAL_SPI_Transmit_DMA+0x50>
340151f2:	88fb      	ldrh	r3, [r7, #6]
340151f4:	2b00      	cmp	r3, #0
340151f6:	d101      	bne.n	340151fc <HAL_SPI_Transmit_DMA+0x54>
  {
    return HAL_ERROR;
340151f8:	2301      	movs	r3, #1
340151fa:	e1af      	b.n	3401555c <HAL_SPI_Transmit_DMA+0x3b4>
  }

  /* Lock the process */
  __HAL_LOCK(hspi);
340151fc:	68fb      	ldr	r3, [r7, #12]
340151fe:	f893 3088 	ldrb.w	r3, [r3, #136]	@ 0x88
34015202:	2b01      	cmp	r3, #1
34015204:	d101      	bne.n	3401520a <HAL_SPI_Transmit_DMA+0x62>
34015206:	2302      	movs	r3, #2
34015208:	e1a8      	b.n	3401555c <HAL_SPI_Transmit_DMA+0x3b4>
3401520a:	68fb      	ldr	r3, [r7, #12]
3401520c:	2201      	movs	r2, #1
3401520e:	f883 2088 	strb.w	r2, [r3, #136]	@ 0x88

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
34015212:	68fb      	ldr	r3, [r7, #12]
34015214:	2203      	movs	r2, #3
34015216:	f883 2089 	strb.w	r2, [r3, #137]	@ 0x89
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
3401521a:	68fb      	ldr	r3, [r7, #12]
3401521c:	2200      	movs	r2, #0
3401521e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  hspi->pTxBuffPtr  = (const uint8_t *)pData;
34015222:	68fb      	ldr	r3, [r7, #12]
34015224:	68ba      	ldr	r2, [r7, #8]
34015226:	665a      	str	r2, [r3, #100]	@ 0x64
  hspi->TxXferSize  = Size;
34015228:	68fb      	ldr	r3, [r7, #12]
3401522a:	88fa      	ldrh	r2, [r7, #6]
3401522c:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
  hspi->TxXferCount = Size;
34015230:	68fb      	ldr	r3, [r7, #12]
34015232:	88fa      	ldrh	r2, [r7, #6]
34015234:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a

  /* Init field not used in handle to zero */
  hspi->pRxBuffPtr  = NULL;
34015238:	68fb      	ldr	r3, [r7, #12]
3401523a:	2200      	movs	r2, #0
3401523c:	66da      	str	r2, [r3, #108]	@ 0x6c
  hspi->TxISR       = NULL;
3401523e:	68fb      	ldr	r3, [r7, #12]
34015240:	2200      	movs	r2, #0
34015242:	67da      	str	r2, [r3, #124]	@ 0x7c
  hspi->RxISR       = NULL;
34015244:	68fb      	ldr	r3, [r7, #12]
34015246:	2200      	movs	r2, #0
34015248:	679a      	str	r2, [r3, #120]	@ 0x78
  hspi->RxXferSize  = (uint16_t)0UL;
3401524a:	68fb      	ldr	r3, [r7, #12]
3401524c:	2200      	movs	r2, #0
3401524e:	f8a3 2070 	strh.w	r2, [r3, #112]	@ 0x70
  hspi->RxXferCount = (uint16_t)0UL;
34015252:	68fb      	ldr	r3, [r7, #12]
34015254:	2200      	movs	r2, #0
34015256:	f8a3 2072 	strh.w	r2, [r3, #114]	@ 0x72

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
3401525a:	68fb      	ldr	r3, [r7, #12]
3401525c:	689b      	ldr	r3, [r3, #8]
3401525e:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
34015262:	d108      	bne.n	34015276 <HAL_SPI_Transmit_DMA+0xce>
  {
    SPI_1LINE_TX(hspi);
34015264:	68fb      	ldr	r3, [r7, #12]
34015266:	681b      	ldr	r3, [r3, #0]
34015268:	681a      	ldr	r2, [r3, #0]
3401526a:	68fb      	ldr	r3, [r7, #12]
3401526c:	681b      	ldr	r3, [r3, #0]
3401526e:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
34015272:	601a      	str	r2, [r3, #0]
34015274:	e009      	b.n	3401528a <HAL_SPI_Transmit_DMA+0xe2>
  }
  else
  {
    SPI_2LINES_TX(hspi);
34015276:	68fb      	ldr	r3, [r7, #12]
34015278:	681b      	ldr	r3, [r3, #0]
3401527a:	68db      	ldr	r3, [r3, #12]
3401527c:	f423 22c0 	bic.w	r2, r3, #393216	@ 0x60000
34015280:	68fb      	ldr	r3, [r7, #12]
34015282:	681b      	ldr	r3, [r3, #0]
34015284:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
34015288:	60da      	str	r2, [r3, #12]
  }

  /* Packing mode management is enabled by the DMA settings */
  if (((hspi->Init.DataSize > SPI_DATASIZE_16BIT) && (hspi->hdmatx->Init.SrcDataWidth !=  DMA_SRC_DATAWIDTH_WORD) && \
3401528a:	68fb      	ldr	r3, [r7, #12]
3401528c:	68db      	ldr	r3, [r3, #12]
3401528e:	2b0f      	cmp	r3, #15
34015290:	d92d      	bls.n	340152ee <HAL_SPI_Transmit_DMA+0x146>
34015292:	68fb      	ldr	r3, [r7, #12]
34015294:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34015298:	699b      	ldr	r3, [r3, #24]
3401529a:	2b02      	cmp	r3, #2
3401529c:	d027      	beq.n	340152ee <HAL_SPI_Transmit_DMA+0x146>
       (IS_SPI_FULL_INSTANCE(hspi->Instance))) || \
3401529e:	68fb      	ldr	r3, [r7, #12]
340152a0:	681b      	ldr	r3, [r3, #0]
  if (((hspi->Init.DataSize > SPI_DATASIZE_16BIT) && (hspi->hdmatx->Init.SrcDataWidth !=  DMA_SRC_DATAWIDTH_WORD) && \
340152a2:	4a50      	ldr	r2, [pc, #320]	@ (340153e4 <HAL_SPI_Transmit_DMA+0x23c>)
340152a4:	4293      	cmp	r3, r2
340152a6:	d02c      	beq.n	34015302 <HAL_SPI_Transmit_DMA+0x15a>
       (IS_SPI_FULL_INSTANCE(hspi->Instance))) || \
340152a8:	68fb      	ldr	r3, [r7, #12]
340152aa:	681b      	ldr	r3, [r3, #0]
340152ac:	4a4e      	ldr	r2, [pc, #312]	@ (340153e8 <HAL_SPI_Transmit_DMA+0x240>)
340152ae:	4293      	cmp	r3, r2
340152b0:	d027      	beq.n	34015302 <HAL_SPI_Transmit_DMA+0x15a>
340152b2:	68fb      	ldr	r3, [r7, #12]
340152b4:	681b      	ldr	r3, [r3, #0]
340152b6:	4a4d      	ldr	r2, [pc, #308]	@ (340153ec <HAL_SPI_Transmit_DMA+0x244>)
340152b8:	4293      	cmp	r3, r2
340152ba:	d022      	beq.n	34015302 <HAL_SPI_Transmit_DMA+0x15a>
340152bc:	68fb      	ldr	r3, [r7, #12]
340152be:	681b      	ldr	r3, [r3, #0]
340152c0:	4a4b      	ldr	r2, [pc, #300]	@ (340153f0 <HAL_SPI_Transmit_DMA+0x248>)
340152c2:	4293      	cmp	r3, r2
340152c4:	d01d      	beq.n	34015302 <HAL_SPI_Transmit_DMA+0x15a>
340152c6:	68fb      	ldr	r3, [r7, #12]
340152c8:	681b      	ldr	r3, [r3, #0]
340152ca:	4a4a      	ldr	r2, [pc, #296]	@ (340153f4 <HAL_SPI_Transmit_DMA+0x24c>)
340152cc:	4293      	cmp	r3, r2
340152ce:	d018      	beq.n	34015302 <HAL_SPI_Transmit_DMA+0x15a>
340152d0:	68fb      	ldr	r3, [r7, #12]
340152d2:	681b      	ldr	r3, [r3, #0]
340152d4:	4a48      	ldr	r2, [pc, #288]	@ (340153f8 <HAL_SPI_Transmit_DMA+0x250>)
340152d6:	4293      	cmp	r3, r2
340152d8:	d013      	beq.n	34015302 <HAL_SPI_Transmit_DMA+0x15a>
340152da:	68fb      	ldr	r3, [r7, #12]
340152dc:	681b      	ldr	r3, [r3, #0]
340152de:	4a47      	ldr	r2, [pc, #284]	@ (340153fc <HAL_SPI_Transmit_DMA+0x254>)
340152e0:	4293      	cmp	r3, r2
340152e2:	d00e      	beq.n	34015302 <HAL_SPI_Transmit_DMA+0x15a>
340152e4:	68fb      	ldr	r3, [r7, #12]
340152e6:	681b      	ldr	r3, [r3, #0]
340152e8:	4a45      	ldr	r2, [pc, #276]	@ (34015400 <HAL_SPI_Transmit_DMA+0x258>)
340152ea:	4293      	cmp	r3, r2
340152ec:	d009      	beq.n	34015302 <HAL_SPI_Transmit_DMA+0x15a>
      ((hspi->Init.DataSize > SPI_DATASIZE_8BIT)  && (hspi->hdmatx->Init.SrcDataWidth ==  DMA_SRC_DATAWIDTH_BYTE)))
340152ee:	68fb      	ldr	r3, [r7, #12]
340152f0:	68db      	ldr	r3, [r3, #12]
       (IS_SPI_FULL_INSTANCE(hspi->Instance))) || \
340152f2:	2b07      	cmp	r3, #7
340152f4:	d90b      	bls.n	3401530e <HAL_SPI_Transmit_DMA+0x166>
      ((hspi->Init.DataSize > SPI_DATASIZE_8BIT)  && (hspi->hdmatx->Init.SrcDataWidth ==  DMA_SRC_DATAWIDTH_BYTE)))
340152f6:	68fb      	ldr	r3, [r7, #12]
340152f8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340152fc:	699b      	ldr	r3, [r3, #24]
340152fe:	2b00      	cmp	r3, #0
34015300:	d105      	bne.n	3401530e <HAL_SPI_Transmit_DMA+0x166>
  {
    /* Restriction the DMA data received is not allowed in this mode */
    __HAL_UNLOCK(hspi);
34015302:	68fb      	ldr	r3, [r7, #12]
34015304:	2200      	movs	r2, #0
34015306:	f883 2088 	strb.w	r2, [r3, #136]	@ 0x88
    return HAL_ERROR;
3401530a:	2301      	movs	r3, #1
3401530c:	e126      	b.n	3401555c <HAL_SPI_Transmit_DMA+0x3b4>
  }

  /* Adjust XferCount according to DMA alignment / Data size */
  if (hspi->Init.DataSize <= SPI_DATASIZE_8BIT)
3401530e:	68fb      	ldr	r3, [r7, #12]
34015310:	68db      	ldr	r3, [r3, #12]
34015312:	2b07      	cmp	r3, #7
34015314:	d820      	bhi.n	34015358 <HAL_SPI_Transmit_DMA+0x1b0>
  {
    if (hspi->hdmatx->Init.SrcDataWidth == DMA_SRC_DATAWIDTH_HALFWORD)
34015316:	68fb      	ldr	r3, [r7, #12]
34015318:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3401531c:	699b      	ldr	r3, [r3, #24]
3401531e:	2b01      	cmp	r3, #1
34015320:	d109      	bne.n	34015336 <HAL_SPI_Transmit_DMA+0x18e>
    {
      hspi->TxXferCount = (hspi->TxXferCount + (uint16_t) 1UL) >> 1UL;
34015322:	68fb      	ldr	r3, [r7, #12]
34015324:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
34015328:	b29b      	uxth	r3, r3
3401532a:	3301      	adds	r3, #1
3401532c:	105b      	asrs	r3, r3, #1
3401532e:	b29a      	uxth	r2, r3
34015330:	68fb      	ldr	r3, [r7, #12]
34015332:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
    }
    if (hspi->hdmatx->Init.SrcDataWidth == DMA_SRC_DATAWIDTH_WORD)
34015336:	68fb      	ldr	r3, [r7, #12]
34015338:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3401533c:	699b      	ldr	r3, [r3, #24]
3401533e:	2b02      	cmp	r3, #2
34015340:	d11e      	bne.n	34015380 <HAL_SPI_Transmit_DMA+0x1d8>
    {
      hspi->TxXferCount = (hspi->TxXferCount + (uint16_t) 3UL) >> 2UL;
34015342:	68fb      	ldr	r3, [r7, #12]
34015344:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
34015348:	b29b      	uxth	r3, r3
3401534a:	3303      	adds	r3, #3
3401534c:	109b      	asrs	r3, r3, #2
3401534e:	b29a      	uxth	r2, r3
34015350:	68fb      	ldr	r3, [r7, #12]
34015352:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
34015356:	e013      	b.n	34015380 <HAL_SPI_Transmit_DMA+0x1d8>
    }
  }
  else if (hspi->Init.DataSize <= SPI_DATASIZE_16BIT)
34015358:	68fb      	ldr	r3, [r7, #12]
3401535a:	68db      	ldr	r3, [r3, #12]
3401535c:	2b0f      	cmp	r3, #15
3401535e:	d80f      	bhi.n	34015380 <HAL_SPI_Transmit_DMA+0x1d8>
  {
    if (hspi->hdmatx->Init.SrcDataWidth == DMA_SRC_DATAWIDTH_WORD)
34015360:	68fb      	ldr	r3, [r7, #12]
34015362:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34015366:	699b      	ldr	r3, [r3, #24]
34015368:	2b02      	cmp	r3, #2
3401536a:	d109      	bne.n	34015380 <HAL_SPI_Transmit_DMA+0x1d8>
    {
      hspi->TxXferCount = (hspi->TxXferCount + (uint16_t) 1UL) >> 1UL;
3401536c:	68fb      	ldr	r3, [r7, #12]
3401536e:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
34015372:	b29b      	uxth	r3, r3
34015374:	3301      	adds	r3, #1
34015376:	105b      	asrs	r3, r3, #1
34015378:	b29a      	uxth	r2, r3
3401537a:	68fb      	ldr	r3, [r7, #12]
3401537c:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
  {
    /* Adjustment done */
  }

  /* Set the SPI TxDMA Half transfer complete callback */
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
34015380:	68fb      	ldr	r3, [r7, #12]
34015382:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34015386:	4a1f      	ldr	r2, [pc, #124]	@ (34015404 <HAL_SPI_Transmit_DMA+0x25c>)
34015388:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Set the SPI TxDMA transfer complete callback */
  hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
3401538a:	68fb      	ldr	r3, [r7, #12]
3401538c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34015390:	4a1d      	ldr	r2, [pc, #116]	@ (34015408 <HAL_SPI_Transmit_DMA+0x260>)
34015392:	661a      	str	r2, [r3, #96]	@ 0x60

  /* Set the DMA error callback */
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;
34015394:	68fb      	ldr	r3, [r7, #12]
34015396:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3401539a:	4a1c      	ldr	r2, [pc, #112]	@ (3401540c <HAL_SPI_Transmit_DMA+0x264>)
3401539c:	669a      	str	r2, [r3, #104]	@ 0x68

  /* Set the DMA AbortCpltCallback */
  hspi->hdmatx->XferAbortCallback = NULL;
3401539e:	68fb      	ldr	r3, [r7, #12]
340153a0:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340153a4:	2200      	movs	r2, #0
340153a6:	66da      	str	r2, [r3, #108]	@ 0x6c

  /* Clear TXDMAEN bit*/
  CLEAR_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN);
340153a8:	68fb      	ldr	r3, [r7, #12]
340153aa:	681b      	ldr	r3, [r3, #0]
340153ac:	689a      	ldr	r2, [r3, #8]
340153ae:	68fb      	ldr	r3, [r7, #12]
340153b0:	681b      	ldr	r3, [r3, #0]
340153b2:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
340153b6:	609a      	str	r2, [r3, #8]

  if (hspi->Init.DataSize <= SPI_DATASIZE_8BIT)
340153b8:	68fb      	ldr	r3, [r7, #12]
340153ba:	68db      	ldr	r3, [r3, #12]
340153bc:	2b07      	cmp	r3, #7
340153be:	d804      	bhi.n	340153ca <HAL_SPI_Transmit_DMA+0x222>
  {
    hspi->TxXferCount = Size;
340153c0:	68fb      	ldr	r3, [r7, #12]
340153c2:	88fa      	ldrh	r2, [r7, #6]
340153c4:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
340153c8:	e028      	b.n	3401541c <HAL_SPI_Transmit_DMA+0x274>
  }
  else if (hspi->Init.DataSize <= SPI_DATASIZE_16BIT)
340153ca:	68fb      	ldr	r3, [r7, #12]
340153cc:	68db      	ldr	r3, [r3, #12]
340153ce:	2b0f      	cmp	r3, #15
340153d0:	d81e      	bhi.n	34015410 <HAL_SPI_Transmit_DMA+0x268>
  {
    hspi->TxXferCount = Size * 2U;
340153d2:	88fb      	ldrh	r3, [r7, #6]
340153d4:	005b      	lsls	r3, r3, #1
340153d6:	b29a      	uxth	r2, r3
340153d8:	68fb      	ldr	r3, [r7, #12]
340153da:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
340153de:	e01d      	b.n	3401541c <HAL_SPI_Transmit_DMA+0x274>
340153e0:	3401efb4 	.word	0x3401efb4
340153e4:	52003000 	.word	0x52003000
340153e8:	42003000 	.word	0x42003000
340153ec:	50003800 	.word	0x50003800
340153f0:	40003800 	.word	0x40003800
340153f4:	50003c00 	.word	0x50003c00
340153f8:	40003c00 	.word	0x40003c00
340153fc:	56001400 	.word	0x56001400
34015400:	46001400 	.word	0x46001400
34015404:	340159a3 	.word	0x340159a3
34015408:	3401595d 	.word	0x3401595d
3401540c:	340159bf 	.word	0x340159bf
  }
  else
  {
    hspi->TxXferCount = Size * 4U;
34015410:	88fb      	ldrh	r3, [r7, #6]
34015412:	009b      	lsls	r3, r3, #2
34015414:	b29a      	uxth	r2, r3
34015416:	68fb      	ldr	r3, [r7, #12]
34015418:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
  }

  /* Enable the Tx DMA Stream/Channel */
  if ((hspi->hdmatx->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
3401541c:	68fb      	ldr	r3, [r7, #12]
3401541e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34015422:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
34015424:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34015428:	2b00      	cmp	r3, #0
3401542a:	d02d      	beq.n	34015488 <HAL_SPI_Transmit_DMA+0x2e0>
  {
    if (hspi->hdmatx->LinkedListQueue != NULL)
3401542c:	68fb      	ldr	r3, [r7, #12]
3401542e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34015432:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34015434:	2b00      	cmp	r3, #0
34015436:	d024      	beq.n	34015482 <HAL_SPI_Transmit_DMA+0x2da>
    {
      /* Set DMA data size */
      hspi->hdmatx->LinkedListQueue->Head->LinkRegisters[NODE_CBR1_DEFAULT_OFFSET] = hspi->TxXferCount;
34015438:	68fb      	ldr	r3, [r7, #12]
3401543a:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
3401543e:	b29a      	uxth	r2, r3
34015440:	68fb      	ldr	r3, [r7, #12]
34015442:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34015446:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34015448:	681b      	ldr	r3, [r3, #0]
3401544a:	609a      	str	r2, [r3, #8]

      /* Set DMA source address */
      hspi->hdmatx->LinkedListQueue->Head->LinkRegisters[NODE_CSAR_DEFAULT_OFFSET] = (uint32_t)hspi->pTxBuffPtr;
3401544c:	68fb      	ldr	r3, [r7, #12]
3401544e:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
34015450:	68fb      	ldr	r3, [r7, #12]
34015452:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34015456:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34015458:	681b      	ldr	r3, [r3, #0]
3401545a:	60da      	str	r2, [r3, #12]

      /* Set DMA destination address */
      hspi->hdmatx->LinkedListQueue->Head->LinkRegisters[NODE_CDAR_DEFAULT_OFFSET] = (uint32_t)&hspi->Instance->TXDR;
3401545c:	68fb      	ldr	r3, [r7, #12]
3401545e:	681b      	ldr	r3, [r3, #0]
34015460:	f103 0220 	add.w	r2, r3, #32
34015464:	68fb      	ldr	r3, [r7, #12]
34015466:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3401546a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3401546c:	681b      	ldr	r3, [r3, #0]
3401546e:	611a      	str	r2, [r3, #16]

      status = HAL_DMAEx_List_Start_IT(hspi->hdmatx);
34015470:	68fb      	ldr	r3, [r7, #12]
34015472:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34015476:	4618      	mov	r0, r3
34015478:	f7f0 fbb3 	bl	34005be2 <HAL_DMAEx_List_Start_IT>
3401547c:	4603      	mov	r3, r0
3401547e:	75fb      	strb	r3, [r7, #23]
34015480:	e014      	b.n	340154ac <HAL_SPI_Transmit_DMA+0x304>
    }
    else
    {
      status = HAL_ERROR;
34015482:	2301      	movs	r3, #1
34015484:	75fb      	strb	r3, [r7, #23]
34015486:	e011      	b.n	340154ac <HAL_SPI_Transmit_DMA+0x304>
    }
  }
  else
  {
    status = HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->TXDR,
34015488:	68fb      	ldr	r3, [r7, #12]
3401548a:	f8d3 0080 	ldr.w	r0, [r3, #128]	@ 0x80
3401548e:	68fb      	ldr	r3, [r7, #12]
34015490:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34015492:	4619      	mov	r1, r3
34015494:	68fb      	ldr	r3, [r7, #12]
34015496:	681b      	ldr	r3, [r3, #0]
34015498:	3320      	adds	r3, #32
3401549a:	461a      	mov	r2, r3
                              hspi->TxXferCount);
3401549c:	68fb      	ldr	r3, [r7, #12]
3401549e:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
340154a2:	b29b      	uxth	r3, r3
    status = HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->TXDR,
340154a4:	f7f0 f85c 	bl	34005560 <HAL_DMA_Start_IT>
340154a8:	4603      	mov	r3, r0
340154aa:	75fb      	strb	r3, [r7, #23]
  }

  /* Check status */
  if (status != HAL_OK)
340154ac:	7dfb      	ldrb	r3, [r7, #23]
340154ae:	2b00      	cmp	r3, #0
340154b0:	d011      	beq.n	340154d6 <HAL_SPI_Transmit_DMA+0x32e>
  {
    /* Update SPI error code */
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
340154b2:	68fb      	ldr	r3, [r7, #12]
340154b4:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
340154b8:	f043 0210 	orr.w	r2, r3, #16
340154bc:	68fb      	ldr	r3, [r7, #12]
340154be:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
    hspi->State = HAL_SPI_STATE_READY;
340154c2:	68fb      	ldr	r3, [r7, #12]
340154c4:	2201      	movs	r2, #1
340154c6:	f883 2089 	strb.w	r2, [r3, #137]	@ 0x89

    /* Unlock the process */
    __HAL_UNLOCK(hspi);
340154ca:	68fb      	ldr	r3, [r7, #12]
340154cc:	2200      	movs	r2, #0
340154ce:	f883 2088 	strb.w	r2, [r3, #136]	@ 0x88

    return HAL_ERROR;
340154d2:	2301      	movs	r3, #1
340154d4:	e042      	b.n	3401555c <HAL_SPI_Transmit_DMA+0x3b4>
  }

  /* Set the number of data at current transfer */
  if (hspi->hdmatx->Mode == DMA_LINKEDLIST_CIRCULAR)
340154d6:	68fb      	ldr	r3, [r7, #12]
340154d8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340154dc:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340154de:	2b81      	cmp	r3, #129	@ 0x81
340154e0:	d108      	bne.n	340154f4 <HAL_SPI_Transmit_DMA+0x34c>
  {
    MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, 0UL);
340154e2:	68fb      	ldr	r3, [r7, #12]
340154e4:	681b      	ldr	r3, [r3, #0]
340154e6:	685b      	ldr	r3, [r3, #4]
340154e8:	68fa      	ldr	r2, [r7, #12]
340154ea:	6812      	ldr	r2, [r2, #0]
340154ec:	0c1b      	lsrs	r3, r3, #16
340154ee:	041b      	lsls	r3, r3, #16
340154f0:	6053      	str	r3, [r2, #4]
340154f2:	e009      	b.n	34015508 <HAL_SPI_Transmit_DMA+0x360>
  }
  else
  {
    MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, Size);
340154f4:	68fb      	ldr	r3, [r7, #12]
340154f6:	681b      	ldr	r3, [r3, #0]
340154f8:	685b      	ldr	r3, [r3, #4]
340154fa:	0c1b      	lsrs	r3, r3, #16
340154fc:	041b      	lsls	r3, r3, #16
340154fe:	88f9      	ldrh	r1, [r7, #6]
34015500:	68fa      	ldr	r2, [r7, #12]
34015502:	6812      	ldr	r2, [r2, #0]
34015504:	430b      	orrs	r3, r1
34015506:	6053      	str	r3, [r2, #4]
  }

  /* Enable Tx DMA Request */
  SET_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN);
34015508:	68fb      	ldr	r3, [r7, #12]
3401550a:	681b      	ldr	r3, [r3, #0]
3401550c:	689a      	ldr	r2, [r3, #8]
3401550e:	68fb      	ldr	r3, [r7, #12]
34015510:	681b      	ldr	r3, [r3, #0]
34015512:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34015516:	609a      	str	r2, [r3, #8]

  /* Enable the SPI Error Interrupt Bit */
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_UDR | SPI_IT_FRE | SPI_IT_MODF));
34015518:	68fb      	ldr	r3, [r7, #12]
3401551a:	681b      	ldr	r3, [r3, #0]
3401551c:	691a      	ldr	r2, [r3, #16]
3401551e:	68fb      	ldr	r3, [r7, #12]
34015520:	681b      	ldr	r3, [r3, #0]
34015522:	f442 7248 	orr.w	r2, r2, #800	@ 0x320
34015526:	611a      	str	r2, [r3, #16]

  /* Enable SPI peripheral */
  __HAL_SPI_ENABLE(hspi);
34015528:	68fb      	ldr	r3, [r7, #12]
3401552a:	681b      	ldr	r3, [r3, #0]
3401552c:	681a      	ldr	r2, [r3, #0]
3401552e:	68fb      	ldr	r3, [r7, #12]
34015530:	681b      	ldr	r3, [r3, #0]
34015532:	f042 0201 	orr.w	r2, r2, #1
34015536:	601a      	str	r2, [r3, #0]

  if (hspi->Init.Mode == SPI_MODE_MASTER)
34015538:	68fb      	ldr	r3, [r7, #12]
3401553a:	685b      	ldr	r3, [r3, #4]
3401553c:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
34015540:	d107      	bne.n	34015552 <HAL_SPI_Transmit_DMA+0x3aa>
  {
    /* Master transfer start */
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CSTART);
34015542:	68fb      	ldr	r3, [r7, #12]
34015544:	681b      	ldr	r3, [r3, #0]
34015546:	681a      	ldr	r2, [r3, #0]
34015548:	68fb      	ldr	r3, [r7, #12]
3401554a:	681b      	ldr	r3, [r3, #0]
3401554c:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
34015550:	601a      	str	r2, [r3, #0]
  }

  /* Unlock the process */
  __HAL_UNLOCK(hspi);
34015552:	68fb      	ldr	r3, [r7, #12]
34015554:	2200      	movs	r2, #0
34015556:	f883 2088 	strb.w	r2, [r3, #136]	@ 0x88

  return HAL_OK;
3401555a:	2300      	movs	r3, #0
}
3401555c:	4618      	mov	r0, r3
3401555e:	3718      	adds	r7, #24
34015560:	46bd      	mov	sp, r7
34015562:	bd80      	pop	{r7, pc}

34015564 <HAL_SPI_IRQHandler>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval None
  */
void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
{
34015564:	b580      	push	{r7, lr}
34015566:	b08a      	sub	sp, #40	@ 0x28
34015568:	af00      	add	r7, sp, #0
3401556a:	6078      	str	r0, [r7, #4]
  uint32_t itsource = hspi->Instance->IER;
3401556c:	687b      	ldr	r3, [r7, #4]
3401556e:	681b      	ldr	r3, [r3, #0]
34015570:	691b      	ldr	r3, [r3, #16]
34015572:	623b      	str	r3, [r7, #32]
  uint32_t itflag   = hspi->Instance->SR;
34015574:	687b      	ldr	r3, [r7, #4]
34015576:	681b      	ldr	r3, [r3, #0]
34015578:	695b      	ldr	r3, [r3, #20]
3401557a:	61fb      	str	r3, [r7, #28]
  uint32_t trigger  = itsource & itflag;
3401557c:	6a3a      	ldr	r2, [r7, #32]
3401557e:	69fb      	ldr	r3, [r7, #28]
34015580:	4013      	ands	r3, r2
34015582:	61bb      	str	r3, [r7, #24]
  uint32_t cfg1     = hspi->Instance->CFG1;
34015584:	687b      	ldr	r3, [r7, #4]
34015586:	681b      	ldr	r3, [r3, #0]
34015588:	689b      	ldr	r3, [r3, #8]
3401558a:	617b      	str	r3, [r7, #20]
  uint32_t handled  = 0UL;
3401558c:	2300      	movs	r3, #0
3401558e:	627b      	str	r3, [r7, #36]	@ 0x24

  HAL_SPI_StateTypeDef State = hspi->State;
34015590:	687b      	ldr	r3, [r7, #4]
34015592:	f893 3089 	ldrb.w	r3, [r3, #137]	@ 0x89
34015596:	74fb      	strb	r3, [r7, #19]
#if defined (__GNUC__)
  __IO uint16_t *prxdr_16bits = (__IO uint16_t *)(&(hspi->Instance->RXDR));
34015598:	687b      	ldr	r3, [r7, #4]
3401559a:	681b      	ldr	r3, [r3, #0]
3401559c:	3330      	adds	r3, #48	@ 0x30
3401559e:	60fb      	str	r3, [r7, #12]
#endif /* __GNUC__ */

  /* SPI in SUSPEND mode  ----------------------------------------------------*/
  if (HAL_IS_BIT_SET(itflag, SPI_FLAG_SUSP) && HAL_IS_BIT_SET(itsource, SPI_FLAG_EOT))
340155a0:	69fb      	ldr	r3, [r7, #28]
340155a2:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
340155a6:	2b00      	cmp	r3, #0
340155a8:	d010      	beq.n	340155cc <HAL_SPI_IRQHandler+0x68>
340155aa:	6a3b      	ldr	r3, [r7, #32]
340155ac:	f003 0308 	and.w	r3, r3, #8
340155b0:	2b00      	cmp	r3, #0
340155b2:	d00b      	beq.n	340155cc <HAL_SPI_IRQHandler+0x68>
  {
    /* Clear the Suspend flag */
    __HAL_SPI_CLEAR_SUSPFLAG(hspi);
340155b4:	687b      	ldr	r3, [r7, #4]
340155b6:	681b      	ldr	r3, [r3, #0]
340155b8:	699a      	ldr	r2, [r3, #24]
340155ba:	687b      	ldr	r3, [r7, #4]
340155bc:	681b      	ldr	r3, [r3, #0]
340155be:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
340155c2:	619a      	str	r2, [r3, #24]

    /* Suspend on going, Call the Suspend callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)
    hspi->SuspendCallback(hspi);
#else
    HAL_SPI_SuspendCallback(hspi);
340155c4:	6878      	ldr	r0, [r7, #4]
340155c6:	f000 f9bf 	bl	34015948 <HAL_SPI_SuspendCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
    return;
340155ca:	e19a      	b.n	34015902 <HAL_SPI_IRQHandler+0x39e>
  }

  /* SPI in mode Transmitter and Receiver ------------------------------------*/
  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_OVR) && HAL_IS_BIT_CLR(trigger, SPI_FLAG_UDR) && \
340155cc:	69bb      	ldr	r3, [r7, #24]
340155ce:	f003 0340 	and.w	r3, r3, #64	@ 0x40
340155d2:	2b00      	cmp	r3, #0
340155d4:	d113      	bne.n	340155fe <HAL_SPI_IRQHandler+0x9a>
340155d6:	69bb      	ldr	r3, [r7, #24]
340155d8:	f003 0320 	and.w	r3, r3, #32
340155dc:	2b00      	cmp	r3, #0
340155de:	d10e      	bne.n	340155fe <HAL_SPI_IRQHandler+0x9a>
      HAL_IS_BIT_SET(trigger, SPI_FLAG_DXP))
340155e0:	69bb      	ldr	r3, [r7, #24]
340155e2:	f003 0304 	and.w	r3, r3, #4
  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_OVR) && HAL_IS_BIT_CLR(trigger, SPI_FLAG_UDR) && \
340155e6:	2b00      	cmp	r3, #0
340155e8:	d009      	beq.n	340155fe <HAL_SPI_IRQHandler+0x9a>
  {
    hspi->TxISR(hspi);
340155ea:	687b      	ldr	r3, [r7, #4]
340155ec:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340155ee:	6878      	ldr	r0, [r7, #4]
340155f0:	4798      	blx	r3
    hspi->RxISR(hspi);
340155f2:	687b      	ldr	r3, [r7, #4]
340155f4:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
340155f6:	6878      	ldr	r0, [r7, #4]
340155f8:	4798      	blx	r3
    handled = 1UL;
340155fa:	2301      	movs	r3, #1
340155fc:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  /* SPI in mode Receiver ----------------------------------------------------*/
  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_OVR) && HAL_IS_BIT_SET(trigger, SPI_FLAG_RXP) && \
340155fe:	69bb      	ldr	r3, [r7, #24]
34015600:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34015604:	2b00      	cmp	r3, #0
34015606:	d10f      	bne.n	34015628 <HAL_SPI_IRQHandler+0xc4>
34015608:	69bb      	ldr	r3, [r7, #24]
3401560a:	f003 0301 	and.w	r3, r3, #1
3401560e:	2b00      	cmp	r3, #0
34015610:	d00a      	beq.n	34015628 <HAL_SPI_IRQHandler+0xc4>
      HAL_IS_BIT_CLR(trigger, SPI_FLAG_DXP))
34015612:	69bb      	ldr	r3, [r7, #24]
34015614:	f003 0304 	and.w	r3, r3, #4
  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_OVR) && HAL_IS_BIT_SET(trigger, SPI_FLAG_RXP) && \
34015618:	2b00      	cmp	r3, #0
3401561a:	d105      	bne.n	34015628 <HAL_SPI_IRQHandler+0xc4>
  {
    hspi->RxISR(hspi);
3401561c:	687b      	ldr	r3, [r7, #4]
3401561e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34015620:	6878      	ldr	r0, [r7, #4]
34015622:	4798      	blx	r3
    handled = 1UL;
34015624:	2301      	movs	r3, #1
34015626:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  /* SPI in mode Transmitter -------------------------------------------------*/
  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_UDR) && HAL_IS_BIT_SET(trigger, SPI_FLAG_TXP) && \
34015628:	69bb      	ldr	r3, [r7, #24]
3401562a:	f003 0320 	and.w	r3, r3, #32
3401562e:	2b00      	cmp	r3, #0
34015630:	d10f      	bne.n	34015652 <HAL_SPI_IRQHandler+0xee>
34015632:	69bb      	ldr	r3, [r7, #24]
34015634:	f003 0302 	and.w	r3, r3, #2
34015638:	2b00      	cmp	r3, #0
3401563a:	d00a      	beq.n	34015652 <HAL_SPI_IRQHandler+0xee>
      HAL_IS_BIT_CLR(trigger, SPI_FLAG_DXP))
3401563c:	69bb      	ldr	r3, [r7, #24]
3401563e:	f003 0304 	and.w	r3, r3, #4
  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_UDR) && HAL_IS_BIT_SET(trigger, SPI_FLAG_TXP) && \
34015642:	2b00      	cmp	r3, #0
34015644:	d105      	bne.n	34015652 <HAL_SPI_IRQHandler+0xee>
  {
    hspi->TxISR(hspi);
34015646:	687b      	ldr	r3, [r7, #4]
34015648:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3401564a:	6878      	ldr	r0, [r7, #4]
3401564c:	4798      	blx	r3
    handled = 1UL;
3401564e:	2301      	movs	r3, #1
34015650:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  if (handled != 0UL)
34015652:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34015654:	2b00      	cmp	r3, #0
34015656:	f040 814f 	bne.w	340158f8 <HAL_SPI_IRQHandler+0x394>
  {
    return;
  }

  /* SPI End Of Transfer: DMA or IT based transfer */
  if (HAL_IS_BIT_SET(trigger, SPI_FLAG_EOT))
3401565a:	69bb      	ldr	r3, [r7, #24]
3401565c:	f003 0308 	and.w	r3, r3, #8
34015660:	2b00      	cmp	r3, #0
34015662:	f000 808b 	beq.w	3401577c <HAL_SPI_IRQHandler+0x218>
  {
    /* Clear EOT/TXTF/SUSP flag */
    __HAL_SPI_CLEAR_EOTFLAG(hspi);
34015666:	687b      	ldr	r3, [r7, #4]
34015668:	681b      	ldr	r3, [r3, #0]
3401566a:	699a      	ldr	r2, [r3, #24]
3401566c:	687b      	ldr	r3, [r7, #4]
3401566e:	681b      	ldr	r3, [r3, #0]
34015670:	f042 0208 	orr.w	r2, r2, #8
34015674:	619a      	str	r2, [r3, #24]
    __HAL_SPI_CLEAR_TXTFFLAG(hspi);
34015676:	687b      	ldr	r3, [r7, #4]
34015678:	681b      	ldr	r3, [r3, #0]
3401567a:	699a      	ldr	r2, [r3, #24]
3401567c:	687b      	ldr	r3, [r7, #4]
3401567e:	681b      	ldr	r3, [r3, #0]
34015680:	f042 0210 	orr.w	r2, r2, #16
34015684:	619a      	str	r2, [r3, #24]
    __HAL_SPI_CLEAR_SUSPFLAG(hspi);
34015686:	687b      	ldr	r3, [r7, #4]
34015688:	681b      	ldr	r3, [r3, #0]
3401568a:	699a      	ldr	r2, [r3, #24]
3401568c:	687b      	ldr	r3, [r7, #4]
3401568e:	681b      	ldr	r3, [r3, #0]
34015690:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
34015694:	619a      	str	r2, [r3, #24]

    /* Disable EOT interrupt */
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_EOT);
34015696:	687b      	ldr	r3, [r7, #4]
34015698:	681b      	ldr	r3, [r3, #0]
3401569a:	691a      	ldr	r2, [r3, #16]
3401569c:	687b      	ldr	r3, [r7, #4]
3401569e:	681b      	ldr	r3, [r3, #0]
340156a0:	f022 0208 	bic.w	r2, r2, #8
340156a4:	611a      	str	r2, [r3, #16]

    /* For the IT based receive extra polling maybe required for last packet */
    if (HAL_IS_BIT_CLR(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN))
340156a6:	687b      	ldr	r3, [r7, #4]
340156a8:	681b      	ldr	r3, [r3, #0]
340156aa:	689b      	ldr	r3, [r3, #8]
340156ac:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
340156b0:	2b00      	cmp	r3, #0
340156b2:	d13d      	bne.n	34015730 <HAL_SPI_IRQHandler+0x1cc>
    {
      /* Pooling remaining data */
      while (hspi->RxXferCount != 0UL)
340156b4:	e036      	b.n	34015724 <HAL_SPI_IRQHandler+0x1c0>
      {
        /* Receive data in 32 Bit mode */
        if (hspi->Init.DataSize > SPI_DATASIZE_16BIT)
340156b6:	687b      	ldr	r3, [r7, #4]
340156b8:	68db      	ldr	r3, [r3, #12]
340156ba:	2b0f      	cmp	r3, #15
340156bc:	d90b      	bls.n	340156d6 <HAL_SPI_IRQHandler+0x172>
        {
          *((uint32_t *)hspi->pRxBuffPtr) = *((__IO uint32_t *)&hspi->Instance->RXDR);
340156be:	687b      	ldr	r3, [r7, #4]
340156c0:	681a      	ldr	r2, [r3, #0]
340156c2:	687b      	ldr	r3, [r7, #4]
340156c4:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
340156c6:	6b12      	ldr	r2, [r2, #48]	@ 0x30
340156c8:	601a      	str	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint32_t);
340156ca:	687b      	ldr	r3, [r7, #4]
340156cc:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
340156ce:	1d1a      	adds	r2, r3, #4
340156d0:	687b      	ldr	r3, [r7, #4]
340156d2:	66da      	str	r2, [r3, #108]	@ 0x6c
340156d4:	e01d      	b.n	34015712 <HAL_SPI_IRQHandler+0x1ae>
        }
        /* Receive data in 16 Bit mode */
        else if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
340156d6:	687b      	ldr	r3, [r7, #4]
340156d8:	68db      	ldr	r3, [r3, #12]
340156da:	2b07      	cmp	r3, #7
340156dc:	d90b      	bls.n	340156f6 <HAL_SPI_IRQHandler+0x192>
        {
#if defined (__GNUC__)
          *((uint16_t *)hspi->pRxBuffPtr) = *prxdr_16bits;
340156de:	687b      	ldr	r3, [r7, #4]
340156e0:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
340156e2:	68fa      	ldr	r2, [r7, #12]
340156e4:	8812      	ldrh	r2, [r2, #0]
340156e6:	b292      	uxth	r2, r2
340156e8:	801a      	strh	r2, [r3, #0]
#else
          *((uint16_t *)hspi->pRxBuffPtr) = *((__IO uint16_t *)&hspi->Instance->RXDR);
#endif /* __GNUC__ */
          hspi->pRxBuffPtr += sizeof(uint16_t);
340156ea:	687b      	ldr	r3, [r7, #4]
340156ec:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
340156ee:	1c9a      	adds	r2, r3, #2
340156f0:	687b      	ldr	r3, [r7, #4]
340156f2:	66da      	str	r2, [r3, #108]	@ 0x6c
340156f4:	e00d      	b.n	34015712 <HAL_SPI_IRQHandler+0x1ae>
        }
        /* Receive data in 8 Bit mode */
        else
        {
          *((uint8_t *)hspi->pRxBuffPtr) = *((__IO uint8_t *)&hspi->Instance->RXDR);
340156f6:	687b      	ldr	r3, [r7, #4]
340156f8:	681b      	ldr	r3, [r3, #0]
340156fa:	f103 0230 	add.w	r2, r3, #48	@ 0x30
340156fe:	687b      	ldr	r3, [r7, #4]
34015700:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34015702:	7812      	ldrb	r2, [r2, #0]
34015704:	b2d2      	uxtb	r2, r2
34015706:	701a      	strb	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint8_t);
34015708:	687b      	ldr	r3, [r7, #4]
3401570a:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
3401570c:	1c5a      	adds	r2, r3, #1
3401570e:	687b      	ldr	r3, [r7, #4]
34015710:	66da      	str	r2, [r3, #108]	@ 0x6c
        }

        hspi->RxXferCount--;
34015712:	687b      	ldr	r3, [r7, #4]
34015714:	f8b3 3072 	ldrh.w	r3, [r3, #114]	@ 0x72
34015718:	b29b      	uxth	r3, r3
3401571a:	3b01      	subs	r3, #1
3401571c:	b29a      	uxth	r2, r3
3401571e:	687b      	ldr	r3, [r7, #4]
34015720:	f8a3 2072 	strh.w	r2, [r3, #114]	@ 0x72
      while (hspi->RxXferCount != 0UL)
34015724:	687b      	ldr	r3, [r7, #4]
34015726:	f8b3 3072 	ldrh.w	r3, [r3, #114]	@ 0x72
3401572a:	b29b      	uxth	r3, r3
3401572c:	2b00      	cmp	r3, #0
3401572e:	d1c2      	bne.n	340156b6 <HAL_SPI_IRQHandler+0x152>
      }
    }

    /* Call SPI Standard close procedure */
    SPI_CloseTransfer(hspi);
34015730:	6878      	ldr	r0, [r7, #4]
34015732:	f000 f981 	bl	34015a38 <SPI_CloseTransfer>

    hspi->State = HAL_SPI_STATE_READY;
34015736:	687b      	ldr	r3, [r7, #4]
34015738:	2201      	movs	r2, #1
3401573a:	f883 2089 	strb.w	r2, [r3, #137]	@ 0x89
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
3401573e:	687b      	ldr	r3, [r7, #4]
34015740:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34015744:	2b00      	cmp	r3, #0
34015746:	d003      	beq.n	34015750 <HAL_SPI_IRQHandler+0x1ec>
    {
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)
      hspi->ErrorCallback(hspi);
#else
      HAL_SPI_ErrorCallback(hspi);
34015748:	6878      	ldr	r0, [r7, #4]
3401574a:	f002 fcdd 	bl	34018108 <HAL_SPI_ErrorCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
      return;
3401574e:	e0d8      	b.n	34015902 <HAL_SPI_IRQHandler+0x39e>
    {
      hspi->TxCpltCallback(hspi);
    }
#else
    /* Call appropriate user callback */
    if (State == HAL_SPI_STATE_BUSY_TX_RX)
34015750:	7cfb      	ldrb	r3, [r7, #19]
34015752:	2b05      	cmp	r3, #5
34015754:	d103      	bne.n	3401575e <HAL_SPI_IRQHandler+0x1fa>
    {
      HAL_SPI_TxRxCpltCallback(hspi);
34015756:	6878      	ldr	r0, [r7, #4]
34015758:	f000 f8e2 	bl	34015920 <HAL_SPI_TxRxCpltCallback>
    else
    {
      /* End of the appropriate call */
    }

    return;
3401575c:	e0ce      	b.n	340158fc <HAL_SPI_IRQHandler+0x398>
    else if (State == HAL_SPI_STATE_BUSY_RX)
3401575e:	7cfb      	ldrb	r3, [r7, #19]
34015760:	2b04      	cmp	r3, #4
34015762:	d103      	bne.n	3401576c <HAL_SPI_IRQHandler+0x208>
      HAL_SPI_RxCpltCallback(hspi);
34015764:	6878      	ldr	r0, [r7, #4]
34015766:	f000 f8d1 	bl	3401590c <HAL_SPI_RxCpltCallback>
    return;
3401576a:	e0c7      	b.n	340158fc <HAL_SPI_IRQHandler+0x398>
    else if (State == HAL_SPI_STATE_BUSY_TX)
3401576c:	7cfb      	ldrb	r3, [r7, #19]
3401576e:	2b03      	cmp	r3, #3
34015770:	f040 80c4 	bne.w	340158fc <HAL_SPI_IRQHandler+0x398>
      HAL_SPI_TxCpltCallback(hspi);
34015774:	6878      	ldr	r0, [r7, #4]
34015776:	f002 fcab 	bl	340180d0 <HAL_SPI_TxCpltCallback>
    return;
3401577a:	e0bf      	b.n	340158fc <HAL_SPI_IRQHandler+0x398>
  }

  /* SPI in Error Treatment --------------------------------------------------*/
  if ((trigger & (SPI_FLAG_MODF | SPI_FLAG_OVR | SPI_FLAG_FRE | SPI_FLAG_UDR)) != 0UL)
3401577c:	69bb      	ldr	r3, [r7, #24]
3401577e:	f403 7358 	and.w	r3, r3, #864	@ 0x360
34015782:	2b00      	cmp	r3, #0
34015784:	f000 80bd 	beq.w	34015902 <HAL_SPI_IRQHandler+0x39e>
  {
    /* SPI Overrun error interrupt occurred ----------------------------------*/
    if ((trigger & SPI_FLAG_OVR) != 0UL)
34015788:	69bb      	ldr	r3, [r7, #24]
3401578a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3401578e:	2b00      	cmp	r3, #0
34015790:	d00f      	beq.n	340157b2 <HAL_SPI_IRQHandler+0x24e>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
34015792:	687b      	ldr	r3, [r7, #4]
34015794:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34015798:	f043 0204 	orr.w	r2, r3, #4
3401579c:	687b      	ldr	r3, [r7, #4]
3401579e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
340157a2:	687b      	ldr	r3, [r7, #4]
340157a4:	681b      	ldr	r3, [r3, #0]
340157a6:	699a      	ldr	r2, [r3, #24]
340157a8:	687b      	ldr	r3, [r7, #4]
340157aa:	681b      	ldr	r3, [r3, #0]
340157ac:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
340157b0:	619a      	str	r2, [r3, #24]
    }

    /* SPI Mode Fault error interrupt occurred -------------------------------*/
    if ((trigger & SPI_FLAG_MODF) != 0UL)
340157b2:	69bb      	ldr	r3, [r7, #24]
340157b4:	f403 7300 	and.w	r3, r3, #512	@ 0x200
340157b8:	2b00      	cmp	r3, #0
340157ba:	d00f      	beq.n	340157dc <HAL_SPI_IRQHandler+0x278>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
340157bc:	687b      	ldr	r3, [r7, #4]
340157be:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
340157c2:	f043 0201 	orr.w	r2, r3, #1
340157c6:	687b      	ldr	r3, [r7, #4]
340157c8:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      __HAL_SPI_CLEAR_MODFFLAG(hspi);
340157cc:	687b      	ldr	r3, [r7, #4]
340157ce:	681b      	ldr	r3, [r3, #0]
340157d0:	699a      	ldr	r2, [r3, #24]
340157d2:	687b      	ldr	r3, [r7, #4]
340157d4:	681b      	ldr	r3, [r3, #0]
340157d6:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
340157da:	619a      	str	r2, [r3, #24]
    }

    /* SPI Frame error interrupt occurred ------------------------------------*/
    if ((trigger & SPI_FLAG_FRE) != 0UL)
340157dc:	69bb      	ldr	r3, [r7, #24]
340157de:	f403 7380 	and.w	r3, r3, #256	@ 0x100
340157e2:	2b00      	cmp	r3, #0
340157e4:	d00f      	beq.n	34015806 <HAL_SPI_IRQHandler+0x2a2>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
340157e6:	687b      	ldr	r3, [r7, #4]
340157e8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
340157ec:	f043 0208 	orr.w	r2, r3, #8
340157f0:	687b      	ldr	r3, [r7, #4]
340157f2:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      __HAL_SPI_CLEAR_FREFLAG(hspi);
340157f6:	687b      	ldr	r3, [r7, #4]
340157f8:	681b      	ldr	r3, [r3, #0]
340157fa:	699a      	ldr	r2, [r3, #24]
340157fc:	687b      	ldr	r3, [r7, #4]
340157fe:	681b      	ldr	r3, [r3, #0]
34015800:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
34015804:	619a      	str	r2, [r3, #24]
    }

    /* SPI Underrun error interrupt occurred ------------------------------------*/
    if ((trigger & SPI_FLAG_UDR) != 0UL)
34015806:	69bb      	ldr	r3, [r7, #24]
34015808:	f003 0320 	and.w	r3, r3, #32
3401580c:	2b00      	cmp	r3, #0
3401580e:	d00f      	beq.n	34015830 <HAL_SPI_IRQHandler+0x2cc>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_UDR);
34015810:	687b      	ldr	r3, [r7, #4]
34015812:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34015816:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
3401581a:	687b      	ldr	r3, [r7, #4]
3401581c:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      __HAL_SPI_CLEAR_UDRFLAG(hspi);
34015820:	687b      	ldr	r3, [r7, #4]
34015822:	681b      	ldr	r3, [r3, #0]
34015824:	699a      	ldr	r2, [r3, #24]
34015826:	687b      	ldr	r3, [r7, #4]
34015828:	681b      	ldr	r3, [r3, #0]
3401582a:	f042 0220 	orr.w	r2, r2, #32
3401582e:	619a      	str	r2, [r3, #24]
    }

    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
34015830:	687b      	ldr	r3, [r7, #4]
34015832:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34015836:	2b00      	cmp	r3, #0
34015838:	d062      	beq.n	34015900 <HAL_SPI_IRQHandler+0x39c>
    {
      /* Disable SPI peripheral */
      __HAL_SPI_DISABLE(hspi);
3401583a:	687b      	ldr	r3, [r7, #4]
3401583c:	681b      	ldr	r3, [r3, #0]
3401583e:	681a      	ldr	r2, [r3, #0]
34015840:	687b      	ldr	r3, [r7, #4]
34015842:	681b      	ldr	r3, [r3, #0]
34015844:	f022 0201 	bic.w	r2, r2, #1
34015848:	601a      	str	r2, [r3, #0]

      /* Disable all interrupts */
      __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_EOT | SPI_IT_RXP | SPI_IT_TXP | SPI_IT_MODF |
3401584a:	687b      	ldr	r3, [r7, #4]
3401584c:	681b      	ldr	r3, [r3, #0]
3401584e:	691b      	ldr	r3, [r3, #16]
34015850:	687a      	ldr	r2, [r7, #4]
34015852:	6812      	ldr	r2, [r2, #0]
34015854:	f423 735a 	bic.w	r3, r3, #872	@ 0x368
34015858:	f023 0303 	bic.w	r3, r3, #3
3401585c:	6113      	str	r3, [r2, #16]
                                  SPI_IT_OVR | SPI_IT_FRE | SPI_IT_UDR));

      /* Disable the SPI DMA requests if enabled */
      if (HAL_IS_BIT_SET(cfg1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN))
3401585e:	697b      	ldr	r3, [r7, #20]
34015860:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
34015864:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
34015868:	d13e      	bne.n	340158e8 <HAL_SPI_IRQHandler+0x384>
      {
        /* Disable the SPI DMA requests */
        CLEAR_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN);
3401586a:	687b      	ldr	r3, [r7, #4]
3401586c:	681b      	ldr	r3, [r3, #0]
3401586e:	689a      	ldr	r2, [r3, #8]
34015870:	687b      	ldr	r3, [r7, #4]
34015872:	681b      	ldr	r3, [r3, #0]
34015874:	f422 4240 	bic.w	r2, r2, #49152	@ 0xc000
34015878:	609a      	str	r2, [r3, #8]

        /* Abort the SPI DMA Rx channel */
        if (hspi->hdmarx != NULL)
3401587a:	687b      	ldr	r3, [r7, #4]
3401587c:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34015880:	2b00      	cmp	r3, #0
34015882:	d015      	beq.n	340158b0 <HAL_SPI_IRQHandler+0x34c>
        {
          /* Set the SPI DMA Abort callback :
          will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
          hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
34015884:	687b      	ldr	r3, [r7, #4]
34015886:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3401588a:	4a1f      	ldr	r2, [pc, #124]	@ (34015908 <HAL_SPI_IRQHandler+0x3a4>)
3401588c:	66da      	str	r2, [r3, #108]	@ 0x6c
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
3401588e:	687b      	ldr	r3, [r7, #4]
34015890:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34015894:	4618      	mov	r0, r3
34015896:	f7ef fed1 	bl	3400563c <HAL_DMA_Abort_IT>
3401589a:	4603      	mov	r3, r0
3401589c:	2b00      	cmp	r3, #0
3401589e:	d007      	beq.n	340158b0 <HAL_SPI_IRQHandler+0x34c>
          {
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
340158a0:	687b      	ldr	r3, [r7, #4]
340158a2:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
340158a6:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
340158aa:	687b      	ldr	r3, [r7, #4]
340158ac:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
          }
        }
        /* Abort the SPI DMA Tx channel */
        if (hspi->hdmatx != NULL)
340158b0:	687b      	ldr	r3, [r7, #4]
340158b2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340158b6:	2b00      	cmp	r3, #0
340158b8:	d022      	beq.n	34015900 <HAL_SPI_IRQHandler+0x39c>
        {
          /* Set the SPI DMA Abort callback :
          will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
          hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
340158ba:	687b      	ldr	r3, [r7, #4]
340158bc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340158c0:	4a11      	ldr	r2, [pc, #68]	@ (34015908 <HAL_SPI_IRQHandler+0x3a4>)
340158c2:	66da      	str	r2, [r3, #108]	@ 0x6c
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
340158c4:	687b      	ldr	r3, [r7, #4]
340158c6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340158ca:	4618      	mov	r0, r3
340158cc:	f7ef feb6 	bl	3400563c <HAL_DMA_Abort_IT>
340158d0:	4603      	mov	r3, r0
340158d2:	2b00      	cmp	r3, #0
340158d4:	d014      	beq.n	34015900 <HAL_SPI_IRQHandler+0x39c>
          {
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
340158d6:	687b      	ldr	r3, [r7, #4]
340158d8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
340158dc:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
340158e0:	687b      	ldr	r3, [r7, #4]
340158e2:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
#else
        HAL_SPI_ErrorCallback(hspi);
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
      }
    }
    return;
340158e6:	e00b      	b.n	34015900 <HAL_SPI_IRQHandler+0x39c>
        hspi->State = HAL_SPI_STATE_READY;
340158e8:	687b      	ldr	r3, [r7, #4]
340158ea:	2201      	movs	r2, #1
340158ec:	f883 2089 	strb.w	r2, [r3, #137]	@ 0x89
        HAL_SPI_ErrorCallback(hspi);
340158f0:	6878      	ldr	r0, [r7, #4]
340158f2:	f002 fc09 	bl	34018108 <HAL_SPI_ErrorCallback>
    return;
340158f6:	e003      	b.n	34015900 <HAL_SPI_IRQHandler+0x39c>
    return;
340158f8:	bf00      	nop
340158fa:	e002      	b.n	34015902 <HAL_SPI_IRQHandler+0x39e>
    return;
340158fc:	bf00      	nop
340158fe:	e000      	b.n	34015902 <HAL_SPI_IRQHandler+0x39e>
    return;
34015900:	bf00      	nop
  }
}
34015902:	3728      	adds	r7, #40	@ 0x28
34015904:	46bd      	mov	sp, r7
34015906:	bd80      	pop	{r7, pc}
34015908:	34015a05 	.word	0x34015a05

3401590c <HAL_SPI_RxCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi) /* Derogation MISRAC2012-Rule-8.13 */
{
3401590c:	b480      	push	{r7}
3401590e:	b083      	sub	sp, #12
34015910:	af00      	add	r7, sp, #0
34015912:	6078      	str	r0, [r7, #4]
  UNUSED(hspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_RxCpltCallback should be implemented in the user file
   */
}
34015914:	bf00      	nop
34015916:	370c      	adds	r7, #12
34015918:	46bd      	mov	sp, r7
3401591a:	f85d 7b04 	ldr.w	r7, [sp], #4
3401591e:	4770      	bx	lr

34015920 <HAL_SPI_TxRxCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi) /* Derogation MISRAC2012-Rule-8.13 */
{
34015920:	b480      	push	{r7}
34015922:	b083      	sub	sp, #12
34015924:	af00      	add	r7, sp, #0
34015926:	6078      	str	r0, [r7, #4]
  UNUSED(hspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_TxRxCpltCallback should be implemented in the user file
   */
}
34015928:	bf00      	nop
3401592a:	370c      	adds	r7, #12
3401592c:	46bd      	mov	sp, r7
3401592e:	f85d 7b04 	ldr.w	r7, [sp], #4
34015932:	4770      	bx	lr

34015934 <HAL_SPI_TxHalfCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi) /* Derogation MISRAC2012-Rule-8.13 */
{
34015934:	b480      	push	{r7}
34015936:	b083      	sub	sp, #12
34015938:	af00      	add	r7, sp, #0
3401593a:	6078      	str	r0, [r7, #4]
  UNUSED(hspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_TxHalfCpltCallback should be implemented in the user file
   */
}
3401593c:	bf00      	nop
3401593e:	370c      	adds	r7, #12
34015940:	46bd      	mov	sp, r7
34015942:	f85d 7b04 	ldr.w	r7, [sp], #4
34015946:	4770      	bx	lr

34015948 <HAL_SPI_SuspendCallback>:
  * @brief  SPI Suspend callback.
  * @param  hspi SPI handle.
  * @retval None
  */
__weak void HAL_SPI_SuspendCallback(SPI_HandleTypeDef *hspi) /* Derogation MISRAC2012-Rule-8.13 */
{
34015948:	b480      	push	{r7}
3401594a:	b083      	sub	sp, #12
3401594c:	af00      	add	r7, sp, #0
3401594e:	6078      	str	r0, [r7, #4]
  UNUSED(hspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_SuspendCallback can be implemented in the user file.
   */
}
34015950:	bf00      	nop
34015952:	370c      	adds	r7, #12
34015954:	46bd      	mov	sp, r7
34015956:	f85d 7b04 	ldr.w	r7, [sp], #4
3401595a:	4770      	bx	lr

3401595c <SPI_DMATransmitCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
3401595c:	b580      	push	{r7, lr}
3401595e:	b084      	sub	sp, #16
34015960:	af00      	add	r7, sp, #0
34015962:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
34015964:	687b      	ldr	r3, [r7, #4]
34015966:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34015968:	60fb      	str	r3, [r7, #12]

  if (hspi->State != HAL_SPI_STATE_ABORT)
3401596a:	68fb      	ldr	r3, [r7, #12]
3401596c:	f893 3089 	ldrb.w	r3, [r3, #137]	@ 0x89
34015970:	b2db      	uxtb	r3, r3
34015972:	2b07      	cmp	r3, #7
34015974:	d011      	beq.n	3401599a <SPI_DMATransmitCplt+0x3e>
  {
    if (hspi->hdmatx->Mode == DMA_LINKEDLIST_CIRCULAR)
34015976:	68fb      	ldr	r3, [r7, #12]
34015978:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3401597c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3401597e:	2b81      	cmp	r3, #129	@ 0x81
34015980:	d103      	bne.n	3401598a <SPI_DMATransmitCplt+0x2e>
    {
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)
      hspi->TxCpltCallback(hspi);
#else
      HAL_SPI_TxCpltCallback(hspi);
34015982:	68f8      	ldr	r0, [r7, #12]
34015984:	f002 fba4 	bl	340180d0 <HAL_SPI_TxCpltCallback>
    {
      /* Enable EOT interrupt */
      __HAL_SPI_ENABLE_IT(hspi, SPI_IT_EOT);
    }
  }
}
34015988:	e007      	b.n	3401599a <SPI_DMATransmitCplt+0x3e>
      __HAL_SPI_ENABLE_IT(hspi, SPI_IT_EOT);
3401598a:	68fb      	ldr	r3, [r7, #12]
3401598c:	681b      	ldr	r3, [r3, #0]
3401598e:	691a      	ldr	r2, [r3, #16]
34015990:	68fb      	ldr	r3, [r7, #12]
34015992:	681b      	ldr	r3, [r3, #0]
34015994:	f042 0208 	orr.w	r2, r2, #8
34015998:	611a      	str	r2, [r3, #16]
}
3401599a:	bf00      	nop
3401599c:	3710      	adds	r7, #16
3401599e:	46bd      	mov	sp, r7
340159a0:	bd80      	pop	{r7, pc}

340159a2 <SPI_DMAHalfTransmitCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma) /* Derogation MISRAC2012-Rule-8.13 */
{
340159a2:	b580      	push	{r7, lr}
340159a4:	b084      	sub	sp, #16
340159a6:	af00      	add	r7, sp, #0
340159a8:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)
340159aa:	687b      	ldr	r3, [r7, #4]
340159ac:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
340159ae:	60fb      	str	r3, [r7, #12]
                            ((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-8.13 */

#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)
  hspi->TxHalfCpltCallback(hspi);
#else
  HAL_SPI_TxHalfCpltCallback(hspi);
340159b0:	68f8      	ldr	r0, [r7, #12]
340159b2:	f7ff ffbf 	bl	34015934 <HAL_SPI_TxHalfCpltCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
}
340159b6:	bf00      	nop
340159b8:	3710      	adds	r7, #16
340159ba:	46bd      	mov	sp, r7
340159bc:	bd80      	pop	{r7, pc}

340159be <SPI_DMAError>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAError(DMA_HandleTypeDef *hdma)
{
340159be:	b580      	push	{r7, lr}
340159c0:	b084      	sub	sp, #16
340159c2:	af00      	add	r7, sp, #0
340159c4:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
340159c6:	687b      	ldr	r3, [r7, #4]
340159c8:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
340159ca:	60fb      	str	r3, [r7, #12]

  /* if DMA error is FIFO error ignore it */
  if (HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_NONE)
340159cc:	6878      	ldr	r0, [r7, #4]
340159ce:	f7ef ffc7 	bl	34005960 <HAL_DMA_GetError>
340159d2:	4603      	mov	r3, r0
340159d4:	2b00      	cmp	r3, #0
340159d6:	d011      	beq.n	340159fc <SPI_DMAError+0x3e>
  {
    /* Call SPI standard close procedure */
    SPI_CloseTransfer(hspi);
340159d8:	68f8      	ldr	r0, [r7, #12]
340159da:	f000 f82d 	bl	34015a38 <SPI_CloseTransfer>

    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
340159de:	68fb      	ldr	r3, [r7, #12]
340159e0:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
340159e4:	f043 0210 	orr.w	r2, r3, #16
340159e8:	68fb      	ldr	r3, [r7, #12]
340159ea:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
    hspi->State = HAL_SPI_STATE_READY;
340159ee:	68fb      	ldr	r3, [r7, #12]
340159f0:	2201      	movs	r2, #1
340159f2:	f883 2089 	strb.w	r2, [r3, #137]	@ 0x89
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)
    hspi->ErrorCallback(hspi);
#else
    HAL_SPI_ErrorCallback(hspi);
340159f6:	68f8      	ldr	r0, [r7, #12]
340159f8:	f002 fb86 	bl	34018108 <HAL_SPI_ErrorCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }
}
340159fc:	bf00      	nop
340159fe:	3710      	adds	r7, #16
34015a00:	46bd      	mov	sp, r7
34015a02:	bd80      	pop	{r7, pc}

34015a04 <SPI_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
34015a04:	b580      	push	{r7, lr}
34015a06:	b084      	sub	sp, #16
34015a08:	af00      	add	r7, sp, #0
34015a0a:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
34015a0c:	687b      	ldr	r3, [r7, #4]
34015a0e:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34015a10:	60fb      	str	r3, [r7, #12]
  hspi->RxXferCount = (uint16_t) 0UL;
34015a12:	68fb      	ldr	r3, [r7, #12]
34015a14:	2200      	movs	r2, #0
34015a16:	f8a3 2072 	strh.w	r2, [r3, #114]	@ 0x72
  hspi->TxXferCount = (uint16_t) 0UL;
34015a1a:	68fb      	ldr	r3, [r7, #12]
34015a1c:	2200      	movs	r2, #0
34015a1e:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a

  /* Restore hspi->State to Ready */
  hspi->State = HAL_SPI_STATE_READY;
34015a22:	68fb      	ldr	r3, [r7, #12]
34015a24:	2201      	movs	r2, #1
34015a26:	f883 2089 	strb.w	r2, [r3, #137]	@ 0x89

#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)
  hspi->ErrorCallback(hspi);
#else
  HAL_SPI_ErrorCallback(hspi);
34015a2a:	68f8      	ldr	r0, [r7, #12]
34015a2c:	f002 fb6c 	bl	34018108 <HAL_SPI_ErrorCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
}
34015a30:	bf00      	nop
34015a32:	3710      	adds	r7, #16
34015a34:	46bd      	mov	sp, r7
34015a36:	bd80      	pop	{r7, pc}

34015a38 <SPI_CloseTransfer>:
  *               the configuration information for SPI module.
  * @retval HAL_ERROR: if any error detected
  *         HAL_OK: if nothing detected
  */
static void SPI_CloseTransfer(SPI_HandleTypeDef *hspi)
{
34015a38:	b480      	push	{r7}
34015a3a:	b085      	sub	sp, #20
34015a3c:	af00      	add	r7, sp, #0
34015a3e:	6078      	str	r0, [r7, #4]
  uint32_t itflag = hspi->Instance->SR;
34015a40:	687b      	ldr	r3, [r7, #4]
34015a42:	681b      	ldr	r3, [r3, #0]
34015a44:	695b      	ldr	r3, [r3, #20]
34015a46:	60fb      	str	r3, [r7, #12]

  __HAL_SPI_CLEAR_EOTFLAG(hspi);
34015a48:	687b      	ldr	r3, [r7, #4]
34015a4a:	681b      	ldr	r3, [r3, #0]
34015a4c:	699a      	ldr	r2, [r3, #24]
34015a4e:	687b      	ldr	r3, [r7, #4]
34015a50:	681b      	ldr	r3, [r3, #0]
34015a52:	f042 0208 	orr.w	r2, r2, #8
34015a56:	619a      	str	r2, [r3, #24]
  __HAL_SPI_CLEAR_TXTFFLAG(hspi);
34015a58:	687b      	ldr	r3, [r7, #4]
34015a5a:	681b      	ldr	r3, [r3, #0]
34015a5c:	699a      	ldr	r2, [r3, #24]
34015a5e:	687b      	ldr	r3, [r7, #4]
34015a60:	681b      	ldr	r3, [r3, #0]
34015a62:	f042 0210 	orr.w	r2, r2, #16
34015a66:	619a      	str	r2, [r3, #24]

  /* Disable SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
34015a68:	687b      	ldr	r3, [r7, #4]
34015a6a:	681b      	ldr	r3, [r3, #0]
34015a6c:	681a      	ldr	r2, [r3, #0]
34015a6e:	687b      	ldr	r3, [r7, #4]
34015a70:	681b      	ldr	r3, [r3, #0]
34015a72:	f022 0201 	bic.w	r2, r2, #1
34015a76:	601a      	str	r2, [r3, #0]

  /* Disable ITs */
  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_EOT | SPI_IT_TXP | SPI_IT_RXP | SPI_IT_DXP | SPI_IT_UDR | SPI_IT_OVR | \
34015a78:	687b      	ldr	r3, [r7, #4]
34015a7a:	681b      	ldr	r3, [r3, #0]
34015a7c:	691b      	ldr	r3, [r3, #16]
34015a7e:	687a      	ldr	r2, [r7, #4]
34015a80:	6812      	ldr	r2, [r2, #0]
34015a82:	f423 735b 	bic.w	r3, r3, #876	@ 0x36c
34015a86:	f023 0303 	bic.w	r3, r3, #3
34015a8a:	6113      	str	r3, [r2, #16]
                              SPI_IT_FRE | SPI_IT_MODF));

  /* Disable Tx DMA Request */
  CLEAR_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN);
34015a8c:	687b      	ldr	r3, [r7, #4]
34015a8e:	681b      	ldr	r3, [r3, #0]
34015a90:	689a      	ldr	r2, [r3, #8]
34015a92:	687b      	ldr	r3, [r7, #4]
34015a94:	681b      	ldr	r3, [r3, #0]
34015a96:	f422 4240 	bic.w	r2, r2, #49152	@ 0xc000
34015a9a:	609a      	str	r2, [r3, #8]

  /* Report UnderRun error for non RX Only communication */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
34015a9c:	687b      	ldr	r3, [r7, #4]
34015a9e:	f893 3089 	ldrb.w	r3, [r3, #137]	@ 0x89
34015aa2:	b2db      	uxtb	r3, r3
34015aa4:	2b04      	cmp	r3, #4
34015aa6:	d014      	beq.n	34015ad2 <SPI_CloseTransfer+0x9a>
  {
    if ((itflag & SPI_FLAG_UDR) != 0UL)
34015aa8:	68fb      	ldr	r3, [r7, #12]
34015aaa:	f003 0320 	and.w	r3, r3, #32
34015aae:	2b00      	cmp	r3, #0
34015ab0:	d00f      	beq.n	34015ad2 <SPI_CloseTransfer+0x9a>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_UDR);
34015ab2:	687b      	ldr	r3, [r7, #4]
34015ab4:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34015ab8:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
34015abc:	687b      	ldr	r3, [r7, #4]
34015abe:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      __HAL_SPI_CLEAR_UDRFLAG(hspi);
34015ac2:	687b      	ldr	r3, [r7, #4]
34015ac4:	681b      	ldr	r3, [r3, #0]
34015ac6:	699a      	ldr	r2, [r3, #24]
34015ac8:	687b      	ldr	r3, [r7, #4]
34015aca:	681b      	ldr	r3, [r3, #0]
34015acc:	f042 0220 	orr.w	r2, r2, #32
34015ad0:	619a      	str	r2, [r3, #24]
    }
  }

  /* Report OverRun error for non TX Only communication */
  if (hspi->State != HAL_SPI_STATE_BUSY_TX)
34015ad2:	687b      	ldr	r3, [r7, #4]
34015ad4:	f893 3089 	ldrb.w	r3, [r3, #137]	@ 0x89
34015ad8:	b2db      	uxtb	r3, r3
34015ada:	2b03      	cmp	r3, #3
34015adc:	d02e      	beq.n	34015b3c <SPI_CloseTransfer+0x104>
  {
    if ((itflag & SPI_FLAG_OVR) != 0UL)
34015ade:	68fb      	ldr	r3, [r7, #12]
34015ae0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34015ae4:	2b00      	cmp	r3, #0
34015ae6:	d00f      	beq.n	34015b08 <SPI_CloseTransfer+0xd0>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
34015ae8:	687b      	ldr	r3, [r7, #4]
34015aea:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34015aee:	f043 0204 	orr.w	r2, r3, #4
34015af2:	687b      	ldr	r3, [r7, #4]
34015af4:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
34015af8:	687b      	ldr	r3, [r7, #4]
34015afa:	681b      	ldr	r3, [r3, #0]
34015afc:	699a      	ldr	r2, [r3, #24]
34015afe:	687b      	ldr	r3, [r7, #4]
34015b00:	681b      	ldr	r3, [r3, #0]
34015b02:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
34015b06:	619a      	str	r2, [r3, #24]
    }

#if (USE_SPI_CRC != 0UL)
    /* Check if CRC error occurred */
    if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
34015b08:	687b      	ldr	r3, [r7, #4]
34015b0a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34015b0c:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
34015b10:	d114      	bne.n	34015b3c <SPI_CloseTransfer+0x104>
    {
      if ((itflag & SPI_FLAG_CRCERR) != 0UL)
34015b12:	68fb      	ldr	r3, [r7, #12]
34015b14:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34015b18:	2b00      	cmp	r3, #0
34015b1a:	d00f      	beq.n	34015b3c <SPI_CloseTransfer+0x104>
      {
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
34015b1c:	687b      	ldr	r3, [r7, #4]
34015b1e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34015b22:	f043 0202 	orr.w	r2, r3, #2
34015b26:	687b      	ldr	r3, [r7, #4]
34015b28:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
34015b2c:	687b      	ldr	r3, [r7, #4]
34015b2e:	681b      	ldr	r3, [r3, #0]
34015b30:	699a      	ldr	r2, [r3, #24]
34015b32:	687b      	ldr	r3, [r7, #4]
34015b34:	681b      	ldr	r3, [r3, #0]
34015b36:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
34015b3a:	619a      	str	r2, [r3, #24]
    }
#endif /* USE_SPI_CRC */
  }

  /* SPI Mode Fault error interrupt occurred -------------------------------*/
  if ((itflag & SPI_FLAG_MODF) != 0UL)
34015b3c:	68fb      	ldr	r3, [r7, #12]
34015b3e:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34015b42:	2b00      	cmp	r3, #0
34015b44:	d00f      	beq.n	34015b66 <SPI_CloseTransfer+0x12e>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
34015b46:	687b      	ldr	r3, [r7, #4]
34015b48:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34015b4c:	f043 0201 	orr.w	r2, r3, #1
34015b50:	687b      	ldr	r3, [r7, #4]
34015b52:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
    __HAL_SPI_CLEAR_MODFFLAG(hspi);
34015b56:	687b      	ldr	r3, [r7, #4]
34015b58:	681b      	ldr	r3, [r3, #0]
34015b5a:	699a      	ldr	r2, [r3, #24]
34015b5c:	687b      	ldr	r3, [r7, #4]
34015b5e:	681b      	ldr	r3, [r3, #0]
34015b60:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
34015b64:	619a      	str	r2, [r3, #24]
  }

  /* SPI Frame error interrupt occurred ------------------------------------*/
  if ((itflag & SPI_FLAG_FRE) != 0UL)
34015b66:	68fb      	ldr	r3, [r7, #12]
34015b68:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34015b6c:	2b00      	cmp	r3, #0
34015b6e:	d00f      	beq.n	34015b90 <SPI_CloseTransfer+0x158>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
34015b70:	687b      	ldr	r3, [r7, #4]
34015b72:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34015b76:	f043 0208 	orr.w	r2, r3, #8
34015b7a:	687b      	ldr	r3, [r7, #4]
34015b7c:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
    __HAL_SPI_CLEAR_FREFLAG(hspi);
34015b80:	687b      	ldr	r3, [r7, #4]
34015b82:	681b      	ldr	r3, [r3, #0]
34015b84:	699a      	ldr	r2, [r3, #24]
34015b86:	687b      	ldr	r3, [r7, #4]
34015b88:	681b      	ldr	r3, [r3, #0]
34015b8a:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
34015b8e:	619a      	str	r2, [r3, #24]
  }

  hspi->TxXferCount = (uint16_t)0UL;
34015b90:	687b      	ldr	r3, [r7, #4]
34015b92:	2200      	movs	r2, #0
34015b94:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
  hspi->RxXferCount = (uint16_t)0UL;
34015b98:	687b      	ldr	r3, [r7, #4]
34015b9a:	2200      	movs	r2, #0
34015b9c:	f8a3 2072 	strh.w	r2, [r3, #114]	@ 0x72
}
34015ba0:	bf00      	nop
34015ba2:	3714      	adds	r7, #20
34015ba4:	46bd      	mov	sp, r7
34015ba6:	f85d 7b04 	ldr.w	r7, [sp], #4
34015baa:	4770      	bx	lr

34015bac <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
34015bac:	b580      	push	{r7, lr}
34015bae:	b082      	sub	sp, #8
34015bb0:	af00      	add	r7, sp, #0
34015bb2:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
34015bb4:	687b      	ldr	r3, [r7, #4]
34015bb6:	2b00      	cmp	r3, #0
34015bb8:	d101      	bne.n	34015bbe <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
34015bba:	2301      	movs	r3, #1
34015bbc:	e16e      	b.n	34015e9c <HAL_UART_Init+0x2f0>
  }

  if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
34015bbe:	687b      	ldr	r3, [r7, #4]
34015bc0:	699b      	ldr	r3, [r3, #24]
34015bc2:	2b00      	cmp	r3, #0
34015bc4:	f000 8088 	beq.w	34015cd8 <HAL_UART_Init+0x12c>
  {
    /* Check the parameters */
    assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
34015bc8:	687b      	ldr	r3, [r7, #4]
34015bca:	681b      	ldr	r3, [r3, #0]
34015bcc:	4a8f      	ldr	r2, [pc, #572]	@ (34015e0c <HAL_UART_Init+0x260>)
34015bce:	4293      	cmp	r3, r2
34015bd0:	f000 80f5 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015bd4:	687b      	ldr	r3, [r7, #4]
34015bd6:	681b      	ldr	r3, [r3, #0]
34015bd8:	4a8d      	ldr	r2, [pc, #564]	@ (34015e10 <HAL_UART_Init+0x264>)
34015bda:	4293      	cmp	r3, r2
34015bdc:	f000 80ef 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015be0:	687b      	ldr	r3, [r7, #4]
34015be2:	681b      	ldr	r3, [r3, #0]
34015be4:	4a8b      	ldr	r2, [pc, #556]	@ (34015e14 <HAL_UART_Init+0x268>)
34015be6:	4293      	cmp	r3, r2
34015be8:	f000 80e9 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015bec:	687b      	ldr	r3, [r7, #4]
34015bee:	681b      	ldr	r3, [r3, #0]
34015bf0:	4a89      	ldr	r2, [pc, #548]	@ (34015e18 <HAL_UART_Init+0x26c>)
34015bf2:	4293      	cmp	r3, r2
34015bf4:	f000 80e3 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015bf8:	687b      	ldr	r3, [r7, #4]
34015bfa:	681b      	ldr	r3, [r3, #0]
34015bfc:	4a87      	ldr	r2, [pc, #540]	@ (34015e1c <HAL_UART_Init+0x270>)
34015bfe:	4293      	cmp	r3, r2
34015c00:	f000 80dd 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015c04:	687b      	ldr	r3, [r7, #4]
34015c06:	681b      	ldr	r3, [r3, #0]
34015c08:	4a85      	ldr	r2, [pc, #532]	@ (34015e20 <HAL_UART_Init+0x274>)
34015c0a:	4293      	cmp	r3, r2
34015c0c:	f000 80d7 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015c10:	687b      	ldr	r3, [r7, #4]
34015c12:	681b      	ldr	r3, [r3, #0]
34015c14:	4a83      	ldr	r2, [pc, #524]	@ (34015e24 <HAL_UART_Init+0x278>)
34015c16:	4293      	cmp	r3, r2
34015c18:	f000 80d1 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015c1c:	687b      	ldr	r3, [r7, #4]
34015c1e:	681b      	ldr	r3, [r3, #0]
34015c20:	4a81      	ldr	r2, [pc, #516]	@ (34015e28 <HAL_UART_Init+0x27c>)
34015c22:	4293      	cmp	r3, r2
34015c24:	f000 80cb 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015c28:	687b      	ldr	r3, [r7, #4]
34015c2a:	681b      	ldr	r3, [r3, #0]
34015c2c:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
34015c30:	f000 80c5 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015c34:	687b      	ldr	r3, [r7, #4]
34015c36:	681b      	ldr	r3, [r3, #0]
34015c38:	4a7c      	ldr	r2, [pc, #496]	@ (34015e2c <HAL_UART_Init+0x280>)
34015c3a:	4293      	cmp	r3, r2
34015c3c:	f000 80bf 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015c40:	687b      	ldr	r3, [r7, #4]
34015c42:	681b      	ldr	r3, [r3, #0]
34015c44:	4a7a      	ldr	r2, [pc, #488]	@ (34015e30 <HAL_UART_Init+0x284>)
34015c46:	4293      	cmp	r3, r2
34015c48:	f000 80b9 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015c4c:	687b      	ldr	r3, [r7, #4]
34015c4e:	681b      	ldr	r3, [r3, #0]
34015c50:	4a78      	ldr	r2, [pc, #480]	@ (34015e34 <HAL_UART_Init+0x288>)
34015c52:	4293      	cmp	r3, r2
34015c54:	f000 80b3 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015c58:	687b      	ldr	r3, [r7, #4]
34015c5a:	681b      	ldr	r3, [r3, #0]
34015c5c:	4a76      	ldr	r2, [pc, #472]	@ (34015e38 <HAL_UART_Init+0x28c>)
34015c5e:	4293      	cmp	r3, r2
34015c60:	f000 80ad 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015c64:	687b      	ldr	r3, [r7, #4]
34015c66:	681b      	ldr	r3, [r3, #0]
34015c68:	4a74      	ldr	r2, [pc, #464]	@ (34015e3c <HAL_UART_Init+0x290>)
34015c6a:	4293      	cmp	r3, r2
34015c6c:	f000 80a7 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015c70:	687b      	ldr	r3, [r7, #4]
34015c72:	681b      	ldr	r3, [r3, #0]
34015c74:	4a72      	ldr	r2, [pc, #456]	@ (34015e40 <HAL_UART_Init+0x294>)
34015c76:	4293      	cmp	r3, r2
34015c78:	f000 80a1 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015c7c:	687b      	ldr	r3, [r7, #4]
34015c7e:	681b      	ldr	r3, [r3, #0]
34015c80:	4a70      	ldr	r2, [pc, #448]	@ (34015e44 <HAL_UART_Init+0x298>)
34015c82:	4293      	cmp	r3, r2
34015c84:	f000 809b 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015c88:	687b      	ldr	r3, [r7, #4]
34015c8a:	681b      	ldr	r3, [r3, #0]
34015c8c:	4a6e      	ldr	r2, [pc, #440]	@ (34015e48 <HAL_UART_Init+0x29c>)
34015c8e:	4293      	cmp	r3, r2
34015c90:	f000 8095 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015c94:	687b      	ldr	r3, [r7, #4]
34015c96:	681b      	ldr	r3, [r3, #0]
34015c98:	4a6c      	ldr	r2, [pc, #432]	@ (34015e4c <HAL_UART_Init+0x2a0>)
34015c9a:	4293      	cmp	r3, r2
34015c9c:	f000 808f 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015ca0:	687b      	ldr	r3, [r7, #4]
34015ca2:	681b      	ldr	r3, [r3, #0]
34015ca4:	4a6a      	ldr	r2, [pc, #424]	@ (34015e50 <HAL_UART_Init+0x2a4>)
34015ca6:	4293      	cmp	r3, r2
34015ca8:	f000 8089 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015cac:	687b      	ldr	r3, [r7, #4]
34015cae:	681b      	ldr	r3, [r3, #0]
34015cb0:	4a68      	ldr	r2, [pc, #416]	@ (34015e54 <HAL_UART_Init+0x2a8>)
34015cb2:	4293      	cmp	r3, r2
34015cb4:	f000 8083 	beq.w	34015dbe <HAL_UART_Init+0x212>
34015cb8:	687b      	ldr	r3, [r7, #4]
34015cba:	681b      	ldr	r3, [r3, #0]
34015cbc:	4a66      	ldr	r2, [pc, #408]	@ (34015e58 <HAL_UART_Init+0x2ac>)
34015cbe:	4293      	cmp	r3, r2
34015cc0:	d07d      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015cc2:	687b      	ldr	r3, [r7, #4]
34015cc4:	681b      	ldr	r3, [r3, #0]
34015cc6:	4a65      	ldr	r2, [pc, #404]	@ (34015e5c <HAL_UART_Init+0x2b0>)
34015cc8:	4293      	cmp	r3, r2
34015cca:	d078      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015ccc:	f240 113f 	movw	r1, #319	@ 0x13f
34015cd0:	4863      	ldr	r0, [pc, #396]	@ (34015e60 <HAL_UART_Init+0x2b4>)
34015cd2:	f7ec f99d 	bl	34002010 <assert_failed>
34015cd6:	e072      	b.n	34015dbe <HAL_UART_Init+0x212>
  }
  else
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
34015cd8:	687b      	ldr	r3, [r7, #4]
34015cda:	681b      	ldr	r3, [r3, #0]
34015cdc:	4a4b      	ldr	r2, [pc, #300]	@ (34015e0c <HAL_UART_Init+0x260>)
34015cde:	4293      	cmp	r3, r2
34015ce0:	d06d      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015ce2:	687b      	ldr	r3, [r7, #4]
34015ce4:	681b      	ldr	r3, [r3, #0]
34015ce6:	4a4a      	ldr	r2, [pc, #296]	@ (34015e10 <HAL_UART_Init+0x264>)
34015ce8:	4293      	cmp	r3, r2
34015cea:	d068      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015cec:	687b      	ldr	r3, [r7, #4]
34015cee:	681b      	ldr	r3, [r3, #0]
34015cf0:	4a48      	ldr	r2, [pc, #288]	@ (34015e14 <HAL_UART_Init+0x268>)
34015cf2:	4293      	cmp	r3, r2
34015cf4:	d063      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015cf6:	687b      	ldr	r3, [r7, #4]
34015cf8:	681b      	ldr	r3, [r3, #0]
34015cfa:	4a47      	ldr	r2, [pc, #284]	@ (34015e18 <HAL_UART_Init+0x26c>)
34015cfc:	4293      	cmp	r3, r2
34015cfe:	d05e      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015d00:	687b      	ldr	r3, [r7, #4]
34015d02:	681b      	ldr	r3, [r3, #0]
34015d04:	4a45      	ldr	r2, [pc, #276]	@ (34015e1c <HAL_UART_Init+0x270>)
34015d06:	4293      	cmp	r3, r2
34015d08:	d059      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015d0a:	687b      	ldr	r3, [r7, #4]
34015d0c:	681b      	ldr	r3, [r3, #0]
34015d0e:	4a44      	ldr	r2, [pc, #272]	@ (34015e20 <HAL_UART_Init+0x274>)
34015d10:	4293      	cmp	r3, r2
34015d12:	d054      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015d14:	687b      	ldr	r3, [r7, #4]
34015d16:	681b      	ldr	r3, [r3, #0]
34015d18:	4a42      	ldr	r2, [pc, #264]	@ (34015e24 <HAL_UART_Init+0x278>)
34015d1a:	4293      	cmp	r3, r2
34015d1c:	d04f      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015d1e:	687b      	ldr	r3, [r7, #4]
34015d20:	681b      	ldr	r3, [r3, #0]
34015d22:	4a41      	ldr	r2, [pc, #260]	@ (34015e28 <HAL_UART_Init+0x27c>)
34015d24:	4293      	cmp	r3, r2
34015d26:	d04a      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015d28:	687b      	ldr	r3, [r7, #4]
34015d2a:	681b      	ldr	r3, [r3, #0]
34015d2c:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
34015d30:	d045      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015d32:	687b      	ldr	r3, [r7, #4]
34015d34:	681b      	ldr	r3, [r3, #0]
34015d36:	4a3d      	ldr	r2, [pc, #244]	@ (34015e2c <HAL_UART_Init+0x280>)
34015d38:	4293      	cmp	r3, r2
34015d3a:	d040      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015d3c:	687b      	ldr	r3, [r7, #4]
34015d3e:	681b      	ldr	r3, [r3, #0]
34015d40:	4a3b      	ldr	r2, [pc, #236]	@ (34015e30 <HAL_UART_Init+0x284>)
34015d42:	4293      	cmp	r3, r2
34015d44:	d03b      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015d46:	687b      	ldr	r3, [r7, #4]
34015d48:	681b      	ldr	r3, [r3, #0]
34015d4a:	4a3a      	ldr	r2, [pc, #232]	@ (34015e34 <HAL_UART_Init+0x288>)
34015d4c:	4293      	cmp	r3, r2
34015d4e:	d036      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015d50:	687b      	ldr	r3, [r7, #4]
34015d52:	681b      	ldr	r3, [r3, #0]
34015d54:	4a38      	ldr	r2, [pc, #224]	@ (34015e38 <HAL_UART_Init+0x28c>)
34015d56:	4293      	cmp	r3, r2
34015d58:	d031      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015d5a:	687b      	ldr	r3, [r7, #4]
34015d5c:	681b      	ldr	r3, [r3, #0]
34015d5e:	4a37      	ldr	r2, [pc, #220]	@ (34015e3c <HAL_UART_Init+0x290>)
34015d60:	4293      	cmp	r3, r2
34015d62:	d02c      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015d64:	687b      	ldr	r3, [r7, #4]
34015d66:	681b      	ldr	r3, [r3, #0]
34015d68:	4a35      	ldr	r2, [pc, #212]	@ (34015e40 <HAL_UART_Init+0x294>)
34015d6a:	4293      	cmp	r3, r2
34015d6c:	d027      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015d6e:	687b      	ldr	r3, [r7, #4]
34015d70:	681b      	ldr	r3, [r3, #0]
34015d72:	4a34      	ldr	r2, [pc, #208]	@ (34015e44 <HAL_UART_Init+0x298>)
34015d74:	4293      	cmp	r3, r2
34015d76:	d022      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015d78:	687b      	ldr	r3, [r7, #4]
34015d7a:	681b      	ldr	r3, [r3, #0]
34015d7c:	4a32      	ldr	r2, [pc, #200]	@ (34015e48 <HAL_UART_Init+0x29c>)
34015d7e:	4293      	cmp	r3, r2
34015d80:	d01d      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015d82:	687b      	ldr	r3, [r7, #4]
34015d84:	681b      	ldr	r3, [r3, #0]
34015d86:	4a31      	ldr	r2, [pc, #196]	@ (34015e4c <HAL_UART_Init+0x2a0>)
34015d88:	4293      	cmp	r3, r2
34015d8a:	d018      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015d8c:	687b      	ldr	r3, [r7, #4]
34015d8e:	681b      	ldr	r3, [r3, #0]
34015d90:	4a2f      	ldr	r2, [pc, #188]	@ (34015e50 <HAL_UART_Init+0x2a4>)
34015d92:	4293      	cmp	r3, r2
34015d94:	d013      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015d96:	687b      	ldr	r3, [r7, #4]
34015d98:	681b      	ldr	r3, [r3, #0]
34015d9a:	4a2e      	ldr	r2, [pc, #184]	@ (34015e54 <HAL_UART_Init+0x2a8>)
34015d9c:	4293      	cmp	r3, r2
34015d9e:	d00e      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015da0:	687b      	ldr	r3, [r7, #4]
34015da2:	681b      	ldr	r3, [r3, #0]
34015da4:	4a2c      	ldr	r2, [pc, #176]	@ (34015e58 <HAL_UART_Init+0x2ac>)
34015da6:	4293      	cmp	r3, r2
34015da8:	d009      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015daa:	687b      	ldr	r3, [r7, #4]
34015dac:	681b      	ldr	r3, [r3, #0]
34015dae:	4a2b      	ldr	r2, [pc, #172]	@ (34015e5c <HAL_UART_Init+0x2b0>)
34015db0:	4293      	cmp	r3, r2
34015db2:	d004      	beq.n	34015dbe <HAL_UART_Init+0x212>
34015db4:	f44f 71a2 	mov.w	r1, #324	@ 0x144
34015db8:	4829      	ldr	r0, [pc, #164]	@ (34015e60 <HAL_UART_Init+0x2b4>)
34015dba:	f7ec f929 	bl	34002010 <assert_failed>
  }

  if (huart->gState == HAL_UART_STATE_RESET)
34015dbe:	687b      	ldr	r3, [r7, #4]
34015dc0:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34015dc4:	2b00      	cmp	r3, #0
34015dc6:	d106      	bne.n	34015dd6 <HAL_UART_Init+0x22a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
34015dc8:	687b      	ldr	r3, [r7, #4]
34015dca:	2200      	movs	r2, #0
34015dcc:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
34015dd0:	6878      	ldr	r0, [r7, #4]
34015dd2:	f000 f867 	bl	34015ea4 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
34015dd6:	687b      	ldr	r3, [r7, #4]
34015dd8:	2224      	movs	r2, #36	@ 0x24
34015dda:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  __HAL_UART_DISABLE(huart);
34015dde:	687b      	ldr	r3, [r7, #4]
34015de0:	681b      	ldr	r3, [r3, #0]
34015de2:	681a      	ldr	r2, [r3, #0]
34015de4:	687b      	ldr	r3, [r7, #4]
34015de6:	681b      	ldr	r3, [r3, #0]
34015de8:	f022 0201 	bic.w	r2, r2, #1
34015dec:	601a      	str	r2, [r3, #0]

  /* Perform advanced settings configuration */
  /* For some items, configuration requires to be done prior TE and RE bits are set */
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
34015dee:	687b      	ldr	r3, [r7, #4]
34015df0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34015df2:	2b00      	cmp	r3, #0
34015df4:	d002      	beq.n	34015dfc <HAL_UART_Init+0x250>
  {
    UART_AdvFeatureConfig(huart);
34015df6:	6878      	ldr	r0, [r7, #4]
34015df8:	f000 fbb8 	bl	3401656c <UART_AdvFeatureConfig>
  }

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
34015dfc:	6878      	ldr	r0, [r7, #4]
34015dfe:	f000 f8e9 	bl	34015fd4 <UART_SetConfig>
34015e02:	4603      	mov	r3, r0
34015e04:	2b01      	cmp	r3, #1
34015e06:	d12d      	bne.n	34015e64 <HAL_UART_Init+0x2b8>
  {
    return HAL_ERROR;
34015e08:	2301      	movs	r3, #1
34015e0a:	e047      	b.n	34015e9c <HAL_UART_Init+0x2f0>
34015e0c:	52001000 	.word	0x52001000
34015e10:	42001000 	.word	0x42001000
34015e14:	50004400 	.word	0x50004400
34015e18:	40004400 	.word	0x40004400
34015e1c:	50004800 	.word	0x50004800
34015e20:	40004800 	.word	0x40004800
34015e24:	50004c00 	.word	0x50004c00
34015e28:	40004c00 	.word	0x40004c00
34015e2c:	40005000 	.word	0x40005000
34015e30:	52001400 	.word	0x52001400
34015e34:	42001400 	.word	0x42001400
34015e38:	50007800 	.word	0x50007800
34015e3c:	40007800 	.word	0x40007800
34015e40:	50007c00 	.word	0x50007c00
34015e44:	40007c00 	.word	0x40007c00
34015e48:	52001800 	.word	0x52001800
34015e4c:	42001800 	.word	0x42001800
34015e50:	52001c00 	.word	0x52001c00
34015e54:	42001c00 	.word	0x42001c00
34015e58:	56000c00 	.word	0x56000c00
34015e5c:	46000c00 	.word	0x46000c00
34015e60:	3401f05c 	.word	0x3401f05c
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
34015e64:	687b      	ldr	r3, [r7, #4]
34015e66:	681b      	ldr	r3, [r3, #0]
34015e68:	685a      	ldr	r2, [r3, #4]
34015e6a:	687b      	ldr	r3, [r7, #4]
34015e6c:	681b      	ldr	r3, [r3, #0]
34015e6e:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
34015e72:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
34015e74:	687b      	ldr	r3, [r7, #4]
34015e76:	681b      	ldr	r3, [r3, #0]
34015e78:	689a      	ldr	r2, [r3, #8]
34015e7a:	687b      	ldr	r3, [r7, #4]
34015e7c:	681b      	ldr	r3, [r3, #0]
34015e7e:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
34015e82:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
34015e84:	687b      	ldr	r3, [r7, #4]
34015e86:	681b      	ldr	r3, [r3, #0]
34015e88:	681a      	ldr	r2, [r3, #0]
34015e8a:	687b      	ldr	r3, [r7, #4]
34015e8c:	681b      	ldr	r3, [r3, #0]
34015e8e:	f042 0201 	orr.w	r2, r2, #1
34015e92:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
34015e94:	6878      	ldr	r0, [r7, #4]
34015e96:	f000 fd33 	bl	34016900 <UART_CheckIdleState>
34015e9a:	4603      	mov	r3, r0
}
34015e9c:	4618      	mov	r0, r3
34015e9e:	3708      	adds	r7, #8
34015ea0:	46bd      	mov	sp, r7
34015ea2:	bd80      	pop	{r7, pc}

34015ea4 <HAL_UART_MspInit>:
  * @brief Initialize the UART MSP.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
34015ea4:	b480      	push	{r7}
34015ea6:	b083      	sub	sp, #12
34015ea8:	af00      	add	r7, sp, #0
34015eaa:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_MspInit can be implemented in the user file
   */
}
34015eac:	bf00      	nop
34015eae:	370c      	adds	r7, #12
34015eb0:	46bd      	mov	sp, r7
34015eb2:	f85d 7b04 	ldr.w	r7, [sp], #4
34015eb6:	4770      	bx	lr

34015eb8 <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
34015eb8:	b580      	push	{r7, lr}
34015eba:	b08a      	sub	sp, #40	@ 0x28
34015ebc:	af02      	add	r7, sp, #8
34015ebe:	60f8      	str	r0, [r7, #12]
34015ec0:	60b9      	str	r1, [r7, #8]
34015ec2:	603b      	str	r3, [r7, #0]
34015ec4:	4613      	mov	r3, r2
34015ec6:	80fb      	strh	r3, [r7, #6]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
34015ec8:	68fb      	ldr	r3, [r7, #12]
34015eca:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34015ece:	2b20      	cmp	r3, #32
34015ed0:	d17b      	bne.n	34015fca <HAL_UART_Transmit+0x112>
  {
    if ((pData == NULL) || (Size == 0U))
34015ed2:	68bb      	ldr	r3, [r7, #8]
34015ed4:	2b00      	cmp	r3, #0
34015ed6:	d002      	beq.n	34015ede <HAL_UART_Transmit+0x26>
34015ed8:	88fb      	ldrh	r3, [r7, #6]
34015eda:	2b00      	cmp	r3, #0
34015edc:	d101      	bne.n	34015ee2 <HAL_UART_Transmit+0x2a>
    {
      return  HAL_ERROR;
34015ede:	2301      	movs	r3, #1
34015ee0:	e074      	b.n	34015fcc <HAL_UART_Transmit+0x114>
    }

    huart->ErrorCode = HAL_UART_ERROR_NONE;
34015ee2:	68fb      	ldr	r3, [r7, #12]
34015ee4:	2200      	movs	r2, #0
34015ee6:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
34015eea:	68fb      	ldr	r3, [r7, #12]
34015eec:	2221      	movs	r2, #33	@ 0x21
34015eee:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
34015ef2:	f7ee f8af 	bl	34004054 <HAL_GetTick>
34015ef6:	6178      	str	r0, [r7, #20]

    huart->TxXferSize  = Size;
34015ef8:	68fb      	ldr	r3, [r7, #12]
34015efa:	88fa      	ldrh	r2, [r7, #6]
34015efc:	f8a3 2054 	strh.w	r2, [r3, #84]	@ 0x54
    huart->TxXferCount = Size;
34015f00:	68fb      	ldr	r3, [r7, #12]
34015f02:	88fa      	ldrh	r2, [r7, #6]
34015f04:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
34015f08:	68fb      	ldr	r3, [r7, #12]
34015f0a:	689b      	ldr	r3, [r3, #8]
34015f0c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34015f10:	d108      	bne.n	34015f24 <HAL_UART_Transmit+0x6c>
34015f12:	68fb      	ldr	r3, [r7, #12]
34015f14:	691b      	ldr	r3, [r3, #16]
34015f16:	2b00      	cmp	r3, #0
34015f18:	d104      	bne.n	34015f24 <HAL_UART_Transmit+0x6c>
    {
      pdata8bits  = NULL;
34015f1a:	2300      	movs	r3, #0
34015f1c:	61fb      	str	r3, [r7, #28]
      pdata16bits = (const uint16_t *) pData;
34015f1e:	68bb      	ldr	r3, [r7, #8]
34015f20:	61bb      	str	r3, [r7, #24]
34015f22:	e003      	b.n	34015f2c <HAL_UART_Transmit+0x74>
    }
    else
    {
      pdata8bits  = pData;
34015f24:	68bb      	ldr	r3, [r7, #8]
34015f26:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
34015f28:	2300      	movs	r3, #0
34015f2a:	61bb      	str	r3, [r7, #24]
    }

    while (huart->TxXferCount > 0U)
34015f2c:	e030      	b.n	34015f90 <HAL_UART_Transmit+0xd8>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
34015f2e:	683b      	ldr	r3, [r7, #0]
34015f30:	9300      	str	r3, [sp, #0]
34015f32:	697b      	ldr	r3, [r7, #20]
34015f34:	2200      	movs	r2, #0
34015f36:	2180      	movs	r1, #128	@ 0x80
34015f38:	68f8      	ldr	r0, [r7, #12]
34015f3a:	f000 fd8b 	bl	34016a54 <UART_WaitOnFlagUntilTimeout>
34015f3e:	4603      	mov	r3, r0
34015f40:	2b00      	cmp	r3, #0
34015f42:	d005      	beq.n	34015f50 <HAL_UART_Transmit+0x98>
      {

        huart->gState = HAL_UART_STATE_READY;
34015f44:	68fb      	ldr	r3, [r7, #12]
34015f46:	2220      	movs	r2, #32
34015f48:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

        return HAL_TIMEOUT;
34015f4c:	2303      	movs	r3, #3
34015f4e:	e03d      	b.n	34015fcc <HAL_UART_Transmit+0x114>
      }
      if (pdata8bits == NULL)
34015f50:	69fb      	ldr	r3, [r7, #28]
34015f52:	2b00      	cmp	r3, #0
34015f54:	d10b      	bne.n	34015f6e <HAL_UART_Transmit+0xb6>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
34015f56:	69bb      	ldr	r3, [r7, #24]
34015f58:	881b      	ldrh	r3, [r3, #0]
34015f5a:	461a      	mov	r2, r3
34015f5c:	68fb      	ldr	r3, [r7, #12]
34015f5e:	681b      	ldr	r3, [r3, #0]
34015f60:	f3c2 0208 	ubfx	r2, r2, #0, #9
34015f64:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata16bits++;
34015f66:	69bb      	ldr	r3, [r7, #24]
34015f68:	3302      	adds	r3, #2
34015f6a:	61bb      	str	r3, [r7, #24]
34015f6c:	e007      	b.n	34015f7e <HAL_UART_Transmit+0xc6>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
34015f6e:	69fb      	ldr	r3, [r7, #28]
34015f70:	781a      	ldrb	r2, [r3, #0]
34015f72:	68fb      	ldr	r3, [r7, #12]
34015f74:	681b      	ldr	r3, [r3, #0]
34015f76:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata8bits++;
34015f78:	69fb      	ldr	r3, [r7, #28]
34015f7a:	3301      	adds	r3, #1
34015f7c:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
34015f7e:	68fb      	ldr	r3, [r7, #12]
34015f80:	f8b3 3056 	ldrh.w	r3, [r3, #86]	@ 0x56
34015f84:	b29b      	uxth	r3, r3
34015f86:	3b01      	subs	r3, #1
34015f88:	b29a      	uxth	r2, r3
34015f8a:	68fb      	ldr	r3, [r7, #12]
34015f8c:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56
    while (huart->TxXferCount > 0U)
34015f90:	68fb      	ldr	r3, [r7, #12]
34015f92:	f8b3 3056 	ldrh.w	r3, [r3, #86]	@ 0x56
34015f96:	b29b      	uxth	r3, r3
34015f98:	2b00      	cmp	r3, #0
34015f9a:	d1c8      	bne.n	34015f2e <HAL_UART_Transmit+0x76>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
34015f9c:	683b      	ldr	r3, [r7, #0]
34015f9e:	9300      	str	r3, [sp, #0]
34015fa0:	697b      	ldr	r3, [r7, #20]
34015fa2:	2200      	movs	r2, #0
34015fa4:	2140      	movs	r1, #64	@ 0x40
34015fa6:	68f8      	ldr	r0, [r7, #12]
34015fa8:	f000 fd54 	bl	34016a54 <UART_WaitOnFlagUntilTimeout>
34015fac:	4603      	mov	r3, r0
34015fae:	2b00      	cmp	r3, #0
34015fb0:	d005      	beq.n	34015fbe <HAL_UART_Transmit+0x106>
    {
      huart->gState = HAL_UART_STATE_READY;
34015fb2:	68fb      	ldr	r3, [r7, #12]
34015fb4:	2220      	movs	r2, #32
34015fb6:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

      return HAL_TIMEOUT;
34015fba:	2303      	movs	r3, #3
34015fbc:	e006      	b.n	34015fcc <HAL_UART_Transmit+0x114>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
34015fbe:	68fb      	ldr	r3, [r7, #12]
34015fc0:	2220      	movs	r2, #32
34015fc2:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

    return HAL_OK;
34015fc6:	2300      	movs	r3, #0
34015fc8:	e000      	b.n	34015fcc <HAL_UART_Transmit+0x114>
  }
  else
  {
    return HAL_BUSY;
34015fca:	2302      	movs	r3, #2
  }
}
34015fcc:	4618      	mov	r0, r3
34015fce:	3720      	adds	r7, #32
34015fd0:	46bd      	mov	sp, r7
34015fd2:	bd80      	pop	{r7, pc}

34015fd4 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
34015fd4:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
34015fd8:	b090      	sub	sp, #64	@ 0x40
34015fda:	af00      	add	r7, sp, #0
34015fdc:	6178      	str	r0, [r7, #20]
  uint32_t tmpreg;
  uint16_t brrtemp;
  uint64_t clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
34015fde:	2300      	movs	r3, #0
34015fe0:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  uint32_t lpuart_ker_ck_pres;
  uint32_t pclk;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
34015fe4:	697b      	ldr	r3, [r7, #20]
34015fe6:	685b      	ldr	r3, [r3, #4]
34015fe8:	4a19      	ldr	r2, [pc, #100]	@ (34016050 <UART_SetConfig+0x7c>)
34015fea:	4293      	cmp	r3, r2
34015fec:	d904      	bls.n	34015ff8 <UART_SetConfig+0x24>
34015fee:	f640 414f 	movw	r1, #3151	@ 0xc4f
34015ff2:	4818      	ldr	r0, [pc, #96]	@ (34016054 <UART_SetConfig+0x80>)
34015ff4:	f7ec f80c 	bl	34002010 <assert_failed>
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
34015ff8:	697b      	ldr	r3, [r7, #20]
34015ffa:	689b      	ldr	r3, [r3, #8]
34015ffc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34016000:	d00d      	beq.n	3401601e <UART_SetConfig+0x4a>
34016002:	697b      	ldr	r3, [r7, #20]
34016004:	689b      	ldr	r3, [r3, #8]
34016006:	2b00      	cmp	r3, #0
34016008:	d009      	beq.n	3401601e <UART_SetConfig+0x4a>
3401600a:	697b      	ldr	r3, [r7, #20]
3401600c:	689b      	ldr	r3, [r3, #8]
3401600e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34016012:	d004      	beq.n	3401601e <UART_SetConfig+0x4a>
34016014:	f44f 6145 	mov.w	r1, #3152	@ 0xc50
34016018:	480e      	ldr	r0, [pc, #56]	@ (34016054 <UART_SetConfig+0x80>)
3401601a:	f7eb fff9 	bl	34002010 <assert_failed>
  if (UART_INSTANCE_LOWPOWER(huart))
3401601e:	697b      	ldr	r3, [r7, #20]
34016020:	681b      	ldr	r3, [r3, #0]
34016022:	4a0d      	ldr	r2, [pc, #52]	@ (34016058 <UART_SetConfig+0x84>)
34016024:	4293      	cmp	r3, r2
34016026:	d004      	beq.n	34016032 <UART_SetConfig+0x5e>
34016028:	697b      	ldr	r3, [r7, #20]
3401602a:	681b      	ldr	r3, [r3, #0]
3401602c:	4a0b      	ldr	r2, [pc, #44]	@ (3401605c <UART_SetConfig+0x88>)
3401602e:	4293      	cmp	r3, r2
34016030:	d116      	bne.n	34016060 <UART_SetConfig+0x8c>
  {
    assert_param(IS_LPUART_STOPBITS(huart->Init.StopBits));
34016032:	697b      	ldr	r3, [r7, #20]
34016034:	68db      	ldr	r3, [r3, #12]
34016036:	2b00      	cmp	r3, #0
34016038:	d038      	beq.n	340160ac <UART_SetConfig+0xd8>
3401603a:	697b      	ldr	r3, [r7, #20]
3401603c:	68db      	ldr	r3, [r3, #12]
3401603e:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34016042:	d033      	beq.n	340160ac <UART_SetConfig+0xd8>
34016044:	f640 4153 	movw	r1, #3155	@ 0xc53
34016048:	4802      	ldr	r0, [pc, #8]	@ (34016054 <UART_SetConfig+0x80>)
3401604a:	f7eb ffe1 	bl	34002010 <assert_failed>
3401604e:	e02d      	b.n	340160ac <UART_SetConfig+0xd8>
34016050:	00bebc1f 	.word	0x00bebc1f
34016054:	3401f05c 	.word	0x3401f05c
34016058:	56000c00 	.word	0x56000c00
3401605c:	46000c00 	.word	0x46000c00
  }
  else
  {
    assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
34016060:	697b      	ldr	r3, [r7, #20]
34016062:	68db      	ldr	r3, [r3, #12]
34016064:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34016068:	d012      	beq.n	34016090 <UART_SetConfig+0xbc>
3401606a:	697b      	ldr	r3, [r7, #20]
3401606c:	68db      	ldr	r3, [r3, #12]
3401606e:	2b00      	cmp	r3, #0
34016070:	d00e      	beq.n	34016090 <UART_SetConfig+0xbc>
34016072:	697b      	ldr	r3, [r7, #20]
34016074:	68db      	ldr	r3, [r3, #12]
34016076:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
3401607a:	d009      	beq.n	34016090 <UART_SetConfig+0xbc>
3401607c:	697b      	ldr	r3, [r7, #20]
3401607e:	68db      	ldr	r3, [r3, #12]
34016080:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34016084:	d004      	beq.n	34016090 <UART_SetConfig+0xbc>
34016086:	f640 4157 	movw	r1, #3159	@ 0xc57
3401608a:	4896      	ldr	r0, [pc, #600]	@ (340162e4 <UART_SetConfig+0x310>)
3401608c:	f7eb ffc0 	bl	34002010 <assert_failed>
    assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
34016090:	697b      	ldr	r3, [r7, #20]
34016092:	6a1b      	ldr	r3, [r3, #32]
34016094:	2b00      	cmp	r3, #0
34016096:	d009      	beq.n	340160ac <UART_SetConfig+0xd8>
34016098:	697b      	ldr	r3, [r7, #20]
3401609a:	6a1b      	ldr	r3, [r3, #32]
3401609c:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
340160a0:	d004      	beq.n	340160ac <UART_SetConfig+0xd8>
340160a2:	f640 4158 	movw	r1, #3160	@ 0xc58
340160a6:	488f      	ldr	r0, [pc, #572]	@ (340162e4 <UART_SetConfig+0x310>)
340160a8:	f7eb ffb2 	bl	34002010 <assert_failed>
  }

  assert_param(IS_UART_PARITY(huart->Init.Parity));
340160ac:	697b      	ldr	r3, [r7, #20]
340160ae:	691b      	ldr	r3, [r3, #16]
340160b0:	2b00      	cmp	r3, #0
340160b2:	d00e      	beq.n	340160d2 <UART_SetConfig+0xfe>
340160b4:	697b      	ldr	r3, [r7, #20]
340160b6:	691b      	ldr	r3, [r3, #16]
340160b8:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
340160bc:	d009      	beq.n	340160d2 <UART_SetConfig+0xfe>
340160be:	697b      	ldr	r3, [r7, #20]
340160c0:	691b      	ldr	r3, [r3, #16]
340160c2:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
340160c6:	d004      	beq.n	340160d2 <UART_SetConfig+0xfe>
340160c8:	f640 415b 	movw	r1, #3163	@ 0xc5b
340160cc:	4885      	ldr	r0, [pc, #532]	@ (340162e4 <UART_SetConfig+0x310>)
340160ce:	f7eb ff9f 	bl	34002010 <assert_failed>
  assert_param(IS_UART_MODE(huart->Init.Mode));
340160d2:	697b      	ldr	r3, [r7, #20]
340160d4:	695b      	ldr	r3, [r3, #20]
340160d6:	f023 030c 	bic.w	r3, r3, #12
340160da:	2b00      	cmp	r3, #0
340160dc:	d103      	bne.n	340160e6 <UART_SetConfig+0x112>
340160de:	697b      	ldr	r3, [r7, #20]
340160e0:	695b      	ldr	r3, [r3, #20]
340160e2:	2b00      	cmp	r3, #0
340160e4:	d104      	bne.n	340160f0 <UART_SetConfig+0x11c>
340160e6:	f640 415c 	movw	r1, #3164	@ 0xc5c
340160ea:	487e      	ldr	r0, [pc, #504]	@ (340162e4 <UART_SetConfig+0x310>)
340160ec:	f7eb ff90 	bl	34002010 <assert_failed>
  assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
340160f0:	697b      	ldr	r3, [r7, #20]
340160f2:	699b      	ldr	r3, [r3, #24]
340160f4:	2b00      	cmp	r3, #0
340160f6:	d013      	beq.n	34016120 <UART_SetConfig+0x14c>
340160f8:	697b      	ldr	r3, [r7, #20]
340160fa:	699b      	ldr	r3, [r3, #24]
340160fc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34016100:	d00e      	beq.n	34016120 <UART_SetConfig+0x14c>
34016102:	697b      	ldr	r3, [r7, #20]
34016104:	699b      	ldr	r3, [r3, #24]
34016106:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3401610a:	d009      	beq.n	34016120 <UART_SetConfig+0x14c>
3401610c:	697b      	ldr	r3, [r7, #20]
3401610e:	699b      	ldr	r3, [r3, #24]
34016110:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34016114:	d004      	beq.n	34016120 <UART_SetConfig+0x14c>
34016116:	f640 415d 	movw	r1, #3165	@ 0xc5d
3401611a:	4872      	ldr	r0, [pc, #456]	@ (340162e4 <UART_SetConfig+0x310>)
3401611c:	f7eb ff78 	bl	34002010 <assert_failed>
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
34016120:	697b      	ldr	r3, [r7, #20]
34016122:	69db      	ldr	r3, [r3, #28]
34016124:	2b00      	cmp	r3, #0
34016126:	d009      	beq.n	3401613c <UART_SetConfig+0x168>
34016128:	697b      	ldr	r3, [r7, #20]
3401612a:	69db      	ldr	r3, [r3, #28]
3401612c:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
34016130:	d004      	beq.n	3401613c <UART_SetConfig+0x168>
34016132:	f640 415e 	movw	r1, #3166	@ 0xc5e
34016136:	486b      	ldr	r0, [pc, #428]	@ (340162e4 <UART_SetConfig+0x310>)
34016138:	f7eb ff6a 	bl	34002010 <assert_failed>
  assert_param(IS_UART_PRESCALER(huart->Init.ClockPrescaler));
3401613c:	697b      	ldr	r3, [r7, #20]
3401613e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34016140:	2b00      	cmp	r3, #0
34016142:	d030      	beq.n	340161a6 <UART_SetConfig+0x1d2>
34016144:	697b      	ldr	r3, [r7, #20]
34016146:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34016148:	2b01      	cmp	r3, #1
3401614a:	d02c      	beq.n	340161a6 <UART_SetConfig+0x1d2>
3401614c:	697b      	ldr	r3, [r7, #20]
3401614e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34016150:	2b02      	cmp	r3, #2
34016152:	d028      	beq.n	340161a6 <UART_SetConfig+0x1d2>
34016154:	697b      	ldr	r3, [r7, #20]
34016156:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34016158:	2b03      	cmp	r3, #3
3401615a:	d024      	beq.n	340161a6 <UART_SetConfig+0x1d2>
3401615c:	697b      	ldr	r3, [r7, #20]
3401615e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34016160:	2b04      	cmp	r3, #4
34016162:	d020      	beq.n	340161a6 <UART_SetConfig+0x1d2>
34016164:	697b      	ldr	r3, [r7, #20]
34016166:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34016168:	2b05      	cmp	r3, #5
3401616a:	d01c      	beq.n	340161a6 <UART_SetConfig+0x1d2>
3401616c:	697b      	ldr	r3, [r7, #20]
3401616e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34016170:	2b06      	cmp	r3, #6
34016172:	d018      	beq.n	340161a6 <UART_SetConfig+0x1d2>
34016174:	697b      	ldr	r3, [r7, #20]
34016176:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34016178:	2b07      	cmp	r3, #7
3401617a:	d014      	beq.n	340161a6 <UART_SetConfig+0x1d2>
3401617c:	697b      	ldr	r3, [r7, #20]
3401617e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34016180:	2b08      	cmp	r3, #8
34016182:	d010      	beq.n	340161a6 <UART_SetConfig+0x1d2>
34016184:	697b      	ldr	r3, [r7, #20]
34016186:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34016188:	2b09      	cmp	r3, #9
3401618a:	d00c      	beq.n	340161a6 <UART_SetConfig+0x1d2>
3401618c:	697b      	ldr	r3, [r7, #20]
3401618e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34016190:	2b0a      	cmp	r3, #10
34016192:	d008      	beq.n	340161a6 <UART_SetConfig+0x1d2>
34016194:	697b      	ldr	r3, [r7, #20]
34016196:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34016198:	2b0b      	cmp	r3, #11
3401619a:	d004      	beq.n	340161a6 <UART_SetConfig+0x1d2>
3401619c:	f640 415f 	movw	r1, #3167	@ 0xc5f
340161a0:	4850      	ldr	r0, [pc, #320]	@ (340162e4 <UART_SetConfig+0x310>)
340161a2:	f7eb ff35 	bl	34002010 <assert_failed>
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
340161a6:	697b      	ldr	r3, [r7, #20]
340161a8:	689a      	ldr	r2, [r3, #8]
340161aa:	697b      	ldr	r3, [r7, #20]
340161ac:	691b      	ldr	r3, [r3, #16]
340161ae:	431a      	orrs	r2, r3
340161b0:	697b      	ldr	r3, [r7, #20]
340161b2:	695b      	ldr	r3, [r3, #20]
340161b4:	431a      	orrs	r2, r3
340161b6:	697b      	ldr	r3, [r7, #20]
340161b8:	69db      	ldr	r3, [r3, #28]
340161ba:	4313      	orrs	r3, r2
340161bc:	63fb      	str	r3, [r7, #60]	@ 0x3c
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
340161be:	697b      	ldr	r3, [r7, #20]
340161c0:	681b      	ldr	r3, [r3, #0]
340161c2:	681a      	ldr	r2, [r3, #0]
340161c4:	4b48      	ldr	r3, [pc, #288]	@ (340162e8 <UART_SetConfig+0x314>)
340161c6:	4013      	ands	r3, r2
340161c8:	697a      	ldr	r2, [r7, #20]
340161ca:	6812      	ldr	r2, [r2, #0]
340161cc:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
340161ce:	430b      	orrs	r3, r1
340161d0:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
340161d2:	697b      	ldr	r3, [r7, #20]
340161d4:	681b      	ldr	r3, [r3, #0]
340161d6:	685b      	ldr	r3, [r3, #4]
340161d8:	f423 5140 	bic.w	r1, r3, #12288	@ 0x3000
340161dc:	697b      	ldr	r3, [r7, #20]
340161de:	68da      	ldr	r2, [r3, #12]
340161e0:	697b      	ldr	r3, [r7, #20]
340161e2:	681b      	ldr	r3, [r3, #0]
340161e4:	430a      	orrs	r2, r1
340161e6:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
340161e8:	697b      	ldr	r3, [r7, #20]
340161ea:	699b      	ldr	r3, [r3, #24]
340161ec:	63fb      	str	r3, [r7, #60]	@ 0x3c

  if (!(UART_INSTANCE_LOWPOWER(huart)))
340161ee:	697b      	ldr	r3, [r7, #20]
340161f0:	681b      	ldr	r3, [r3, #0]
340161f2:	4a3e      	ldr	r2, [pc, #248]	@ (340162ec <UART_SetConfig+0x318>)
340161f4:	4293      	cmp	r3, r2
340161f6:	d009      	beq.n	3401620c <UART_SetConfig+0x238>
340161f8:	697b      	ldr	r3, [r7, #20]
340161fa:	681b      	ldr	r3, [r3, #0]
340161fc:	4a3c      	ldr	r2, [pc, #240]	@ (340162f0 <UART_SetConfig+0x31c>)
340161fe:	4293      	cmp	r3, r2
34016200:	d004      	beq.n	3401620c <UART_SetConfig+0x238>
  {
    tmpreg |= huart->Init.OneBitSampling;
34016202:	697b      	ldr	r3, [r7, #20]
34016204:	6a1b      	ldr	r3, [r3, #32]
34016206:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34016208:	4313      	orrs	r3, r2
3401620a:	63fb      	str	r3, [r7, #60]	@ 0x3c
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
3401620c:	697b      	ldr	r3, [r7, #20]
3401620e:	681b      	ldr	r3, [r3, #0]
34016210:	689b      	ldr	r3, [r3, #8]
34016212:	f023 436e 	bic.w	r3, r3, #3992977408	@ 0xee000000
34016216:	f423 6330 	bic.w	r3, r3, #2816	@ 0xb00
3401621a:	697a      	ldr	r2, [r7, #20]
3401621c:	6812      	ldr	r2, [r2, #0]
3401621e:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
34016220:	430b      	orrs	r3, r1
34016222:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
34016224:	697b      	ldr	r3, [r7, #20]
34016226:	681b      	ldr	r3, [r3, #0]
34016228:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401622a:	f023 010f 	bic.w	r1, r3, #15
3401622e:	697b      	ldr	r3, [r7, #20]
34016230:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
34016232:	697b      	ldr	r3, [r7, #20]
34016234:	681b      	ldr	r3, [r3, #0]
34016236:	430a      	orrs	r2, r1
34016238:	62da      	str	r2, [r3, #44]	@ 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
3401623a:	697b      	ldr	r3, [r7, #20]
3401623c:	681b      	ldr	r3, [r3, #0]
3401623e:	4a2d      	ldr	r2, [pc, #180]	@ (340162f4 <UART_SetConfig+0x320>)
34016240:	4293      	cmp	r3, r2
34016242:	d106      	bne.n	34016252 <UART_SetConfig+0x27e>
34016244:	f04f 0200 	mov.w	r2, #0
34016248:	f44f 7380 	mov.w	r3, #256	@ 0x100
3401624c:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
34016250:	e092      	b.n	34016378 <UART_SetConfig+0x3a4>
34016252:	697b      	ldr	r3, [r7, #20]
34016254:	681b      	ldr	r3, [r3, #0]
34016256:	4a28      	ldr	r2, [pc, #160]	@ (340162f8 <UART_SetConfig+0x324>)
34016258:	4293      	cmp	r3, r2
3401625a:	d106      	bne.n	3401626a <UART_SetConfig+0x296>
3401625c:	f04f 0200 	mov.w	r2, #0
34016260:	f44f 7300 	mov.w	r3, #512	@ 0x200
34016264:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
34016268:	e086      	b.n	34016378 <UART_SetConfig+0x3a4>
3401626a:	697b      	ldr	r3, [r7, #20]
3401626c:	681b      	ldr	r3, [r3, #0]
3401626e:	4a23      	ldr	r2, [pc, #140]	@ (340162fc <UART_SetConfig+0x328>)
34016270:	4293      	cmp	r3, r2
34016272:	d106      	bne.n	34016282 <UART_SetConfig+0x2ae>
34016274:	f04f 0200 	mov.w	r2, #0
34016278:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3401627c:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
34016280:	e07a      	b.n	34016378 <UART_SetConfig+0x3a4>
34016282:	697b      	ldr	r3, [r7, #20]
34016284:	681b      	ldr	r3, [r3, #0]
34016286:	4a1e      	ldr	r2, [pc, #120]	@ (34016300 <UART_SetConfig+0x32c>)
34016288:	4293      	cmp	r3, r2
3401628a:	d106      	bne.n	3401629a <UART_SetConfig+0x2c6>
3401628c:	f04f 0200 	mov.w	r2, #0
34016290:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34016294:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
34016298:	e06e      	b.n	34016378 <UART_SetConfig+0x3a4>
3401629a:	697b      	ldr	r3, [r7, #20]
3401629c:	681b      	ldr	r3, [r3, #0]
3401629e:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
340162a2:	d106      	bne.n	340162b2 <UART_SetConfig+0x2de>
340162a4:	f04f 0200 	mov.w	r2, #0
340162a8:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
340162ac:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
340162b0:	e062      	b.n	34016378 <UART_SetConfig+0x3a4>
340162b2:	697b      	ldr	r3, [r7, #20]
340162b4:	681b      	ldr	r3, [r3, #0]
340162b6:	4a13      	ldr	r2, [pc, #76]	@ (34016304 <UART_SetConfig+0x330>)
340162b8:	4293      	cmp	r3, r2
340162ba:	d106      	bne.n	340162ca <UART_SetConfig+0x2f6>
340162bc:	f04f 0200 	mov.w	r2, #0
340162c0:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
340162c4:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
340162c8:	e056      	b.n	34016378 <UART_SetConfig+0x3a4>
340162ca:	697b      	ldr	r3, [r7, #20]
340162cc:	681b      	ldr	r3, [r3, #0]
340162ce:	4a0e      	ldr	r2, [pc, #56]	@ (34016308 <UART_SetConfig+0x334>)
340162d0:	4293      	cmp	r3, r2
340162d2:	d11b      	bne.n	3401630c <UART_SetConfig+0x338>
340162d4:	f04f 0200 	mov.w	r2, #0
340162d8:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
340162dc:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
340162e0:	e04a      	b.n	34016378 <UART_SetConfig+0x3a4>
340162e2:	bf00      	nop
340162e4:	3401f05c 	.word	0x3401f05c
340162e8:	cfff69f3 	.word	0xcfff69f3
340162ec:	56000c00 	.word	0x56000c00
340162f0:	46000c00 	.word	0x46000c00
340162f4:	52001000 	.word	0x52001000
340162f8:	50004400 	.word	0x50004400
340162fc:	50004800 	.word	0x50004800
34016300:	50004c00 	.word	0x50004c00
34016304:	52001400 	.word	0x52001400
34016308:	50007800 	.word	0x50007800
3401630c:	697b      	ldr	r3, [r7, #20]
3401630e:	681b      	ldr	r3, [r3, #0]
34016310:	4a90      	ldr	r2, [pc, #576]	@ (34016554 <UART_SetConfig+0x580>)
34016312:	4293      	cmp	r3, r2
34016314:	d106      	bne.n	34016324 <UART_SetConfig+0x350>
34016316:	f04f 0200 	mov.w	r2, #0
3401631a:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
3401631e:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
34016322:	e029      	b.n	34016378 <UART_SetConfig+0x3a4>
34016324:	697b      	ldr	r3, [r7, #20]
34016326:	681b      	ldr	r3, [r3, #0]
34016328:	4a8b      	ldr	r2, [pc, #556]	@ (34016558 <UART_SetConfig+0x584>)
3401632a:	4293      	cmp	r3, r2
3401632c:	d106      	bne.n	3401633c <UART_SetConfig+0x368>
3401632e:	f04f 0200 	mov.w	r2, #0
34016332:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
34016336:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3401633a:	e01d      	b.n	34016378 <UART_SetConfig+0x3a4>
3401633c:	697b      	ldr	r3, [r7, #20]
3401633e:	681b      	ldr	r3, [r3, #0]
34016340:	4a86      	ldr	r2, [pc, #536]	@ (3401655c <UART_SetConfig+0x588>)
34016342:	4293      	cmp	r3, r2
34016344:	d106      	bne.n	34016354 <UART_SetConfig+0x380>
34016346:	f04f 0200 	mov.w	r2, #0
3401634a:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
3401634e:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
34016352:	e011      	b.n	34016378 <UART_SetConfig+0x3a4>
34016354:	697b      	ldr	r3, [r7, #20]
34016356:	681b      	ldr	r3, [r3, #0]
34016358:	4a81      	ldr	r2, [pc, #516]	@ (34016560 <UART_SetConfig+0x58c>)
3401635a:	4293      	cmp	r3, r2
3401635c:	d106      	bne.n	3401636c <UART_SetConfig+0x398>
3401635e:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
34016362:	f04f 0300 	mov.w	r3, #0
34016366:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3401636a:	e005      	b.n	34016378 <UART_SetConfig+0x3a4>
3401636c:	f04f 0200 	mov.w	r2, #0
34016370:	f04f 0300 	mov.w	r3, #0
34016374:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
34016378:	697b      	ldr	r3, [r7, #20]
3401637a:	681b      	ldr	r3, [r3, #0]
3401637c:	4a78      	ldr	r2, [pc, #480]	@ (34016560 <UART_SetConfig+0x58c>)
3401637e:	4293      	cmp	r3, r2
34016380:	d004      	beq.n	3401638c <UART_SetConfig+0x3b8>
34016382:	697b      	ldr	r3, [r7, #20]
34016384:	681b      	ldr	r3, [r3, #0]
34016386:	4a77      	ldr	r2, [pc, #476]	@ (34016564 <UART_SetConfig+0x590>)
34016388:	4293      	cmp	r3, r2
3401638a:	d166      	bne.n	3401645a <UART_SetConfig+0x486>
  {
    /* Retrieve frequency clock */
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
3401638c:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
34016390:	f7fa f934 	bl	340105fc <HAL_RCCEx_GetPeriphCLKFreq>
34016394:	62b8      	str	r0, [r7, #40]	@ 0x28

    /* If proper clock source reported */
    if (pclk != 0U)
34016396:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34016398:	2b00      	cmp	r3, #0
3401639a:	f000 80c6 	beq.w	3401652a <UART_SetConfig+0x556>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
3401639e:	697b      	ldr	r3, [r7, #20]
340163a0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340163a2:	4a71      	ldr	r2, [pc, #452]	@ (34016568 <UART_SetConfig+0x594>)
340163a4:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
340163a8:	461a      	mov	r2, r3
340163aa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340163ac:	fbb3 f3f2 	udiv	r3, r3, r2
340163b0:	61fb      	str	r3, [r7, #28]

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
340163b2:	697b      	ldr	r3, [r7, #20]
340163b4:	685a      	ldr	r2, [r3, #4]
340163b6:	4613      	mov	r3, r2
340163b8:	005b      	lsls	r3, r3, #1
340163ba:	4413      	add	r3, r2
340163bc:	69fa      	ldr	r2, [r7, #28]
340163be:	429a      	cmp	r2, r3
340163c0:	d305      	bcc.n	340163ce <UART_SetConfig+0x3fa>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
340163c2:	697b      	ldr	r3, [r7, #20]
340163c4:	685b      	ldr	r3, [r3, #4]
340163c6:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
340163c8:	69fa      	ldr	r2, [r7, #28]
340163ca:	429a      	cmp	r2, r3
340163cc:	d903      	bls.n	340163d6 <UART_SetConfig+0x402>
      {
        ret = HAL_ERROR;
340163ce:	2301      	movs	r3, #1
340163d0:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
340163d4:	e040      	b.n	34016458 <UART_SetConfig+0x484>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
340163d6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340163d8:	2200      	movs	r2, #0
340163da:	60bb      	str	r3, [r7, #8]
340163dc:	60fa      	str	r2, [r7, #12]
340163de:	697b      	ldr	r3, [r7, #20]
340163e0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340163e2:	4a61      	ldr	r2, [pc, #388]	@ (34016568 <UART_SetConfig+0x594>)
340163e4:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
340163e8:	b29b      	uxth	r3, r3
340163ea:	2200      	movs	r2, #0
340163ec:	603b      	str	r3, [r7, #0]
340163ee:	607a      	str	r2, [r7, #4]
340163f0:	e9d7 2300 	ldrd	r2, r3, [r7]
340163f4:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
340163f8:	f7ea f9d2 	bl	340007a0 <__aeabi_uldivmod>
340163fc:	4602      	mov	r2, r0
340163fe:	460b      	mov	r3, r1
34016400:	ea52 230f 	orrs.w	r3, r2, pc, lsl #8
34016404:	6979      	ldr	r1, [r7, #20]
34016406:	6849      	ldr	r1, [r1, #4]
34016408:	0849      	lsrs	r1, r1, #1
3401640a:	2000      	movs	r0, #0
3401640c:	460c      	mov	r4, r1
3401640e:	4605      	mov	r5, r0
34016410:	eb12 0804 	adds.w	r8, r2, r4
34016414:	eb43 0905 	adc.w	r9, r3, r5
34016418:	697b      	ldr	r3, [r7, #20]
3401641a:	685b      	ldr	r3, [r3, #4]
3401641c:	2200      	movs	r2, #0
3401641e:	469a      	mov	sl, r3
34016420:	4693      	mov	fp, r2
34016422:	4652      	mov	r2, sl
34016424:	465b      	mov	r3, fp
34016426:	4640      	mov	r0, r8
34016428:	4649      	mov	r1, r9
3401642a:	f7ea f9b9 	bl	340007a0 <__aeabi_uldivmod>
3401642e:	4602      	mov	r2, r0
34016430:	460b      	mov	r3, r1
34016432:	4613      	mov	r3, r2
34016434:	627b      	str	r3, [r7, #36]	@ 0x24
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
34016436:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34016438:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3401643c:	d308      	bcc.n	34016450 <UART_SetConfig+0x47c>
3401643e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34016440:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34016444:	d204      	bcs.n	34016450 <UART_SetConfig+0x47c>
        {
          huart->Instance->BRR = usartdiv;
34016446:	697b      	ldr	r3, [r7, #20]
34016448:	681b      	ldr	r3, [r3, #0]
3401644a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3401644c:	60da      	str	r2, [r3, #12]
3401644e:	e003      	b.n	34016458 <UART_SetConfig+0x484>
        }
        else
        {
          ret = HAL_ERROR;
34016450:	2301      	movs	r3, #1
34016452:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    if (pclk != 0U)
34016456:	e068      	b.n	3401652a <UART_SetConfig+0x556>
34016458:	e067      	b.n	3401652a <UART_SetConfig+0x556>
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
3401645a:	697b      	ldr	r3, [r7, #20]
3401645c:	69db      	ldr	r3, [r3, #28]
3401645e:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
34016462:	d138      	bne.n	340164d6 <UART_SetConfig+0x502>
  {
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
34016464:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
34016468:	f7fa f8c8 	bl	340105fc <HAL_RCCEx_GetPeriphCLKFreq>
3401646c:	62b8      	str	r0, [r7, #40]	@ 0x28

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
3401646e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34016470:	2b00      	cmp	r3, #0
34016472:	d05a      	beq.n	3401652a <UART_SetConfig+0x556>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
34016474:	697b      	ldr	r3, [r7, #20]
34016476:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34016478:	4a3b      	ldr	r2, [pc, #236]	@ (34016568 <UART_SetConfig+0x594>)
3401647a:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
3401647e:	461a      	mov	r2, r3
34016480:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34016482:	fbb3 f3f2 	udiv	r3, r3, r2
34016486:	005a      	lsls	r2, r3, #1
34016488:	697b      	ldr	r3, [r7, #20]
3401648a:	685b      	ldr	r3, [r3, #4]
3401648c:	085b      	lsrs	r3, r3, #1
3401648e:	441a      	add	r2, r3
34016490:	697b      	ldr	r3, [r7, #20]
34016492:	685b      	ldr	r3, [r3, #4]
34016494:	fbb2 f3f3 	udiv	r3, r2, r3
34016498:	627b      	str	r3, [r7, #36]	@ 0x24
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
3401649a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401649c:	2b0f      	cmp	r3, #15
3401649e:	d916      	bls.n	340164ce <UART_SetConfig+0x4fa>
340164a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340164a2:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
340164a6:	d212      	bcs.n	340164ce <UART_SetConfig+0x4fa>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
340164a8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340164aa:	b29b      	uxth	r3, r3
340164ac:	f023 030f 	bic.w	r3, r3, #15
340164b0:	847b      	strh	r3, [r7, #34]	@ 0x22
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
340164b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340164b4:	085b      	lsrs	r3, r3, #1
340164b6:	b29b      	uxth	r3, r3
340164b8:	f003 0307 	and.w	r3, r3, #7
340164bc:	b29a      	uxth	r2, r3
340164be:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
340164c0:	4313      	orrs	r3, r2
340164c2:	847b      	strh	r3, [r7, #34]	@ 0x22
        huart->Instance->BRR = brrtemp;
340164c4:	697b      	ldr	r3, [r7, #20]
340164c6:	681b      	ldr	r3, [r3, #0]
340164c8:	8c7a      	ldrh	r2, [r7, #34]	@ 0x22
340164ca:	60da      	str	r2, [r3, #12]
340164cc:	e02d      	b.n	3401652a <UART_SetConfig+0x556>
      }
      else
      {
        ret = HAL_ERROR;
340164ce:	2301      	movs	r3, #1
340164d0:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
340164d4:	e029      	b.n	3401652a <UART_SetConfig+0x556>
      }
    }
  }
  else
  {
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
340164d6:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
340164da:	f7fa f88f 	bl	340105fc <HAL_RCCEx_GetPeriphCLKFreq>
340164de:	62b8      	str	r0, [r7, #40]	@ 0x28

    if (pclk != 0U)
340164e0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340164e2:	2b00      	cmp	r3, #0
340164e4:	d021      	beq.n	3401652a <UART_SetConfig+0x556>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
340164e6:	697b      	ldr	r3, [r7, #20]
340164e8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340164ea:	4a1f      	ldr	r2, [pc, #124]	@ (34016568 <UART_SetConfig+0x594>)
340164ec:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
340164f0:	461a      	mov	r2, r3
340164f2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340164f4:	fbb3 f2f2 	udiv	r2, r3, r2
340164f8:	697b      	ldr	r3, [r7, #20]
340164fa:	685b      	ldr	r3, [r3, #4]
340164fc:	085b      	lsrs	r3, r3, #1
340164fe:	441a      	add	r2, r3
34016500:	697b      	ldr	r3, [r7, #20]
34016502:	685b      	ldr	r3, [r3, #4]
34016504:	fbb2 f3f3 	udiv	r3, r2, r3
34016508:	627b      	str	r3, [r7, #36]	@ 0x24
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
3401650a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401650c:	2b0f      	cmp	r3, #15
3401650e:	d909      	bls.n	34016524 <UART_SetConfig+0x550>
34016510:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34016512:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34016516:	d205      	bcs.n	34016524 <UART_SetConfig+0x550>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
34016518:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401651a:	b29a      	uxth	r2, r3
3401651c:	697b      	ldr	r3, [r7, #20]
3401651e:	681b      	ldr	r3, [r3, #0]
34016520:	60da      	str	r2, [r3, #12]
34016522:	e002      	b.n	3401652a <UART_SetConfig+0x556>
      }
      else
      {
        ret = HAL_ERROR;
34016524:	2301      	movs	r3, #1
34016526:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
3401652a:	697b      	ldr	r3, [r7, #20]
3401652c:	2201      	movs	r2, #1
3401652e:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
  huart->NbRxDataToProcess = 1;
34016532:	697b      	ldr	r3, [r7, #20]
34016534:	2201      	movs	r2, #1
34016536:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
3401653a:	697b      	ldr	r3, [r7, #20]
3401653c:	2200      	movs	r2, #0
3401653e:	675a      	str	r2, [r3, #116]	@ 0x74
  huart->TxISR = NULL;
34016540:	697b      	ldr	r3, [r7, #20]
34016542:	2200      	movs	r2, #0
34016544:	679a      	str	r2, [r3, #120]	@ 0x78

  return ret;
34016546:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
}
3401654a:	4618      	mov	r0, r3
3401654c:	3740      	adds	r7, #64	@ 0x40
3401654e:	46bd      	mov	sp, r7
34016550:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
34016554:	50007c00 	.word	0x50007c00
34016558:	52001800 	.word	0x52001800
3401655c:	52001c00 	.word	0x52001c00
34016560:	56000c00 	.word	0x56000c00
34016564:	46000c00 	.word	0x46000c00
34016568:	3401ff9c 	.word	0x3401ff9c

3401656c <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
3401656c:	b580      	push	{r7, lr}
3401656e:	b082      	sub	sp, #8
34016570:	af00      	add	r7, sp, #0
34016572:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
34016574:	687b      	ldr	r3, [r7, #4]
34016576:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34016578:	2bff      	cmp	r3, #255	@ 0xff
3401657a:	d904      	bls.n	34016586 <UART_AdvFeatureConfig+0x1a>
3401657c:	f640 41e4 	movw	r1, #3300	@ 0xce4
34016580:	4890      	ldr	r0, [pc, #576]	@ (340167c4 <UART_AdvFeatureConfig+0x258>)
34016582:	f7eb fd45 	bl	34002010 <assert_failed>

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
34016586:	687b      	ldr	r3, [r7, #4]
34016588:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401658a:	f003 0308 	and.w	r3, r3, #8
3401658e:	2b00      	cmp	r3, #0
34016590:	d018      	beq.n	340165c4 <UART_AdvFeatureConfig+0x58>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
34016592:	687b      	ldr	r3, [r7, #4]
34016594:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34016596:	2b00      	cmp	r3, #0
34016598:	d009      	beq.n	340165ae <UART_AdvFeatureConfig+0x42>
3401659a:	687b      	ldr	r3, [r7, #4]
3401659c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401659e:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
340165a2:	d004      	beq.n	340165ae <UART_AdvFeatureConfig+0x42>
340165a4:	f640 41e9 	movw	r1, #3305	@ 0xce9
340165a8:	4886      	ldr	r0, [pc, #536]	@ (340167c4 <UART_AdvFeatureConfig+0x258>)
340165aa:	f7eb fd31 	bl	34002010 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
340165ae:	687b      	ldr	r3, [r7, #4]
340165b0:	681b      	ldr	r3, [r3, #0]
340165b2:	685b      	ldr	r3, [r3, #4]
340165b4:	f423 4100 	bic.w	r1, r3, #32768	@ 0x8000
340165b8:	687b      	ldr	r3, [r7, #4]
340165ba:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
340165bc:	687b      	ldr	r3, [r7, #4]
340165be:	681b      	ldr	r3, [r3, #0]
340165c0:	430a      	orrs	r2, r1
340165c2:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
340165c4:	687b      	ldr	r3, [r7, #4]
340165c6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
340165c8:	f003 0301 	and.w	r3, r3, #1
340165cc:	2b00      	cmp	r3, #0
340165ce:	d018      	beq.n	34016602 <UART_AdvFeatureConfig+0x96>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
340165d0:	687b      	ldr	r3, [r7, #4]
340165d2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340165d4:	2b00      	cmp	r3, #0
340165d6:	d009      	beq.n	340165ec <UART_AdvFeatureConfig+0x80>
340165d8:	687b      	ldr	r3, [r7, #4]
340165da:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340165dc:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
340165e0:	d004      	beq.n	340165ec <UART_AdvFeatureConfig+0x80>
340165e2:	f44f 614f 	mov.w	r1, #3312	@ 0xcf0
340165e6:	4877      	ldr	r0, [pc, #476]	@ (340167c4 <UART_AdvFeatureConfig+0x258>)
340165e8:	f7eb fd12 	bl	34002010 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
340165ec:	687b      	ldr	r3, [r7, #4]
340165ee:	681b      	ldr	r3, [r3, #0]
340165f0:	685b      	ldr	r3, [r3, #4]
340165f2:	f423 3100 	bic.w	r1, r3, #131072	@ 0x20000
340165f6:	687b      	ldr	r3, [r7, #4]
340165f8:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
340165fa:	687b      	ldr	r3, [r7, #4]
340165fc:	681b      	ldr	r3, [r3, #0]
340165fe:	430a      	orrs	r2, r1
34016600:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
34016602:	687b      	ldr	r3, [r7, #4]
34016604:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34016606:	f003 0302 	and.w	r3, r3, #2
3401660a:	2b00      	cmp	r3, #0
3401660c:	d018      	beq.n	34016640 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
3401660e:	687b      	ldr	r3, [r7, #4]
34016610:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016612:	2b00      	cmp	r3, #0
34016614:	d009      	beq.n	3401662a <UART_AdvFeatureConfig+0xbe>
34016616:	687b      	ldr	r3, [r7, #4]
34016618:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401661a:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3401661e:	d004      	beq.n	3401662a <UART_AdvFeatureConfig+0xbe>
34016620:	f640 41f7 	movw	r1, #3319	@ 0xcf7
34016624:	4867      	ldr	r0, [pc, #412]	@ (340167c4 <UART_AdvFeatureConfig+0x258>)
34016626:	f7eb fcf3 	bl	34002010 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
3401662a:	687b      	ldr	r3, [r7, #4]
3401662c:	681b      	ldr	r3, [r3, #0]
3401662e:	685b      	ldr	r3, [r3, #4]
34016630:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
34016634:	687b      	ldr	r3, [r7, #4]
34016636:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
34016638:	687b      	ldr	r3, [r7, #4]
3401663a:	681b      	ldr	r3, [r3, #0]
3401663c:	430a      	orrs	r2, r1
3401663e:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
34016640:	687b      	ldr	r3, [r7, #4]
34016642:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34016644:	f003 0304 	and.w	r3, r3, #4
34016648:	2b00      	cmp	r3, #0
3401664a:	d018      	beq.n	3401667e <UART_AdvFeatureConfig+0x112>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
3401664c:	687b      	ldr	r3, [r7, #4]
3401664e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34016650:	2b00      	cmp	r3, #0
34016652:	d009      	beq.n	34016668 <UART_AdvFeatureConfig+0xfc>
34016654:	687b      	ldr	r3, [r7, #4]
34016656:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34016658:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3401665c:	d004      	beq.n	34016668 <UART_AdvFeatureConfig+0xfc>
3401665e:	f640 41fe 	movw	r1, #3326	@ 0xcfe
34016662:	4858      	ldr	r0, [pc, #352]	@ (340167c4 <UART_AdvFeatureConfig+0x258>)
34016664:	f7eb fcd4 	bl	34002010 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
34016668:	687b      	ldr	r3, [r7, #4]
3401666a:	681b      	ldr	r3, [r3, #0]
3401666c:	685b      	ldr	r3, [r3, #4]
3401666e:	f423 2180 	bic.w	r1, r3, #262144	@ 0x40000
34016672:	687b      	ldr	r3, [r7, #4]
34016674:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
34016676:	687b      	ldr	r3, [r7, #4]
34016678:	681b      	ldr	r3, [r3, #0]
3401667a:	430a      	orrs	r2, r1
3401667c:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
3401667e:	687b      	ldr	r3, [r7, #4]
34016680:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34016682:	f003 0310 	and.w	r3, r3, #16
34016686:	2b00      	cmp	r3, #0
34016688:	d018      	beq.n	340166bc <UART_AdvFeatureConfig+0x150>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
3401668a:	687b      	ldr	r3, [r7, #4]
3401668c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3401668e:	2b00      	cmp	r3, #0
34016690:	d009      	beq.n	340166a6 <UART_AdvFeatureConfig+0x13a>
34016692:	687b      	ldr	r3, [r7, #4]
34016694:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34016696:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401669a:	d004      	beq.n	340166a6 <UART_AdvFeatureConfig+0x13a>
3401669c:	f640 5105 	movw	r1, #3333	@ 0xd05
340166a0:	4848      	ldr	r0, [pc, #288]	@ (340167c4 <UART_AdvFeatureConfig+0x258>)
340166a2:	f7eb fcb5 	bl	34002010 <assert_failed>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
340166a6:	687b      	ldr	r3, [r7, #4]
340166a8:	681b      	ldr	r3, [r3, #0]
340166aa:	689b      	ldr	r3, [r3, #8]
340166ac:	f423 5180 	bic.w	r1, r3, #4096	@ 0x1000
340166b0:	687b      	ldr	r3, [r7, #4]
340166b2:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
340166b4:	687b      	ldr	r3, [r7, #4]
340166b6:	681b      	ldr	r3, [r3, #0]
340166b8:	430a      	orrs	r2, r1
340166ba:	609a      	str	r2, [r3, #8]
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
340166bc:	687b      	ldr	r3, [r7, #4]
340166be:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
340166c0:	f003 0320 	and.w	r3, r3, #32
340166c4:	2b00      	cmp	r3, #0
340166c6:	d018      	beq.n	340166fa <UART_AdvFeatureConfig+0x18e>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
340166c8:	687b      	ldr	r3, [r7, #4]
340166ca:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
340166cc:	2b00      	cmp	r3, #0
340166ce:	d009      	beq.n	340166e4 <UART_AdvFeatureConfig+0x178>
340166d0:	687b      	ldr	r3, [r7, #4]
340166d2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
340166d4:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
340166d8:	d004      	beq.n	340166e4 <UART_AdvFeatureConfig+0x178>
340166da:	f640 510d 	movw	r1, #3341	@ 0xd0d
340166de:	4839      	ldr	r0, [pc, #228]	@ (340167c4 <UART_AdvFeatureConfig+0x258>)
340166e0:	f7eb fc96 	bl	34002010 <assert_failed>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
340166e4:	687b      	ldr	r3, [r7, #4]
340166e6:	681b      	ldr	r3, [r3, #0]
340166e8:	689b      	ldr	r3, [r3, #8]
340166ea:	f423 5100 	bic.w	r1, r3, #8192	@ 0x2000
340166ee:	687b      	ldr	r3, [r7, #4]
340166f0:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
340166f2:	687b      	ldr	r3, [r7, #4]
340166f4:	681b      	ldr	r3, [r3, #0]
340166f6:	430a      	orrs	r2, r1
340166f8:	609a      	str	r2, [r3, #8]
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
340166fa:	687b      	ldr	r3, [r7, #4]
340166fc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
340166fe:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34016702:	2b00      	cmp	r3, #0
34016704:	f000 80d2 	beq.w	340168ac <UART_AdvFeatureConfig+0x340>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
34016708:	687b      	ldr	r3, [r7, #4]
3401670a:	681b      	ldr	r3, [r3, #0]
3401670c:	4a2e      	ldr	r2, [pc, #184]	@ (340167c8 <UART_AdvFeatureConfig+0x25c>)
3401670e:	4293      	cmp	r3, r2
34016710:	f000 808b 	beq.w	3401682a <UART_AdvFeatureConfig+0x2be>
34016714:	687b      	ldr	r3, [r7, #4]
34016716:	681b      	ldr	r3, [r3, #0]
34016718:	4a2c      	ldr	r2, [pc, #176]	@ (340167cc <UART_AdvFeatureConfig+0x260>)
3401671a:	4293      	cmp	r3, r2
3401671c:	f000 8085 	beq.w	3401682a <UART_AdvFeatureConfig+0x2be>
34016720:	687b      	ldr	r3, [r7, #4]
34016722:	681b      	ldr	r3, [r3, #0]
34016724:	4a2a      	ldr	r2, [pc, #168]	@ (340167d0 <UART_AdvFeatureConfig+0x264>)
34016726:	4293      	cmp	r3, r2
34016728:	d07f      	beq.n	3401682a <UART_AdvFeatureConfig+0x2be>
3401672a:	687b      	ldr	r3, [r7, #4]
3401672c:	681b      	ldr	r3, [r3, #0]
3401672e:	4a29      	ldr	r2, [pc, #164]	@ (340167d4 <UART_AdvFeatureConfig+0x268>)
34016730:	4293      	cmp	r3, r2
34016732:	d07a      	beq.n	3401682a <UART_AdvFeatureConfig+0x2be>
34016734:	687b      	ldr	r3, [r7, #4]
34016736:	681b      	ldr	r3, [r3, #0]
34016738:	4a27      	ldr	r2, [pc, #156]	@ (340167d8 <UART_AdvFeatureConfig+0x26c>)
3401673a:	4293      	cmp	r3, r2
3401673c:	d075      	beq.n	3401682a <UART_AdvFeatureConfig+0x2be>
3401673e:	687b      	ldr	r3, [r7, #4]
34016740:	681b      	ldr	r3, [r3, #0]
34016742:	4a26      	ldr	r2, [pc, #152]	@ (340167dc <UART_AdvFeatureConfig+0x270>)
34016744:	4293      	cmp	r3, r2
34016746:	d070      	beq.n	3401682a <UART_AdvFeatureConfig+0x2be>
34016748:	687b      	ldr	r3, [r7, #4]
3401674a:	681b      	ldr	r3, [r3, #0]
3401674c:	4a24      	ldr	r2, [pc, #144]	@ (340167e0 <UART_AdvFeatureConfig+0x274>)
3401674e:	4293      	cmp	r3, r2
34016750:	d06b      	beq.n	3401682a <UART_AdvFeatureConfig+0x2be>
34016752:	687b      	ldr	r3, [r7, #4]
34016754:	681b      	ldr	r3, [r3, #0]
34016756:	4a23      	ldr	r2, [pc, #140]	@ (340167e4 <UART_AdvFeatureConfig+0x278>)
34016758:	4293      	cmp	r3, r2
3401675a:	d066      	beq.n	3401682a <UART_AdvFeatureConfig+0x2be>
3401675c:	687b      	ldr	r3, [r7, #4]
3401675e:	681b      	ldr	r3, [r3, #0]
34016760:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
34016764:	d061      	beq.n	3401682a <UART_AdvFeatureConfig+0x2be>
34016766:	687b      	ldr	r3, [r7, #4]
34016768:	681b      	ldr	r3, [r3, #0]
3401676a:	4a1f      	ldr	r2, [pc, #124]	@ (340167e8 <UART_AdvFeatureConfig+0x27c>)
3401676c:	4293      	cmp	r3, r2
3401676e:	d05c      	beq.n	3401682a <UART_AdvFeatureConfig+0x2be>
34016770:	687b      	ldr	r3, [r7, #4]
34016772:	681b      	ldr	r3, [r3, #0]
34016774:	4a1d      	ldr	r2, [pc, #116]	@ (340167ec <UART_AdvFeatureConfig+0x280>)
34016776:	4293      	cmp	r3, r2
34016778:	d057      	beq.n	3401682a <UART_AdvFeatureConfig+0x2be>
3401677a:	687b      	ldr	r3, [r7, #4]
3401677c:	681b      	ldr	r3, [r3, #0]
3401677e:	4a1c      	ldr	r2, [pc, #112]	@ (340167f0 <UART_AdvFeatureConfig+0x284>)
34016780:	4293      	cmp	r3, r2
34016782:	d052      	beq.n	3401682a <UART_AdvFeatureConfig+0x2be>
34016784:	687b      	ldr	r3, [r7, #4]
34016786:	681b      	ldr	r3, [r3, #0]
34016788:	4a1a      	ldr	r2, [pc, #104]	@ (340167f4 <UART_AdvFeatureConfig+0x288>)
3401678a:	4293      	cmp	r3, r2
3401678c:	d04d      	beq.n	3401682a <UART_AdvFeatureConfig+0x2be>
3401678e:	687b      	ldr	r3, [r7, #4]
34016790:	681b      	ldr	r3, [r3, #0]
34016792:	4a19      	ldr	r2, [pc, #100]	@ (340167f8 <UART_AdvFeatureConfig+0x28c>)
34016794:	4293      	cmp	r3, r2
34016796:	d048      	beq.n	3401682a <UART_AdvFeatureConfig+0x2be>
34016798:	687b      	ldr	r3, [r7, #4]
3401679a:	681b      	ldr	r3, [r3, #0]
3401679c:	4a17      	ldr	r2, [pc, #92]	@ (340167fc <UART_AdvFeatureConfig+0x290>)
3401679e:	4293      	cmp	r3, r2
340167a0:	d043      	beq.n	3401682a <UART_AdvFeatureConfig+0x2be>
340167a2:	687b      	ldr	r3, [r7, #4]
340167a4:	681b      	ldr	r3, [r3, #0]
340167a6:	4a16      	ldr	r2, [pc, #88]	@ (34016800 <UART_AdvFeatureConfig+0x294>)
340167a8:	4293      	cmp	r3, r2
340167aa:	d03e      	beq.n	3401682a <UART_AdvFeatureConfig+0x2be>
340167ac:	687b      	ldr	r3, [r7, #4]
340167ae:	681b      	ldr	r3, [r3, #0]
340167b0:	4a14      	ldr	r2, [pc, #80]	@ (34016804 <UART_AdvFeatureConfig+0x298>)
340167b2:	4293      	cmp	r3, r2
340167b4:	d039      	beq.n	3401682a <UART_AdvFeatureConfig+0x2be>
340167b6:	687b      	ldr	r3, [r7, #4]
340167b8:	681b      	ldr	r3, [r3, #0]
340167ba:	4a13      	ldr	r2, [pc, #76]	@ (34016808 <UART_AdvFeatureConfig+0x29c>)
340167bc:	4293      	cmp	r3, r2
340167be:	d034      	beq.n	3401682a <UART_AdvFeatureConfig+0x2be>
340167c0:	e024      	b.n	3401680c <UART_AdvFeatureConfig+0x2a0>
340167c2:	bf00      	nop
340167c4:	3401f05c 	.word	0x3401f05c
340167c8:	52001000 	.word	0x52001000
340167cc:	42001000 	.word	0x42001000
340167d0:	50004400 	.word	0x50004400
340167d4:	40004400 	.word	0x40004400
340167d8:	50004800 	.word	0x50004800
340167dc:	40004800 	.word	0x40004800
340167e0:	50004c00 	.word	0x50004c00
340167e4:	40004c00 	.word	0x40004c00
340167e8:	40005000 	.word	0x40005000
340167ec:	52001400 	.word	0x52001400
340167f0:	42001400 	.word	0x42001400
340167f4:	50007800 	.word	0x50007800
340167f8:	40007800 	.word	0x40007800
340167fc:	50007c00 	.word	0x50007c00
34016800:	40007c00 	.word	0x40007c00
34016804:	52001800 	.word	0x52001800
34016808:	42001800 	.word	0x42001800
3401680c:	687b      	ldr	r3, [r7, #4]
3401680e:	681b      	ldr	r3, [r3, #0]
34016810:	4a38      	ldr	r2, [pc, #224]	@ (340168f4 <UART_AdvFeatureConfig+0x388>)
34016812:	4293      	cmp	r3, r2
34016814:	d009      	beq.n	3401682a <UART_AdvFeatureConfig+0x2be>
34016816:	687b      	ldr	r3, [r7, #4]
34016818:	681b      	ldr	r3, [r3, #0]
3401681a:	4a37      	ldr	r2, [pc, #220]	@ (340168f8 <UART_AdvFeatureConfig+0x38c>)
3401681c:	4293      	cmp	r3, r2
3401681e:	d004      	beq.n	3401682a <UART_AdvFeatureConfig+0x2be>
34016820:	f640 5115 	movw	r1, #3349	@ 0xd15
34016824:	4835      	ldr	r0, [pc, #212]	@ (340168fc <UART_AdvFeatureConfig+0x390>)
34016826:	f7eb fbf3 	bl	34002010 <assert_failed>
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
3401682a:	687b      	ldr	r3, [r7, #4]
3401682c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401682e:	2b00      	cmp	r3, #0
34016830:	d009      	beq.n	34016846 <UART_AdvFeatureConfig+0x2da>
34016832:	687b      	ldr	r3, [r7, #4]
34016834:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34016836:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3401683a:	d004      	beq.n	34016846 <UART_AdvFeatureConfig+0x2da>
3401683c:	f640 5116 	movw	r1, #3350	@ 0xd16
34016840:	482e      	ldr	r0, [pc, #184]	@ (340168fc <UART_AdvFeatureConfig+0x390>)
34016842:	f7eb fbe5 	bl	34002010 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
34016846:	687b      	ldr	r3, [r7, #4]
34016848:	681b      	ldr	r3, [r3, #0]
3401684a:	685b      	ldr	r3, [r3, #4]
3401684c:	f423 1180 	bic.w	r1, r3, #1048576	@ 0x100000
34016850:	687b      	ldr	r3, [r7, #4]
34016852:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
34016854:	687b      	ldr	r3, [r7, #4]
34016856:	681b      	ldr	r3, [r3, #0]
34016858:	430a      	orrs	r2, r1
3401685a:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
3401685c:	687b      	ldr	r3, [r7, #4]
3401685e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34016860:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34016864:	d122      	bne.n	340168ac <UART_AdvFeatureConfig+0x340>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
34016866:	687b      	ldr	r3, [r7, #4]
34016868:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401686a:	2b00      	cmp	r3, #0
3401686c:	d013      	beq.n	34016896 <UART_AdvFeatureConfig+0x32a>
3401686e:	687b      	ldr	r3, [r7, #4]
34016870:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34016872:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34016876:	d00e      	beq.n	34016896 <UART_AdvFeatureConfig+0x32a>
34016878:	687b      	ldr	r3, [r7, #4]
3401687a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401687c:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
34016880:	d009      	beq.n	34016896 <UART_AdvFeatureConfig+0x32a>
34016882:	687b      	ldr	r3, [r7, #4]
34016884:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34016886:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
3401688a:	d004      	beq.n	34016896 <UART_AdvFeatureConfig+0x32a>
3401688c:	f640 511b 	movw	r1, #3355	@ 0xd1b
34016890:	481a      	ldr	r0, [pc, #104]	@ (340168fc <UART_AdvFeatureConfig+0x390>)
34016892:	f7eb fbbd 	bl	34002010 <assert_failed>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
34016896:	687b      	ldr	r3, [r7, #4]
34016898:	681b      	ldr	r3, [r3, #0]
3401689a:	685b      	ldr	r3, [r3, #4]
3401689c:	f423 01c0 	bic.w	r1, r3, #6291456	@ 0x600000
340168a0:	687b      	ldr	r3, [r7, #4]
340168a2:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
340168a4:	687b      	ldr	r3, [r7, #4]
340168a6:	681b      	ldr	r3, [r3, #0]
340168a8:	430a      	orrs	r2, r1
340168aa:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
340168ac:	687b      	ldr	r3, [r7, #4]
340168ae:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
340168b0:	f003 0380 	and.w	r3, r3, #128	@ 0x80
340168b4:	2b00      	cmp	r3, #0
340168b6:	d018      	beq.n	340168ea <UART_AdvFeatureConfig+0x37e>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
340168b8:	687b      	ldr	r3, [r7, #4]
340168ba:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340168bc:	2b00      	cmp	r3, #0
340168be:	d009      	beq.n	340168d4 <UART_AdvFeatureConfig+0x368>
340168c0:	687b      	ldr	r3, [r7, #4]
340168c2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340168c4:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
340168c8:	d004      	beq.n	340168d4 <UART_AdvFeatureConfig+0x368>
340168ca:	f640 5123 	movw	r1, #3363	@ 0xd23
340168ce:	480b      	ldr	r0, [pc, #44]	@ (340168fc <UART_AdvFeatureConfig+0x390>)
340168d0:	f7eb fb9e 	bl	34002010 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
340168d4:	687b      	ldr	r3, [r7, #4]
340168d6:	681b      	ldr	r3, [r3, #0]
340168d8:	685b      	ldr	r3, [r3, #4]
340168da:	f423 2100 	bic.w	r1, r3, #524288	@ 0x80000
340168de:	687b      	ldr	r3, [r7, #4]
340168e0:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
340168e2:	687b      	ldr	r3, [r7, #4]
340168e4:	681b      	ldr	r3, [r3, #0]
340168e6:	430a      	orrs	r2, r1
340168e8:	605a      	str	r2, [r3, #4]
  }
}
340168ea:	bf00      	nop
340168ec:	3708      	adds	r7, #8
340168ee:	46bd      	mov	sp, r7
340168f0:	bd80      	pop	{r7, pc}
340168f2:	bf00      	nop
340168f4:	52001c00 	.word	0x52001c00
340168f8:	42001c00 	.word	0x42001c00
340168fc:	3401f05c 	.word	0x3401f05c

34016900 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
34016900:	b580      	push	{r7, lr}
34016902:	b098      	sub	sp, #96	@ 0x60
34016904:	af02      	add	r7, sp, #8
34016906:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
34016908:	687b      	ldr	r3, [r7, #4]
3401690a:	2200      	movs	r2, #0
3401690c:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
34016910:	f7ed fba0 	bl	34004054 <HAL_GetTick>
34016914:	6578      	str	r0, [r7, #84]	@ 0x54

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
34016916:	687b      	ldr	r3, [r7, #4]
34016918:	681b      	ldr	r3, [r3, #0]
3401691a:	681b      	ldr	r3, [r3, #0]
3401691c:	f003 0308 	and.w	r3, r3, #8
34016920:	2b08      	cmp	r3, #8
34016922:	d12f      	bne.n	34016984 <UART_CheckIdleState+0x84>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
34016924:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
34016928:	9300      	str	r3, [sp, #0]
3401692a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401692c:	2200      	movs	r2, #0
3401692e:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
34016932:	6878      	ldr	r0, [r7, #4]
34016934:	f000 f88e 	bl	34016a54 <UART_WaitOnFlagUntilTimeout>
34016938:	4603      	mov	r3, r0
3401693a:	2b00      	cmp	r3, #0
3401693c:	d022      	beq.n	34016984 <UART_CheckIdleState+0x84>
    {
      /* Disable TXE interrupt for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
3401693e:	687b      	ldr	r3, [r7, #4]
34016940:	681b      	ldr	r3, [r3, #0]
34016942:	63bb      	str	r3, [r7, #56]	@ 0x38
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34016944:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34016946:	e853 3f00 	ldrex	r3, [r3]
3401694a:	637b      	str	r3, [r7, #52]	@ 0x34
   return(result);
3401694c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3401694e:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
34016952:	653b      	str	r3, [r7, #80]	@ 0x50
34016954:	687b      	ldr	r3, [r7, #4]
34016956:	681b      	ldr	r3, [r3, #0]
34016958:	461a      	mov	r2, r3
3401695a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3401695c:	647b      	str	r3, [r7, #68]	@ 0x44
3401695e:	643a      	str	r2, [r7, #64]	@ 0x40
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34016960:	6c39      	ldr	r1, [r7, #64]	@ 0x40
34016962:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
34016964:	e841 2300 	strex	r3, r2, [r1]
34016968:	63fb      	str	r3, [r7, #60]	@ 0x3c
   return(result);
3401696a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3401696c:	2b00      	cmp	r3, #0
3401696e:	d1e6      	bne.n	3401693e <UART_CheckIdleState+0x3e>

      huart->gState = HAL_UART_STATE_READY;
34016970:	687b      	ldr	r3, [r7, #4]
34016972:	2220      	movs	r2, #32
34016974:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

      __HAL_UNLOCK(huart);
34016978:	687b      	ldr	r3, [r7, #4]
3401697a:	2200      	movs	r2, #0
3401697c:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
34016980:	2303      	movs	r3, #3
34016982:	e063      	b.n	34016a4c <UART_CheckIdleState+0x14c>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
34016984:	687b      	ldr	r3, [r7, #4]
34016986:	681b      	ldr	r3, [r3, #0]
34016988:	681b      	ldr	r3, [r3, #0]
3401698a:	f003 0304 	and.w	r3, r3, #4
3401698e:	2b04      	cmp	r3, #4
34016990:	d149      	bne.n	34016a26 <UART_CheckIdleState+0x126>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
34016992:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
34016996:	9300      	str	r3, [sp, #0]
34016998:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401699a:	2200      	movs	r2, #0
3401699c:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
340169a0:	6878      	ldr	r0, [r7, #4]
340169a2:	f000 f857 	bl	34016a54 <UART_WaitOnFlagUntilTimeout>
340169a6:	4603      	mov	r3, r0
340169a8:	2b00      	cmp	r3, #0
340169aa:	d03c      	beq.n	34016a26 <UART_CheckIdleState+0x126>
    {
      /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error)
      interrupts for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
340169ac:	687b      	ldr	r3, [r7, #4]
340169ae:	681b      	ldr	r3, [r3, #0]
340169b0:	627b      	str	r3, [r7, #36]	@ 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
340169b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340169b4:	e853 3f00 	ldrex	r3, [r3]
340169b8:	623b      	str	r3, [r7, #32]
   return(result);
340169ba:	6a3b      	ldr	r3, [r7, #32]
340169bc:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
340169c0:	64fb      	str	r3, [r7, #76]	@ 0x4c
340169c2:	687b      	ldr	r3, [r7, #4]
340169c4:	681b      	ldr	r3, [r3, #0]
340169c6:	461a      	mov	r2, r3
340169c8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
340169ca:	633b      	str	r3, [r7, #48]	@ 0x30
340169cc:	62fa      	str	r2, [r7, #44]	@ 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
340169ce:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
340169d0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
340169d2:	e841 2300 	strex	r3, r2, [r1]
340169d6:	62bb      	str	r3, [r7, #40]	@ 0x28
   return(result);
340169d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340169da:	2b00      	cmp	r3, #0
340169dc:	d1e6      	bne.n	340169ac <UART_CheckIdleState+0xac>
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
340169de:	687b      	ldr	r3, [r7, #4]
340169e0:	681b      	ldr	r3, [r3, #0]
340169e2:	3308      	adds	r3, #8
340169e4:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
340169e6:	693b      	ldr	r3, [r7, #16]
340169e8:	e853 3f00 	ldrex	r3, [r3]
340169ec:	60fb      	str	r3, [r7, #12]
   return(result);
340169ee:	68fb      	ldr	r3, [r7, #12]
340169f0:	f023 0301 	bic.w	r3, r3, #1
340169f4:	64bb      	str	r3, [r7, #72]	@ 0x48
340169f6:	687b      	ldr	r3, [r7, #4]
340169f8:	681b      	ldr	r3, [r3, #0]
340169fa:	3308      	adds	r3, #8
340169fc:	6cba      	ldr	r2, [r7, #72]	@ 0x48
340169fe:	61fa      	str	r2, [r7, #28]
34016a00:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34016a02:	69b9      	ldr	r1, [r7, #24]
34016a04:	69fa      	ldr	r2, [r7, #28]
34016a06:	e841 2300 	strex	r3, r2, [r1]
34016a0a:	617b      	str	r3, [r7, #20]
   return(result);
34016a0c:	697b      	ldr	r3, [r7, #20]
34016a0e:	2b00      	cmp	r3, #0
34016a10:	d1e5      	bne.n	340169de <UART_CheckIdleState+0xde>

      huart->RxState = HAL_UART_STATE_READY;
34016a12:	687b      	ldr	r3, [r7, #4]
34016a14:	2220      	movs	r2, #32
34016a16:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

      __HAL_UNLOCK(huart);
34016a1a:	687b      	ldr	r3, [r7, #4]
34016a1c:	2200      	movs	r2, #0
34016a1e:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
34016a22:	2303      	movs	r3, #3
34016a24:	e012      	b.n	34016a4c <UART_CheckIdleState+0x14c>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
34016a26:	687b      	ldr	r3, [r7, #4]
34016a28:	2220      	movs	r2, #32
34016a2a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
34016a2e:	687b      	ldr	r3, [r7, #4]
34016a30:	2220      	movs	r2, #32
34016a32:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
34016a36:	687b      	ldr	r3, [r7, #4]
34016a38:	2200      	movs	r2, #0
34016a3a:	66da      	str	r2, [r3, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
34016a3c:	687b      	ldr	r3, [r7, #4]
34016a3e:	2200      	movs	r2, #0
34016a40:	671a      	str	r2, [r3, #112]	@ 0x70

  __HAL_UNLOCK(huart);
34016a42:	687b      	ldr	r3, [r7, #4]
34016a44:	2200      	movs	r2, #0
34016a46:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
34016a4a:	2300      	movs	r3, #0
}
34016a4c:	4618      	mov	r0, r3
34016a4e:	3758      	adds	r7, #88	@ 0x58
34016a50:	46bd      	mov	sp, r7
34016a52:	bd80      	pop	{r7, pc}

34016a54 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
34016a54:	b580      	push	{r7, lr}
34016a56:	b084      	sub	sp, #16
34016a58:	af00      	add	r7, sp, #0
34016a5a:	60f8      	str	r0, [r7, #12]
34016a5c:	60b9      	str	r1, [r7, #8]
34016a5e:	603b      	str	r3, [r7, #0]
34016a60:	4613      	mov	r3, r2
34016a62:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
34016a64:	e04f      	b.n	34016b06 <UART_WaitOnFlagUntilTimeout+0xb2>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
34016a66:	69bb      	ldr	r3, [r7, #24]
34016a68:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
34016a6c:	d04b      	beq.n	34016b06 <UART_WaitOnFlagUntilTimeout+0xb2>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34016a6e:	f7ed faf1 	bl	34004054 <HAL_GetTick>
34016a72:	4602      	mov	r2, r0
34016a74:	683b      	ldr	r3, [r7, #0]
34016a76:	1ad3      	subs	r3, r2, r3
34016a78:	69ba      	ldr	r2, [r7, #24]
34016a7a:	429a      	cmp	r2, r3
34016a7c:	d302      	bcc.n	34016a84 <UART_WaitOnFlagUntilTimeout+0x30>
34016a7e:	69bb      	ldr	r3, [r7, #24]
34016a80:	2b00      	cmp	r3, #0
34016a82:	d101      	bne.n	34016a88 <UART_WaitOnFlagUntilTimeout+0x34>
      {

        return HAL_TIMEOUT;
34016a84:	2303      	movs	r3, #3
34016a86:	e04e      	b.n	34016b26 <UART_WaitOnFlagUntilTimeout+0xd2>
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
34016a88:	68fb      	ldr	r3, [r7, #12]
34016a8a:	681b      	ldr	r3, [r3, #0]
34016a8c:	681b      	ldr	r3, [r3, #0]
34016a8e:	f003 0304 	and.w	r3, r3, #4
34016a92:	2b00      	cmp	r3, #0
34016a94:	d037      	beq.n	34016b06 <UART_WaitOnFlagUntilTimeout+0xb2>
34016a96:	68bb      	ldr	r3, [r7, #8]
34016a98:	2b80      	cmp	r3, #128	@ 0x80
34016a9a:	d034      	beq.n	34016b06 <UART_WaitOnFlagUntilTimeout+0xb2>
34016a9c:	68bb      	ldr	r3, [r7, #8]
34016a9e:	2b40      	cmp	r3, #64	@ 0x40
34016aa0:	d031      	beq.n	34016b06 <UART_WaitOnFlagUntilTimeout+0xb2>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
34016aa2:	68fb      	ldr	r3, [r7, #12]
34016aa4:	681b      	ldr	r3, [r3, #0]
34016aa6:	69db      	ldr	r3, [r3, #28]
34016aa8:	f003 0308 	and.w	r3, r3, #8
34016aac:	2b08      	cmp	r3, #8
34016aae:	d110      	bne.n	34016ad2 <UART_WaitOnFlagUntilTimeout+0x7e>
        {
          /* Clear Overrun Error flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
34016ab0:	68fb      	ldr	r3, [r7, #12]
34016ab2:	681b      	ldr	r3, [r3, #0]
34016ab4:	2208      	movs	r2, #8
34016ab6:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
34016ab8:	68f8      	ldr	r0, [r7, #12]
34016aba:	f000 f838 	bl	34016b2e <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_ORE;
34016abe:	68fb      	ldr	r3, [r7, #12]
34016ac0:	2208      	movs	r2, #8
34016ac2:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
34016ac6:	68fb      	ldr	r3, [r7, #12]
34016ac8:	2200      	movs	r2, #0
34016aca:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_ERROR;
34016ace:	2301      	movs	r3, #1
34016ad0:	e029      	b.n	34016b26 <UART_WaitOnFlagUntilTimeout+0xd2>
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
34016ad2:	68fb      	ldr	r3, [r7, #12]
34016ad4:	681b      	ldr	r3, [r3, #0]
34016ad6:	69db      	ldr	r3, [r3, #28]
34016ad8:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34016adc:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34016ae0:	d111      	bne.n	34016b06 <UART_WaitOnFlagUntilTimeout+0xb2>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
34016ae2:	68fb      	ldr	r3, [r7, #12]
34016ae4:	681b      	ldr	r3, [r3, #0]
34016ae6:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34016aea:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
34016aec:	68f8      	ldr	r0, [r7, #12]
34016aee:	f000 f81e 	bl	34016b2e <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_RTO;
34016af2:	68fb      	ldr	r3, [r7, #12]
34016af4:	2220      	movs	r2, #32
34016af6:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
34016afa:	68fb      	ldr	r3, [r7, #12]
34016afc:	2200      	movs	r2, #0
34016afe:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_TIMEOUT;
34016b02:	2303      	movs	r3, #3
34016b04:	e00f      	b.n	34016b26 <UART_WaitOnFlagUntilTimeout+0xd2>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
34016b06:	68fb      	ldr	r3, [r7, #12]
34016b08:	681b      	ldr	r3, [r3, #0]
34016b0a:	69da      	ldr	r2, [r3, #28]
34016b0c:	68bb      	ldr	r3, [r7, #8]
34016b0e:	4013      	ands	r3, r2
34016b10:	68ba      	ldr	r2, [r7, #8]
34016b12:	429a      	cmp	r2, r3
34016b14:	bf0c      	ite	eq
34016b16:	2301      	moveq	r3, #1
34016b18:	2300      	movne	r3, #0
34016b1a:	b2db      	uxtb	r3, r3
34016b1c:	461a      	mov	r2, r3
34016b1e:	79fb      	ldrb	r3, [r7, #7]
34016b20:	429a      	cmp	r2, r3
34016b22:	d0a0      	beq.n	34016a66 <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
34016b24:	2300      	movs	r3, #0
}
34016b26:	4618      	mov	r0, r3
34016b28:	3710      	adds	r7, #16
34016b2a:	46bd      	mov	sp, r7
34016b2c:	bd80      	pop	{r7, pc}

34016b2e <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
34016b2e:	b480      	push	{r7}
34016b30:	b095      	sub	sp, #84	@ 0x54
34016b32:	af00      	add	r7, sp, #0
34016b34:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
34016b36:	687b      	ldr	r3, [r7, #4]
34016b38:	681b      	ldr	r3, [r3, #0]
34016b3a:	637b      	str	r3, [r7, #52]	@ 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34016b3c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34016b3e:	e853 3f00 	ldrex	r3, [r3]
34016b42:	633b      	str	r3, [r7, #48]	@ 0x30
   return(result);
34016b44:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34016b46:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
34016b4a:	64fb      	str	r3, [r7, #76]	@ 0x4c
34016b4c:	687b      	ldr	r3, [r7, #4]
34016b4e:	681b      	ldr	r3, [r3, #0]
34016b50:	461a      	mov	r2, r3
34016b52:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34016b54:	643b      	str	r3, [r7, #64]	@ 0x40
34016b56:	63fa      	str	r2, [r7, #60]	@ 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34016b58:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
34016b5a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
34016b5c:	e841 2300 	strex	r3, r2, [r1]
34016b60:	63bb      	str	r3, [r7, #56]	@ 0x38
   return(result);
34016b62:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34016b64:	2b00      	cmp	r3, #0
34016b66:	d1e6      	bne.n	34016b36 <UART_EndRxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
34016b68:	687b      	ldr	r3, [r7, #4]
34016b6a:	681b      	ldr	r3, [r3, #0]
34016b6c:	3308      	adds	r3, #8
34016b6e:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34016b70:	6a3b      	ldr	r3, [r7, #32]
34016b72:	e853 3f00 	ldrex	r3, [r3]
34016b76:	61fb      	str	r3, [r7, #28]
   return(result);
34016b78:	69fb      	ldr	r3, [r7, #28]
34016b7a:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
34016b7e:	f023 0301 	bic.w	r3, r3, #1
34016b82:	64bb      	str	r3, [r7, #72]	@ 0x48
34016b84:	687b      	ldr	r3, [r7, #4]
34016b86:	681b      	ldr	r3, [r3, #0]
34016b88:	3308      	adds	r3, #8
34016b8a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
34016b8c:	62fa      	str	r2, [r7, #44]	@ 0x2c
34016b8e:	62bb      	str	r3, [r7, #40]	@ 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34016b90:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34016b92:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34016b94:	e841 2300 	strex	r3, r2, [r1]
34016b98:	627b      	str	r3, [r7, #36]	@ 0x24
   return(result);
34016b9a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34016b9c:	2b00      	cmp	r3, #0
34016b9e:	d1e3      	bne.n	34016b68 <UART_EndRxTransfer+0x3a>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
34016ba0:	687b      	ldr	r3, [r7, #4]
34016ba2:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34016ba4:	2b01      	cmp	r3, #1
34016ba6:	d118      	bne.n	34016bda <UART_EndRxTransfer+0xac>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
34016ba8:	687b      	ldr	r3, [r7, #4]
34016baa:	681b      	ldr	r3, [r3, #0]
34016bac:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34016bae:	68fb      	ldr	r3, [r7, #12]
34016bb0:	e853 3f00 	ldrex	r3, [r3]
34016bb4:	60bb      	str	r3, [r7, #8]
   return(result);
34016bb6:	68bb      	ldr	r3, [r7, #8]
34016bb8:	f023 0310 	bic.w	r3, r3, #16
34016bbc:	647b      	str	r3, [r7, #68]	@ 0x44
34016bbe:	687b      	ldr	r3, [r7, #4]
34016bc0:	681b      	ldr	r3, [r3, #0]
34016bc2:	461a      	mov	r2, r3
34016bc4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34016bc6:	61bb      	str	r3, [r7, #24]
34016bc8:	617a      	str	r2, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34016bca:	6979      	ldr	r1, [r7, #20]
34016bcc:	69ba      	ldr	r2, [r7, #24]
34016bce:	e841 2300 	strex	r3, r2, [r1]
34016bd2:	613b      	str	r3, [r7, #16]
   return(result);
34016bd4:	693b      	ldr	r3, [r7, #16]
34016bd6:	2b00      	cmp	r3, #0
34016bd8:	d1e6      	bne.n	34016ba8 <UART_EndRxTransfer+0x7a>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
34016bda:	687b      	ldr	r3, [r7, #4]
34016bdc:	2220      	movs	r2, #32
34016bde:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
34016be2:	687b      	ldr	r3, [r7, #4]
34016be4:	2200      	movs	r2, #0
34016be6:	66da      	str	r2, [r3, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
34016be8:	687b      	ldr	r3, [r7, #4]
34016bea:	2200      	movs	r2, #0
34016bec:	675a      	str	r2, [r3, #116]	@ 0x74
}
34016bee:	bf00      	nop
34016bf0:	3754      	adds	r7, #84	@ 0x54
34016bf2:	46bd      	mov	sp, r7
34016bf4:	f85d 7b04 	ldr.w	r7, [sp], #4
34016bf8:	4770      	bx	lr
	...

34016bfc <HAL_XSPI_Init>:
  *         in the XSPI_InitTypeDef and initialize the associated handle.
  * @param  hxspi : XSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Init(XSPI_HandleTypeDef *hxspi)
{
34016bfc:	b580      	push	{r7, lr}
34016bfe:	b086      	sub	sp, #24
34016c00:	af02      	add	r7, sp, #8
34016c02:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
34016c04:	2300      	movs	r3, #0
34016c06:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
34016c08:	f7ed fa24 	bl	34004054 <HAL_GetTick>
34016c0c:	60b8      	str	r0, [r7, #8]

  /* Check the XSPI handle allocation */
  if (hxspi == NULL)
34016c0e:	687b      	ldr	r3, [r7, #4]
34016c10:	2b00      	cmp	r3, #0
34016c12:	d102      	bne.n	34016c1a <HAL_XSPI_Init+0x1e>
  {
    status = HAL_ERROR;
34016c14:	2301      	movs	r3, #1
34016c16:	73fb      	strb	r3, [r7, #15]
34016c18:	e2c8      	b.n	340171ac <HAL_XSPI_Init+0x5b0>
    /* No error code can be set set as the handler is null */
  }
  else
  {
    /* Check the parameters of the initialization structure */
    assert_param(IS_XSPI_MEMORY_MODE(hxspi->Init.MemoryMode));
34016c1a:	687b      	ldr	r3, [r7, #4]
34016c1c:	689b      	ldr	r3, [r3, #8]
34016c1e:	2b00      	cmp	r3, #0
34016c20:	d008      	beq.n	34016c34 <HAL_XSPI_Init+0x38>
34016c22:	687b      	ldr	r3, [r7, #4]
34016c24:	689b      	ldr	r3, [r3, #8]
34016c26:	2b40      	cmp	r3, #64	@ 0x40
34016c28:	d004      	beq.n	34016c34 <HAL_XSPI_Init+0x38>
34016c2a:	f240 1161 	movw	r1, #353	@ 0x161
34016c2e:	488a      	ldr	r0, [pc, #552]	@ (34016e58 <HAL_XSPI_Init+0x25c>)
34016c30:	f7eb f9ee 	bl	34002010 <assert_failed>
    assert_param(IS_XSPI_MEMORY_TYPE(hxspi->Init.MemoryType));
34016c34:	687b      	ldr	r3, [r7, #4]
34016c36:	68db      	ldr	r3, [r3, #12]
34016c38:	2b00      	cmp	r3, #0
34016c3a:	d01d      	beq.n	34016c78 <HAL_XSPI_Init+0x7c>
34016c3c:	687b      	ldr	r3, [r7, #4]
34016c3e:	68db      	ldr	r3, [r3, #12]
34016c40:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34016c44:	d018      	beq.n	34016c78 <HAL_XSPI_Init+0x7c>
34016c46:	687b      	ldr	r3, [r7, #4]
34016c48:	68db      	ldr	r3, [r3, #12]
34016c4a:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34016c4e:	d013      	beq.n	34016c78 <HAL_XSPI_Init+0x7c>
34016c50:	687b      	ldr	r3, [r7, #4]
34016c52:	68db      	ldr	r3, [r3, #12]
34016c54:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
34016c58:	d00e      	beq.n	34016c78 <HAL_XSPI_Init+0x7c>
34016c5a:	687b      	ldr	r3, [r7, #4]
34016c5c:	68db      	ldr	r3, [r3, #12]
34016c5e:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
34016c62:	d009      	beq.n	34016c78 <HAL_XSPI_Init+0x7c>
34016c64:	687b      	ldr	r3, [r7, #4]
34016c66:	68db      	ldr	r3, [r3, #12]
34016c68:	f1b3 6fc0 	cmp.w	r3, #100663296	@ 0x6000000
34016c6c:	d004      	beq.n	34016c78 <HAL_XSPI_Init+0x7c>
34016c6e:	f44f 71b1 	mov.w	r1, #354	@ 0x162
34016c72:	4879      	ldr	r0, [pc, #484]	@ (34016e58 <HAL_XSPI_Init+0x25c>)
34016c74:	f7eb f9cc 	bl	34002010 <assert_failed>
    assert_param(IS_XSPI_MEMORY_SIZE(hxspi->Init.MemorySize));
34016c78:	687b      	ldr	r3, [r7, #4]
34016c7a:	691b      	ldr	r3, [r3, #16]
34016c7c:	2b00      	cmp	r3, #0
34016c7e:	f000 8081 	beq.w	34016d84 <HAL_XSPI_Init+0x188>
34016c82:	687b      	ldr	r3, [r7, #4]
34016c84:	691b      	ldr	r3, [r3, #16]
34016c86:	2b01      	cmp	r3, #1
34016c88:	d07c      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016c8a:	687b      	ldr	r3, [r7, #4]
34016c8c:	691b      	ldr	r3, [r3, #16]
34016c8e:	2b02      	cmp	r3, #2
34016c90:	d078      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016c92:	687b      	ldr	r3, [r7, #4]
34016c94:	691b      	ldr	r3, [r3, #16]
34016c96:	2b03      	cmp	r3, #3
34016c98:	d074      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016c9a:	687b      	ldr	r3, [r7, #4]
34016c9c:	691b      	ldr	r3, [r3, #16]
34016c9e:	2b04      	cmp	r3, #4
34016ca0:	d070      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016ca2:	687b      	ldr	r3, [r7, #4]
34016ca4:	691b      	ldr	r3, [r3, #16]
34016ca6:	2b05      	cmp	r3, #5
34016ca8:	d06c      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016caa:	687b      	ldr	r3, [r7, #4]
34016cac:	691b      	ldr	r3, [r3, #16]
34016cae:	2b06      	cmp	r3, #6
34016cb0:	d068      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016cb2:	687b      	ldr	r3, [r7, #4]
34016cb4:	691b      	ldr	r3, [r3, #16]
34016cb6:	2b07      	cmp	r3, #7
34016cb8:	d064      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016cba:	687b      	ldr	r3, [r7, #4]
34016cbc:	691b      	ldr	r3, [r3, #16]
34016cbe:	2b08      	cmp	r3, #8
34016cc0:	d060      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016cc2:	687b      	ldr	r3, [r7, #4]
34016cc4:	691b      	ldr	r3, [r3, #16]
34016cc6:	2b09      	cmp	r3, #9
34016cc8:	d05c      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016cca:	687b      	ldr	r3, [r7, #4]
34016ccc:	691b      	ldr	r3, [r3, #16]
34016cce:	2b0a      	cmp	r3, #10
34016cd0:	d058      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016cd2:	687b      	ldr	r3, [r7, #4]
34016cd4:	691b      	ldr	r3, [r3, #16]
34016cd6:	2b0b      	cmp	r3, #11
34016cd8:	d054      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016cda:	687b      	ldr	r3, [r7, #4]
34016cdc:	691b      	ldr	r3, [r3, #16]
34016cde:	2b0c      	cmp	r3, #12
34016ce0:	d050      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016ce2:	687b      	ldr	r3, [r7, #4]
34016ce4:	691b      	ldr	r3, [r3, #16]
34016ce6:	2b0d      	cmp	r3, #13
34016ce8:	d04c      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016cea:	687b      	ldr	r3, [r7, #4]
34016cec:	691b      	ldr	r3, [r3, #16]
34016cee:	2b0e      	cmp	r3, #14
34016cf0:	d048      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016cf2:	687b      	ldr	r3, [r7, #4]
34016cf4:	691b      	ldr	r3, [r3, #16]
34016cf6:	2b0f      	cmp	r3, #15
34016cf8:	d044      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016cfa:	687b      	ldr	r3, [r7, #4]
34016cfc:	691b      	ldr	r3, [r3, #16]
34016cfe:	2b10      	cmp	r3, #16
34016d00:	d040      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016d02:	687b      	ldr	r3, [r7, #4]
34016d04:	691b      	ldr	r3, [r3, #16]
34016d06:	2b11      	cmp	r3, #17
34016d08:	d03c      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016d0a:	687b      	ldr	r3, [r7, #4]
34016d0c:	691b      	ldr	r3, [r3, #16]
34016d0e:	2b12      	cmp	r3, #18
34016d10:	d038      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016d12:	687b      	ldr	r3, [r7, #4]
34016d14:	691b      	ldr	r3, [r3, #16]
34016d16:	2b13      	cmp	r3, #19
34016d18:	d034      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016d1a:	687b      	ldr	r3, [r7, #4]
34016d1c:	691b      	ldr	r3, [r3, #16]
34016d1e:	2b14      	cmp	r3, #20
34016d20:	d030      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016d22:	687b      	ldr	r3, [r7, #4]
34016d24:	691b      	ldr	r3, [r3, #16]
34016d26:	2b15      	cmp	r3, #21
34016d28:	d02c      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016d2a:	687b      	ldr	r3, [r7, #4]
34016d2c:	691b      	ldr	r3, [r3, #16]
34016d2e:	2b16      	cmp	r3, #22
34016d30:	d028      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016d32:	687b      	ldr	r3, [r7, #4]
34016d34:	691b      	ldr	r3, [r3, #16]
34016d36:	2b17      	cmp	r3, #23
34016d38:	d024      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016d3a:	687b      	ldr	r3, [r7, #4]
34016d3c:	691b      	ldr	r3, [r3, #16]
34016d3e:	2b18      	cmp	r3, #24
34016d40:	d020      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016d42:	687b      	ldr	r3, [r7, #4]
34016d44:	691b      	ldr	r3, [r3, #16]
34016d46:	2b19      	cmp	r3, #25
34016d48:	d01c      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016d4a:	687b      	ldr	r3, [r7, #4]
34016d4c:	691b      	ldr	r3, [r3, #16]
34016d4e:	2b1a      	cmp	r3, #26
34016d50:	d018      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016d52:	687b      	ldr	r3, [r7, #4]
34016d54:	691b      	ldr	r3, [r3, #16]
34016d56:	2b1b      	cmp	r3, #27
34016d58:	d014      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016d5a:	687b      	ldr	r3, [r7, #4]
34016d5c:	691b      	ldr	r3, [r3, #16]
34016d5e:	2b1c      	cmp	r3, #28
34016d60:	d010      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016d62:	687b      	ldr	r3, [r7, #4]
34016d64:	691b      	ldr	r3, [r3, #16]
34016d66:	2b1d      	cmp	r3, #29
34016d68:	d00c      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016d6a:	687b      	ldr	r3, [r7, #4]
34016d6c:	691b      	ldr	r3, [r3, #16]
34016d6e:	2b1e      	cmp	r3, #30
34016d70:	d008      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016d72:	687b      	ldr	r3, [r7, #4]
34016d74:	691b      	ldr	r3, [r3, #16]
34016d76:	2b1f      	cmp	r3, #31
34016d78:	d004      	beq.n	34016d84 <HAL_XSPI_Init+0x188>
34016d7a:	f240 1163 	movw	r1, #355	@ 0x163
34016d7e:	4836      	ldr	r0, [pc, #216]	@ (34016e58 <HAL_XSPI_Init+0x25c>)
34016d80:	f7eb f946 	bl	34002010 <assert_failed>
    assert_param(IS_XSPI_CS_HIGH_TIME_CYCLE(hxspi->Init.ChipSelectHighTimeCycle));
34016d84:	687b      	ldr	r3, [r7, #4]
34016d86:	695b      	ldr	r3, [r3, #20]
34016d88:	2b00      	cmp	r3, #0
34016d8a:	d003      	beq.n	34016d94 <HAL_XSPI_Init+0x198>
34016d8c:	687b      	ldr	r3, [r7, #4]
34016d8e:	695b      	ldr	r3, [r3, #20]
34016d90:	2b40      	cmp	r3, #64	@ 0x40
34016d92:	d904      	bls.n	34016d9e <HAL_XSPI_Init+0x1a2>
34016d94:	f44f 71b2 	mov.w	r1, #356	@ 0x164
34016d98:	482f      	ldr	r0, [pc, #188]	@ (34016e58 <HAL_XSPI_Init+0x25c>)
34016d9a:	f7eb f939 	bl	34002010 <assert_failed>
    assert_param(IS_XSPI_FREE_RUN_CLK(hxspi->Init.FreeRunningClock));
34016d9e:	687b      	ldr	r3, [r7, #4]
34016da0:	699b      	ldr	r3, [r3, #24]
34016da2:	2b00      	cmp	r3, #0
34016da4:	d008      	beq.n	34016db8 <HAL_XSPI_Init+0x1bc>
34016da6:	687b      	ldr	r3, [r7, #4]
34016da8:	699b      	ldr	r3, [r3, #24]
34016daa:	2b02      	cmp	r3, #2
34016dac:	d004      	beq.n	34016db8 <HAL_XSPI_Init+0x1bc>
34016dae:	f240 1165 	movw	r1, #357	@ 0x165
34016db2:	4829      	ldr	r0, [pc, #164]	@ (34016e58 <HAL_XSPI_Init+0x25c>)
34016db4:	f7eb f92c 	bl	34002010 <assert_failed>
    assert_param(IS_XSPI_CLOCK_MODE(hxspi->Init.ClockMode));
34016db8:	687b      	ldr	r3, [r7, #4]
34016dba:	69db      	ldr	r3, [r3, #28]
34016dbc:	2b00      	cmp	r3, #0
34016dbe:	d008      	beq.n	34016dd2 <HAL_XSPI_Init+0x1d6>
34016dc0:	687b      	ldr	r3, [r7, #4]
34016dc2:	69db      	ldr	r3, [r3, #28]
34016dc4:	2b01      	cmp	r3, #1
34016dc6:	d004      	beq.n	34016dd2 <HAL_XSPI_Init+0x1d6>
34016dc8:	f44f 71b3 	mov.w	r1, #358	@ 0x166
34016dcc:	4822      	ldr	r0, [pc, #136]	@ (34016e58 <HAL_XSPI_Init+0x25c>)
34016dce:	f7eb f91f 	bl	34002010 <assert_failed>
    assert_param(IS_XSPI_WRAP_SIZE(hxspi->Init.WrapSize));
34016dd2:	687b      	ldr	r3, [r7, #4]
34016dd4:	6a1b      	ldr	r3, [r3, #32]
34016dd6:	2b00      	cmp	r3, #0
34016dd8:	d018      	beq.n	34016e0c <HAL_XSPI_Init+0x210>
34016dda:	687b      	ldr	r3, [r7, #4]
34016ddc:	6a1b      	ldr	r3, [r3, #32]
34016dde:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34016de2:	d013      	beq.n	34016e0c <HAL_XSPI_Init+0x210>
34016de4:	687b      	ldr	r3, [r7, #4]
34016de6:	6a1b      	ldr	r3, [r3, #32]
34016de8:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34016dec:	d00e      	beq.n	34016e0c <HAL_XSPI_Init+0x210>
34016dee:	687b      	ldr	r3, [r7, #4]
34016df0:	6a1b      	ldr	r3, [r3, #32]
34016df2:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34016df6:	d009      	beq.n	34016e0c <HAL_XSPI_Init+0x210>
34016df8:	687b      	ldr	r3, [r7, #4]
34016dfa:	6a1b      	ldr	r3, [r3, #32]
34016dfc:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
34016e00:	d004      	beq.n	34016e0c <HAL_XSPI_Init+0x210>
34016e02:	f240 1167 	movw	r1, #359	@ 0x167
34016e06:	4814      	ldr	r0, [pc, #80]	@ (34016e58 <HAL_XSPI_Init+0x25c>)
34016e08:	f7eb f902 	bl	34002010 <assert_failed>
    assert_param(IS_XSPI_CLK_PRESCALER(hxspi->Init.ClockPrescaler));
34016e0c:	687b      	ldr	r3, [r7, #4]
34016e0e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34016e10:	2bff      	cmp	r3, #255	@ 0xff
34016e12:	d904      	bls.n	34016e1e <HAL_XSPI_Init+0x222>
34016e14:	f44f 71b4 	mov.w	r1, #360	@ 0x168
34016e18:	480f      	ldr	r0, [pc, #60]	@ (34016e58 <HAL_XSPI_Init+0x25c>)
34016e1a:	f7eb f8f9 	bl	34002010 <assert_failed>
    assert_param(IS_XSPI_SAMPLE_SHIFTING(hxspi->Init.SampleShifting));
34016e1e:	687b      	ldr	r3, [r7, #4]
34016e20:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34016e22:	2b00      	cmp	r3, #0
34016e24:	d009      	beq.n	34016e3a <HAL_XSPI_Init+0x23e>
34016e26:	687b      	ldr	r3, [r7, #4]
34016e28:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34016e2a:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34016e2e:	d004      	beq.n	34016e3a <HAL_XSPI_Init+0x23e>
34016e30:	f240 1169 	movw	r1, #361	@ 0x169
34016e34:	4808      	ldr	r0, [pc, #32]	@ (34016e58 <HAL_XSPI_Init+0x25c>)
34016e36:	f7eb f8eb 	bl	34002010 <assert_failed>
    assert_param(IS_XSPI_DHQC(hxspi->Init.DelayHoldQuarterCycle));
34016e3a:	687b      	ldr	r3, [r7, #4]
34016e3c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34016e3e:	2b00      	cmp	r3, #0
34016e40:	d00c      	beq.n	34016e5c <HAL_XSPI_Init+0x260>
34016e42:	687b      	ldr	r3, [r7, #4]
34016e44:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34016e46:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34016e4a:	d007      	beq.n	34016e5c <HAL_XSPI_Init+0x260>
34016e4c:	f44f 71b5 	mov.w	r1, #362	@ 0x16a
34016e50:	4801      	ldr	r0, [pc, #4]	@ (34016e58 <HAL_XSPI_Init+0x25c>)
34016e52:	f7eb f8dd 	bl	34002010 <assert_failed>
34016e56:	e001      	b.n	34016e5c <HAL_XSPI_Init+0x260>
34016e58:	3401f094 	.word	0x3401f094
    assert_param(IS_XSPI_CS_BOUND(hxspi->Init.ChipSelectBoundary));
34016e5c:	687b      	ldr	r3, [r7, #4]
34016e5e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016e60:	2b00      	cmp	r3, #0
34016e62:	f000 8081 	beq.w	34016f68 <HAL_XSPI_Init+0x36c>
34016e66:	687b      	ldr	r3, [r7, #4]
34016e68:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016e6a:	2b01      	cmp	r3, #1
34016e6c:	d07c      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016e6e:	687b      	ldr	r3, [r7, #4]
34016e70:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016e72:	2b02      	cmp	r3, #2
34016e74:	d078      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016e76:	687b      	ldr	r3, [r7, #4]
34016e78:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016e7a:	2b03      	cmp	r3, #3
34016e7c:	d074      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016e7e:	687b      	ldr	r3, [r7, #4]
34016e80:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016e82:	2b04      	cmp	r3, #4
34016e84:	d070      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016e86:	687b      	ldr	r3, [r7, #4]
34016e88:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016e8a:	2b05      	cmp	r3, #5
34016e8c:	d06c      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016e8e:	687b      	ldr	r3, [r7, #4]
34016e90:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016e92:	2b06      	cmp	r3, #6
34016e94:	d068      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016e96:	687b      	ldr	r3, [r7, #4]
34016e98:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016e9a:	2b07      	cmp	r3, #7
34016e9c:	d064      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016e9e:	687b      	ldr	r3, [r7, #4]
34016ea0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016ea2:	2b08      	cmp	r3, #8
34016ea4:	d060      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016ea6:	687b      	ldr	r3, [r7, #4]
34016ea8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016eaa:	2b09      	cmp	r3, #9
34016eac:	d05c      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016eae:	687b      	ldr	r3, [r7, #4]
34016eb0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016eb2:	2b0a      	cmp	r3, #10
34016eb4:	d058      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016eb6:	687b      	ldr	r3, [r7, #4]
34016eb8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016eba:	2b0b      	cmp	r3, #11
34016ebc:	d054      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016ebe:	687b      	ldr	r3, [r7, #4]
34016ec0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016ec2:	2b0c      	cmp	r3, #12
34016ec4:	d050      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016ec6:	687b      	ldr	r3, [r7, #4]
34016ec8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016eca:	2b0d      	cmp	r3, #13
34016ecc:	d04c      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016ece:	687b      	ldr	r3, [r7, #4]
34016ed0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016ed2:	2b0e      	cmp	r3, #14
34016ed4:	d048      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016ed6:	687b      	ldr	r3, [r7, #4]
34016ed8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016eda:	2b0f      	cmp	r3, #15
34016edc:	d044      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016ede:	687b      	ldr	r3, [r7, #4]
34016ee0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016ee2:	2b10      	cmp	r3, #16
34016ee4:	d040      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016ee6:	687b      	ldr	r3, [r7, #4]
34016ee8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016eea:	2b11      	cmp	r3, #17
34016eec:	d03c      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016eee:	687b      	ldr	r3, [r7, #4]
34016ef0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016ef2:	2b12      	cmp	r3, #18
34016ef4:	d038      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016ef6:	687b      	ldr	r3, [r7, #4]
34016ef8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016efa:	2b13      	cmp	r3, #19
34016efc:	d034      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016efe:	687b      	ldr	r3, [r7, #4]
34016f00:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016f02:	2b14      	cmp	r3, #20
34016f04:	d030      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016f06:	687b      	ldr	r3, [r7, #4]
34016f08:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016f0a:	2b15      	cmp	r3, #21
34016f0c:	d02c      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016f0e:	687b      	ldr	r3, [r7, #4]
34016f10:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016f12:	2b16      	cmp	r3, #22
34016f14:	d028      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016f16:	687b      	ldr	r3, [r7, #4]
34016f18:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016f1a:	2b17      	cmp	r3, #23
34016f1c:	d024      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016f1e:	687b      	ldr	r3, [r7, #4]
34016f20:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016f22:	2b18      	cmp	r3, #24
34016f24:	d020      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016f26:	687b      	ldr	r3, [r7, #4]
34016f28:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016f2a:	2b19      	cmp	r3, #25
34016f2c:	d01c      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016f2e:	687b      	ldr	r3, [r7, #4]
34016f30:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016f32:	2b1a      	cmp	r3, #26
34016f34:	d018      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016f36:	687b      	ldr	r3, [r7, #4]
34016f38:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016f3a:	2b1b      	cmp	r3, #27
34016f3c:	d014      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016f3e:	687b      	ldr	r3, [r7, #4]
34016f40:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016f42:	2b1c      	cmp	r3, #28
34016f44:	d010      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016f46:	687b      	ldr	r3, [r7, #4]
34016f48:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016f4a:	2b1d      	cmp	r3, #29
34016f4c:	d00c      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016f4e:	687b      	ldr	r3, [r7, #4]
34016f50:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016f52:	2b1e      	cmp	r3, #30
34016f54:	d008      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016f56:	687b      	ldr	r3, [r7, #4]
34016f58:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34016f5a:	2b1f      	cmp	r3, #31
34016f5c:	d004      	beq.n	34016f68 <HAL_XSPI_Init+0x36c>
34016f5e:	f240 116b 	movw	r1, #363	@ 0x16b
34016f62:	4895      	ldr	r0, [pc, #596]	@ (340171b8 <HAL_XSPI_Init+0x5bc>)
34016f64:	f7eb f854 	bl	34002010 <assert_failed>
    assert_param(IS_XSPI_FIFO_THRESHOLD_BYTE(hxspi->Init.FifoThresholdByte));
34016f68:	687b      	ldr	r3, [r7, #4]
34016f6a:	685b      	ldr	r3, [r3, #4]
34016f6c:	2b00      	cmp	r3, #0
34016f6e:	d003      	beq.n	34016f78 <HAL_XSPI_Init+0x37c>
34016f70:	687b      	ldr	r3, [r7, #4]
34016f72:	685b      	ldr	r3, [r3, #4]
34016f74:	2b40      	cmp	r3, #64	@ 0x40
34016f76:	d904      	bls.n	34016f82 <HAL_XSPI_Init+0x386>
34016f78:	f44f 71b6 	mov.w	r1, #364	@ 0x16c
34016f7c:	488e      	ldr	r0, [pc, #568]	@ (340171b8 <HAL_XSPI_Init+0x5bc>)
34016f7e:	f7eb f847 	bl	34002010 <assert_failed>
    assert_param(IS_XSPI_MAXTRAN(hxspi->Init.MaxTran));
34016f82:	687b      	ldr	r3, [r7, #4]
34016f84:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34016f86:	2bff      	cmp	r3, #255	@ 0xff
34016f88:	d904      	bls.n	34016f94 <HAL_XSPI_Init+0x398>
34016f8a:	f240 116d 	movw	r1, #365	@ 0x16d
34016f8e:	488a      	ldr	r0, [pc, #552]	@ (340171b8 <HAL_XSPI_Init+0x5bc>)
34016f90:	f7eb f83e 	bl	34002010 <assert_failed>
    assert_param(IS_XSPI_CSSEL(hxspi->Init.MemorySelect));
34016f94:	687b      	ldr	r3, [r7, #4]
34016f96:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34016f98:	2b00      	cmp	r3, #0
34016f9a:	d009      	beq.n	34016fb0 <HAL_XSPI_Init+0x3b4>
34016f9c:	687b      	ldr	r3, [r7, #4]
34016f9e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34016fa0:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34016fa4:	d004      	beq.n	34016fb0 <HAL_XSPI_Init+0x3b4>
34016fa6:	f44f 71b7 	mov.w	r1, #366	@ 0x16e
34016faa:	4883      	ldr	r0, [pc, #524]	@ (340171b8 <HAL_XSPI_Init+0x5bc>)
34016fac:	f7eb f830 	bl	34002010 <assert_failed>
    assert_param(IS_XSPI_EXTENDMEM(hxspi->Init.MemoryExtended));
34016fb0:	687b      	ldr	r3, [r7, #4]
34016fb2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34016fb4:	2b00      	cmp	r3, #0
34016fb6:	d009      	beq.n	34016fcc <HAL_XSPI_Init+0x3d0>
34016fb8:	687b      	ldr	r3, [r7, #4]
34016fba:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34016fbc:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34016fc0:	d004      	beq.n	34016fcc <HAL_XSPI_Init+0x3d0>
34016fc2:	f240 116f 	movw	r1, #367	@ 0x16f
34016fc6:	487c      	ldr	r0, [pc, #496]	@ (340171b8 <HAL_XSPI_Init+0x5bc>)
34016fc8:	f7eb f822 	bl	34002010 <assert_failed>
    /* Initialize error code */
    hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
34016fcc:	687b      	ldr	r3, [r7, #4]
34016fce:	2200      	movs	r2, #0
34016fd0:	65da      	str	r2, [r3, #92]	@ 0x5c

    /* Check if the state is the reset state */
    if (hxspi->State == HAL_XSPI_STATE_RESET)
34016fd2:	687b      	ldr	r3, [r7, #4]
34016fd4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34016fd6:	2b00      	cmp	r3, #0
34016fd8:	f040 80e8 	bne.w	340171ac <HAL_XSPI_Init+0x5b0>

      /* Init the low level hardware */
      hxspi->MspInitCallback(hxspi);
#else
      /* Initialization of the low level hardware */
      HAL_XSPI_MspInit(hxspi);
34016fdc:	6878      	ldr	r0, [r7, #4]
34016fde:	f000 f8fb 	bl	340171d8 <HAL_XSPI_MspInit>
#endif /* defined (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U) */

      /* Configure the default timeout for the XSPI memory access */
      (void)HAL_XSPI_SetTimeout(hxspi, HAL_XSPI_TIMEOUT_DEFAULT_VALUE);
34016fe2:	f241 3188 	movw	r1, #5000	@ 0x1388
34016fe6:	6878      	ldr	r0, [r7, #4]
34016fe8:	f000 fdc4 	bl	34017b74 <HAL_XSPI_SetTimeout>

      /* Configure memory type, device size, chip select high time, free running clock, clock mode */
      MODIFY_REG(hxspi->Instance->DCR1,
34016fec:	687b      	ldr	r3, [r7, #4]
34016fee:	681b      	ldr	r3, [r3, #0]
34016ff0:	689a      	ldr	r2, [r3, #8]
34016ff2:	4b72      	ldr	r3, [pc, #456]	@ (340171bc <HAL_XSPI_Init+0x5c0>)
34016ff4:	4013      	ands	r3, r2
34016ff6:	687a      	ldr	r2, [r7, #4]
34016ff8:	68d1      	ldr	r1, [r2, #12]
34016ffa:	687a      	ldr	r2, [r7, #4]
34016ffc:	6912      	ldr	r2, [r2, #16]
34016ffe:	0412      	lsls	r2, r2, #16
34017000:	4311      	orrs	r1, r2
34017002:	687a      	ldr	r2, [r7, #4]
34017004:	6952      	ldr	r2, [r2, #20]
34017006:	3a01      	subs	r2, #1
34017008:	0212      	lsls	r2, r2, #8
3401700a:	4311      	orrs	r1, r2
3401700c:	687a      	ldr	r2, [r7, #4]
3401700e:	69d2      	ldr	r2, [r2, #28]
34017010:	4311      	orrs	r1, r2
34017012:	687a      	ldr	r2, [r7, #4]
34017014:	6812      	ldr	r2, [r2, #0]
34017016:	430b      	orrs	r3, r1
34017018:	6093      	str	r3, [r2, #8]
                 (XSPI_DCR1_MTYP | XSPI_DCR1_DEVSIZE | XSPI_DCR1_CSHT | XSPI_DCR1_FRCK | XSPI_DCR1_CKMODE),
                 (hxspi->Init.MemoryType | ((hxspi->Init.MemorySize) << XSPI_DCR1_DEVSIZE_Pos) |
                  ((hxspi->Init.ChipSelectHighTimeCycle - 1U) << XSPI_DCR1_CSHT_Pos) | hxspi->Init.ClockMode));

      /* Configure wrap size */
      MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_WRAPSIZE, hxspi->Init.WrapSize);
3401701a:	687b      	ldr	r3, [r7, #4]
3401701c:	681b      	ldr	r3, [r3, #0]
3401701e:	68db      	ldr	r3, [r3, #12]
34017020:	f423 21e0 	bic.w	r1, r3, #458752	@ 0x70000
34017024:	687b      	ldr	r3, [r7, #4]
34017026:	6a1a      	ldr	r2, [r3, #32]
34017028:	687b      	ldr	r3, [r7, #4]
3401702a:	681b      	ldr	r3, [r3, #0]
3401702c:	430a      	orrs	r2, r1
3401702e:	60da      	str	r2, [r3, #12]

      /* Configure chip select boundary */
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_CSBOUND, (hxspi->Init.ChipSelectBoundary << XSPI_DCR3_CSBOUND_Pos));
34017030:	687b      	ldr	r3, [r7, #4]
34017032:	681b      	ldr	r3, [r3, #0]
34017034:	691b      	ldr	r3, [r3, #16]
34017036:	f423 11f8 	bic.w	r1, r3, #2031616	@ 0x1f0000
3401703a:	687b      	ldr	r3, [r7, #4]
3401703c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401703e:	041a      	lsls	r2, r3, #16
34017040:	687b      	ldr	r3, [r7, #4]
34017042:	681b      	ldr	r3, [r3, #0]
34017044:	430a      	orrs	r2, r1
34017046:	611a      	str	r2, [r3, #16]

      /* Configure maximum transfer */
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_MAXTRAN, \
34017048:	687b      	ldr	r3, [r7, #4]
3401704a:	681b      	ldr	r3, [r3, #0]
3401704c:	691b      	ldr	r3, [r3, #16]
3401704e:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
34017052:	687b      	ldr	r3, [r7, #4]
34017054:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
34017056:	687b      	ldr	r3, [r7, #4]
34017058:	681b      	ldr	r3, [r3, #0]
3401705a:	430a      	orrs	r2, r1
3401705c:	611a      	str	r2, [r3, #16]
                 (hxspi->Init.MaxTran << XSPI_DCR3_MAXTRAN_Pos));

      /* Configure refresh */
      hxspi->Instance->DCR4 = hxspi->Init.Refresh;
3401705e:	687b      	ldr	r3, [r7, #4]
34017060:	681b      	ldr	r3, [r3, #0]
34017062:	687a      	ldr	r2, [r7, #4]
34017064:	6b92      	ldr	r2, [r2, #56]	@ 0x38
34017066:	615a      	str	r2, [r3, #20]

      /* Configure FIFO threshold */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FTHRES, ((hxspi->Init.FifoThresholdByte - 1U) << XSPI_CR_FTHRES_Pos));
34017068:	687b      	ldr	r3, [r7, #4]
3401706a:	681b      	ldr	r3, [r3, #0]
3401706c:	681b      	ldr	r3, [r3, #0]
3401706e:	f423 517c 	bic.w	r1, r3, #16128	@ 0x3f00
34017072:	687b      	ldr	r3, [r7, #4]
34017074:	685b      	ldr	r3, [r3, #4]
34017076:	3b01      	subs	r3, #1
34017078:	021a      	lsls	r2, r3, #8
3401707a:	687b      	ldr	r3, [r7, #4]
3401707c:	681b      	ldr	r3, [r3, #0]
3401707e:	430a      	orrs	r2, r1
34017080:	601a      	str	r2, [r3, #0]

      /* Wait till busy flag is reset */
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
34017082:	687b      	ldr	r3, [r7, #4]
34017084:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34017086:	9300      	str	r3, [sp, #0]
34017088:	68bb      	ldr	r3, [r7, #8]
3401708a:	2200      	movs	r2, #0
3401708c:	2120      	movs	r1, #32
3401708e:	6878      	ldr	r0, [r7, #4]
34017090:	f000 fd7f 	bl	34017b92 <XSPI_WaitFlagStateUntilTimeout>
34017094:	4603      	mov	r3, r0
34017096:	73fb      	strb	r3, [r7, #15]

      if (status == HAL_OK)
34017098:	7bfb      	ldrb	r3, [r7, #15]
3401709a:	2b00      	cmp	r3, #0
3401709c:	f040 8086 	bne.w	340171ac <HAL_XSPI_Init+0x5b0>
      {
        /* Configure clock prescaler */
        MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
340170a0:	687b      	ldr	r3, [r7, #4]
340170a2:	681b      	ldr	r3, [r3, #0]
340170a4:	68db      	ldr	r3, [r3, #12]
340170a6:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
340170aa:	687b      	ldr	r3, [r7, #4]
340170ac:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
340170ae:	687b      	ldr	r3, [r7, #4]
340170b0:	681b      	ldr	r3, [r3, #0]
340170b2:	430a      	orrs	r2, r1
340170b4:	60da      	str	r2, [r3, #12]
                   ((hxspi->Init.ClockPrescaler) << XSPI_DCR2_PRESCALER_Pos));

        if (IS_XSPI_ALL_INSTANCE(hxspi->Instance))
340170b6:	687b      	ldr	r3, [r7, #4]
340170b8:	681b      	ldr	r3, [r3, #0]
340170ba:	4a41      	ldr	r2, [pc, #260]	@ (340171c0 <HAL_XSPI_Init+0x5c4>)
340170bc:	4293      	cmp	r3, r2
340170be:	d018      	beq.n	340170f2 <HAL_XSPI_Init+0x4f6>
340170c0:	687b      	ldr	r3, [r7, #4]
340170c2:	681b      	ldr	r3, [r3, #0]
340170c4:	4a3f      	ldr	r2, [pc, #252]	@ (340171c4 <HAL_XSPI_Init+0x5c8>)
340170c6:	4293      	cmp	r3, r2
340170c8:	d013      	beq.n	340170f2 <HAL_XSPI_Init+0x4f6>
340170ca:	687b      	ldr	r3, [r7, #4]
340170cc:	681b      	ldr	r3, [r3, #0]
340170ce:	4a3e      	ldr	r2, [pc, #248]	@ (340171c8 <HAL_XSPI_Init+0x5cc>)
340170d0:	4293      	cmp	r3, r2
340170d2:	d00e      	beq.n	340170f2 <HAL_XSPI_Init+0x4f6>
340170d4:	687b      	ldr	r3, [r7, #4]
340170d6:	681b      	ldr	r3, [r3, #0]
340170d8:	4a3c      	ldr	r2, [pc, #240]	@ (340171cc <HAL_XSPI_Init+0x5d0>)
340170da:	4293      	cmp	r3, r2
340170dc:	d009      	beq.n	340170f2 <HAL_XSPI_Init+0x4f6>
340170de:	687b      	ldr	r3, [r7, #4]
340170e0:	681b      	ldr	r3, [r3, #0]
340170e2:	4a3b      	ldr	r2, [pc, #236]	@ (340171d0 <HAL_XSPI_Init+0x5d4>)
340170e4:	4293      	cmp	r3, r2
340170e6:	d004      	beq.n	340170f2 <HAL_XSPI_Init+0x4f6>
340170e8:	687b      	ldr	r3, [r7, #4]
340170ea:	681b      	ldr	r3, [r3, #0]
340170ec:	4a39      	ldr	r2, [pc, #228]	@ (340171d4 <HAL_XSPI_Init+0x5d8>)
340170ee:	4293      	cmp	r3, r2
340170f0:	d10f      	bne.n	34017112 <HAL_XSPI_Init+0x516>
        {
          /* The configuration of clock prescaler trigger automatically a calibration process.
          So it is necessary to wait the calibration is complete */
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
340170f2:	687b      	ldr	r3, [r7, #4]
340170f4:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
340170f6:	9300      	str	r3, [sp, #0]
340170f8:	68bb      	ldr	r3, [r7, #8]
340170fa:	2200      	movs	r2, #0
340170fc:	2120      	movs	r1, #32
340170fe:	6878      	ldr	r0, [r7, #4]
34017100:	f000 fd47 	bl	34017b92 <XSPI_WaitFlagStateUntilTimeout>
34017104:	4603      	mov	r3, r0
34017106:	73fb      	strb	r3, [r7, #15]
          if (status != HAL_OK)
34017108:	7bfb      	ldrb	r3, [r7, #15]
3401710a:	2b00      	cmp	r3, #0
3401710c:	d001      	beq.n	34017112 <HAL_XSPI_Init+0x516>
          {
            return status;
3401710e:	7bfb      	ldrb	r3, [r7, #15]
34017110:	e04d      	b.n	340171ae <HAL_XSPI_Init+0x5b2>
          }
        }
        /* Configure Dual Memory mode and CS Selection */
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_DMM | XSPI_CR_CSSEL),
34017112:	687b      	ldr	r3, [r7, #4]
34017114:	681b      	ldr	r3, [r3, #0]
34017116:	681b      	ldr	r3, [r3, #0]
34017118:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
3401711c:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
34017120:	687a      	ldr	r2, [r7, #4]
34017122:	6891      	ldr	r1, [r2, #8]
34017124:	687a      	ldr	r2, [r7, #4]
34017126:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
34017128:	4311      	orrs	r1, r2
3401712a:	687a      	ldr	r2, [r7, #4]
3401712c:	6812      	ldr	r2, [r2, #0]
3401712e:	430b      	orrs	r3, r1
34017130:	6013      	str	r3, [r2, #0]
                   (hxspi->Init.MemoryMode | hxspi->Init.MemorySelect));

        /* Configure sample shifting and delay hold quarter cycle */
        MODIFY_REG(hxspi->Instance->TCR, (XSPI_TCR_SSHIFT | XSPI_TCR_DHQC),
34017132:	687b      	ldr	r3, [r7, #4]
34017134:	681b      	ldr	r3, [r3, #0]
34017136:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
3401713a:	f023 41a0 	bic.w	r1, r3, #1342177280	@ 0x50000000
3401713e:	687b      	ldr	r3, [r7, #4]
34017140:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34017142:	687b      	ldr	r3, [r7, #4]
34017144:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34017146:	431a      	orrs	r2, r3
34017148:	687b      	ldr	r3, [r7, #4]
3401714a:	681b      	ldr	r3, [r3, #0]
3401714c:	430a      	orrs	r2, r1
3401714e:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
                   (hxspi->Init.SampleShifting | hxspi->Init.DelayHoldQuarterCycle));

        /* Enable XSPI */
        HAL_XSPI_ENABLE(hxspi);
34017152:	687b      	ldr	r3, [r7, #4]
34017154:	681b      	ldr	r3, [r3, #0]
34017156:	681a      	ldr	r2, [r3, #0]
34017158:	687b      	ldr	r3, [r7, #4]
3401715a:	681b      	ldr	r3, [r3, #0]
3401715c:	f042 0201 	orr.w	r2, r2, #1
34017160:	601a      	str	r2, [r3, #0]

        /* Enable free running clock if needed : must be done after XSPI enable */
        if (hxspi->Init.FreeRunningClock == HAL_XSPI_FREERUNCLK_ENABLE)
34017162:	687b      	ldr	r3, [r7, #4]
34017164:	699b      	ldr	r3, [r3, #24]
34017166:	2b02      	cmp	r3, #2
34017168:	d107      	bne.n	3401717a <HAL_XSPI_Init+0x57e>
        {
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_FRCK);
3401716a:	687b      	ldr	r3, [r7, #4]
3401716c:	681b      	ldr	r3, [r3, #0]
3401716e:	689a      	ldr	r2, [r3, #8]
34017170:	687b      	ldr	r3, [r7, #4]
34017172:	681b      	ldr	r3, [r3, #0]
34017174:	f042 0202 	orr.w	r2, r2, #2
34017178:	609a      	str	r2, [r3, #8]
        }

        if (hxspi->Init.MemoryExtended == HAL_XSPI_CSSEL_HW)
3401717a:	687b      	ldr	r3, [r7, #4]
3401717c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401717e:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34017182:	d107      	bne.n	34017194 <HAL_XSPI_Init+0x598>
        {
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_EXTENDMEM);
34017184:	687b      	ldr	r3, [r7, #4]
34017186:	681b      	ldr	r3, [r3, #0]
34017188:	689a      	ldr	r2, [r3, #8]
3401718a:	687b      	ldr	r3, [r7, #4]
3401718c:	681b      	ldr	r3, [r3, #0]
3401718e:	f442 1200 	orr.w	r2, r2, #2097152	@ 0x200000
34017192:	609a      	str	r2, [r3, #8]
        }

        /* Initialize the XSPI state */
        if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
34017194:	687b      	ldr	r3, [r7, #4]
34017196:	68db      	ldr	r3, [r3, #12]
34017198:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3401719c:	d103      	bne.n	340171a6 <HAL_XSPI_Init+0x5aa>
        {
          hxspi->State = HAL_XSPI_STATE_HYPERBUS_INIT;
3401719e:	687b      	ldr	r3, [r7, #4]
340171a0:	2201      	movs	r2, #1
340171a2:	659a      	str	r2, [r3, #88]	@ 0x58
340171a4:	e002      	b.n	340171ac <HAL_XSPI_Init+0x5b0>
        }
        else
        {
          hxspi->State = HAL_XSPI_STATE_READY;
340171a6:	687b      	ldr	r3, [r7, #4]
340171a8:	2202      	movs	r2, #2
340171aa:	659a      	str	r2, [r3, #88]	@ 0x58
        }
      }
    }
  }
  return status;
340171ac:	7bfb      	ldrb	r3, [r7, #15]
}
340171ae:	4618      	mov	r0, r3
340171b0:	3710      	adds	r7, #16
340171b2:	46bd      	mov	sp, r7
340171b4:	bd80      	pop	{r7, pc}
340171b6:	bf00      	nop
340171b8:	3401f094 	.word	0x3401f094
340171bc:	f8e0c0fc 	.word	0xf8e0c0fc
340171c0:	58025000 	.word	0x58025000
340171c4:	48025000 	.word	0x48025000
340171c8:	5802a000 	.word	0x5802a000
340171cc:	4802a000 	.word	0x4802a000
340171d0:	5802d000 	.word	0x5802d000
340171d4:	4802d000 	.word	0x4802d000

340171d8 <HAL_XSPI_MspInit>:
  * @brief  Initialize the XSPI MSP.
  * @param  hxspi : XSPI handle
  * @retval None
  */
__weak void HAL_XSPI_MspInit(XSPI_HandleTypeDef *hxspi)
{
340171d8:	b480      	push	{r7}
340171da:	b083      	sub	sp, #12
340171dc:	af00      	add	r7, sp, #0
340171de:	6078      	str	r0, [r7, #4]
  UNUSED(hxspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_XSPI_MspInit can be implemented in the user file
   */
}
340171e0:	bf00      	nop
340171e2:	370c      	adds	r7, #12
340171e4:	46bd      	mov	sp, r7
340171e6:	f85d 7b04 	ldr.w	r7, [sp], #4
340171ea:	4770      	bx	lr

340171ec <HAL_XSPI_Command>:
  * @param  pCmd     : structure that contains the command configuration information
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Command(XSPI_HandleTypeDef *hxspi, const XSPI_RegularCmdTypeDef *pCmd, uint32_t Timeout)
{
340171ec:	b580      	push	{r7, lr}
340171ee:	b08a      	sub	sp, #40	@ 0x28
340171f0:	af02      	add	r7, sp, #8
340171f2:	60f8      	str	r0, [r7, #12]
340171f4:	60b9      	str	r1, [r7, #8]
340171f6:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t state;
  uint32_t tickstart = HAL_GetTick();
340171f8:	f7ec ff2c 	bl	34004054 <HAL_GetTick>
340171fc:	61b8      	str	r0, [r7, #24]

  /* Check the parameters of the command structure */
  assert_param(IS_XSPI_OPERATION_TYPE(pCmd->OperationType));
340171fe:	68bb      	ldr	r3, [r7, #8]
34017200:	681b      	ldr	r3, [r3, #0]
34017202:	2b00      	cmp	r3, #0
34017204:	d010      	beq.n	34017228 <HAL_XSPI_Command+0x3c>
34017206:	68bb      	ldr	r3, [r7, #8]
34017208:	681b      	ldr	r3, [r3, #0]
3401720a:	2b01      	cmp	r3, #1
3401720c:	d00c      	beq.n	34017228 <HAL_XSPI_Command+0x3c>
3401720e:	68bb      	ldr	r3, [r7, #8]
34017210:	681b      	ldr	r3, [r3, #0]
34017212:	2b02      	cmp	r3, #2
34017214:	d008      	beq.n	34017228 <HAL_XSPI_Command+0x3c>
34017216:	68bb      	ldr	r3, [r7, #8]
34017218:	681b      	ldr	r3, [r3, #0]
3401721a:	2b03      	cmp	r3, #3
3401721c:	d004      	beq.n	34017228 <HAL_XSPI_Command+0x3c>
3401721e:	f240 313e 	movw	r1, #830	@ 0x33e
34017222:	4887      	ldr	r0, [pc, #540]	@ (34017440 <HAL_XSPI_Command+0x254>)
34017224:	f7ea fef4 	bl	34002010 <assert_failed>
  if (hxspi->Init.MemoryMode == HAL_XSPI_SINGLE_MEM)
34017228:	68fb      	ldr	r3, [r7, #12]
3401722a:	689b      	ldr	r3, [r3, #8]
3401722c:	2b00      	cmp	r3, #0
3401722e:	d120      	bne.n	34017272 <HAL_XSPI_Command+0x86>
  {
    assert_param(IS_XSPI_IO_SELECT(pCmd->IOSelect));
34017230:	68bb      	ldr	r3, [r7, #8]
34017232:	685b      	ldr	r3, [r3, #4]
34017234:	2b00      	cmp	r3, #0
34017236:	d01c      	beq.n	34017272 <HAL_XSPI_Command+0x86>
34017238:	68bb      	ldr	r3, [r7, #8]
3401723a:	685b      	ldr	r3, [r3, #4]
3401723c:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34017240:	d017      	beq.n	34017272 <HAL_XSPI_Command+0x86>
34017242:	68bb      	ldr	r3, [r7, #8]
34017244:	685b      	ldr	r3, [r3, #4]
34017246:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
3401724a:	d012      	beq.n	34017272 <HAL_XSPI_Command+0x86>
3401724c:	68bb      	ldr	r3, [r7, #8]
3401724e:	685b      	ldr	r3, [r3, #4]
34017250:	f1b3 4f40 	cmp.w	r3, #3221225472	@ 0xc0000000
34017254:	d00d      	beq.n	34017272 <HAL_XSPI_Command+0x86>
34017256:	68bb      	ldr	r3, [r7, #8]
34017258:	685b      	ldr	r3, [r3, #4]
3401725a:	2b00      	cmp	r3, #0
3401725c:	d009      	beq.n	34017272 <HAL_XSPI_Command+0x86>
3401725e:	68bb      	ldr	r3, [r7, #8]
34017260:	685b      	ldr	r3, [r3, #4]
34017262:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
34017266:	d004      	beq.n	34017272 <HAL_XSPI_Command+0x86>
34017268:	f240 3141 	movw	r1, #833	@ 0x341
3401726c:	4874      	ldr	r0, [pc, #464]	@ (34017440 <HAL_XSPI_Command+0x254>)
3401726e:	f7ea fecf 	bl	34002010 <assert_failed>
  }

  assert_param(IS_XSPI_INSTRUCTION_MODE(pCmd->InstructionMode));
34017272:	68bb      	ldr	r3, [r7, #8]
34017274:	68db      	ldr	r3, [r3, #12]
34017276:	2b00      	cmp	r3, #0
34017278:	d014      	beq.n	340172a4 <HAL_XSPI_Command+0xb8>
3401727a:	68bb      	ldr	r3, [r7, #8]
3401727c:	68db      	ldr	r3, [r3, #12]
3401727e:	2b01      	cmp	r3, #1
34017280:	d010      	beq.n	340172a4 <HAL_XSPI_Command+0xb8>
34017282:	68bb      	ldr	r3, [r7, #8]
34017284:	68db      	ldr	r3, [r3, #12]
34017286:	2b02      	cmp	r3, #2
34017288:	d00c      	beq.n	340172a4 <HAL_XSPI_Command+0xb8>
3401728a:	68bb      	ldr	r3, [r7, #8]
3401728c:	68db      	ldr	r3, [r3, #12]
3401728e:	2b03      	cmp	r3, #3
34017290:	d008      	beq.n	340172a4 <HAL_XSPI_Command+0xb8>
34017292:	68bb      	ldr	r3, [r7, #8]
34017294:	68db      	ldr	r3, [r3, #12]
34017296:	2b04      	cmp	r3, #4
34017298:	d004      	beq.n	340172a4 <HAL_XSPI_Command+0xb8>
3401729a:	f44f 7151 	mov.w	r1, #836	@ 0x344
3401729e:	4868      	ldr	r0, [pc, #416]	@ (34017440 <HAL_XSPI_Command+0x254>)
340172a0:	f7ea feb6 	bl	34002010 <assert_failed>
  if (pCmd->InstructionMode != HAL_XSPI_INSTRUCTION_NONE)
340172a4:	68bb      	ldr	r3, [r7, #8]
340172a6:	68db      	ldr	r3, [r3, #12]
340172a8:	2b00      	cmp	r3, #0
340172aa:	d021      	beq.n	340172f0 <HAL_XSPI_Command+0x104>
  {
    assert_param(IS_XSPI_INSTRUCTION_WIDTH(pCmd->InstructionWidth));
340172ac:	68bb      	ldr	r3, [r7, #8]
340172ae:	691b      	ldr	r3, [r3, #16]
340172b0:	2b00      	cmp	r3, #0
340172b2:	d010      	beq.n	340172d6 <HAL_XSPI_Command+0xea>
340172b4:	68bb      	ldr	r3, [r7, #8]
340172b6:	691b      	ldr	r3, [r3, #16]
340172b8:	2b10      	cmp	r3, #16
340172ba:	d00c      	beq.n	340172d6 <HAL_XSPI_Command+0xea>
340172bc:	68bb      	ldr	r3, [r7, #8]
340172be:	691b      	ldr	r3, [r3, #16]
340172c0:	2b20      	cmp	r3, #32
340172c2:	d008      	beq.n	340172d6 <HAL_XSPI_Command+0xea>
340172c4:	68bb      	ldr	r3, [r7, #8]
340172c6:	691b      	ldr	r3, [r3, #16]
340172c8:	2b30      	cmp	r3, #48	@ 0x30
340172ca:	d004      	beq.n	340172d6 <HAL_XSPI_Command+0xea>
340172cc:	f240 3147 	movw	r1, #839	@ 0x347
340172d0:	485b      	ldr	r0, [pc, #364]	@ (34017440 <HAL_XSPI_Command+0x254>)
340172d2:	f7ea fe9d 	bl	34002010 <assert_failed>
    assert_param(IS_XSPI_INSTRUCTION_DTR_MODE(pCmd->InstructionDTRMode));
340172d6:	68bb      	ldr	r3, [r7, #8]
340172d8:	695b      	ldr	r3, [r3, #20]
340172da:	2b00      	cmp	r3, #0
340172dc:	d008      	beq.n	340172f0 <HAL_XSPI_Command+0x104>
340172de:	68bb      	ldr	r3, [r7, #8]
340172e0:	695b      	ldr	r3, [r3, #20]
340172e2:	2b08      	cmp	r3, #8
340172e4:	d004      	beq.n	340172f0 <HAL_XSPI_Command+0x104>
340172e6:	f44f 7152 	mov.w	r1, #840	@ 0x348
340172ea:	4855      	ldr	r0, [pc, #340]	@ (34017440 <HAL_XSPI_Command+0x254>)
340172ec:	f7ea fe90 	bl	34002010 <assert_failed>
  }

  assert_param(IS_XSPI_ADDRESS_MODE(pCmd->AddressMode));
340172f0:	68bb      	ldr	r3, [r7, #8]
340172f2:	69db      	ldr	r3, [r3, #28]
340172f4:	2b00      	cmp	r3, #0
340172f6:	d018      	beq.n	3401732a <HAL_XSPI_Command+0x13e>
340172f8:	68bb      	ldr	r3, [r7, #8]
340172fa:	69db      	ldr	r3, [r3, #28]
340172fc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34017300:	d013      	beq.n	3401732a <HAL_XSPI_Command+0x13e>
34017302:	68bb      	ldr	r3, [r7, #8]
34017304:	69db      	ldr	r3, [r3, #28]
34017306:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3401730a:	d00e      	beq.n	3401732a <HAL_XSPI_Command+0x13e>
3401730c:	68bb      	ldr	r3, [r7, #8]
3401730e:	69db      	ldr	r3, [r3, #28]
34017310:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34017314:	d009      	beq.n	3401732a <HAL_XSPI_Command+0x13e>
34017316:	68bb      	ldr	r3, [r7, #8]
34017318:	69db      	ldr	r3, [r3, #28]
3401731a:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3401731e:	d004      	beq.n	3401732a <HAL_XSPI_Command+0x13e>
34017320:	f240 314b 	movw	r1, #843	@ 0x34b
34017324:	4846      	ldr	r0, [pc, #280]	@ (34017440 <HAL_XSPI_Command+0x254>)
34017326:	f7ea fe73 	bl	34002010 <assert_failed>
  if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
3401732a:	68bb      	ldr	r3, [r7, #8]
3401732c:	69db      	ldr	r3, [r3, #28]
3401732e:	2b00      	cmp	r3, #0
34017330:	d025      	beq.n	3401737e <HAL_XSPI_Command+0x192>
  {
    assert_param(IS_XSPI_ADDRESS_WIDTH(pCmd->AddressWidth));
34017332:	68bb      	ldr	r3, [r7, #8]
34017334:	6a1b      	ldr	r3, [r3, #32]
34017336:	2b00      	cmp	r3, #0
34017338:	d013      	beq.n	34017362 <HAL_XSPI_Command+0x176>
3401733a:	68bb      	ldr	r3, [r7, #8]
3401733c:	6a1b      	ldr	r3, [r3, #32]
3401733e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34017342:	d00e      	beq.n	34017362 <HAL_XSPI_Command+0x176>
34017344:	68bb      	ldr	r3, [r7, #8]
34017346:	6a1b      	ldr	r3, [r3, #32]
34017348:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3401734c:	d009      	beq.n	34017362 <HAL_XSPI_Command+0x176>
3401734e:	68bb      	ldr	r3, [r7, #8]
34017350:	6a1b      	ldr	r3, [r3, #32]
34017352:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
34017356:	d004      	beq.n	34017362 <HAL_XSPI_Command+0x176>
34017358:	f240 314e 	movw	r1, #846	@ 0x34e
3401735c:	4838      	ldr	r0, [pc, #224]	@ (34017440 <HAL_XSPI_Command+0x254>)
3401735e:	f7ea fe57 	bl	34002010 <assert_failed>
    assert_param(IS_XSPI_ADDRESS_DTR_MODE(pCmd->AddressDTRMode));
34017362:	68bb      	ldr	r3, [r7, #8]
34017364:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34017366:	2b00      	cmp	r3, #0
34017368:	d009      	beq.n	3401737e <HAL_XSPI_Command+0x192>
3401736a:	68bb      	ldr	r3, [r7, #8]
3401736c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401736e:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34017372:	d004      	beq.n	3401737e <HAL_XSPI_Command+0x192>
34017374:	f240 314f 	movw	r1, #847	@ 0x34f
34017378:	4831      	ldr	r0, [pc, #196]	@ (34017440 <HAL_XSPI_Command+0x254>)
3401737a:	f7ea fe49 	bl	34002010 <assert_failed>
  }

  assert_param(IS_XSPI_ALT_BYTES_MODE(pCmd->AlternateBytesMode));
3401737e:	68bb      	ldr	r3, [r7, #8]
34017380:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34017382:	2b00      	cmp	r3, #0
34017384:	d018      	beq.n	340173b8 <HAL_XSPI_Command+0x1cc>
34017386:	68bb      	ldr	r3, [r7, #8]
34017388:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401738a:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3401738e:	d013      	beq.n	340173b8 <HAL_XSPI_Command+0x1cc>
34017390:	68bb      	ldr	r3, [r7, #8]
34017392:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34017394:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34017398:	d00e      	beq.n	340173b8 <HAL_XSPI_Command+0x1cc>
3401739a:	68bb      	ldr	r3, [r7, #8]
3401739c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401739e:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
340173a2:	d009      	beq.n	340173b8 <HAL_XSPI_Command+0x1cc>
340173a4:	68bb      	ldr	r3, [r7, #8]
340173a6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340173a8:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
340173ac:	d004      	beq.n	340173b8 <HAL_XSPI_Command+0x1cc>
340173ae:	f240 3152 	movw	r1, #850	@ 0x352
340173b2:	4823      	ldr	r0, [pc, #140]	@ (34017440 <HAL_XSPI_Command+0x254>)
340173b4:	f7ea fe2c 	bl	34002010 <assert_failed>
  if (pCmd->AlternateBytesMode != HAL_XSPI_ALT_BYTES_NONE)
340173b8:	68bb      	ldr	r3, [r7, #8]
340173ba:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340173bc:	2b00      	cmp	r3, #0
340173be:	d025      	beq.n	3401740c <HAL_XSPI_Command+0x220>
  {
    assert_param(IS_XSPI_ALT_BYTES_WIDTH(pCmd->AlternateBytesWidth));
340173c0:	68bb      	ldr	r3, [r7, #8]
340173c2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
340173c4:	2b00      	cmp	r3, #0
340173c6:	d013      	beq.n	340173f0 <HAL_XSPI_Command+0x204>
340173c8:	68bb      	ldr	r3, [r7, #8]
340173ca:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
340173cc:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
340173d0:	d00e      	beq.n	340173f0 <HAL_XSPI_Command+0x204>
340173d2:	68bb      	ldr	r3, [r7, #8]
340173d4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
340173d6:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
340173da:	d009      	beq.n	340173f0 <HAL_XSPI_Command+0x204>
340173dc:	68bb      	ldr	r3, [r7, #8]
340173de:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
340173e0:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
340173e4:	d004      	beq.n	340173f0 <HAL_XSPI_Command+0x204>
340173e6:	f240 3155 	movw	r1, #853	@ 0x355
340173ea:	4815      	ldr	r0, [pc, #84]	@ (34017440 <HAL_XSPI_Command+0x254>)
340173ec:	f7ea fe10 	bl	34002010 <assert_failed>
    assert_param(IS_XSPI_ALT_BYTES_DTR_MODE(pCmd->AlternateBytesDTRMode));
340173f0:	68bb      	ldr	r3, [r7, #8]
340173f2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
340173f4:	2b00      	cmp	r3, #0
340173f6:	d009      	beq.n	3401740c <HAL_XSPI_Command+0x220>
340173f8:	68bb      	ldr	r3, [r7, #8]
340173fa:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
340173fc:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
34017400:	d004      	beq.n	3401740c <HAL_XSPI_Command+0x220>
34017402:	f240 3156 	movw	r1, #854	@ 0x356
34017406:	480e      	ldr	r0, [pc, #56]	@ (34017440 <HAL_XSPI_Command+0x254>)
34017408:	f7ea fe02 	bl	34002010 <assert_failed>
  }

  assert_param(IS_XSPI_DATA_MODE(hxspi->Init.MemoryType, pCmd->DataMode));
3401740c:	68fb      	ldr	r3, [r7, #12]
3401740e:	68db      	ldr	r3, [r3, #12]
34017410:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
34017414:	d116      	bne.n	34017444 <HAL_XSPI_Command+0x258>
34017416:	68bb      	ldr	r3, [r7, #8]
34017418:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401741a:	2b00      	cmp	r3, #0
3401741c:	d009      	beq.n	34017432 <HAL_XSPI_Command+0x246>
3401741e:	68bb      	ldr	r3, [r7, #8]
34017420:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34017422:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
34017426:	d004      	beq.n	34017432 <HAL_XSPI_Command+0x246>
34017428:	68bb      	ldr	r3, [r7, #8]
3401742a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401742c:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
34017430:	d101      	bne.n	34017436 <HAL_XSPI_Command+0x24a>
34017432:	2301      	movs	r3, #1
34017434:	e000      	b.n	34017438 <HAL_XSPI_Command+0x24c>
34017436:	2300      	movs	r3, #0
34017438:	f003 0301 	and.w	r3, r3, #1
3401743c:	b2db      	uxtb	r3, r3
3401743e:	e024      	b.n	3401748a <HAL_XSPI_Command+0x29e>
34017440:	3401f094 	.word	0x3401f094
34017444:	68bb      	ldr	r3, [r7, #8]
34017446:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34017448:	2b00      	cmp	r3, #0
3401744a:	d018      	beq.n	3401747e <HAL_XSPI_Command+0x292>
3401744c:	68bb      	ldr	r3, [r7, #8]
3401744e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34017450:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34017454:	d013      	beq.n	3401747e <HAL_XSPI_Command+0x292>
34017456:	68bb      	ldr	r3, [r7, #8]
34017458:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401745a:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3401745e:	d00e      	beq.n	3401747e <HAL_XSPI_Command+0x292>
34017460:	68bb      	ldr	r3, [r7, #8]
34017462:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34017464:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
34017468:	d009      	beq.n	3401747e <HAL_XSPI_Command+0x292>
3401746a:	68bb      	ldr	r3, [r7, #8]
3401746c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401746e:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
34017472:	d004      	beq.n	3401747e <HAL_XSPI_Command+0x292>
34017474:	68bb      	ldr	r3, [r7, #8]
34017476:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34017478:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
3401747c:	d101      	bne.n	34017482 <HAL_XSPI_Command+0x296>
3401747e:	2301      	movs	r3, #1
34017480:	e000      	b.n	34017484 <HAL_XSPI_Command+0x298>
34017482:	2300      	movs	r3, #0
34017484:	f003 0301 	and.w	r3, r3, #1
34017488:	b2db      	uxtb	r3, r3
3401748a:	2b00      	cmp	r3, #0
3401748c:	d104      	bne.n	34017498 <HAL_XSPI_Command+0x2ac>
3401748e:	f240 3159 	movw	r1, #857	@ 0x359
34017492:	485e      	ldr	r0, [pc, #376]	@ (3401760c <HAL_XSPI_Command+0x420>)
34017494:	f7ea fdbc 	bl	34002010 <assert_failed>

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34017498:	68bb      	ldr	r3, [r7, #8]
3401749a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401749c:	2b00      	cmp	r3, #0
3401749e:	d023      	beq.n	340174e8 <HAL_XSPI_Command+0x2fc>
  {
    if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
340174a0:	68bb      	ldr	r3, [r7, #8]
340174a2:	681b      	ldr	r3, [r3, #0]
340174a4:	2b00      	cmp	r3, #0
340174a6:	d108      	bne.n	340174ba <HAL_XSPI_Command+0x2ce>
    {
      assert_param(IS_XSPI_DATA_LENGTH(pCmd->DataLength));
340174a8:	68bb      	ldr	r3, [r7, #8]
340174aa:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340174ac:	2b00      	cmp	r3, #0
340174ae:	d104      	bne.n	340174ba <HAL_XSPI_Command+0x2ce>
340174b0:	f240 315f 	movw	r1, #863	@ 0x35f
340174b4:	4855      	ldr	r0, [pc, #340]	@ (3401760c <HAL_XSPI_Command+0x420>)
340174b6:	f7ea fdab 	bl	34002010 <assert_failed>
    }
    assert_param(IS_XSPI_DATA_DTR_MODE(pCmd->DataDTRMode));
340174ba:	68bb      	ldr	r3, [r7, #8]
340174bc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
340174be:	2b00      	cmp	r3, #0
340174c0:	d009      	beq.n	340174d6 <HAL_XSPI_Command+0x2ea>
340174c2:	68bb      	ldr	r3, [r7, #8]
340174c4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
340174c6:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
340174ca:	d004      	beq.n	340174d6 <HAL_XSPI_Command+0x2ea>
340174cc:	f240 3161 	movw	r1, #865	@ 0x361
340174d0:	484e      	ldr	r0, [pc, #312]	@ (3401760c <HAL_XSPI_Command+0x420>)
340174d2:	f7ea fd9d 	bl	34002010 <assert_failed>
    assert_param(IS_XSPI_DUMMY_CYCLES(pCmd->DummyCycles));
340174d6:	68bb      	ldr	r3, [r7, #8]
340174d8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340174da:	2b1f      	cmp	r3, #31
340174dc:	d904      	bls.n	340174e8 <HAL_XSPI_Command+0x2fc>
340174de:	f240 3162 	movw	r1, #866	@ 0x362
340174e2:	484a      	ldr	r0, [pc, #296]	@ (3401760c <HAL_XSPI_Command+0x420>)
340174e4:	f7ea fd94 	bl	34002010 <assert_failed>
  }

  assert_param(IS_XSPI_DQS_MODE(pCmd->DQSMode));
340174e8:	68bb      	ldr	r3, [r7, #8]
340174ea:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340174ec:	2b00      	cmp	r3, #0
340174ee:	d009      	beq.n	34017504 <HAL_XSPI_Command+0x318>
340174f0:	68bb      	ldr	r3, [r7, #8]
340174f2:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340174f4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340174f8:	d004      	beq.n	34017504 <HAL_XSPI_Command+0x318>
340174fa:	f240 3165 	movw	r1, #869	@ 0x365
340174fe:	4843      	ldr	r0, [pc, #268]	@ (3401760c <HAL_XSPI_Command+0x420>)
34017500:	f7ea fd86 	bl	34002010 <assert_failed>

  /* Check the state of the driver */
  state = hxspi->State;
34017504:	68fb      	ldr	r3, [r7, #12]
34017506:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34017508:	617b      	str	r3, [r7, #20]
  if (((state == HAL_XSPI_STATE_READY)         && (hxspi->Init.MemoryType != HAL_XSPI_MEMTYPE_HYPERBUS)) ||
3401750a:	697b      	ldr	r3, [r7, #20]
3401750c:	2b02      	cmp	r3, #2
3401750e:	d104      	bne.n	3401751a <HAL_XSPI_Command+0x32e>
34017510:	68fb      	ldr	r3, [r7, #12]
34017512:	68db      	ldr	r3, [r3, #12]
34017514:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
34017518:	d115      	bne.n	34017546 <HAL_XSPI_Command+0x35a>
3401751a:	697b      	ldr	r3, [r7, #20]
3401751c:	2b14      	cmp	r3, #20
3401751e:	d107      	bne.n	34017530 <HAL_XSPI_Command+0x344>
      ((state == HAL_XSPI_STATE_READ_CMD_CFG)  && ((pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG) ||
34017520:	68bb      	ldr	r3, [r7, #8]
34017522:	681b      	ldr	r3, [r3, #0]
34017524:	2b02      	cmp	r3, #2
34017526:	d00e      	beq.n	34017546 <HAL_XSPI_Command+0x35a>
                                                   (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))) ||
34017528:	68bb      	ldr	r3, [r7, #8]
3401752a:	681b      	ldr	r3, [r3, #0]
      ((state == HAL_XSPI_STATE_READ_CMD_CFG)  && ((pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG) ||
3401752c:	2b03      	cmp	r3, #3
3401752e:	d00a      	beq.n	34017546 <HAL_XSPI_Command+0x35a>
                                                   (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))) ||
34017530:	697b      	ldr	r3, [r7, #20]
34017532:	2b24      	cmp	r3, #36	@ 0x24
34017534:	d15e      	bne.n	340175f4 <HAL_XSPI_Command+0x408>
      ((state == HAL_XSPI_STATE_WRITE_CMD_CFG) &&
       ((pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)  ||
34017536:	68bb      	ldr	r3, [r7, #8]
34017538:	681b      	ldr	r3, [r3, #0]
      ((state == HAL_XSPI_STATE_WRITE_CMD_CFG) &&
3401753a:	2b01      	cmp	r3, #1
3401753c:	d003      	beq.n	34017546 <HAL_XSPI_Command+0x35a>
        (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))))
3401753e:	68bb      	ldr	r3, [r7, #8]
34017540:	681b      	ldr	r3, [r3, #0]
       ((pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)  ||
34017542:	2b03      	cmp	r3, #3
34017544:	d156      	bne.n	340175f4 <HAL_XSPI_Command+0x408>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
34017546:	687b      	ldr	r3, [r7, #4]
34017548:	9300      	str	r3, [sp, #0]
3401754a:	69bb      	ldr	r3, [r7, #24]
3401754c:	2200      	movs	r2, #0
3401754e:	2120      	movs	r1, #32
34017550:	68f8      	ldr	r0, [r7, #12]
34017552:	f000 fb1e 	bl	34017b92 <XSPI_WaitFlagStateUntilTimeout>
34017556:	4603      	mov	r3, r0
34017558:	77fb      	strb	r3, [r7, #31]

    if (status == HAL_OK)
3401755a:	7ffb      	ldrb	r3, [r7, #31]
3401755c:	2b00      	cmp	r3, #0
3401755e:	d146      	bne.n	340175ee <HAL_XSPI_Command+0x402>
    {
      /* Initialize error code */
      hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
34017560:	68fb      	ldr	r3, [r7, #12]
34017562:	2200      	movs	r2, #0
34017564:	65da      	str	r2, [r3, #92]	@ 0x5c

      /* Configure the registers */
      status = XSPI_ConfigCmd(hxspi, pCmd);
34017566:	68b9      	ldr	r1, [r7, #8]
34017568:	68f8      	ldr	r0, [r7, #12]
3401756a:	f000 fb49 	bl	34017c00 <XSPI_ConfigCmd>
3401756e:	4603      	mov	r3, r0
34017570:	77fb      	strb	r3, [r7, #31]

      if (status == HAL_OK)
34017572:	7ffb      	ldrb	r3, [r7, #31]
34017574:	2b00      	cmp	r3, #0
34017576:	d143      	bne.n	34017600 <HAL_XSPI_Command+0x414>
      {
        if (pCmd->DataMode == HAL_XSPI_DATA_NONE)
34017578:	68bb      	ldr	r3, [r7, #8]
3401757a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401757c:	2b00      	cmp	r3, #0
3401757e:	d10e      	bne.n	3401759e <HAL_XSPI_Command+0x3b2>
        {
          /* When there is no data phase, the transfer start as soon as the configuration is done
             so wait until BUSY flag is reset to go back in idle state. */
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
34017580:	687b      	ldr	r3, [r7, #4]
34017582:	9300      	str	r3, [sp, #0]
34017584:	69bb      	ldr	r3, [r7, #24]
34017586:	2200      	movs	r2, #0
34017588:	2120      	movs	r1, #32
3401758a:	68f8      	ldr	r0, [r7, #12]
3401758c:	f000 fb01 	bl	34017b92 <XSPI_WaitFlagStateUntilTimeout>
34017590:	4603      	mov	r3, r0
34017592:	77fb      	strb	r3, [r7, #31]

          /* Clear TC flag */
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
34017594:	68fb      	ldr	r3, [r7, #12]
34017596:	681b      	ldr	r3, [r3, #0]
34017598:	2202      	movs	r2, #2
3401759a:	625a      	str	r2, [r3, #36]	@ 0x24
    if (status == HAL_OK)
3401759c:	e030      	b.n	34017600 <HAL_XSPI_Command+0x414>
        }
        else
        {
          /* Update the state */
          if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
3401759e:	68bb      	ldr	r3, [r7, #8]
340175a0:	681b      	ldr	r3, [r3, #0]
340175a2:	2b00      	cmp	r3, #0
340175a4:	d103      	bne.n	340175ae <HAL_XSPI_Command+0x3c2>
          {
            hxspi->State = HAL_XSPI_STATE_CMD_CFG;
340175a6:	68fb      	ldr	r3, [r7, #12]
340175a8:	2204      	movs	r2, #4
340175aa:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
340175ac:	e028      	b.n	34017600 <HAL_XSPI_Command+0x414>
          }
          else if (pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)
340175ae:	68bb      	ldr	r3, [r7, #8]
340175b0:	681b      	ldr	r3, [r3, #0]
340175b2:	2b01      	cmp	r3, #1
340175b4:	d10b      	bne.n	340175ce <HAL_XSPI_Command+0x3e2>
          {
            if (hxspi->State == HAL_XSPI_STATE_WRITE_CMD_CFG)
340175b6:	68fb      	ldr	r3, [r7, #12]
340175b8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340175ba:	2b24      	cmp	r3, #36	@ 0x24
340175bc:	d103      	bne.n	340175c6 <HAL_XSPI_Command+0x3da>
            {
              hxspi->State = HAL_XSPI_STATE_CMD_CFG;
340175be:	68fb      	ldr	r3, [r7, #12]
340175c0:	2204      	movs	r2, #4
340175c2:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
340175c4:	e01c      	b.n	34017600 <HAL_XSPI_Command+0x414>
            }
            else
            {
              hxspi->State = HAL_XSPI_STATE_READ_CMD_CFG;
340175c6:	68fb      	ldr	r3, [r7, #12]
340175c8:	2214      	movs	r2, #20
340175ca:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
340175cc:	e018      	b.n	34017600 <HAL_XSPI_Command+0x414>
            }
          }
          else if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
340175ce:	68bb      	ldr	r3, [r7, #8]
340175d0:	681b      	ldr	r3, [r3, #0]
340175d2:	2b02      	cmp	r3, #2
340175d4:	d114      	bne.n	34017600 <HAL_XSPI_Command+0x414>
          {
            if (hxspi->State == HAL_XSPI_STATE_READ_CMD_CFG)
340175d6:	68fb      	ldr	r3, [r7, #12]
340175d8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340175da:	2b14      	cmp	r3, #20
340175dc:	d103      	bne.n	340175e6 <HAL_XSPI_Command+0x3fa>
            {
              hxspi->State = HAL_XSPI_STATE_CMD_CFG;
340175de:	68fb      	ldr	r3, [r7, #12]
340175e0:	2204      	movs	r2, #4
340175e2:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
340175e4:	e00c      	b.n	34017600 <HAL_XSPI_Command+0x414>
            }
            else
            {
              hxspi->State = HAL_XSPI_STATE_WRITE_CMD_CFG;
340175e6:	68fb      	ldr	r3, [r7, #12]
340175e8:	2224      	movs	r2, #36	@ 0x24
340175ea:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
340175ec:	e008      	b.n	34017600 <HAL_XSPI_Command+0x414>
        }
      }
    }
    else
    {
      status = HAL_BUSY;
340175ee:	2302      	movs	r3, #2
340175f0:	77fb      	strb	r3, [r7, #31]
    if (status == HAL_OK)
340175f2:	e005      	b.n	34017600 <HAL_XSPI_Command+0x414>
    }
  }
  else
  {
    status = HAL_ERROR;
340175f4:	2301      	movs	r3, #1
340175f6:	77fb      	strb	r3, [r7, #31]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340175f8:	68fb      	ldr	r3, [r7, #12]
340175fa:	2210      	movs	r2, #16
340175fc:	65da      	str	r2, [r3, #92]	@ 0x5c
340175fe:	e000      	b.n	34017602 <HAL_XSPI_Command+0x416>
    if (status == HAL_OK)
34017600:	bf00      	nop
  }

  return status;
34017602:	7ffb      	ldrb	r3, [r7, #31]
}
34017604:	4618      	mov	r0, r3
34017606:	3720      	adds	r7, #32
34017608:	46bd      	mov	sp, r7
3401760a:	bd80      	pop	{r7, pc}
3401760c:	3401f094 	.word	0x3401f094

34017610 <HAL_XSPI_Transmit>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Transmit(XSPI_HandleTypeDef *hxspi, const uint8_t *pData, uint32_t Timeout)
{
34017610:	b580      	push	{r7, lr}
34017612:	b08a      	sub	sp, #40	@ 0x28
34017614:	af02      	add	r7, sp, #8
34017616:	60f8      	str	r0, [r7, #12]
34017618:	60b9      	str	r1, [r7, #8]
3401761a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
3401761c:	f7ec fd1a 	bl	34004054 <HAL_GetTick>
34017620:	61b8      	str	r0, [r7, #24]
  __IO uint32_t *data_reg = &hxspi->Instance->DR;
34017622:	68fb      	ldr	r3, [r7, #12]
34017624:	681b      	ldr	r3, [r3, #0]
34017626:	3350      	adds	r3, #80	@ 0x50
34017628:	617b      	str	r3, [r7, #20]

  /* Check the data pointer allocation */
  if (pData == NULL)
3401762a:	68bb      	ldr	r3, [r7, #8]
3401762c:	2b00      	cmp	r3, #0
3401762e:	d105      	bne.n	3401763c <HAL_XSPI_Transmit+0x2c>
  {
    status = HAL_ERROR;
34017630:	2301      	movs	r3, #1
34017632:	77fb      	strb	r3, [r7, #31]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
34017634:	68fb      	ldr	r3, [r7, #12]
34017636:	2208      	movs	r2, #8
34017638:	65da      	str	r2, [r3, #92]	@ 0x5c
3401763a:	e057      	b.n	340176ec <HAL_XSPI_Transmit+0xdc>
  }
  else
  {
    /* Check the state */
    if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
3401763c:	68fb      	ldr	r3, [r7, #12]
3401763e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34017640:	2b04      	cmp	r3, #4
34017642:	d14e      	bne.n	340176e2 <HAL_XSPI_Transmit+0xd2>
    {
      /* Configure counters and size */
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
34017644:	68fb      	ldr	r3, [r7, #12]
34017646:	681b      	ldr	r3, [r3, #0]
34017648:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401764a:	1c5a      	adds	r2, r3, #1
3401764c:	68fb      	ldr	r3, [r7, #12]
3401764e:	64da      	str	r2, [r3, #76]	@ 0x4c
      hxspi->XferSize  = hxspi->XferCount;
34017650:	68fb      	ldr	r3, [r7, #12]
34017652:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
34017654:	68fb      	ldr	r3, [r7, #12]
34017656:	649a      	str	r2, [r3, #72]	@ 0x48
      hxspi->pBuffPtr  = (uint8_t *)pData;
34017658:	68fb      	ldr	r3, [r7, #12]
3401765a:	68ba      	ldr	r2, [r7, #8]
3401765c:	645a      	str	r2, [r3, #68]	@ 0x44

      /* Configure CR register with functional mode as indirect write */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
3401765e:	68fb      	ldr	r3, [r7, #12]
34017660:	681b      	ldr	r3, [r3, #0]
34017662:	681a      	ldr	r2, [r3, #0]
34017664:	68fb      	ldr	r3, [r7, #12]
34017666:	681b      	ldr	r3, [r3, #0]
34017668:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
3401766c:	601a      	str	r2, [r3, #0]

      do
      {
        /* Wait till fifo threshold flag is set to send data */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_FT, SET, tickstart, Timeout);
3401766e:	687b      	ldr	r3, [r7, #4]
34017670:	9300      	str	r3, [sp, #0]
34017672:	69bb      	ldr	r3, [r7, #24]
34017674:	2201      	movs	r2, #1
34017676:	2104      	movs	r1, #4
34017678:	68f8      	ldr	r0, [r7, #12]
3401767a:	f000 fa8a 	bl	34017b92 <XSPI_WaitFlagStateUntilTimeout>
3401767e:	4603      	mov	r3, r0
34017680:	77fb      	strb	r3, [r7, #31]

        if (status != HAL_OK)
34017682:	7ffb      	ldrb	r3, [r7, #31]
34017684:	2b00      	cmp	r3, #0
34017686:	d113      	bne.n	340176b0 <HAL_XSPI_Transmit+0xa0>
        {
          break;
        }

        *((__IO uint8_t *)data_reg) = *hxspi->pBuffPtr;
34017688:	68fb      	ldr	r3, [r7, #12]
3401768a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401768c:	781a      	ldrb	r2, [r3, #0]
3401768e:	697b      	ldr	r3, [r7, #20]
34017690:	701a      	strb	r2, [r3, #0]
        hxspi->pBuffPtr++;
34017692:	68fb      	ldr	r3, [r7, #12]
34017694:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34017696:	1c5a      	adds	r2, r3, #1
34017698:	68fb      	ldr	r3, [r7, #12]
3401769a:	645a      	str	r2, [r3, #68]	@ 0x44
        hxspi->XferCount--;
3401769c:	68fb      	ldr	r3, [r7, #12]
3401769e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340176a0:	1e5a      	subs	r2, r3, #1
340176a2:	68fb      	ldr	r3, [r7, #12]
340176a4:	64da      	str	r2, [r3, #76]	@ 0x4c
      } while (hxspi->XferCount > 0U);
340176a6:	68fb      	ldr	r3, [r7, #12]
340176a8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340176aa:	2b00      	cmp	r3, #0
340176ac:	d1df      	bne.n	3401766e <HAL_XSPI_Transmit+0x5e>
340176ae:	e000      	b.n	340176b2 <HAL_XSPI_Transmit+0xa2>
          break;
340176b0:	bf00      	nop

      if (status == HAL_OK)
340176b2:	7ffb      	ldrb	r3, [r7, #31]
340176b4:	2b00      	cmp	r3, #0
340176b6:	d119      	bne.n	340176ec <HAL_XSPI_Transmit+0xdc>
      {
        /* Wait till transfer complete flag is set to go back in idle state */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
340176b8:	687b      	ldr	r3, [r7, #4]
340176ba:	9300      	str	r3, [sp, #0]
340176bc:	69bb      	ldr	r3, [r7, #24]
340176be:	2201      	movs	r2, #1
340176c0:	2102      	movs	r1, #2
340176c2:	68f8      	ldr	r0, [r7, #12]
340176c4:	f000 fa65 	bl	34017b92 <XSPI_WaitFlagStateUntilTimeout>
340176c8:	4603      	mov	r3, r0
340176ca:	77fb      	strb	r3, [r7, #31]

        if (status == HAL_OK)
340176cc:	7ffb      	ldrb	r3, [r7, #31]
340176ce:	2b00      	cmp	r3, #0
340176d0:	d10c      	bne.n	340176ec <HAL_XSPI_Transmit+0xdc>
        {
          /* Clear transfer complete flag */
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
340176d2:	68fb      	ldr	r3, [r7, #12]
340176d4:	681b      	ldr	r3, [r3, #0]
340176d6:	2202      	movs	r2, #2
340176d8:	625a      	str	r2, [r3, #36]	@ 0x24

          hxspi->State = HAL_XSPI_STATE_READY;
340176da:	68fb      	ldr	r3, [r7, #12]
340176dc:	2202      	movs	r2, #2
340176de:	659a      	str	r2, [r3, #88]	@ 0x58
340176e0:	e004      	b.n	340176ec <HAL_XSPI_Transmit+0xdc>
        }
      }
    }
    else
    {
      status = HAL_ERROR;
340176e2:	2301      	movs	r3, #1
340176e4:	77fb      	strb	r3, [r7, #31]
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340176e6:	68fb      	ldr	r3, [r7, #12]
340176e8:	2210      	movs	r2, #16
340176ea:	65da      	str	r2, [r3, #92]	@ 0x5c
    }
  }

  return status;
340176ec:	7ffb      	ldrb	r3, [r7, #31]
}
340176ee:	4618      	mov	r0, r3
340176f0:	3720      	adds	r7, #32
340176f2:	46bd      	mov	sp, r7
340176f4:	bd80      	pop	{r7, pc}

340176f6 <HAL_XSPI_Receive>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Receive(XSPI_HandleTypeDef *hxspi, uint8_t *pData, uint32_t Timeout)
{
340176f6:	b580      	push	{r7, lr}
340176f8:	b08c      	sub	sp, #48	@ 0x30
340176fa:	af02      	add	r7, sp, #8
340176fc:	60f8      	str	r0, [r7, #12]
340176fe:	60b9      	str	r1, [r7, #8]
34017700:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
34017702:	f7ec fca7 	bl	34004054 <HAL_GetTick>
34017706:	6238      	str	r0, [r7, #32]
  __IO uint32_t *data_reg = &hxspi->Instance->DR;
34017708:	68fb      	ldr	r3, [r7, #12]
3401770a:	681b      	ldr	r3, [r3, #0]
3401770c:	3350      	adds	r3, #80	@ 0x50
3401770e:	61fb      	str	r3, [r7, #28]
  uint32_t addr_reg = hxspi->Instance->AR;
34017710:	68fb      	ldr	r3, [r7, #12]
34017712:	681b      	ldr	r3, [r3, #0]
34017714:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34017716:	61bb      	str	r3, [r7, #24]
  uint32_t ir_reg = hxspi->Instance->IR;
34017718:	68fb      	ldr	r3, [r7, #12]
3401771a:	681b      	ldr	r3, [r3, #0]
3401771c:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34017720:	617b      	str	r3, [r7, #20]

  /* Check the data pointer allocation */
  if (pData == NULL)
34017722:	68bb      	ldr	r3, [r7, #8]
34017724:	2b00      	cmp	r3, #0
34017726:	d106      	bne.n	34017736 <HAL_XSPI_Receive+0x40>
  {
    status = HAL_ERROR;
34017728:	2301      	movs	r3, #1
3401772a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
3401772e:	68fb      	ldr	r3, [r7, #12]
34017730:	2208      	movs	r2, #8
34017732:	65da      	str	r2, [r3, #92]	@ 0x5c
34017734:	e07c      	b.n	34017830 <HAL_XSPI_Receive+0x13a>
  }
  else
  {
    /* Check the state */
    if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
34017736:	68fb      	ldr	r3, [r7, #12]
34017738:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3401773a:	2b04      	cmp	r3, #4
3401773c:	d172      	bne.n	34017824 <HAL_XSPI_Receive+0x12e>
    {
      /* Configure counters and size */
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
3401773e:	68fb      	ldr	r3, [r7, #12]
34017740:	681b      	ldr	r3, [r3, #0]
34017742:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34017744:	1c5a      	adds	r2, r3, #1
34017746:	68fb      	ldr	r3, [r7, #12]
34017748:	64da      	str	r2, [r3, #76]	@ 0x4c
      hxspi->XferSize  = hxspi->XferCount;
3401774a:	68fb      	ldr	r3, [r7, #12]
3401774c:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
3401774e:	68fb      	ldr	r3, [r7, #12]
34017750:	649a      	str	r2, [r3, #72]	@ 0x48
      hxspi->pBuffPtr  = pData;
34017752:	68fb      	ldr	r3, [r7, #12]
34017754:	68ba      	ldr	r2, [r7, #8]
34017756:	645a      	str	r2, [r3, #68]	@ 0x44

      /* Configure CR register with functional mode as indirect read */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_READ);
34017758:	68fb      	ldr	r3, [r7, #12]
3401775a:	681b      	ldr	r3, [r3, #0]
3401775c:	681b      	ldr	r3, [r3, #0]
3401775e:	f023 5240 	bic.w	r2, r3, #805306368	@ 0x30000000
34017762:	68fb      	ldr	r3, [r7, #12]
34017764:	681b      	ldr	r3, [r3, #0]
34017766:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
3401776a:	601a      	str	r2, [r3, #0]

      /* Trig the transfer by re-writing address or instruction register */
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
3401776c:	68fb      	ldr	r3, [r7, #12]
3401776e:	68db      	ldr	r3, [r3, #12]
34017770:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
34017774:	d104      	bne.n	34017780 <HAL_XSPI_Receive+0x8a>
      {
        WRITE_REG(hxspi->Instance->AR, addr_reg);
34017776:	68fb      	ldr	r3, [r7, #12]
34017778:	681b      	ldr	r3, [r3, #0]
3401777a:	69ba      	ldr	r2, [r7, #24]
3401777c:	649a      	str	r2, [r3, #72]	@ 0x48
3401777e:	e011      	b.n	340177a4 <HAL_XSPI_Receive+0xae>
      }
      else
      {
        if (READ_BIT(hxspi->Instance->CCR, XSPI_CCR_ADMODE) != HAL_XSPI_ADDRESS_NONE)
34017780:	68fb      	ldr	r3, [r7, #12]
34017782:	681b      	ldr	r3, [r3, #0]
34017784:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
34017788:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
3401778c:	2b00      	cmp	r3, #0
3401778e:	d004      	beq.n	3401779a <HAL_XSPI_Receive+0xa4>
        {
          WRITE_REG(hxspi->Instance->AR, addr_reg);
34017790:	68fb      	ldr	r3, [r7, #12]
34017792:	681b      	ldr	r3, [r3, #0]
34017794:	69ba      	ldr	r2, [r7, #24]
34017796:	649a      	str	r2, [r3, #72]	@ 0x48
34017798:	e004      	b.n	340177a4 <HAL_XSPI_Receive+0xae>
        }
        else
        {
          WRITE_REG(hxspi->Instance->IR, ir_reg);
3401779a:	68fb      	ldr	r3, [r7, #12]
3401779c:	681b      	ldr	r3, [r3, #0]
3401779e:	697a      	ldr	r2, [r7, #20]
340177a0:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
      }

      do
      {
        /* Wait till fifo threshold or transfer complete flags are set to read received data */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, (HAL_XSPI_FLAG_FT | HAL_XSPI_FLAG_TC), SET, tickstart, Timeout);
340177a4:	687b      	ldr	r3, [r7, #4]
340177a6:	9300      	str	r3, [sp, #0]
340177a8:	6a3b      	ldr	r3, [r7, #32]
340177aa:	2201      	movs	r2, #1
340177ac:	2106      	movs	r1, #6
340177ae:	68f8      	ldr	r0, [r7, #12]
340177b0:	f000 f9ef 	bl	34017b92 <XSPI_WaitFlagStateUntilTimeout>
340177b4:	4603      	mov	r3, r0
340177b6:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        if (status != HAL_OK)
340177ba:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
340177be:	2b00      	cmp	r3, #0
340177c0:	d114      	bne.n	340177ec <HAL_XSPI_Receive+0xf6>
        {
          break;
        }

        *hxspi->pBuffPtr = *((__IO uint8_t *)data_reg);
340177c2:	68fb      	ldr	r3, [r7, #12]
340177c4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340177c6:	69fa      	ldr	r2, [r7, #28]
340177c8:	7812      	ldrb	r2, [r2, #0]
340177ca:	b2d2      	uxtb	r2, r2
340177cc:	701a      	strb	r2, [r3, #0]
        hxspi->pBuffPtr++;
340177ce:	68fb      	ldr	r3, [r7, #12]
340177d0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340177d2:	1c5a      	adds	r2, r3, #1
340177d4:	68fb      	ldr	r3, [r7, #12]
340177d6:	645a      	str	r2, [r3, #68]	@ 0x44
        hxspi->XferCount--;
340177d8:	68fb      	ldr	r3, [r7, #12]
340177da:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340177dc:	1e5a      	subs	r2, r3, #1
340177de:	68fb      	ldr	r3, [r7, #12]
340177e0:	64da      	str	r2, [r3, #76]	@ 0x4c
      } while (hxspi->XferCount > 0U);
340177e2:	68fb      	ldr	r3, [r7, #12]
340177e4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340177e6:	2b00      	cmp	r3, #0
340177e8:	d1dc      	bne.n	340177a4 <HAL_XSPI_Receive+0xae>
340177ea:	e000      	b.n	340177ee <HAL_XSPI_Receive+0xf8>
          break;
340177ec:	bf00      	nop

      if (status == HAL_OK)
340177ee:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
340177f2:	2b00      	cmp	r3, #0
340177f4:	d11c      	bne.n	34017830 <HAL_XSPI_Receive+0x13a>
      {
        /* Wait till transfer complete flag is set to go back in idle state */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
340177f6:	687b      	ldr	r3, [r7, #4]
340177f8:	9300      	str	r3, [sp, #0]
340177fa:	6a3b      	ldr	r3, [r7, #32]
340177fc:	2201      	movs	r2, #1
340177fe:	2102      	movs	r1, #2
34017800:	68f8      	ldr	r0, [r7, #12]
34017802:	f000 f9c6 	bl	34017b92 <XSPI_WaitFlagStateUntilTimeout>
34017806:	4603      	mov	r3, r0
34017808:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        if (status == HAL_OK)
3401780c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34017810:	2b00      	cmp	r3, #0
34017812:	d10d      	bne.n	34017830 <HAL_XSPI_Receive+0x13a>
        {
          /* Clear transfer complete flag */
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
34017814:	68fb      	ldr	r3, [r7, #12]
34017816:	681b      	ldr	r3, [r3, #0]
34017818:	2202      	movs	r2, #2
3401781a:	625a      	str	r2, [r3, #36]	@ 0x24

          hxspi->State = HAL_XSPI_STATE_READY;
3401781c:	68fb      	ldr	r3, [r7, #12]
3401781e:	2202      	movs	r2, #2
34017820:	659a      	str	r2, [r3, #88]	@ 0x58
34017822:	e005      	b.n	34017830 <HAL_XSPI_Receive+0x13a>
        }
      }
    }
    else
    {
      status = HAL_ERROR;
34017824:	2301      	movs	r3, #1
34017826:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3401782a:	68fb      	ldr	r3, [r7, #12]
3401782c:	2210      	movs	r2, #16
3401782e:	65da      	str	r2, [r3, #92]	@ 0x5c
    }
  }

  return status;
34017830:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
34017834:	4618      	mov	r0, r3
34017836:	3728      	adds	r7, #40	@ 0x28
34017838:	46bd      	mov	sp, r7
3401783a:	bd80      	pop	{r7, pc}

3401783c <HAL_XSPI_AutoPolling>:
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_AutoPolling(XSPI_HandleTypeDef *hxspi, const XSPI_AutoPollingTypeDef *pCfg,
                                       uint32_t Timeout)
{
3401783c:	b580      	push	{r7, lr}
3401783e:	b08c      	sub	sp, #48	@ 0x30
34017840:	af02      	add	r7, sp, #8
34017842:	60f8      	str	r0, [r7, #12]
34017844:	60b9      	str	r1, [r7, #8]
34017846:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
34017848:	f7ec fc04 	bl	34004054 <HAL_GetTick>
3401784c:	6238      	str	r0, [r7, #32]
  uint32_t addr_reg = hxspi->Instance->AR;
3401784e:	68fb      	ldr	r3, [r7, #12]
34017850:	681b      	ldr	r3, [r3, #0]
34017852:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34017854:	61fb      	str	r3, [r7, #28]
  uint32_t ir_reg = hxspi->Instance->IR;
34017856:	68fb      	ldr	r3, [r7, #12]
34017858:	681b      	ldr	r3, [r3, #0]
3401785a:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3401785e:	61bb      	str	r3, [r7, #24]
#ifdef USE_FULL_ASSERT
  uint32_t dlr_reg = hxspi->Instance->DLR;
34017860:	68fb      	ldr	r3, [r7, #12]
34017862:	681b      	ldr	r3, [r3, #0]
34017864:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34017866:	617b      	str	r3, [r7, #20]
#endif /* USE_FULL_ASSERT */

  /* Check the parameters of the autopolling configuration structure */
  assert_param(IS_XSPI_MATCH_MODE(pCfg->MatchMode));
34017868:	68bb      	ldr	r3, [r7, #8]
3401786a:	689b      	ldr	r3, [r3, #8]
3401786c:	2b00      	cmp	r3, #0
3401786e:	d009      	beq.n	34017884 <HAL_XSPI_AutoPolling+0x48>
34017870:	68bb      	ldr	r3, [r7, #8]
34017872:	689b      	ldr	r3, [r3, #8]
34017874:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
34017878:	d004      	beq.n	34017884 <HAL_XSPI_AutoPolling+0x48>
3401787a:	f240 7134 	movw	r1, #1844	@ 0x734
3401787e:	4853      	ldr	r0, [pc, #332]	@ (340179cc <HAL_XSPI_AutoPolling+0x190>)
34017880:	f7ea fbc6 	bl	34002010 <assert_failed>
  assert_param(IS_XSPI_AUTOMATIC_STOP(pCfg->AutomaticStop));
34017884:	68bb      	ldr	r3, [r7, #8]
34017886:	68db      	ldr	r3, [r3, #12]
34017888:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
3401788c:	d008      	beq.n	340178a0 <HAL_XSPI_AutoPolling+0x64>
3401788e:	68bb      	ldr	r3, [r7, #8]
34017890:	68db      	ldr	r3, [r3, #12]
34017892:	2b00      	cmp	r3, #0
34017894:	d004      	beq.n	340178a0 <HAL_XSPI_AutoPolling+0x64>
34017896:	f240 7135 	movw	r1, #1845	@ 0x735
3401789a:	484c      	ldr	r0, [pc, #304]	@ (340179cc <HAL_XSPI_AutoPolling+0x190>)
3401789c:	f7ea fbb8 	bl	34002010 <assert_failed>
  assert_param(IS_XSPI_INTERVAL(pCfg->IntervalTime));
340178a0:	68bb      	ldr	r3, [r7, #8]
340178a2:	691b      	ldr	r3, [r3, #16]
340178a4:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
340178a8:	d304      	bcc.n	340178b4 <HAL_XSPI_AutoPolling+0x78>
340178aa:	f240 7136 	movw	r1, #1846	@ 0x736
340178ae:	4847      	ldr	r0, [pc, #284]	@ (340179cc <HAL_XSPI_AutoPolling+0x190>)
340178b0:	f7ea fbae 	bl	34002010 <assert_failed>
  assert_param(IS_XSPI_STATUS_BYTES_SIZE(dlr_reg + 1U));
340178b4:	697b      	ldr	r3, [r7, #20]
340178b6:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
340178ba:	d003      	beq.n	340178c4 <HAL_XSPI_AutoPolling+0x88>
340178bc:	697b      	ldr	r3, [r7, #20]
340178be:	3301      	adds	r3, #1
340178c0:	2b04      	cmp	r3, #4
340178c2:	d904      	bls.n	340178ce <HAL_XSPI_AutoPolling+0x92>
340178c4:	f240 7137 	movw	r1, #1847	@ 0x737
340178c8:	4840      	ldr	r0, [pc, #256]	@ (340179cc <HAL_XSPI_AutoPolling+0x190>)
340178ca:	f7ea fba1 	bl	34002010 <assert_failed>

  /* Check the state */
  if ((hxspi->State == HAL_XSPI_STATE_CMD_CFG) && (pCfg->AutomaticStop == HAL_XSPI_AUTOMATIC_STOP_ENABLE))
340178ce:	68fb      	ldr	r3, [r7, #12]
340178d0:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340178d2:	2b04      	cmp	r3, #4
340178d4:	d16c      	bne.n	340179b0 <HAL_XSPI_AutoPolling+0x174>
340178d6:	68bb      	ldr	r3, [r7, #8]
340178d8:	68db      	ldr	r3, [r3, #12]
340178da:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
340178de:	d167      	bne.n	340179b0 <HAL_XSPI_AutoPolling+0x174>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
340178e0:	687b      	ldr	r3, [r7, #4]
340178e2:	9300      	str	r3, [sp, #0]
340178e4:	6a3b      	ldr	r3, [r7, #32]
340178e6:	2200      	movs	r2, #0
340178e8:	2120      	movs	r1, #32
340178ea:	68f8      	ldr	r0, [r7, #12]
340178ec:	f000 f951 	bl	34017b92 <XSPI_WaitFlagStateUntilTimeout>
340178f0:	4603      	mov	r3, r0
340178f2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

    if (status == HAL_OK)
340178f6:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
340178fa:	2b00      	cmp	r3, #0
340178fc:	d154      	bne.n	340179a8 <HAL_XSPI_AutoPolling+0x16c>
    {
      /* Configure registers */
      WRITE_REG(hxspi->Instance->PSMAR, pCfg->MatchValue);
340178fe:	68fb      	ldr	r3, [r7, #12]
34017900:	681b      	ldr	r3, [r3, #0]
34017902:	68ba      	ldr	r2, [r7, #8]
34017904:	6812      	ldr	r2, [r2, #0]
34017906:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
      WRITE_REG(hxspi->Instance->PSMKR, pCfg->MatchMask);
3401790a:	68fb      	ldr	r3, [r7, #12]
3401790c:	681b      	ldr	r3, [r3, #0]
3401790e:	68ba      	ldr	r2, [r7, #8]
34017910:	6852      	ldr	r2, [r2, #4]
34017912:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      WRITE_REG(hxspi->Instance->PIR,   pCfg->IntervalTime);
34017916:	68fb      	ldr	r3, [r7, #12]
34017918:	681b      	ldr	r3, [r3, #0]
3401791a:	68ba      	ldr	r2, [r7, #8]
3401791c:	6912      	ldr	r2, [r2, #16]
3401791e:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_PMM | XSPI_CR_APMS | XSPI_CR_FMODE),
34017922:	68fb      	ldr	r3, [r7, #12]
34017924:	681b      	ldr	r3, [r3, #0]
34017926:	681b      	ldr	r3, [r3, #0]
34017928:	f023 5243 	bic.w	r2, r3, #817889280	@ 0x30c00000
3401792c:	68bb      	ldr	r3, [r7, #8]
3401792e:	6899      	ldr	r1, [r3, #8]
34017930:	68bb      	ldr	r3, [r7, #8]
34017932:	68db      	ldr	r3, [r3, #12]
34017934:	430b      	orrs	r3, r1
34017936:	431a      	orrs	r2, r3
34017938:	68fb      	ldr	r3, [r7, #12]
3401793a:	681b      	ldr	r3, [r3, #0]
3401793c:	f042 5200 	orr.w	r2, r2, #536870912	@ 0x20000000
34017940:	601a      	str	r2, [r3, #0]
                 (pCfg->MatchMode | pCfg->AutomaticStop | XSPI_FUNCTIONAL_MODE_AUTO_POLLING));

      /* Trig the transfer by re-writing address or instruction register */
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
34017942:	68fb      	ldr	r3, [r7, #12]
34017944:	68db      	ldr	r3, [r3, #12]
34017946:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3401794a:	d104      	bne.n	34017956 <HAL_XSPI_AutoPolling+0x11a>
      {
        WRITE_REG(hxspi->Instance->AR, addr_reg);
3401794c:	68fb      	ldr	r3, [r7, #12]
3401794e:	681b      	ldr	r3, [r3, #0]
34017950:	69fa      	ldr	r2, [r7, #28]
34017952:	649a      	str	r2, [r3, #72]	@ 0x48
34017954:	e011      	b.n	3401797a <HAL_XSPI_AutoPolling+0x13e>
      }
      else
      {
        if (READ_BIT(hxspi->Instance->CCR, XSPI_CCR_ADMODE) != HAL_XSPI_ADDRESS_NONE)
34017956:	68fb      	ldr	r3, [r7, #12]
34017958:	681b      	ldr	r3, [r3, #0]
3401795a:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3401795e:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
34017962:	2b00      	cmp	r3, #0
34017964:	d004      	beq.n	34017970 <HAL_XSPI_AutoPolling+0x134>
        {
          WRITE_REG(hxspi->Instance->AR, addr_reg);
34017966:	68fb      	ldr	r3, [r7, #12]
34017968:	681b      	ldr	r3, [r3, #0]
3401796a:	69fa      	ldr	r2, [r7, #28]
3401796c:	649a      	str	r2, [r3, #72]	@ 0x48
3401796e:	e004      	b.n	3401797a <HAL_XSPI_AutoPolling+0x13e>
        }
        else
        {
          WRITE_REG(hxspi->Instance->IR, ir_reg);
34017970:	68fb      	ldr	r3, [r7, #12]
34017972:	681b      	ldr	r3, [r3, #0]
34017974:	69ba      	ldr	r2, [r7, #24]
34017976:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
        }
      }

      /* Wait till status match flag is set to go back in idle state */
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_SM, SET, tickstart, Timeout);
3401797a:	687b      	ldr	r3, [r7, #4]
3401797c:	9300      	str	r3, [sp, #0]
3401797e:	6a3b      	ldr	r3, [r7, #32]
34017980:	2201      	movs	r2, #1
34017982:	2108      	movs	r1, #8
34017984:	68f8      	ldr	r0, [r7, #12]
34017986:	f000 f904 	bl	34017b92 <XSPI_WaitFlagStateUntilTimeout>
3401798a:	4603      	mov	r3, r0
3401798c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

      if (status == HAL_OK)
34017990:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34017994:	2b00      	cmp	r3, #0
34017996:	d112      	bne.n	340179be <HAL_XSPI_AutoPolling+0x182>
      {
        /* Clear status match flag */
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_SM);
34017998:	68fb      	ldr	r3, [r7, #12]
3401799a:	681b      	ldr	r3, [r3, #0]
3401799c:	2208      	movs	r2, #8
3401799e:	625a      	str	r2, [r3, #36]	@ 0x24

        hxspi->State = HAL_XSPI_STATE_READY;
340179a0:	68fb      	ldr	r3, [r7, #12]
340179a2:	2202      	movs	r2, #2
340179a4:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
340179a6:	e00a      	b.n	340179be <HAL_XSPI_AutoPolling+0x182>
      }
    }
    else
    {
      status = HAL_BUSY;
340179a8:	2302      	movs	r3, #2
340179aa:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    if (status == HAL_OK)
340179ae:	e006      	b.n	340179be <HAL_XSPI_AutoPolling+0x182>
    }
  }
  else
  {
    status = HAL_ERROR;
340179b0:	2301      	movs	r3, #1
340179b2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340179b6:	68fb      	ldr	r3, [r7, #12]
340179b8:	2210      	movs	r2, #16
340179ba:	65da      	str	r2, [r3, #92]	@ 0x5c
340179bc:	e000      	b.n	340179c0 <HAL_XSPI_AutoPolling+0x184>
    if (status == HAL_OK)
340179be:	bf00      	nop
  }

  return status;
340179c0:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
340179c4:	4618      	mov	r0, r3
340179c6:	3728      	adds	r7, #40	@ 0x28
340179c8:	46bd      	mov	sp, r7
340179ca:	bd80      	pop	{r7, pc}
340179cc:	3401f094 	.word	0x3401f094

340179d0 <HAL_XSPI_MemoryMapped>:
  * @param  pCfg   : Pointer to structure that contains the memory mapped configuration information.
  * @note   This function is used only in Memory mapped Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_MemoryMapped(XSPI_HandleTypeDef *hxspi, const XSPI_MemoryMappedTypeDef *pCfg)
{
340179d0:	b580      	push	{r7, lr}
340179d2:	b086      	sub	sp, #24
340179d4:	af02      	add	r7, sp, #8
340179d6:	6078      	str	r0, [r7, #4]
340179d8:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
340179da:	f7ec fb3b 	bl	34004054 <HAL_GetTick>
340179de:	60b8      	str	r0, [r7, #8]

  /* Check the parameters of the memory-mapped configuration structure */
  assert_param(IS_XSPI_TIMEOUT_ACTIVATION(pCfg->TimeOutActivation));
340179e0:	683b      	ldr	r3, [r7, #0]
340179e2:	681b      	ldr	r3, [r3, #0]
340179e4:	2b00      	cmp	r3, #0
340179e6:	d008      	beq.n	340179fa <HAL_XSPI_MemoryMapped+0x2a>
340179e8:	683b      	ldr	r3, [r7, #0]
340179ea:	681b      	ldr	r3, [r3, #0]
340179ec:	2b08      	cmp	r3, #8
340179ee:	d004      	beq.n	340179fa <HAL_XSPI_MemoryMapped+0x2a>
340179f0:	f44f 61f9 	mov.w	r1, #1992	@ 0x7c8
340179f4:	4846      	ldr	r0, [pc, #280]	@ (34017b10 <HAL_XSPI_MemoryMapped+0x140>)
340179f6:	f7ea fb0b 	bl	34002010 <assert_failed>
  assert_param(IS_XSPI_NO_PREFETCH_DATA(pCfg->NoPrefetchData));
340179fa:	683b      	ldr	r3, [r7, #0]
340179fc:	689b      	ldr	r3, [r3, #8]
340179fe:	2b00      	cmp	r3, #0
34017a00:	d009      	beq.n	34017a16 <HAL_XSPI_MemoryMapped+0x46>
34017a02:	683b      	ldr	r3, [r7, #0]
34017a04:	689b      	ldr	r3, [r3, #8]
34017a06:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34017a0a:	d004      	beq.n	34017a16 <HAL_XSPI_MemoryMapped+0x46>
34017a0c:	f240 71c9 	movw	r1, #1993	@ 0x7c9
34017a10:	483f      	ldr	r0, [pc, #252]	@ (34017b10 <HAL_XSPI_MemoryMapped+0x140>)
34017a12:	f7ea fafd 	bl	34002010 <assert_failed>

  /* Check the state */
  if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
34017a16:	687b      	ldr	r3, [r7, #4]
34017a18:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34017a1a:	2b04      	cmp	r3, #4
34017a1c:	d16d      	bne.n	34017afa <HAL_XSPI_MemoryMapped+0x12a>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
34017a1e:	687b      	ldr	r3, [r7, #4]
34017a20:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34017a22:	9300      	str	r3, [sp, #0]
34017a24:	68bb      	ldr	r3, [r7, #8]
34017a26:	2200      	movs	r2, #0
34017a28:	2120      	movs	r1, #32
34017a2a:	6878      	ldr	r0, [r7, #4]
34017a2c:	f000 f8b1 	bl	34017b92 <XSPI_WaitFlagStateUntilTimeout>
34017a30:	4603      	mov	r3, r0
34017a32:	73fb      	strb	r3, [r7, #15]

    if (status == HAL_OK)
34017a34:	7bfb      	ldrb	r3, [r7, #15]
34017a36:	2b00      	cmp	r3, #0
34017a38:	d164      	bne.n	34017b04 <HAL_XSPI_MemoryMapped+0x134>
    {
      hxspi->State = HAL_XSPI_STATE_BUSY_MEM_MAPPED;
34017a3a:	687b      	ldr	r3, [r7, #4]
34017a3c:	2288      	movs	r2, #136	@ 0x88
34017a3e:	659a      	str	r2, [r3, #88]	@ 0x58

      if (pCfg->NoPrefetchData == HAL_XSPI_AUTOMATIC_PREFETCH_DISABLE)
34017a40:	683b      	ldr	r3, [r7, #0]
34017a42:	689b      	ldr	r3, [r3, #8]
34017a44:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34017a48:	d10b      	bne.n	34017a62 <HAL_XSPI_MemoryMapped+0x92>
      {
        /* Configure register */
        MODIFY_REG(hxspi->Instance->CR, XSPI_CR_NOPREF, pCfg->NoPrefetchData);
34017a4a:	687b      	ldr	r3, [r7, #4]
34017a4c:	681b      	ldr	r3, [r3, #0]
34017a4e:	681b      	ldr	r3, [r3, #0]
34017a50:	f023 7100 	bic.w	r1, r3, #33554432	@ 0x2000000
34017a54:	683b      	ldr	r3, [r7, #0]
34017a56:	689a      	ldr	r2, [r3, #8]
34017a58:	687b      	ldr	r3, [r7, #4]
34017a5a:	681b      	ldr	r3, [r3, #0]
34017a5c:	430a      	orrs	r2, r1
34017a5e:	601a      	str	r2, [r3, #0]
34017a60:	e01b      	b.n	34017a9a <HAL_XSPI_MemoryMapped+0xca>
      }

      else
      {
        assert_param(IS_XSPI_NO_PREFETCH_AXI(pCfg->NoPrefetchAXI));
34017a62:	683b      	ldr	r3, [r7, #0]
34017a64:	68db      	ldr	r3, [r3, #12]
34017a66:	2b00      	cmp	r3, #0
34017a68:	d009      	beq.n	34017a7e <HAL_XSPI_MemoryMapped+0xae>
34017a6a:	683b      	ldr	r3, [r7, #0]
34017a6c:	68db      	ldr	r3, [r3, #12]
34017a6e:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
34017a72:	d004      	beq.n	34017a7e <HAL_XSPI_MemoryMapped+0xae>
34017a74:	f240 71dd 	movw	r1, #2013	@ 0x7dd
34017a78:	4825      	ldr	r0, [pc, #148]	@ (34017b10 <HAL_XSPI_MemoryMapped+0x140>)
34017a7a:	f7ea fac9 	bl	34002010 <assert_failed>

        /* Configure register */
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_NOPREF | XSPI_CR_NOPREF_AXI),
34017a7e:	687b      	ldr	r3, [r7, #4]
34017a80:	681b      	ldr	r3, [r3, #0]
34017a82:	681b      	ldr	r3, [r3, #0]
34017a84:	f023 61c0 	bic.w	r1, r3, #100663296	@ 0x6000000
34017a88:	683b      	ldr	r3, [r7, #0]
34017a8a:	689a      	ldr	r2, [r3, #8]
34017a8c:	683b      	ldr	r3, [r7, #0]
34017a8e:	68db      	ldr	r3, [r3, #12]
34017a90:	431a      	orrs	r2, r3
34017a92:	687b      	ldr	r3, [r7, #4]
34017a94:	681b      	ldr	r3, [r3, #0]
34017a96:	430a      	orrs	r2, r1
34017a98:	601a      	str	r2, [r3, #0]
                   (pCfg->NoPrefetchData | pCfg->NoPrefetchAXI));
      }
      if (pCfg->TimeOutActivation == HAL_XSPI_TIMEOUT_COUNTER_ENABLE)
34017a9a:	683b      	ldr	r3, [r7, #0]
34017a9c:	681b      	ldr	r3, [r3, #0]
34017a9e:	2b08      	cmp	r3, #8
34017aa0:	d11b      	bne.n	34017ada <HAL_XSPI_MemoryMapped+0x10a>
      {
        assert_param(IS_XSPI_TIMEOUT_PERIOD(pCfg->TimeoutPeriodClock));
34017aa2:	683b      	ldr	r3, [r7, #0]
34017aa4:	685b      	ldr	r3, [r3, #4]
34017aa6:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34017aaa:	d304      	bcc.n	34017ab6 <HAL_XSPI_MemoryMapped+0xe6>
34017aac:	f240 71e5 	movw	r1, #2021	@ 0x7e5
34017ab0:	4817      	ldr	r0, [pc, #92]	@ (34017b10 <HAL_XSPI_MemoryMapped+0x140>)
34017ab2:	f7ea faad 	bl	34002010 <assert_failed>

        /* Configure register */
        WRITE_REG(hxspi->Instance->LPTR, pCfg->TimeoutPeriodClock);
34017ab6:	687b      	ldr	r3, [r7, #4]
34017ab8:	681b      	ldr	r3, [r3, #0]
34017aba:	683a      	ldr	r2, [r7, #0]
34017abc:	6852      	ldr	r2, [r2, #4]
34017abe:	f8c3 2130 	str.w	r2, [r3, #304]	@ 0x130

        /* Clear flags related to interrupt */
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TO);
34017ac2:	687b      	ldr	r3, [r7, #4]
34017ac4:	681b      	ldr	r3, [r3, #0]
34017ac6:	2210      	movs	r2, #16
34017ac8:	625a      	str	r2, [r3, #36]	@ 0x24

        /* Enable the timeout interrupt */
        HAL_XSPI_ENABLE_IT(hxspi, HAL_XSPI_IT_TO);
34017aca:	687b      	ldr	r3, [r7, #4]
34017acc:	681b      	ldr	r3, [r3, #0]
34017ace:	681a      	ldr	r2, [r3, #0]
34017ad0:	687b      	ldr	r3, [r7, #4]
34017ad2:	681b      	ldr	r3, [r3, #0]
34017ad4:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
34017ad8:	601a      	str	r2, [r3, #0]
      }

      /* Configure CR register with functional mode as memory-mapped */
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_TCEN | XSPI_CR_FMODE),
34017ada:	687b      	ldr	r3, [r7, #4]
34017adc:	681b      	ldr	r3, [r3, #0]
34017ade:	681b      	ldr	r3, [r3, #0]
34017ae0:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
34017ae4:	f023 0308 	bic.w	r3, r3, #8
34017ae8:	683a      	ldr	r2, [r7, #0]
34017aea:	6812      	ldr	r2, [r2, #0]
34017aec:	431a      	orrs	r2, r3
34017aee:	687b      	ldr	r3, [r7, #4]
34017af0:	681b      	ldr	r3, [r3, #0]
34017af2:	f042 5240 	orr.w	r2, r2, #805306368	@ 0x30000000
34017af6:	601a      	str	r2, [r3, #0]
34017af8:	e004      	b.n	34017b04 <HAL_XSPI_MemoryMapped+0x134>
                 (pCfg->TimeOutActivation | XSPI_FUNCTIONAL_MODE_MEMORY_MAPPED));
    }
  }
  else
  {
    status = HAL_ERROR;
34017afa:	2301      	movs	r3, #1
34017afc:	73fb      	strb	r3, [r7, #15]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34017afe:	687b      	ldr	r3, [r7, #4]
34017b00:	2210      	movs	r2, #16
34017b02:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  return status;
34017b04:	7bfb      	ldrb	r3, [r7, #15]
}
34017b06:	4618      	mov	r0, r3
34017b08:	3710      	adds	r7, #16
34017b0a:	46bd      	mov	sp, r7
34017b0c:	bd80      	pop	{r7, pc}
34017b0e:	bf00      	nop
34017b10:	3401f094 	.word	0x3401f094

34017b14 <HAL_XSPI_SetClockPrescaler>:
  * @param  hxspi     : XSPI handle.
  * @param  Prescaler : Clock prescaler.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_SetClockPrescaler(XSPI_HandleTypeDef *hxspi, uint32_t Prescaler)
{
34017b14:	b580      	push	{r7, lr}
34017b16:	b084      	sub	sp, #16
34017b18:	af00      	add	r7, sp, #0
34017b1a:	6078      	str	r0, [r7, #4]
34017b1c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
34017b1e:	2300      	movs	r3, #0
34017b20:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_XSPI_CLK_PRESCALER(Prescaler));
34017b22:	683b      	ldr	r3, [r7, #0]
34017b24:	2bff      	cmp	r3, #255	@ 0xff
34017b26:	d904      	bls.n	34017b32 <HAL_XSPI_SetClockPrescaler+0x1e>
34017b28:	f640 2193 	movw	r1, #2707	@ 0xa93
34017b2c:	4810      	ldr	r0, [pc, #64]	@ (34017b70 <HAL_XSPI_SetClockPrescaler+0x5c>)
34017b2e:	f7ea fa6f 	bl	34002010 <assert_failed>

  /* Check the state */
  if ((hxspi->State & XSPI_BUSY_STATE_MASK) == 0U)
34017b32:	687b      	ldr	r3, [r7, #4]
34017b34:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34017b36:	f003 0308 	and.w	r3, r3, #8
34017b3a:	2b00      	cmp	r3, #0
34017b3c:	d10e      	bne.n	34017b5c <HAL_XSPI_SetClockPrescaler+0x48>
  {
    /* Synchronize initialization structure with the new clock prescaler value */
    hxspi->Init.ClockPrescaler = Prescaler;
34017b3e:	687b      	ldr	r3, [r7, #4]
34017b40:	683a      	ldr	r2, [r7, #0]
34017b42:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Configure clock prescaler */
    MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
34017b44:	687b      	ldr	r3, [r7, #4]
34017b46:	681b      	ldr	r3, [r3, #0]
34017b48:	68db      	ldr	r3, [r3, #12]
34017b4a:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
34017b4e:	687b      	ldr	r3, [r7, #4]
34017b50:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
34017b52:	687b      	ldr	r3, [r7, #4]
34017b54:	681b      	ldr	r3, [r3, #0]
34017b56:	430a      	orrs	r2, r1
34017b58:	60da      	str	r2, [r3, #12]
34017b5a:	e004      	b.n	34017b66 <HAL_XSPI_SetClockPrescaler+0x52>
               ((hxspi->Init.ClockPrescaler) << XSPI_DCR2_PRESCALER_Pos));
  }
  else
  {
    status = HAL_ERROR;
34017b5c:	2301      	movs	r3, #1
34017b5e:	73fb      	strb	r3, [r7, #15]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34017b60:	687b      	ldr	r3, [r7, #4]
34017b62:	2210      	movs	r2, #16
34017b64:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  return status;
34017b66:	7bfb      	ldrb	r3, [r7, #15]
}
34017b68:	4618      	mov	r0, r3
34017b6a:	3710      	adds	r7, #16
34017b6c:	46bd      	mov	sp, r7
34017b6e:	bd80      	pop	{r7, pc}
34017b70:	3401f094 	.word	0x3401f094

34017b74 <HAL_XSPI_SetTimeout>:
  * @param  hxspi   : XSPI handle.
  * @param  Timeout : Timeout for the memory access.
  * @retval HAL state
  */
HAL_StatusTypeDef HAL_XSPI_SetTimeout(XSPI_HandleTypeDef *hxspi, uint32_t Timeout)
{
34017b74:	b480      	push	{r7}
34017b76:	b083      	sub	sp, #12
34017b78:	af00      	add	r7, sp, #0
34017b7a:	6078      	str	r0, [r7, #4]
34017b7c:	6039      	str	r1, [r7, #0]
  hxspi->Timeout = Timeout;
34017b7e:	687b      	ldr	r3, [r7, #4]
34017b80:	683a      	ldr	r2, [r7, #0]
34017b82:	661a      	str	r2, [r3, #96]	@ 0x60
  return HAL_OK;
34017b84:	2300      	movs	r3, #0
}
34017b86:	4618      	mov	r0, r3
34017b88:	370c      	adds	r7, #12
34017b8a:	46bd      	mov	sp, r7
34017b8c:	f85d 7b04 	ldr.w	r7, [sp], #4
34017b90:	4770      	bx	lr

34017b92 <XSPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart : Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef XSPI_WaitFlagStateUntilTimeout(XSPI_HandleTypeDef *hxspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
34017b92:	b580      	push	{r7, lr}
34017b94:	b084      	sub	sp, #16
34017b96:	af00      	add	r7, sp, #0
34017b98:	60f8      	str	r0, [r7, #12]
34017b9a:	60b9      	str	r1, [r7, #8]
34017b9c:	603b      	str	r3, [r7, #0]
34017b9e:	4613      	mov	r3, r2
34017ba0:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
34017ba2:	e019      	b.n	34017bd8 <XSPI_WaitFlagStateUntilTimeout+0x46>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
34017ba4:	69bb      	ldr	r3, [r7, #24]
34017ba6:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
34017baa:	d015      	beq.n	34017bd8 <XSPI_WaitFlagStateUntilTimeout+0x46>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34017bac:	f7ec fa52 	bl	34004054 <HAL_GetTick>
34017bb0:	4602      	mov	r2, r0
34017bb2:	683b      	ldr	r3, [r7, #0]
34017bb4:	1ad3      	subs	r3, r2, r3
34017bb6:	69ba      	ldr	r2, [r7, #24]
34017bb8:	429a      	cmp	r2, r3
34017bba:	d302      	bcc.n	34017bc2 <XSPI_WaitFlagStateUntilTimeout+0x30>
34017bbc:	69bb      	ldr	r3, [r7, #24]
34017bbe:	2b00      	cmp	r3, #0
34017bc0:	d10a      	bne.n	34017bd8 <XSPI_WaitFlagStateUntilTimeout+0x46>
      {
        hxspi->State     = HAL_XSPI_STATE_READY;
34017bc2:	68fb      	ldr	r3, [r7, #12]
34017bc4:	2202      	movs	r2, #2
34017bc6:	659a      	str	r2, [r3, #88]	@ 0x58
        hxspi->ErrorCode |= HAL_XSPI_ERROR_TIMEOUT;
34017bc8:	68fb      	ldr	r3, [r7, #12]
34017bca:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34017bcc:	f043 0201 	orr.w	r2, r3, #1
34017bd0:	68fb      	ldr	r3, [r7, #12]
34017bd2:	65da      	str	r2, [r3, #92]	@ 0x5c

        return HAL_TIMEOUT;
34017bd4:	2303      	movs	r3, #3
34017bd6:	e00e      	b.n	34017bf6 <XSPI_WaitFlagStateUntilTimeout+0x64>
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
34017bd8:	68fb      	ldr	r3, [r7, #12]
34017bda:	681b      	ldr	r3, [r3, #0]
34017bdc:	6a1a      	ldr	r2, [r3, #32]
34017bde:	68bb      	ldr	r3, [r7, #8]
34017be0:	4013      	ands	r3, r2
34017be2:	2b00      	cmp	r3, #0
34017be4:	bf14      	ite	ne
34017be6:	2301      	movne	r3, #1
34017be8:	2300      	moveq	r3, #0
34017bea:	b2db      	uxtb	r3, r3
34017bec:	461a      	mov	r2, r3
34017bee:	79fb      	ldrb	r3, [r7, #7]
34017bf0:	429a      	cmp	r2, r3
34017bf2:	d1d7      	bne.n	34017ba4 <XSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
34017bf4:	2300      	movs	r3, #0
}
34017bf6:	4618      	mov	r0, r3
34017bf8:	3710      	adds	r7, #16
34017bfa:	46bd      	mov	sp, r7
34017bfc:	bd80      	pop	{r7, pc}
	...

34017c00 <XSPI_ConfigCmd>:
  * @param  hxspi : XSPI handle
  * @param  pCmd   : structure that contains the command configuration information
  * @retval HAL status
  */
static HAL_StatusTypeDef XSPI_ConfigCmd(XSPI_HandleTypeDef *hxspi, const XSPI_RegularCmdTypeDef *pCmd)
{
34017c00:	b580      	push	{r7, lr}
34017c02:	b088      	sub	sp, #32
34017c04:	af00      	add	r7, sp, #0
34017c06:	6078      	str	r0, [r7, #4]
34017c08:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
34017c0a:	2300      	movs	r3, #0
34017c0c:	77fb      	strb	r3, [r7, #31]
  __IO uint32_t *tcr_reg;
  __IO uint32_t *ir_reg;
  __IO uint32_t *abr_reg;

  /* Re-initialize the value of the functional mode */
  MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, 0U);
34017c0e:	687b      	ldr	r3, [r7, #4]
34017c10:	681b      	ldr	r3, [r3, #0]
34017c12:	681a      	ldr	r2, [r3, #0]
34017c14:	687b      	ldr	r3, [r7, #4]
34017c16:	681b      	ldr	r3, [r3, #0]
34017c18:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
34017c1c:	601a      	str	r2, [r3, #0]

  if (hxspi->Init.MemoryMode == HAL_XSPI_SINGLE_MEM)
34017c1e:	687b      	ldr	r3, [r7, #4]
34017c20:	689b      	ldr	r3, [r3, #8]
34017c22:	2b00      	cmp	r3, #0
34017c24:	d12b      	bne.n	34017c7e <XSPI_ConfigCmd+0x7e>
  {
    assert_param(IS_XSPI_IO_SELECT(pCmd->IOSelect));
34017c26:	683b      	ldr	r3, [r7, #0]
34017c28:	685b      	ldr	r3, [r3, #4]
34017c2a:	2b00      	cmp	r3, #0
34017c2c:	d01c      	beq.n	34017c68 <XSPI_ConfigCmd+0x68>
34017c2e:	683b      	ldr	r3, [r7, #0]
34017c30:	685b      	ldr	r3, [r3, #4]
34017c32:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34017c36:	d017      	beq.n	34017c68 <XSPI_ConfigCmd+0x68>
34017c38:	683b      	ldr	r3, [r7, #0]
34017c3a:	685b      	ldr	r3, [r3, #4]
34017c3c:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
34017c40:	d012      	beq.n	34017c68 <XSPI_ConfigCmd+0x68>
34017c42:	683b      	ldr	r3, [r7, #0]
34017c44:	685b      	ldr	r3, [r3, #4]
34017c46:	f1b3 4f40 	cmp.w	r3, #3221225472	@ 0xc0000000
34017c4a:	d00d      	beq.n	34017c68 <XSPI_ConfigCmd+0x68>
34017c4c:	683b      	ldr	r3, [r7, #0]
34017c4e:	685b      	ldr	r3, [r3, #4]
34017c50:	2b00      	cmp	r3, #0
34017c52:	d009      	beq.n	34017c68 <XSPI_ConfigCmd+0x68>
34017c54:	683b      	ldr	r3, [r7, #0]
34017c56:	685b      	ldr	r3, [r3, #4]
34017c58:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
34017c5c:	d004      	beq.n	34017c68 <XSPI_ConfigCmd+0x68>
34017c5e:	f640 41a4 	movw	r1, #3236	@ 0xca4
34017c62:	4892      	ldr	r0, [pc, #584]	@ (34017eac <XSPI_ConfigCmd+0x2ac>)
34017c64:	f7ea f9d4 	bl	34002010 <assert_failed>
    MODIFY_REG(hxspi->Instance->CR, XSPI_CR_MSEL, pCmd->IOSelect);
34017c68:	687b      	ldr	r3, [r7, #4]
34017c6a:	681b      	ldr	r3, [r3, #0]
34017c6c:	681b      	ldr	r3, [r3, #0]
34017c6e:	f023 4140 	bic.w	r1, r3, #3221225472	@ 0xc0000000
34017c72:	683b      	ldr	r3, [r7, #0]
34017c74:	685a      	ldr	r2, [r3, #4]
34017c76:	687b      	ldr	r3, [r7, #4]
34017c78:	681b      	ldr	r3, [r3, #0]
34017c7a:	430a      	orrs	r2, r1
34017c7c:	601a      	str	r2, [r3, #0]
  }

  if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
34017c7e:	683b      	ldr	r3, [r7, #0]
34017c80:	681b      	ldr	r3, [r3, #0]
34017c82:	2b02      	cmp	r3, #2
34017c84:	d114      	bne.n	34017cb0 <XSPI_ConfigCmd+0xb0>
  {
    ccr_reg = &(hxspi->Instance->WCCR);
34017c86:	687b      	ldr	r3, [r7, #4]
34017c88:	681b      	ldr	r3, [r3, #0]
34017c8a:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
34017c8e:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hxspi->Instance->WTCR);
34017c90:	687b      	ldr	r3, [r7, #4]
34017c92:	681b      	ldr	r3, [r3, #0]
34017c94:	f503 73c4 	add.w	r3, r3, #392	@ 0x188
34017c98:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hxspi->Instance->WIR);
34017c9a:	687b      	ldr	r3, [r7, #4]
34017c9c:	681b      	ldr	r3, [r3, #0]
34017c9e:	f503 73c8 	add.w	r3, r3, #400	@ 0x190
34017ca2:	613b      	str	r3, [r7, #16]
    abr_reg = &(hxspi->Instance->WABR);
34017ca4:	687b      	ldr	r3, [r7, #4]
34017ca6:	681b      	ldr	r3, [r3, #0]
34017ca8:	f503 73d0 	add.w	r3, r3, #416	@ 0x1a0
34017cac:	60fb      	str	r3, [r7, #12]
34017cae:	e02c      	b.n	34017d0a <XSPI_ConfigCmd+0x10a>
  }
  else if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG)
34017cb0:	683b      	ldr	r3, [r7, #0]
34017cb2:	681b      	ldr	r3, [r3, #0]
34017cb4:	2b03      	cmp	r3, #3
34017cb6:	d114      	bne.n	34017ce2 <XSPI_ConfigCmd+0xe2>
  {
    ccr_reg = &(hxspi->Instance->WPCCR);
34017cb8:	687b      	ldr	r3, [r7, #4]
34017cba:	681b      	ldr	r3, [r3, #0]
34017cbc:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
34017cc0:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hxspi->Instance->WPTCR);
34017cc2:	687b      	ldr	r3, [r7, #4]
34017cc4:	681b      	ldr	r3, [r3, #0]
34017cc6:	f503 73a4 	add.w	r3, r3, #328	@ 0x148
34017cca:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hxspi->Instance->WPIR);
34017ccc:	687b      	ldr	r3, [r7, #4]
34017cce:	681b      	ldr	r3, [r3, #0]
34017cd0:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
34017cd4:	613b      	str	r3, [r7, #16]
    abr_reg = &(hxspi->Instance->WPABR);
34017cd6:	687b      	ldr	r3, [r7, #4]
34017cd8:	681b      	ldr	r3, [r3, #0]
34017cda:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
34017cde:	60fb      	str	r3, [r7, #12]
34017ce0:	e013      	b.n	34017d0a <XSPI_ConfigCmd+0x10a>
  }
  else
  {
    ccr_reg = &(hxspi->Instance->CCR);
34017ce2:	687b      	ldr	r3, [r7, #4]
34017ce4:	681b      	ldr	r3, [r3, #0]
34017ce6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34017cea:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hxspi->Instance->TCR);
34017cec:	687b      	ldr	r3, [r7, #4]
34017cee:	681b      	ldr	r3, [r3, #0]
34017cf0:	f503 7384 	add.w	r3, r3, #264	@ 0x108
34017cf4:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hxspi->Instance->IR);
34017cf6:	687b      	ldr	r3, [r7, #4]
34017cf8:	681b      	ldr	r3, [r3, #0]
34017cfa:	f503 7388 	add.w	r3, r3, #272	@ 0x110
34017cfe:	613b      	str	r3, [r7, #16]
    abr_reg = &(hxspi->Instance->ABR);
34017d00:	687b      	ldr	r3, [r7, #4]
34017d02:	681b      	ldr	r3, [r3, #0]
34017d04:	f503 7390 	add.w	r3, r3, #288	@ 0x120
34017d08:	60fb      	str	r3, [r7, #12]
  }

  /* Configure the CCR register with DQS and SIOO modes */
  *ccr_reg = pCmd->DQSMode;
34017d0a:	683b      	ldr	r3, [r7, #0]
34017d0c:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34017d0e:	69bb      	ldr	r3, [r7, #24]
34017d10:	601a      	str	r2, [r3, #0]

  if (pCmd->AlternateBytesMode != HAL_XSPI_ALT_BYTES_NONE)
34017d12:	683b      	ldr	r3, [r7, #0]
34017d14:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34017d16:	2b00      	cmp	r3, #0
34017d18:	d012      	beq.n	34017d40 <XSPI_ConfigCmd+0x140>
  {
    /* Configure the ABR register with alternate bytes value */
    *abr_reg = pCmd->AlternateBytes;
34017d1a:	683b      	ldr	r3, [r7, #0]
34017d1c:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34017d1e:	68fb      	ldr	r3, [r7, #12]
34017d20:	601a      	str	r2, [r3, #0]

    /* Configure the CCR register with alternate bytes communication parameters */
    MODIFY_REG((*ccr_reg), (XSPI_CCR_ABMODE | XSPI_CCR_ABDTR | XSPI_CCR_ABSIZE),
34017d22:	69bb      	ldr	r3, [r7, #24]
34017d24:	681b      	ldr	r3, [r3, #0]
34017d26:	f423 127c 	bic.w	r2, r3, #4128768	@ 0x3f0000
34017d2a:	683b      	ldr	r3, [r7, #0]
34017d2c:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
34017d2e:	683b      	ldr	r3, [r7, #0]
34017d30:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34017d32:	4319      	orrs	r1, r3
34017d34:	683b      	ldr	r3, [r7, #0]
34017d36:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34017d38:	430b      	orrs	r3, r1
34017d3a:	431a      	orrs	r2, r3
34017d3c:	69bb      	ldr	r3, [r7, #24]
34017d3e:	601a      	str	r2, [r3, #0]
               (pCmd->AlternateBytesMode | pCmd->AlternateBytesDTRMode | pCmd->AlternateBytesWidth));
  }

  /* Configure the TCR register with the number of dummy cycles */
  MODIFY_REG((*tcr_reg), XSPI_TCR_DCYC, pCmd->DummyCycles);
34017d40:	697b      	ldr	r3, [r7, #20]
34017d42:	681b      	ldr	r3, [r3, #0]
34017d44:	f023 021f 	bic.w	r2, r3, #31
34017d48:	683b      	ldr	r3, [r7, #0]
34017d4a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34017d4c:	431a      	orrs	r2, r3
34017d4e:	697b      	ldr	r3, [r7, #20]
34017d50:	601a      	str	r2, [r3, #0]

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34017d52:	683b      	ldr	r3, [r7, #0]
34017d54:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34017d56:	2b00      	cmp	r3, #0
34017d58:	d009      	beq.n	34017d6e <XSPI_ConfigCmd+0x16e>
  {
    if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
34017d5a:	683b      	ldr	r3, [r7, #0]
34017d5c:	681b      	ldr	r3, [r3, #0]
34017d5e:	2b00      	cmp	r3, #0
34017d60:	d105      	bne.n	34017d6e <XSPI_ConfigCmd+0x16e>
    {
      /* Configure the DLR register with the number of data */
      hxspi->Instance->DLR = (pCmd->DataLength - 1U);
34017d62:	683b      	ldr	r3, [r7, #0]
34017d64:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
34017d66:	687b      	ldr	r3, [r7, #4]
34017d68:	681b      	ldr	r3, [r3, #0]
34017d6a:	3a01      	subs	r2, #1
34017d6c:	641a      	str	r2, [r3, #64]	@ 0x40
    }
  }

  /* Configure SSHIFT register to handle SDR/DTR data transfer */
  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34017d6e:	683b      	ldr	r3, [r7, #0]
34017d70:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34017d72:	2b00      	cmp	r3, #0
34017d74:	d01e      	beq.n	34017db4 <XSPI_ConfigCmd+0x1b4>
  {
    if (pCmd->DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE)
34017d76:	683b      	ldr	r3, [r7, #0]
34017d78:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34017d7a:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34017d7e:	d10a      	bne.n	34017d96 <XSPI_ConfigCmd+0x196>
    {
      /* Deactivate sample shifting when receiving data in DTR mode (DDTR=1) */
      CLEAR_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
34017d80:	687b      	ldr	r3, [r7, #4]
34017d82:	681b      	ldr	r3, [r3, #0]
34017d84:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34017d88:	687b      	ldr	r3, [r7, #4]
34017d8a:	681b      	ldr	r3, [r3, #0]
34017d8c:	f022 4280 	bic.w	r2, r2, #1073741824	@ 0x40000000
34017d90:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
34017d94:	e00e      	b.n	34017db4 <XSPI_ConfigCmd+0x1b4>
    }
    else if (hxspi->Init.SampleShifting == HAL_XSPI_SAMPLE_SHIFT_HALFCYCLE)
34017d96:	687b      	ldr	r3, [r7, #4]
34017d98:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34017d9a:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34017d9e:	d109      	bne.n	34017db4 <XSPI_ConfigCmd+0x1b4>
    {
      /* Configure sample shifting */
      SET_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
34017da0:	687b      	ldr	r3, [r7, #4]
34017da2:	681b      	ldr	r3, [r3, #0]
34017da4:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34017da8:	687b      	ldr	r3, [r7, #4]
34017daa:	681b      	ldr	r3, [r3, #0]
34017dac:	f042 4280 	orr.w	r2, r2, #1073741824	@ 0x40000000
34017db0:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
    {
      /* Do nothing */
    }
  }

  if (pCmd->InstructionMode != HAL_XSPI_INSTRUCTION_NONE)
34017db4:	683b      	ldr	r3, [r7, #0]
34017db6:	68db      	ldr	r3, [r3, #12]
34017db8:	2b00      	cmp	r3, #0
34017dba:	f000 809e 	beq.w	34017efa <XSPI_ConfigCmd+0x2fa>
  {
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
34017dbe:	683b      	ldr	r3, [r7, #0]
34017dc0:	69db      	ldr	r3, [r3, #28]
34017dc2:	2b00      	cmp	r3, #0
34017dc4:	d055      	beq.n	34017e72 <XSPI_ConfigCmd+0x272>
    {
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34017dc6:	683b      	ldr	r3, [r7, #0]
34017dc8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34017dca:	2b00      	cmp	r3, #0
34017dcc:	d01e      	beq.n	34017e0c <XSPI_ConfigCmd+0x20c>
      {
        /* ---- Command with instruction, address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
34017dce:	69bb      	ldr	r3, [r7, #24]
34017dd0:	681a      	ldr	r2, [r3, #0]
34017dd2:	4b37      	ldr	r3, [pc, #220]	@ (34017eb0 <XSPI_ConfigCmd+0x2b0>)
34017dd4:	4013      	ands	r3, r2
34017dd6:	683a      	ldr	r2, [r7, #0]
34017dd8:	68d1      	ldr	r1, [r2, #12]
34017dda:	683a      	ldr	r2, [r7, #0]
34017ddc:	6952      	ldr	r2, [r2, #20]
34017dde:	4311      	orrs	r1, r2
34017de0:	683a      	ldr	r2, [r7, #0]
34017de2:	6912      	ldr	r2, [r2, #16]
34017de4:	4311      	orrs	r1, r2
34017de6:	683a      	ldr	r2, [r7, #0]
34017de8:	69d2      	ldr	r2, [r2, #28]
34017dea:	4311      	orrs	r1, r2
34017dec:	683a      	ldr	r2, [r7, #0]
34017dee:	6a52      	ldr	r2, [r2, #36]	@ 0x24
34017df0:	4311      	orrs	r1, r2
34017df2:	683a      	ldr	r2, [r7, #0]
34017df4:	6a12      	ldr	r2, [r2, #32]
34017df6:	4311      	orrs	r1, r2
34017df8:	683a      	ldr	r2, [r7, #0]
34017dfa:	6b92      	ldr	r2, [r2, #56]	@ 0x38
34017dfc:	4311      	orrs	r1, r2
34017dfe:	683a      	ldr	r2, [r7, #0]
34017e00:	6c12      	ldr	r2, [r2, #64]	@ 0x40
34017e02:	430a      	orrs	r2, r1
34017e04:	431a      	orrs	r2, r3
34017e06:	69bb      	ldr	r3, [r7, #24]
34017e08:	601a      	str	r2, [r3, #0]
34017e0a:	e028      	b.n	34017e5e <XSPI_ConfigCmd+0x25e>
      else
      {
        /* ---- Command with instruction and address ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
34017e0c:	69bb      	ldr	r3, [r7, #24]
34017e0e:	681b      	ldr	r3, [r3, #0]
34017e10:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
34017e14:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34017e18:	683a      	ldr	r2, [r7, #0]
34017e1a:	68d1      	ldr	r1, [r2, #12]
34017e1c:	683a      	ldr	r2, [r7, #0]
34017e1e:	6952      	ldr	r2, [r2, #20]
34017e20:	4311      	orrs	r1, r2
34017e22:	683a      	ldr	r2, [r7, #0]
34017e24:	6912      	ldr	r2, [r2, #16]
34017e26:	4311      	orrs	r1, r2
34017e28:	683a      	ldr	r2, [r7, #0]
34017e2a:	69d2      	ldr	r2, [r2, #28]
34017e2c:	4311      	orrs	r1, r2
34017e2e:	683a      	ldr	r2, [r7, #0]
34017e30:	6a52      	ldr	r2, [r2, #36]	@ 0x24
34017e32:	4311      	orrs	r1, r2
34017e34:	683a      	ldr	r2, [r7, #0]
34017e36:	6a12      	ldr	r2, [r2, #32]
34017e38:	430a      	orrs	r2, r1
34017e3a:	431a      	orrs	r2, r3
34017e3c:	69bb      	ldr	r3, [r7, #24]
34017e3e:	601a      	str	r2, [r3, #0]
                                XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE),
                   (pCmd->InstructionMode | pCmd->InstructionDTRMode | pCmd->InstructionWidth |
                    pCmd->AddressMode     | pCmd->AddressDTRMode     | pCmd->AddressWidth));

        /* The DHQC bit is linked with DDTR bit which should be activated */
        if ((hxspi->Init.DelayHoldQuarterCycle == HAL_XSPI_DHQC_ENABLE) &&
34017e40:	687b      	ldr	r3, [r7, #4]
34017e42:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34017e44:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34017e48:	d109      	bne.n	34017e5e <XSPI_ConfigCmd+0x25e>
            (pCmd->InstructionDTRMode == HAL_XSPI_INSTRUCTION_DTR_ENABLE))
34017e4a:	683b      	ldr	r3, [r7, #0]
34017e4c:	695b      	ldr	r3, [r3, #20]
        if ((hxspi->Init.DelayHoldQuarterCycle == HAL_XSPI_DHQC_ENABLE) &&
34017e4e:	2b08      	cmp	r3, #8
34017e50:	d105      	bne.n	34017e5e <XSPI_ConfigCmd+0x25e>
        {
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
34017e52:	69bb      	ldr	r3, [r7, #24]
34017e54:	681b      	ldr	r3, [r3, #0]
34017e56:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
34017e5a:	69bb      	ldr	r3, [r7, #24]
34017e5c:	601a      	str	r2, [r3, #0]
        }
      }
      /* Configure the IR register with the instruction value */
      *ir_reg = pCmd->Instruction;
34017e5e:	683b      	ldr	r3, [r7, #0]
34017e60:	689a      	ldr	r2, [r3, #8]
34017e62:	693b      	ldr	r3, [r7, #16]
34017e64:	601a      	str	r2, [r3, #0]

      /* Configure the AR register with the address value */
      hxspi->Instance->AR = pCmd->Address;
34017e66:	687b      	ldr	r3, [r7, #4]
34017e68:	681b      	ldr	r3, [r3, #0]
34017e6a:	683a      	ldr	r2, [r7, #0]
34017e6c:	6992      	ldr	r2, [r2, #24]
34017e6e:	649a      	str	r2, [r3, #72]	@ 0x48
34017e70:	e07d      	b.n	34017f6e <XSPI_ConfigCmd+0x36e>
    }
    else
    {
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34017e72:	683b      	ldr	r3, [r7, #0]
34017e74:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34017e76:	2b00      	cmp	r3, #0
34017e78:	d01c      	beq.n	34017eb4 <XSPI_ConfigCmd+0x2b4>
      {
        /* ---- Command with instruction and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE |
34017e7a:	69bb      	ldr	r3, [r7, #24]
34017e7c:	681b      	ldr	r3, [r3, #0]
34017e7e:	f023 6370 	bic.w	r3, r3, #251658240	@ 0xf000000
34017e82:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34017e86:	683a      	ldr	r2, [r7, #0]
34017e88:	68d1      	ldr	r1, [r2, #12]
34017e8a:	683a      	ldr	r2, [r7, #0]
34017e8c:	6952      	ldr	r2, [r2, #20]
34017e8e:	4311      	orrs	r1, r2
34017e90:	683a      	ldr	r2, [r7, #0]
34017e92:	6912      	ldr	r2, [r2, #16]
34017e94:	4311      	orrs	r1, r2
34017e96:	683a      	ldr	r2, [r7, #0]
34017e98:	6b92      	ldr	r2, [r2, #56]	@ 0x38
34017e9a:	4311      	orrs	r1, r2
34017e9c:	683a      	ldr	r2, [r7, #0]
34017e9e:	6c12      	ldr	r2, [r2, #64]	@ 0x40
34017ea0:	430a      	orrs	r2, r1
34017ea2:	431a      	orrs	r2, r3
34017ea4:	69bb      	ldr	r3, [r7, #24]
34017ea6:	601a      	str	r2, [r3, #0]
34017ea8:	e022      	b.n	34017ef0 <XSPI_ConfigCmd+0x2f0>
34017eaa:	bf00      	nop
34017eac:	3401f094 	.word	0x3401f094
34017eb0:	f0ffc0c0 	.word	0xf0ffc0c0
      else
      {
        /* ---- Command with only instruction ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE),
34017eb4:	69bb      	ldr	r3, [r7, #24]
34017eb6:	681b      	ldr	r3, [r3, #0]
34017eb8:	f023 023f 	bic.w	r2, r3, #63	@ 0x3f
34017ebc:	683b      	ldr	r3, [r7, #0]
34017ebe:	68d9      	ldr	r1, [r3, #12]
34017ec0:	683b      	ldr	r3, [r7, #0]
34017ec2:	695b      	ldr	r3, [r3, #20]
34017ec4:	4319      	orrs	r1, r3
34017ec6:	683b      	ldr	r3, [r7, #0]
34017ec8:	691b      	ldr	r3, [r3, #16]
34017eca:	430b      	orrs	r3, r1
34017ecc:	431a      	orrs	r2, r3
34017ece:	69bb      	ldr	r3, [r7, #24]
34017ed0:	601a      	str	r2, [r3, #0]
                   (pCmd->InstructionMode | pCmd->InstructionDTRMode | pCmd->InstructionWidth));

        /* The DHQC bit is linked with DDTR bit which should be activated */
        if ((hxspi->Init.DelayHoldQuarterCycle == HAL_XSPI_DHQC_ENABLE) &&
34017ed2:	687b      	ldr	r3, [r7, #4]
34017ed4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34017ed6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34017eda:	d109      	bne.n	34017ef0 <XSPI_ConfigCmd+0x2f0>
            (pCmd->InstructionDTRMode == HAL_XSPI_INSTRUCTION_DTR_ENABLE))
34017edc:	683b      	ldr	r3, [r7, #0]
34017ede:	695b      	ldr	r3, [r3, #20]
        if ((hxspi->Init.DelayHoldQuarterCycle == HAL_XSPI_DHQC_ENABLE) &&
34017ee0:	2b08      	cmp	r3, #8
34017ee2:	d105      	bne.n	34017ef0 <XSPI_ConfigCmd+0x2f0>
        {
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
34017ee4:	69bb      	ldr	r3, [r7, #24]
34017ee6:	681b      	ldr	r3, [r3, #0]
34017ee8:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
34017eec:	69bb      	ldr	r3, [r7, #24]
34017eee:	601a      	str	r2, [r3, #0]
        }
      }

      /* Configure the IR register with the instruction value */
      *ir_reg = pCmd->Instruction;
34017ef0:	683b      	ldr	r3, [r7, #0]
34017ef2:	689a      	ldr	r2, [r3, #8]
34017ef4:	693b      	ldr	r3, [r7, #16]
34017ef6:	601a      	str	r2, [r3, #0]
34017ef8:	e039      	b.n	34017f6e <XSPI_ConfigCmd+0x36e>

    }
  }
  else
  {
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
34017efa:	683b      	ldr	r3, [r7, #0]
34017efc:	69db      	ldr	r3, [r3, #28]
34017efe:	2b00      	cmp	r3, #0
34017f00:	d030      	beq.n	34017f64 <XSPI_ConfigCmd+0x364>
    {
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34017f02:	683b      	ldr	r3, [r7, #0]
34017f04:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34017f06:	2b00      	cmp	r3, #0
34017f08:	d017      	beq.n	34017f3a <XSPI_ConfigCmd+0x33a>
      {
        /* ---- Command with address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE |
34017f0a:	69bb      	ldr	r3, [r7, #24]
34017f0c:	681b      	ldr	r3, [r3, #0]
34017f0e:	f023 6370 	bic.w	r3, r3, #251658240	@ 0xf000000
34017f12:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
34017f16:	683a      	ldr	r2, [r7, #0]
34017f18:	69d1      	ldr	r1, [r2, #28]
34017f1a:	683a      	ldr	r2, [r7, #0]
34017f1c:	6a52      	ldr	r2, [r2, #36]	@ 0x24
34017f1e:	4311      	orrs	r1, r2
34017f20:	683a      	ldr	r2, [r7, #0]
34017f22:	6a12      	ldr	r2, [r2, #32]
34017f24:	4311      	orrs	r1, r2
34017f26:	683a      	ldr	r2, [r7, #0]
34017f28:	6b92      	ldr	r2, [r2, #56]	@ 0x38
34017f2a:	4311      	orrs	r1, r2
34017f2c:	683a      	ldr	r2, [r7, #0]
34017f2e:	6c12      	ldr	r2, [r2, #64]	@ 0x40
34017f30:	430a      	orrs	r2, r1
34017f32:	431a      	orrs	r2, r3
34017f34:	69bb      	ldr	r3, [r7, #24]
34017f36:	601a      	str	r2, [r3, #0]
34017f38:	e00e      	b.n	34017f58 <XSPI_ConfigCmd+0x358>
      else
      {
        /* ---- Command with only address ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE),
34017f3a:	69bb      	ldr	r3, [r7, #24]
34017f3c:	681b      	ldr	r3, [r3, #0]
34017f3e:	f423 527c 	bic.w	r2, r3, #16128	@ 0x3f00
34017f42:	683b      	ldr	r3, [r7, #0]
34017f44:	69d9      	ldr	r1, [r3, #28]
34017f46:	683b      	ldr	r3, [r7, #0]
34017f48:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34017f4a:	4319      	orrs	r1, r3
34017f4c:	683b      	ldr	r3, [r7, #0]
34017f4e:	6a1b      	ldr	r3, [r3, #32]
34017f50:	430b      	orrs	r3, r1
34017f52:	431a      	orrs	r2, r3
34017f54:	69bb      	ldr	r3, [r7, #24]
34017f56:	601a      	str	r2, [r3, #0]
                   (pCmd->AddressMode | pCmd->AddressDTRMode | pCmd->AddressWidth));
      }

      /* Configure the AR register with the instruction value */
      hxspi->Instance->AR = pCmd->Address;
34017f58:	687b      	ldr	r3, [r7, #4]
34017f5a:	681b      	ldr	r3, [r3, #0]
34017f5c:	683a      	ldr	r2, [r7, #0]
34017f5e:	6992      	ldr	r2, [r2, #24]
34017f60:	649a      	str	r2, [r3, #72]	@ 0x48
34017f62:	e004      	b.n	34017f6e <XSPI_ConfigCmd+0x36e>
    }
    else
    {
      /* ---- Invalid command configuration (no instruction, no address) ---- */
      status = HAL_ERROR;
34017f64:	2301      	movs	r3, #1
34017f66:	77fb      	strb	r3, [r7, #31]
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
34017f68:	687b      	ldr	r3, [r7, #4]
34017f6a:	2208      	movs	r2, #8
34017f6c:	65da      	str	r2, [r3, #92]	@ 0x5c
    }
  }

  return status;
34017f6e:	7ffb      	ldrb	r3, [r7, #31]
}
34017f70:	4618      	mov	r0, r3
34017f72:	3720      	adds	r7, #32
34017f74:	46bd      	mov	sp, r7
34017f76:	bd80      	pop	{r7, pc}

34017f78 <CMW_CAMERA_GetDCMIPPHandle>:
static void CMW_CAMERA_PwrDown(void);
static int32_t CMW_CAMERA_SetPipe(DCMIPP_HandleTypeDef *hdcmipp, uint32_t pipe, CMW_DCMIPP_Conf_t *p_conf, uint32_t *pitch);
static int CMW_CAMERA_Probe_Sensor(CMW_Sensor_Init_t *initValues, CMW_Sensor_Name_t *sensorName);

DCMIPP_HandleTypeDef* CMW_CAMERA_GetDCMIPPHandle(void)
{
34017f78:	b480      	push	{r7}
34017f7a:	af00      	add	r7, sp, #0
    return &hcamera_dcmipp;
34017f7c:	4b02      	ldr	r3, [pc, #8]	@ (34017f88 <CMW_CAMERA_GetDCMIPPHandle+0x10>)
}
34017f7e:	4618      	mov	r0, r3
34017f80:	46bd      	mov	sp, r7
34017f82:	f85d 7b04 	ldr.w	r7, [sp], #4
34017f86:	4770      	bx	lr
34017f88:	34021014 	.word	0x34021014

34017f8c <CMW_CAMERA_PIPE_VsyncEventCallback>:
 * @brief  Vsync Event callback on pipe
 * @param  Pipe  Pipe receiving the callback
 * @retval None
 */
__weak int CMW_CAMERA_PIPE_VsyncEventCallback(uint32_t pipe)
{
34017f8c:	b480      	push	{r7}
34017f8e:	b083      	sub	sp, #12
34017f90:	af00      	add	r7, sp, #0
34017f92:	6078      	str	r0, [r7, #4]
  UNUSED(pipe);

  return HAL_OK;
34017f94:	2300      	movs	r3, #0
}
34017f96:	4618      	mov	r0, r3
34017f98:	370c      	adds	r7, #12
34017f9a:	46bd      	mov	sp, r7
34017f9c:	f85d 7b04 	ldr.w	r7, [sp], #4
34017fa0:	4770      	bx	lr

34017fa2 <CMW_CAMERA_PIPE_FrameEventCallback>:
 * @brief  Frame Event callback on pipe
 * @param  Pipe  Pipe receiving the callback
 * @retval None
 */
__weak int CMW_CAMERA_PIPE_FrameEventCallback(uint32_t pipe)
{
34017fa2:	b480      	push	{r7}
34017fa4:	b083      	sub	sp, #12
34017fa6:	af00      	add	r7, sp, #0
34017fa8:	6078      	str	r0, [r7, #4]
  UNUSED(pipe);

  return HAL_OK;
34017faa:	2300      	movs	r3, #0
}
34017fac:	4618      	mov	r0, r3
34017fae:	370c      	adds	r7, #12
34017fb0:	46bd      	mov	sp, r7
34017fb2:	f85d 7b04 	ldr.w	r7, [sp], #4
34017fb6:	4770      	bx	lr

34017fb8 <HAL_DCMIPP_PIPE_VsyncEventCallback>:
 * @param  hdcmipp DCMIPP device handle
 *         Pipe    Pipe receiving the callback
 * @retval None
 */
void HAL_DCMIPP_PIPE_VsyncEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34017fb8:	b580      	push	{r7, lr}
34017fba:	b082      	sub	sp, #8
34017fbc:	af00      	add	r7, sp, #0
34017fbe:	6078      	str	r0, [r7, #4]
34017fc0:	6039      	str	r1, [r7, #0]
  UNUSED(hdcmipp);
  if(Camera_Drv.VsyncEventCallback != NULL)
34017fc2:	4b08      	ldr	r3, [pc, #32]	@ (34017fe4 <HAL_DCMIPP_PIPE_VsyncEventCallback+0x2c>)
34017fc4:	691b      	ldr	r3, [r3, #16]
34017fc6:	2b00      	cmp	r3, #0
34017fc8:	d004      	beq.n	34017fd4 <HAL_DCMIPP_PIPE_VsyncEventCallback+0x1c>
  {
      Camera_Drv.VsyncEventCallback(&camera_bsp, Pipe);
34017fca:	4b06      	ldr	r3, [pc, #24]	@ (34017fe4 <HAL_DCMIPP_PIPE_VsyncEventCallback+0x2c>)
34017fcc:	691b      	ldr	r3, [r3, #16]
34017fce:	6839      	ldr	r1, [r7, #0]
34017fd0:	4805      	ldr	r0, [pc, #20]	@ (34017fe8 <HAL_DCMIPP_PIPE_VsyncEventCallback+0x30>)
34017fd2:	4798      	blx	r3
  }
  CMW_CAMERA_PIPE_VsyncEventCallback(Pipe);
34017fd4:	6838      	ldr	r0, [r7, #0]
34017fd6:	f7ff ffd9 	bl	34017f8c <CMW_CAMERA_PIPE_VsyncEventCallback>
}
34017fda:	bf00      	nop
34017fdc:	3708      	adds	r7, #8
34017fde:	46bd      	mov	sp, r7
34017fe0:	bd80      	pop	{r7, pc}
34017fe2:	bf00      	nop
34017fe4:	34021020 	.word	0x34021020
34017fe8:	34021088 	.word	0x34021088

34017fec <HAL_DCMIPP_PIPE_FrameEventCallback>:
 * @param  hdcmipp DCMIPP device handle
 *         Pipe    Pipe receiving the callback
 * @retval None
 */
void HAL_DCMIPP_PIPE_FrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34017fec:	b580      	push	{r7, lr}
34017fee:	b082      	sub	sp, #8
34017ff0:	af00      	add	r7, sp, #0
34017ff2:	6078      	str	r0, [r7, #4]
34017ff4:	6039      	str	r1, [r7, #0]
  UNUSED(hdcmipp);
  if(Camera_Drv.FrameEventCallback != NULL)
34017ff6:	4b08      	ldr	r3, [pc, #32]	@ (34018018 <HAL_DCMIPP_PIPE_FrameEventCallback+0x2c>)
34017ff8:	695b      	ldr	r3, [r3, #20]
34017ffa:	2b00      	cmp	r3, #0
34017ffc:	d004      	beq.n	34018008 <HAL_DCMIPP_PIPE_FrameEventCallback+0x1c>
  {
      Camera_Drv.FrameEventCallback(&camera_bsp, Pipe);
34017ffe:	4b06      	ldr	r3, [pc, #24]	@ (34018018 <HAL_DCMIPP_PIPE_FrameEventCallback+0x2c>)
34018000:	695b      	ldr	r3, [r3, #20]
34018002:	6839      	ldr	r1, [r7, #0]
34018004:	4805      	ldr	r0, [pc, #20]	@ (3401801c <HAL_DCMIPP_PIPE_FrameEventCallback+0x30>)
34018006:	4798      	blx	r3
  }
  CMW_CAMERA_PIPE_FrameEventCallback(Pipe);
34018008:	6838      	ldr	r0, [r7, #0]
3401800a:	f7ff ffca 	bl	34017fa2 <CMW_CAMERA_PIPE_FrameEventCallback>
}
3401800e:	bf00      	nop
34018010:	3708      	adds	r7, #8
34018012:	46bd      	mov	sp, r7
34018014:	bd80      	pop	{r7, pc}
34018016:	bf00      	nop
34018018:	34021020 	.word	0x34021020
3401801c:	34021088 	.word	0x34021088

34018020 <DMA2D_IRQHandler>:
                                   ctx->layers[0].size.height);
  assert(ret == HAL_OK);
}

void DMA2D_IRQHandler(void)
{
34018020:	b580      	push	{r7, lr}
34018022:	af00      	add	r7, sp, #0
  HAL_DMA2D_IRQHandler(dma2d_current);
34018024:	4b03      	ldr	r3, [pc, #12]	@ (34018034 <DMA2D_IRQHandler+0x14>)
34018026:	681b      	ldr	r3, [r3, #0]
34018028:	4618      	mov	r0, r3
3401802a:	f7ed fcca 	bl	340059c2 <HAL_DMA2D_IRQHandler>
}
3401802e:	bf00      	nop
34018030:	bd80      	pop	{r7, pc}
34018032:	bf00      	nop
34018034:	340211cc 	.word	0x340211cc

34018038 <spi_transfert_data_deinit>:
  ctx->len = w * h * 2;
  LCD_CS_LOW();
}

static void spi_transfert_data_deinit(struct scrl_spi_ctx *ctx)
{
34018038:	b480      	push	{r7}
3401803a:	b083      	sub	sp, #12
3401803c:	af00      	add	r7, sp, #0
3401803e:	6078      	str	r0, [r7, #4]
  LCD_CS_HIGH();
34018040:	4b04      	ldr	r3, [pc, #16]	@ (34018054 <spi_transfert_data_deinit+0x1c>)
34018042:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34018046:	619a      	str	r2, [r3, #24]
}
34018048:	bf00      	nop
3401804a:	370c      	adds	r7, #12
3401804c:	46bd      	mov	sp, r7
3401804e:	f85d 7b04 	ldr.w	r7, [sp], #4
34018052:	4770      	bx	lr
34018054:	56020c00 	.word	0x56020c00

34018058 <spi_transfert_data_chunck_start>:

static void spi_transfert_data_chunck_start(struct scrl_spi_ctx *ctx)
{
34018058:	b580      	push	{r7, lr}
3401805a:	b084      	sub	sp, #16
3401805c:	af00      	add	r7, sp, #0
3401805e:	6078      	str	r0, [r7, #4]
  uint16_t size = MIN(ctx->len, 63 * 1024);
34018060:	687b      	ldr	r3, [r7, #4]
34018062:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
34018066:	f5b3 4f7c 	cmp.w	r3, #64512	@ 0xfc00
3401806a:	bfa8      	it	ge
3401806c:	f44f 437c 	movge.w	r3, #64512	@ 0xfc00
34018070:	81fb      	strh	r3, [r7, #14]
  int ret;

  ret = HAL_SPI_Transmit_DMA(&hspi, ctx->data, size);
34018072:	687b      	ldr	r3, [r7, #4]
34018074:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34018078:	89fa      	ldrh	r2, [r7, #14]
3401807a:	4619      	mov	r1, r3
3401807c:	4810      	ldr	r0, [pc, #64]	@ (340180c0 <spi_transfert_data_chunck_start+0x68>)
3401807e:	f7fd f893 	bl	340151a8 <HAL_SPI_Transmit_DMA>
34018082:	4603      	mov	r3, r0
34018084:	60bb      	str	r3, [r7, #8]
  assert(ret == HAL_OK);
34018086:	68bb      	ldr	r3, [r7, #8]
34018088:	2b00      	cmp	r3, #0
3401808a:	d005      	beq.n	34018098 <spi_transfert_data_chunck_start+0x40>
3401808c:	4b0d      	ldr	r3, [pc, #52]	@ (340180c4 <spi_transfert_data_chunck_start+0x6c>)
3401808e:	4a0e      	ldr	r2, [pc, #56]	@ (340180c8 <spi_transfert_data_chunck_start+0x70>)
34018090:	219e      	movs	r1, #158	@ 0x9e
34018092:	480e      	ldr	r0, [pc, #56]	@ (340180cc <spi_transfert_data_chunck_start+0x74>)
34018094:	f003 fb9a 	bl	3401b7cc <__assert_func>

  ctx->len -= size;
34018098:	687b      	ldr	r3, [r7, #4]
3401809a:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3401809e:	89fb      	ldrh	r3, [r7, #14]
340180a0:	1ad2      	subs	r2, r2, r3
340180a2:	687b      	ldr	r3, [r7, #4]
340180a4:	f8c3 20b4 	str.w	r2, [r3, #180]	@ 0xb4
  ctx->data += size;
340180a8:	687b      	ldr	r3, [r7, #4]
340180aa:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
340180ae:	89fb      	ldrh	r3, [r7, #14]
340180b0:	441a      	add	r2, r3
340180b2:	687b      	ldr	r3, [r7, #4]
340180b4:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
}
340180b8:	bf00      	nop
340180ba:	3710      	adds	r7, #16
340180bc:	46bd      	mov	sp, r7
340180be:	bd80      	pop	{r7, pc}
340180c0:	34021288 	.word	0x34021288
340180c4:	3401f140 	.word	0x3401f140
340180c8:	3401ffb4 	.word	0x3401ffb4
340180cc:	3401f150 	.word	0x3401f150

340180d0 <HAL_SPI_TxCpltCallback>:
  ret = xSemaphoreGive(ctx->dma_sem);
  assert(ret == pdTRUE);
}
#else
void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
{
340180d0:	b580      	push	{r7, lr}
340180d2:	b084      	sub	sp, #16
340180d4:	af00      	add	r7, sp, #0
340180d6:	6078      	str	r0, [r7, #4]
  struct scrl_spi_ctx *ctx = &scrl_ctx;
340180d8:	4b0a      	ldr	r3, [pc, #40]	@ (34018104 <HAL_SPI_TxCpltCallback+0x34>)
340180da:	60fb      	str	r3, [r7, #12]

  if (ctx->len) {
340180dc:	68fb      	ldr	r3, [r7, #12]
340180de:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
340180e2:	2b00      	cmp	r3, #0
340180e4:	d003      	beq.n	340180ee <HAL_SPI_TxCpltCallback+0x1e>
    spi_transfert_data_chunck_start(ctx);
340180e6:	68f8      	ldr	r0, [r7, #12]
340180e8:	f7ff ffb6 	bl	34018058 <spi_transfert_data_chunck_start>
  } else {
    spi_transfert_data_deinit(ctx);
    ctx->is_screen_ready_to_update = 1;
  }
}
340180ec:	e006      	b.n	340180fc <HAL_SPI_TxCpltCallback+0x2c>
    spi_transfert_data_deinit(ctx);
340180ee:	68f8      	ldr	r0, [r7, #12]
340180f0:	f7ff ffa2 	bl	34018038 <spi_transfert_data_deinit>
    ctx->is_screen_ready_to_update = 1;
340180f4:	68fb      	ldr	r3, [r7, #12]
340180f6:	2201      	movs	r2, #1
340180f8:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
}
340180fc:	bf00      	nop
340180fe:	3710      	adds	r7, #16
34018100:	46bd      	mov	sp, r7
34018102:	bd80      	pop	{r7, pc}
34018104:	340211d0 	.word	0x340211d0

34018108 <HAL_SPI_ErrorCallback>:
#endif

void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
{
34018108:	b580      	push	{r7, lr}
3401810a:	b082      	sub	sp, #8
3401810c:	af00      	add	r7, sp, #0
3401810e:	6078      	str	r0, [r7, #4]
  assert(0);
34018110:	4b03      	ldr	r3, [pc, #12]	@ (34018120 <HAL_SPI_ErrorCallback+0x18>)
34018112:	4a04      	ldr	r2, [pc, #16]	@ (34018124 <HAL_SPI_ErrorCallback+0x1c>)
34018114:	f44f 7123 	mov.w	r1, #652	@ 0x28c
34018118:	4803      	ldr	r0, [pc, #12]	@ (34018128 <HAL_SPI_ErrorCallback+0x20>)
3401811a:	f003 fb57 	bl	3401b7cc <__assert_func>
3401811e:	bf00      	nop
34018120:	3401f1d8 	.word	0x3401f1d8
34018124:	3401ffd4 	.word	0x3401ffd4
34018128:	3401f150 	.word	0x3401f150

3401812c <SPI5_IRQHandler>:
}

void SPI5_IRQHandler(void)
{
3401812c:	b580      	push	{r7, lr}
3401812e:	af00      	add	r7, sp, #0
  HAL_SPI_IRQHandler(&hspi);
34018130:	4802      	ldr	r0, [pc, #8]	@ (3401813c <SPI5_IRQHandler+0x10>)
34018132:	f7fd fa17 	bl	34015564 <HAL_SPI_IRQHandler>
}
34018136:	bf00      	nop
34018138:	bd80      	pop	{r7, pc}
3401813a:	bf00      	nop
3401813c:	34021288 	.word	0x34021288

34018140 <HPDMA1_Channel12_IRQHandler>:

void HPDMA1_Channel12_IRQHandler(void)
{
34018140:	b580      	push	{r7, lr}
34018142:	af00      	add	r7, sp, #0
  HAL_DMA_IRQHandler(&hdma);
34018144:	4802      	ldr	r0, [pc, #8]	@ (34018150 <HPDMA1_Channel12_IRQHandler+0x10>)
34018146:	f7ed faa2 	bl	3400568e <HAL_DMA_IRQHandler>
}
3401814a:	bf00      	nop
3401814c:	bd80      	pop	{r7, pc}
3401814e:	bf00      	nop
34018150:	34021318 	.word	0x34021318

34018154 <simd_matrix_vector_mul_int8>:
    const int8_t* matrix,   // Pointer to MxN matrix
    const int8_t* vector,   // Pointer to vector of size N
    int32_t* result,        // Output vector of size M
    uint32_t M,             // Number of rows
    uint32_t N              // Number of columns (must be multiple of 4)
) {
34018154:	b480      	push	{r7}
34018156:	b0a5      	sub	sp, #148	@ 0x94
34018158:	af00      	add	r7, sp, #0
3401815a:	60f8      	str	r0, [r7, #12]
3401815c:	60b9      	str	r1, [r7, #8]
3401815e:	607a      	str	r2, [r7, #4]
34018160:	603b      	str	r3, [r7, #0]
    for (uint32_t i = 0; i < M; i++) {
34018162:	2300      	movs	r3, #0
34018164:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
34018168:	e0c7      	b.n	340182fa <simd_matrix_vector_mul_int8+0x1a6>
        const int8_t* mat_row = &matrix[i * N];
3401816a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
3401816e:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
34018172:	fb02 f303 	mul.w	r3, r2, r3
34018176:	68fa      	ldr	r2, [r7, #12]
34018178:	4413      	add	r3, r2
3401817a:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
        int32_t acc = 0;
3401817e:	2300      	movs	r3, #0
34018180:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88

        for (uint32_t j = 0; j < N; j += 4) {
34018184:	2300      	movs	r3, #0
34018186:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
3401818a:	e0a2      	b.n	340182d2 <simd_matrix_vector_mul_int8+0x17e>
            // Load 4 int8_t matrix elements and widen to int16_t
            int16_t mat16_0 = (int16_t)mat_row[j];
3401818c:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
34018190:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34018194:	4413      	add	r3, r2
34018196:	f993 3000 	ldrsb.w	r3, [r3]
3401819a:	f8a7 307e 	strh.w	r3, [r7, #126]	@ 0x7e
            int16_t mat16_1 = (int16_t)mat_row[j+1];
3401819e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
340181a2:	3301      	adds	r3, #1
340181a4:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
340181a8:	4413      	add	r3, r2
340181aa:	f993 3000 	ldrsb.w	r3, [r3]
340181ae:	f8a7 307c 	strh.w	r3, [r7, #124]	@ 0x7c
            int16_t mat16_2 = (int16_t)mat_row[j+2];
340181b2:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
340181b6:	3302      	adds	r3, #2
340181b8:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
340181bc:	4413      	add	r3, r2
340181be:	f993 3000 	ldrsb.w	r3, [r3]
340181c2:	f8a7 307a 	strh.w	r3, [r7, #122]	@ 0x7a
            int16_t mat16_3 = (int16_t)mat_row[j+3];
340181c6:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
340181ca:	3303      	adds	r3, #3
340181cc:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
340181d0:	4413      	add	r3, r2
340181d2:	f993 3000 	ldrsb.w	r3, [r3]
340181d6:	f8a7 3078 	strh.w	r3, [r7, #120]	@ 0x78

            int16_t vec16_0 = (int16_t)vector[j];
340181da:	68ba      	ldr	r2, [r7, #8]
340181dc:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
340181e0:	4413      	add	r3, r2
340181e2:	f993 3000 	ldrsb.w	r3, [r3]
340181e6:	f8a7 3076 	strh.w	r3, [r7, #118]	@ 0x76
            int16_t vec16_1 = (int16_t)vector[j+1];
340181ea:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
340181ee:	3301      	adds	r3, #1
340181f0:	68ba      	ldr	r2, [r7, #8]
340181f2:	4413      	add	r3, r2
340181f4:	f993 3000 	ldrsb.w	r3, [r3]
340181f8:	f8a7 3074 	strh.w	r3, [r7, #116]	@ 0x74
            int16_t vec16_2 = (int16_t)vector[j+2];
340181fc:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34018200:	3302      	adds	r3, #2
34018202:	68ba      	ldr	r2, [r7, #8]
34018204:	4413      	add	r3, r2
34018206:	f993 3000 	ldrsb.w	r3, [r3]
3401820a:	f8a7 3072 	strh.w	r3, [r7, #114]	@ 0x72
            int16_t vec16_3 = (int16_t)vector[j+3];
3401820e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34018212:	3303      	adds	r3, #3
34018214:	68ba      	ldr	r2, [r7, #8]
34018216:	4413      	add	r3, r2
34018218:	f993 3000 	ldrsb.w	r3, [r3]
3401821c:	f8a7 3070 	strh.w	r3, [r7, #112]	@ 0x70

            // Pack two 16-bit values into one 32-bit value (low | high)
            int32_t mat_pack1 = __PKHBT(mat16_0, mat16_1, 16);
34018220:	f9b7 307e 	ldrsh.w	r3, [r7, #126]	@ 0x7e
34018224:	66fb      	str	r3, [r7, #108]	@ 0x6c
34018226:	f9b7 307c 	ldrsh.w	r3, [r7, #124]	@ 0x7c
3401822a:	66bb      	str	r3, [r7, #104]	@ 0x68
3401822c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3401822e:	6eba      	ldr	r2, [r7, #104]	@ 0x68
34018230:	eac3 4302 	pkhbt	r3, r3, r2, lsl #16
34018234:	667b      	str	r3, [r7, #100]	@ 0x64
34018236:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
34018238:	663b      	str	r3, [r7, #96]	@ 0x60
            int32_t mat_pack2 = __PKHBT(mat16_2, mat16_3, 16);
3401823a:	f9b7 307a 	ldrsh.w	r3, [r7, #122]	@ 0x7a
3401823e:	65fb      	str	r3, [r7, #92]	@ 0x5c
34018240:	f9b7 3078 	ldrsh.w	r3, [r7, #120]	@ 0x78
34018244:	65bb      	str	r3, [r7, #88]	@ 0x58
34018246:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34018248:	6dba      	ldr	r2, [r7, #88]	@ 0x58
3401824a:	eac3 4302 	pkhbt	r3, r3, r2, lsl #16
3401824e:	657b      	str	r3, [r7, #84]	@ 0x54
34018250:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34018252:	653b      	str	r3, [r7, #80]	@ 0x50

            int32_t vec_pack1 = __PKHBT(vec16_0, vec16_1, 16);
34018254:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	@ 0x76
34018258:	64fb      	str	r3, [r7, #76]	@ 0x4c
3401825a:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	@ 0x74
3401825e:	64bb      	str	r3, [r7, #72]	@ 0x48
34018260:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34018262:	6cba      	ldr	r2, [r7, #72]	@ 0x48
34018264:	eac3 4302 	pkhbt	r3, r3, r2, lsl #16
34018268:	647b      	str	r3, [r7, #68]	@ 0x44
3401826a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3401826c:	643b      	str	r3, [r7, #64]	@ 0x40
            int32_t vec_pack2 = __PKHBT(vec16_2, vec16_3, 16);
3401826e:	f9b7 3072 	ldrsh.w	r3, [r7, #114]	@ 0x72
34018272:	63fb      	str	r3, [r7, #60]	@ 0x3c
34018274:	f9b7 3070 	ldrsh.w	r3, [r7, #112]	@ 0x70
34018278:	63bb      	str	r3, [r7, #56]	@ 0x38
3401827a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3401827c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3401827e:	eac3 4302 	pkhbt	r3, r3, r2, lsl #16
34018282:	637b      	str	r3, [r7, #52]	@ 0x34
34018284:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34018286:	633b      	str	r3, [r7, #48]	@ 0x30

            // Multiply-accumulate using SIMD (SMLAD: dual 16-bit signed multiply and accumulate)
            acc = __SMLAD(mat_pack1, vec_pack1, acc);
34018288:	6e39      	ldr	r1, [r7, #96]	@ 0x60
3401828a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
3401828c:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
34018290:	61f9      	str	r1, [r7, #28]
34018292:	61ba      	str	r2, [r7, #24]
34018294:	617b      	str	r3, [r7, #20]

__STATIC_FORCEINLINE uint32_t __SMLAD (uint32_t op1, uint32_t op2, uint32_t op3)
{
  uint32_t result;

  __ASM volatile ("smlad %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
34018296:	69fb      	ldr	r3, [r7, #28]
34018298:	69ba      	ldr	r2, [r7, #24]
3401829a:	6979      	ldr	r1, [r7, #20]
3401829c:	fb23 1302 	smlad	r3, r3, r2, r1
340182a0:	613b      	str	r3, [r7, #16]
  return(result);
340182a2:	693b      	ldr	r3, [r7, #16]
340182a4:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
            acc = __SMLAD(mat_pack2, vec_pack2, acc);
340182a8:	6d39      	ldr	r1, [r7, #80]	@ 0x50
340182aa:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
340182ac:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
340182b0:	62f9      	str	r1, [r7, #44]	@ 0x2c
340182b2:	62ba      	str	r2, [r7, #40]	@ 0x28
340182b4:	627b      	str	r3, [r7, #36]	@ 0x24
  __ASM volatile ("smlad %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
340182b6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
340182b8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340182ba:	6a79      	ldr	r1, [r7, #36]	@ 0x24
340182bc:	fb23 1302 	smlad	r3, r3, r2, r1
340182c0:	623b      	str	r3, [r7, #32]
  return(result);
340182c2:	6a3b      	ldr	r3, [r7, #32]
340182c4:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
        for (uint32_t j = 0; j < N; j += 4) {
340182c8:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
340182cc:	3304      	adds	r3, #4
340182ce:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
340182d2:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
340182d6:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
340182da:	429a      	cmp	r2, r3
340182dc:	f4ff af56 	bcc.w	3401818c <simd_matrix_vector_mul_int8+0x38>
        }

        result[i] = acc;
340182e0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
340182e4:	009b      	lsls	r3, r3, #2
340182e6:	687a      	ldr	r2, [r7, #4]
340182e8:	4413      	add	r3, r2
340182ea:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
340182ee:	601a      	str	r2, [r3, #0]
    for (uint32_t i = 0; i < M; i++) {
340182f0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
340182f4:	3301      	adds	r3, #1
340182f6:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
340182fa:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
340182fe:	683b      	ldr	r3, [r7, #0]
34018300:	429a      	cmp	r2, r3
34018302:	f4ff af32 	bcc.w	3401816a <simd_matrix_vector_mul_int8+0x16>
    }
}
34018306:	bf00      	nop
34018308:	bf00      	nop
3401830a:	3794      	adds	r7, #148	@ 0x94
3401830c:	46bd      	mov	sp, r7
3401830e:	f85d 7b04 	ldr.w	r7, [sp], #4
34018312:	4770      	bx	lr

34018314 <LL_Streng_len>:
  {
    return conf->addr_base.p + conf->offset_limit;
  }

  static inline uint32_t LL_Streng_len(const LL_Streng_TensorInitTypeDef *conf)
  {
34018314:	b480      	push	{r7}
34018316:	b083      	sub	sp, #12
34018318:	af00      	add	r7, sp, #0
3401831a:	6078      	str	r0, [r7, #4]
    return conf->offset_end - conf->offset_start;
3401831c:	687b      	ldr	r3, [r7, #4]
3401831e:	68da      	ldr	r2, [r3, #12]
34018320:	687b      	ldr	r3, [r7, #4]
34018322:	689b      	ldr	r3, [r3, #8]
34018324:	1ad3      	subs	r3, r2, r3
  }
34018326:	4618      	mov	r0, r3
34018328:	370c      	adds	r7, #12
3401832a:	46bd      	mov	sp, r7
3401832c:	f85d 7b04 	ldr.w	r7, [sp], #4
34018330:	4770      	bx	lr
	...

34018334 <ll_aton_static_checks>:
 *  Used to exit from LL_Streng_Wait() in case epoch locks
 * @{
 */

static inline void ll_aton_static_checks(void)
{
34018334:	b580      	push	{r7, lr}
34018336:	b082      	sub	sp, #8
34018338:	af02      	add	r7, sp, #8
  static char done = 0;

  if (done != 0)
3401833a:	4b27      	ldr	r3, [pc, #156]	@ (340183d8 <ll_aton_static_checks+0xa4>)
3401833c:	781b      	ldrb	r3, [r3, #0]
3401833e:	2b00      	cmp	r3, #0
34018340:	d146      	bne.n	340183d0 <ll_aton_static_checks+0x9c>
    return;
  done = 1;
34018342:	4b25      	ldr	r3, [pc, #148]	@ (340183d8 <ll_aton_static_checks+0xa4>)
34018344:	2201      	movs	r2, #1
34018346:	701a      	strb	r2, [r3, #0]
  LL_ATON_ASSERT(ATONN_CONST_SRCPORT(S, J, U, I, P) == __atonn_getSrcPortID(S, J, U, I, P))
#define ASSERT_ATONN_DSTPORT(S, J, U, I, P)                                                                            \
  LL_ATON_ASSERT(ATONN_CONST_DSTPORT(S, J, U, I, P) == __atonn_getDstPortID(S, J, U, I, P))

#if ATON_STRENG_NUM > 1
  ASSERT_ATONN_SRCPORT(STRSWITCH, 0, STRENG, 1, 0);
34018348:	2300      	movs	r3, #0
3401834a:	9300      	str	r3, [sp, #0]
3401834c:	2301      	movs	r3, #1
3401834e:	2200      	movs	r2, #0
34018350:	2100      	movs	r1, #0
34018352:	2000      	movs	r0, #0
34018354:	f001 fa56 	bl	34019804 <__atonn_getSrcPortID>
34018358:	4603      	mov	r3, r0
3401835a:	2b01      	cmp	r3, #1
3401835c:	d005      	beq.n	3401836a <ll_aton_static_checks+0x36>
3401835e:	4b1f      	ldr	r3, [pc, #124]	@ (340183dc <ll_aton_static_checks+0xa8>)
34018360:	4a1f      	ldr	r2, [pc, #124]	@ (340183e0 <ll_aton_static_checks+0xac>)
34018362:	214c      	movs	r1, #76	@ 0x4c
34018364:	481f      	ldr	r0, [pc, #124]	@ (340183e4 <ll_aton_static_checks+0xb0>)
34018366:	f003 fa31 	bl	3401b7cc <__assert_func>
  ASSERT_ATONN_DSTPORT(STRSWITCH, 0, STRENG, 1, 0);
3401836a:	2300      	movs	r3, #0
3401836c:	9300      	str	r3, [sp, #0]
3401836e:	2301      	movs	r3, #1
34018370:	2200      	movs	r2, #0
34018372:	2100      	movs	r1, #0
34018374:	2000      	movs	r0, #0
34018376:	f001 fb35 	bl	340199e4 <__atonn_getDstPortID>
3401837a:	4603      	mov	r3, r0
3401837c:	2b0c      	cmp	r3, #12
3401837e:	d005      	beq.n	3401838c <ll_aton_static_checks+0x58>
34018380:	4b19      	ldr	r3, [pc, #100]	@ (340183e8 <ll_aton_static_checks+0xb4>)
34018382:	4a17      	ldr	r2, [pc, #92]	@ (340183e0 <ll_aton_static_checks+0xac>)
34018384:	214d      	movs	r1, #77	@ 0x4d
34018386:	4817      	ldr	r0, [pc, #92]	@ (340183e4 <ll_aton_static_checks+0xb0>)
34018388:	f003 fa20 	bl	3401b7cc <__assert_func>
#endif
#if ATON_STRENG_NUM > 2
  ASSERT_ATONN_SRCPORT(STRSWITCH, 0, STRENG, 2, 0);
3401838c:	2300      	movs	r3, #0
3401838e:	9300      	str	r3, [sp, #0]
34018390:	2302      	movs	r3, #2
34018392:	2200      	movs	r2, #0
34018394:	2100      	movs	r1, #0
34018396:	2000      	movs	r0, #0
34018398:	f001 fa34 	bl	34019804 <__atonn_getSrcPortID>
3401839c:	4603      	mov	r3, r0
3401839e:	2b02      	cmp	r3, #2
340183a0:	d005      	beq.n	340183ae <ll_aton_static_checks+0x7a>
340183a2:	4b12      	ldr	r3, [pc, #72]	@ (340183ec <ll_aton_static_checks+0xb8>)
340183a4:	4a0e      	ldr	r2, [pc, #56]	@ (340183e0 <ll_aton_static_checks+0xac>)
340183a6:	2150      	movs	r1, #80	@ 0x50
340183a8:	480e      	ldr	r0, [pc, #56]	@ (340183e4 <ll_aton_static_checks+0xb0>)
340183aa:	f003 fa0f 	bl	3401b7cc <__assert_func>
  ASSERT_ATONN_DSTPORT(STRSWITCH, 0, STRENG, 2, 0);
340183ae:	2300      	movs	r3, #0
340183b0:	9300      	str	r3, [sp, #0]
340183b2:	2302      	movs	r3, #2
340183b4:	2200      	movs	r2, #0
340183b6:	2100      	movs	r1, #0
340183b8:	2000      	movs	r0, #0
340183ba:	f001 fb13 	bl	340199e4 <__atonn_getDstPortID>
340183be:	4603      	mov	r3, r0
340183c0:	2b10      	cmp	r3, #16
340183c2:	d006      	beq.n	340183d2 <ll_aton_static_checks+0x9e>
340183c4:	4b0a      	ldr	r3, [pc, #40]	@ (340183f0 <ll_aton_static_checks+0xbc>)
340183c6:	4a06      	ldr	r2, [pc, #24]	@ (340183e0 <ll_aton_static_checks+0xac>)
340183c8:	2151      	movs	r1, #81	@ 0x51
340183ca:	4806      	ldr	r0, [pc, #24]	@ (340183e4 <ll_aton_static_checks+0xb0>)
340183cc:	f003 f9fe 	bl	3401b7cc <__assert_func>
    return;
340183d0:	bf00      	nop

#endif // (LL_ATON_PLATFORM == LL_ATON_PLAT_EC_TRACE)

#undef ASSERT_ATONN_SRCPORT
#undef ASSERT_ATONN_DSTPORT
}
340183d2:	46bd      	mov	sp, r7
340183d4:	bd80      	pop	{r7, pc}
340183d6:	bf00      	nop
340183d8:	340213a0 	.word	0x340213a0
340183dc:	3401f1e8 	.word	0x3401f1e8
340183e0:	3401fffc 	.word	0x3401fffc
340183e4:	3401f224 	.word	0x3401f224
340183e8:	3401f2b4 	.word	0x3401f2b4
340183ec:	3401f300 	.word	0x3401f300
340183f0:	3401f33c 	.word	0x3401f33c

340183f4 <LL_ATON_Init>:
/**
 * @brief  ATON global initialization. Initializes clocks and bus interfaces. Must be called before anything else
 * @retval Always zero
 */
int LL_ATON_Init(void)
{
340183f4:	b590      	push	{r4, r7, lr}
340183f6:	b08b      	sub	sp, #44	@ 0x2c
340183f8:	af08      	add	r7, sp, #32
  uint32_t t;
  int i;

  ll_aton_static_checks();
340183fa:	f7ff ff9b 	bl	34018334 <ll_aton_static_checks>

  /* Clear pipeline */
  t = ATON_CLKCTRL_CTRL_GET(0);
340183fe:	4b97      	ldr	r3, [pc, #604]	@ (3401865c <LL_ATON_Init+0x268>)
34018400:	681b      	ldr	r3, [r3, #0]
34018402:	607b      	str	r3, [r7, #4]
  t = ATON_CLKCTRL_CTRL_SET_CLR(t, 1);
34018404:	687b      	ldr	r3, [r7, #4]
34018406:	f043 0302 	orr.w	r3, r3, #2
3401840a:	607b      	str	r3, [r7, #4]
  ATON_CLKCTRL_CTRL_SET(0, t);
3401840c:	4a93      	ldr	r2, [pc, #588]	@ (3401865c <LL_ATON_Init+0x268>)
3401840e:	687b      	ldr	r3, [r7, #4]
34018410:	6013      	str	r3, [r2, #0]

  /* Enable all ATON clocks */
  ATON_CLKCTRL_CTRL_SET(0, 1);
34018412:	4b92      	ldr	r3, [pc, #584]	@ (3401865c <LL_ATON_Init+0x268>)
34018414:	2201      	movs	r2, #1
34018416:	601a      	str	r2, [r3, #0]
  ATON_CLKCTRL_AGATES0_SET(0, 0xffffffff);
34018418:	4b91      	ldr	r3, [pc, #580]	@ (34018660 <LL_ATON_Init+0x26c>)
3401841a:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
3401841e:	601a      	str	r2, [r3, #0]
  ATON_CLKCTRL_AGATES1_SET(0, 0xffffffff);
34018420:	4b90      	ldr	r3, [pc, #576]	@ (34018664 <LL_ATON_Init+0x270>)
34018422:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
34018426:	601a      	str	r2, [r3, #0]

#if (LL_ATON_ENABLE_CLOCK_GATING == 1)
#if (LL_ATON_PLATFORM == LL_ATON_PLAT_EC_TRACE)
  ATON_CLKCTRL_BGATES_SET(0, (1 << ATON_EPOCHCTRL_CLKB_CLK(0)));
#else
  ATON_CLKCTRL_BGATES_SET(0, 0x0);
34018428:	4b8f      	ldr	r3, [pc, #572]	@ (34018668 <LL_ATON_Init+0x274>)
3401842a:	2200      	movs	r2, #0
3401842c:	601a      	str	r2, [r3, #0]
#ifdef ATON_CLKCTRL_BGATES1_OFFSET
  ATON_CLKCTRL_BGATES1_SET(0, 0xffffffff);
#endif

  /* Check that RTL and ATON.h match. Only check first unit */
  ASSERT_UNITS_VERS_W_MSG(STRENG, t);
3401842e:	4b8f      	ldr	r3, [pc, #572]	@ (3401866c <LL_ATON_Init+0x278>)
34018430:	681b      	ldr	r3, [r3, #0]
34018432:	607b      	str	r3, [r7, #4]
34018434:	687b      	ldr	r3, [r7, #4]
34018436:	2b00      	cmp	r3, #0
34018438:	d0f9      	beq.n	3401842e <LL_ATON_Init+0x3a>
3401843a:	687b      	ldr	r3, [r7, #4]
3401843c:	b2db      	uxtb	r3, r3
3401843e:	2b01      	cmp	r3, #1
34018440:	d10a      	bne.n	34018458 <LL_ATON_Init+0x64>
34018442:	687b      	ldr	r3, [r7, #4]
34018444:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
34018448:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
3401844c:	d104      	bne.n	34018458 <LL_ATON_Init+0x64>
3401844e:	687b      	ldr	r3, [r7, #4]
34018450:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34018454:	2b00      	cmp	r3, #0
34018456:	d02f      	beq.n	340184b8 <LL_ATON_Init+0xc4>
34018458:	f004 fbfc 	bl	3401cc54 <__errno>
3401845c:	4603      	mov	r3, r0
3401845e:	681b      	ldr	r3, [r3, #0]
34018460:	2b00      	cmp	r3, #0
34018462:	d008      	beq.n	34018476 <LL_ATON_Init+0x82>
34018464:	f004 fbf6 	bl	3401cc54 <__errno>
34018468:	4603      	mov	r3, r0
3401846a:	681b      	ldr	r3, [r3, #0]
3401846c:	4618      	mov	r0, r3
3401846e:	f004 fb8b 	bl	3401cb88 <strerror>
34018472:	4603      	mov	r3, r0
34018474:	e000      	b.n	34018478 <LL_ATON_Init+0x84>
34018476:	4b7e      	ldr	r3, [pc, #504]	@ (34018670 <LL_ATON_Init+0x27c>)
34018478:	687a      	ldr	r2, [r7, #4]
3401847a:	b2d2      	uxtb	r2, r2
3401847c:	6879      	ldr	r1, [r7, #4]
3401847e:	0b09      	lsrs	r1, r1, #12
34018480:	f001 010f 	and.w	r1, r1, #15
34018484:	6878      	ldr	r0, [r7, #4]
34018486:	0a00      	lsrs	r0, r0, #8
34018488:	f000 000f 	and.w	r0, r0, #15
3401848c:	2400      	movs	r4, #0
3401848e:	9406      	str	r4, [sp, #24]
34018490:	2405      	movs	r4, #5
34018492:	9405      	str	r4, [sp, #20]
34018494:	2401      	movs	r4, #1
34018496:	9404      	str	r4, [sp, #16]
34018498:	9003      	str	r0, [sp, #12]
3401849a:	9102      	str	r1, [sp, #8]
3401849c:	9201      	str	r2, [sp, #4]
3401849e:	4a75      	ldr	r2, [pc, #468]	@ (34018674 <LL_ATON_Init+0x280>)
340184a0:	9200      	str	r2, [sp, #0]
340184a2:	22c7      	movs	r2, #199	@ 0xc7
340184a4:	4974      	ldr	r1, [pc, #464]	@ (34018678 <LL_ATON_Init+0x284>)
340184a6:	4875      	ldr	r0, [pc, #468]	@ (3401867c <LL_ATON_Init+0x288>)
340184a8:	f004 f838 	bl	3401c51c <iprintf>
340184ac:	4b74      	ldr	r3, [pc, #464]	@ (34018680 <LL_ATON_Init+0x28c>)
340184ae:	4a75      	ldr	r2, [pc, #468]	@ (34018684 <LL_ATON_Init+0x290>)
340184b0:	21c7      	movs	r1, #199	@ 0xc7
340184b2:	4871      	ldr	r0, [pc, #452]	@ (34018678 <LL_ATON_Init+0x284>)
340184b4:	f003 f98a 	bl	3401b7cc <__assert_func>

#ifdef ATON_CONVACC_NUM
  ASSERT_UNITS_VERS_W_MSG(CONVACC, t);
340184b8:	4b73      	ldr	r3, [pc, #460]	@ (34018688 <LL_ATON_Init+0x294>)
340184ba:	681b      	ldr	r3, [r3, #0]
340184bc:	607b      	str	r3, [r7, #4]
340184be:	687b      	ldr	r3, [r7, #4]
340184c0:	2b00      	cmp	r3, #0
340184c2:	d0f9      	beq.n	340184b8 <LL_ATON_Init+0xc4>
340184c4:	687b      	ldr	r3, [r7, #4]
340184c6:	b2db      	uxtb	r3, r3
340184c8:	2b17      	cmp	r3, #23
340184ca:	d10b      	bne.n	340184e4 <LL_ATON_Init+0xf0>
340184cc:	687b      	ldr	r3, [r7, #4]
340184ce:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
340184d2:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
340184d6:	d105      	bne.n	340184e4 <LL_ATON_Init+0xf0>
340184d8:	687b      	ldr	r3, [r7, #4]
340184da:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
340184de:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340184e2:	d02f      	beq.n	34018544 <LL_ATON_Init+0x150>
340184e4:	f004 fbb6 	bl	3401cc54 <__errno>
340184e8:	4603      	mov	r3, r0
340184ea:	681b      	ldr	r3, [r3, #0]
340184ec:	2b00      	cmp	r3, #0
340184ee:	d008      	beq.n	34018502 <LL_ATON_Init+0x10e>
340184f0:	f004 fbb0 	bl	3401cc54 <__errno>
340184f4:	4603      	mov	r3, r0
340184f6:	681b      	ldr	r3, [r3, #0]
340184f8:	4618      	mov	r0, r3
340184fa:	f004 fb45 	bl	3401cb88 <strerror>
340184fe:	4603      	mov	r3, r0
34018500:	e000      	b.n	34018504 <LL_ATON_Init+0x110>
34018502:	4b5b      	ldr	r3, [pc, #364]	@ (34018670 <LL_ATON_Init+0x27c>)
34018504:	687a      	ldr	r2, [r7, #4]
34018506:	b2d2      	uxtb	r2, r2
34018508:	6879      	ldr	r1, [r7, #4]
3401850a:	0b09      	lsrs	r1, r1, #12
3401850c:	f001 010f 	and.w	r1, r1, #15
34018510:	6878      	ldr	r0, [r7, #4]
34018512:	0a00      	lsrs	r0, r0, #8
34018514:	f000 000f 	and.w	r0, r0, #15
34018518:	2401      	movs	r4, #1
3401851a:	9406      	str	r4, [sp, #24]
3401851c:	2405      	movs	r4, #5
3401851e:	9405      	str	r4, [sp, #20]
34018520:	2417      	movs	r4, #23
34018522:	9404      	str	r4, [sp, #16]
34018524:	9003      	str	r0, [sp, #12]
34018526:	9102      	str	r1, [sp, #8]
34018528:	9201      	str	r2, [sp, #4]
3401852a:	4a58      	ldr	r2, [pc, #352]	@ (3401868c <LL_ATON_Init+0x298>)
3401852c:	9200      	str	r2, [sp, #0]
3401852e:	22ca      	movs	r2, #202	@ 0xca
34018530:	4951      	ldr	r1, [pc, #324]	@ (34018678 <LL_ATON_Init+0x284>)
34018532:	4852      	ldr	r0, [pc, #328]	@ (3401867c <LL_ATON_Init+0x288>)
34018534:	f003 fff2 	bl	3401c51c <iprintf>
34018538:	4b51      	ldr	r3, [pc, #324]	@ (34018680 <LL_ATON_Init+0x28c>)
3401853a:	4a52      	ldr	r2, [pc, #328]	@ (34018684 <LL_ATON_Init+0x290>)
3401853c:	21ca      	movs	r1, #202	@ 0xca
3401853e:	484e      	ldr	r0, [pc, #312]	@ (34018678 <LL_ATON_Init+0x284>)
34018540:	f003 f944 	bl	3401b7cc <__assert_func>
#endif

#ifdef ATON_POOL_NUM
  ASSERT_UNITS_VERS_W_MSG(POOL, t);
34018544:	4b52      	ldr	r3, [pc, #328]	@ (34018690 <LL_ATON_Init+0x29c>)
34018546:	681b      	ldr	r3, [r3, #0]
34018548:	607b      	str	r3, [r7, #4]
3401854a:	687b      	ldr	r3, [r7, #4]
3401854c:	2b00      	cmp	r3, #0
3401854e:	d0f9      	beq.n	34018544 <LL_ATON_Init+0x150>
34018550:	687b      	ldr	r3, [r7, #4]
34018552:	b2db      	uxtb	r3, r3
34018554:	2b1c      	cmp	r3, #28
34018556:	d10b      	bne.n	34018570 <LL_ATON_Init+0x17c>
34018558:	687b      	ldr	r3, [r7, #4]
3401855a:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
3401855e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34018562:	d105      	bne.n	34018570 <LL_ATON_Init+0x17c>
34018564:	687b      	ldr	r3, [r7, #4]
34018566:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3401856a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401856e:	d02f      	beq.n	340185d0 <LL_ATON_Init+0x1dc>
34018570:	f004 fb70 	bl	3401cc54 <__errno>
34018574:	4603      	mov	r3, r0
34018576:	681b      	ldr	r3, [r3, #0]
34018578:	2b00      	cmp	r3, #0
3401857a:	d008      	beq.n	3401858e <LL_ATON_Init+0x19a>
3401857c:	f004 fb6a 	bl	3401cc54 <__errno>
34018580:	4603      	mov	r3, r0
34018582:	681b      	ldr	r3, [r3, #0]
34018584:	4618      	mov	r0, r3
34018586:	f004 faff 	bl	3401cb88 <strerror>
3401858a:	4603      	mov	r3, r0
3401858c:	e000      	b.n	34018590 <LL_ATON_Init+0x19c>
3401858e:	4b38      	ldr	r3, [pc, #224]	@ (34018670 <LL_ATON_Init+0x27c>)
34018590:	687a      	ldr	r2, [r7, #4]
34018592:	b2d2      	uxtb	r2, r2
34018594:	6879      	ldr	r1, [r7, #4]
34018596:	0b09      	lsrs	r1, r1, #12
34018598:	f001 010f 	and.w	r1, r1, #15
3401859c:	6878      	ldr	r0, [r7, #4]
3401859e:	0a00      	lsrs	r0, r0, #8
340185a0:	f000 000f 	and.w	r0, r0, #15
340185a4:	2401      	movs	r4, #1
340185a6:	9406      	str	r4, [sp, #24]
340185a8:	2401      	movs	r4, #1
340185aa:	9405      	str	r4, [sp, #20]
340185ac:	241c      	movs	r4, #28
340185ae:	9404      	str	r4, [sp, #16]
340185b0:	9003      	str	r0, [sp, #12]
340185b2:	9102      	str	r1, [sp, #8]
340185b4:	9201      	str	r2, [sp, #4]
340185b6:	4a37      	ldr	r2, [pc, #220]	@ (34018694 <LL_ATON_Init+0x2a0>)
340185b8:	9200      	str	r2, [sp, #0]
340185ba:	22ce      	movs	r2, #206	@ 0xce
340185bc:	492e      	ldr	r1, [pc, #184]	@ (34018678 <LL_ATON_Init+0x284>)
340185be:	482f      	ldr	r0, [pc, #188]	@ (3401867c <LL_ATON_Init+0x288>)
340185c0:	f003 ffac 	bl	3401c51c <iprintf>
340185c4:	4b2e      	ldr	r3, [pc, #184]	@ (34018680 <LL_ATON_Init+0x28c>)
340185c6:	4a2f      	ldr	r2, [pc, #188]	@ (34018684 <LL_ATON_Init+0x290>)
340185c8:	21ce      	movs	r1, #206	@ 0xce
340185ca:	482b      	ldr	r0, [pc, #172]	@ (34018678 <LL_ATON_Init+0x284>)
340185cc:	f003 f8fe 	bl	3401b7cc <__assert_func>
#endif

#ifdef ATON_ARITH_NUM
  ASSERT_UNITS_VERS_W_MSG(ARITH, t);
340185d0:	4b31      	ldr	r3, [pc, #196]	@ (34018698 <LL_ATON_Init+0x2a4>)
340185d2:	681b      	ldr	r3, [r3, #0]
340185d4:	607b      	str	r3, [r7, #4]
340185d6:	687b      	ldr	r3, [r7, #4]
340185d8:	2b00      	cmp	r3, #0
340185da:	d0f9      	beq.n	340185d0 <LL_ATON_Init+0x1dc>
340185dc:	687b      	ldr	r3, [r7, #4]
340185de:	b2db      	uxtb	r3, r3
340185e0:	2b1a      	cmp	r3, #26
340185e2:	d10a      	bne.n	340185fa <LL_ATON_Init+0x206>
340185e4:	687b      	ldr	r3, [r7, #4]
340185e6:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
340185ea:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340185ee:	d104      	bne.n	340185fa <LL_ATON_Init+0x206>
340185f0:	687b      	ldr	r3, [r7, #4]
340185f2:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
340185f6:	2b00      	cmp	r3, #0
340185f8:	d052      	beq.n	340186a0 <LL_ATON_Init+0x2ac>
340185fa:	f004 fb2b 	bl	3401cc54 <__errno>
340185fe:	4603      	mov	r3, r0
34018600:	681b      	ldr	r3, [r3, #0]
34018602:	2b00      	cmp	r3, #0
34018604:	d008      	beq.n	34018618 <LL_ATON_Init+0x224>
34018606:	f004 fb25 	bl	3401cc54 <__errno>
3401860a:	4603      	mov	r3, r0
3401860c:	681b      	ldr	r3, [r3, #0]
3401860e:	4618      	mov	r0, r3
34018610:	f004 faba 	bl	3401cb88 <strerror>
34018614:	4603      	mov	r3, r0
34018616:	e000      	b.n	3401861a <LL_ATON_Init+0x226>
34018618:	4b15      	ldr	r3, [pc, #84]	@ (34018670 <LL_ATON_Init+0x27c>)
3401861a:	687a      	ldr	r2, [r7, #4]
3401861c:	b2d2      	uxtb	r2, r2
3401861e:	6879      	ldr	r1, [r7, #4]
34018620:	0b09      	lsrs	r1, r1, #12
34018622:	f001 010f 	and.w	r1, r1, #15
34018626:	6878      	ldr	r0, [r7, #4]
34018628:	0a00      	lsrs	r0, r0, #8
3401862a:	f000 000f 	and.w	r0, r0, #15
3401862e:	2400      	movs	r4, #0
34018630:	9406      	str	r4, [sp, #24]
34018632:	2401      	movs	r4, #1
34018634:	9405      	str	r4, [sp, #20]
34018636:	241a      	movs	r4, #26
34018638:	9404      	str	r4, [sp, #16]
3401863a:	9003      	str	r0, [sp, #12]
3401863c:	9102      	str	r1, [sp, #8]
3401863e:	9201      	str	r2, [sp, #4]
34018640:	4a16      	ldr	r2, [pc, #88]	@ (3401869c <LL_ATON_Init+0x2a8>)
34018642:	9200      	str	r2, [sp, #0]
34018644:	22d2      	movs	r2, #210	@ 0xd2
34018646:	490c      	ldr	r1, [pc, #48]	@ (34018678 <LL_ATON_Init+0x284>)
34018648:	480c      	ldr	r0, [pc, #48]	@ (3401867c <LL_ATON_Init+0x288>)
3401864a:	f003 ff67 	bl	3401c51c <iprintf>
3401864e:	4b0c      	ldr	r3, [pc, #48]	@ (34018680 <LL_ATON_Init+0x28c>)
34018650:	4a0c      	ldr	r2, [pc, #48]	@ (34018684 <LL_ATON_Init+0x290>)
34018652:	21d2      	movs	r1, #210	@ 0xd2
34018654:	4808      	ldr	r0, [pc, #32]	@ (34018678 <LL_ATON_Init+0x284>)
34018656:	f003 f8b9 	bl	3401b7cc <__assert_func>
3401865a:	bf00      	nop
3401865c:	580e0000 	.word	0x580e0000
34018660:	580e0008 	.word	0x580e0008
34018664:	580e000c 	.word	0x580e000c
34018668:	580e0010 	.word	0x580e0010
3401866c:	580e5004 	.word	0x580e5004
34018670:	3401f388 	.word	0x3401f388
34018674:	3401f3f4 	.word	0x3401f3f4
34018678:	3401f224 	.word	0x3401f224
3401867c:	3401f390 	.word	0x3401f390
34018680:	3401f3fc 	.word	0x3401f3fc
34018684:	3401ffec 	.word	0x3401ffec
34018688:	580ef004 	.word	0x580ef004
3401868c:	3401f400 	.word	0x3401f400
34018690:	580fb004 	.word	0x580fb004
34018694:	3401f408 	.word	0x3401f408
34018698:	580f7004 	.word	0x580f7004
3401869c:	3401f410 	.word	0x3401f410
#endif

#ifdef ATON_ACTIV_NUM
  ASSERT_UNITS_VERS_W_MSG(ACTIV, t);
340186a0:	4b9e      	ldr	r3, [pc, #632]	@ (3401891c <LL_ATON_Init+0x528>)
340186a2:	681b      	ldr	r3, [r3, #0]
340186a4:	607b      	str	r3, [r7, #4]
340186a6:	687b      	ldr	r3, [r7, #4]
340186a8:	2b00      	cmp	r3, #0
340186aa:	d0f9      	beq.n	340186a0 <LL_ATON_Init+0x2ac>
340186ac:	687b      	ldr	r3, [r7, #4]
340186ae:	b2db      	uxtb	r3, r3
340186b0:	2b1b      	cmp	r3, #27
340186b2:	d10b      	bne.n	340186cc <LL_ATON_Init+0x2d8>
340186b4:	687b      	ldr	r3, [r7, #4]
340186b6:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
340186ba:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340186be:	d105      	bne.n	340186cc <LL_ATON_Init+0x2d8>
340186c0:	687b      	ldr	r3, [r7, #4]
340186c2:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
340186c6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340186ca:	d02f      	beq.n	3401872c <LL_ATON_Init+0x338>
340186cc:	f004 fac2 	bl	3401cc54 <__errno>
340186d0:	4603      	mov	r3, r0
340186d2:	681b      	ldr	r3, [r3, #0]
340186d4:	2b00      	cmp	r3, #0
340186d6:	d008      	beq.n	340186ea <LL_ATON_Init+0x2f6>
340186d8:	f004 fabc 	bl	3401cc54 <__errno>
340186dc:	4603      	mov	r3, r0
340186de:	681b      	ldr	r3, [r3, #0]
340186e0:	4618      	mov	r0, r3
340186e2:	f004 fa51 	bl	3401cb88 <strerror>
340186e6:	4603      	mov	r3, r0
340186e8:	e000      	b.n	340186ec <LL_ATON_Init+0x2f8>
340186ea:	4b8d      	ldr	r3, [pc, #564]	@ (34018920 <LL_ATON_Init+0x52c>)
340186ec:	687a      	ldr	r2, [r7, #4]
340186ee:	b2d2      	uxtb	r2, r2
340186f0:	6879      	ldr	r1, [r7, #4]
340186f2:	0b09      	lsrs	r1, r1, #12
340186f4:	f001 010f 	and.w	r1, r1, #15
340186f8:	6878      	ldr	r0, [r7, #4]
340186fa:	0a00      	lsrs	r0, r0, #8
340186fc:	f000 000f 	and.w	r0, r0, #15
34018700:	2401      	movs	r4, #1
34018702:	9406      	str	r4, [sp, #24]
34018704:	2401      	movs	r4, #1
34018706:	9405      	str	r4, [sp, #20]
34018708:	241b      	movs	r4, #27
3401870a:	9404      	str	r4, [sp, #16]
3401870c:	9003      	str	r0, [sp, #12]
3401870e:	9102      	str	r1, [sp, #8]
34018710:	9201      	str	r2, [sp, #4]
34018712:	4a84      	ldr	r2, [pc, #528]	@ (34018924 <LL_ATON_Init+0x530>)
34018714:	9200      	str	r2, [sp, #0]
34018716:	22d6      	movs	r2, #214	@ 0xd6
34018718:	4983      	ldr	r1, [pc, #524]	@ (34018928 <LL_ATON_Init+0x534>)
3401871a:	4884      	ldr	r0, [pc, #528]	@ (3401892c <LL_ATON_Init+0x538>)
3401871c:	f003 fefe 	bl	3401c51c <iprintf>
34018720:	4b83      	ldr	r3, [pc, #524]	@ (34018930 <LL_ATON_Init+0x53c>)
34018722:	4a84      	ldr	r2, [pc, #528]	@ (34018934 <LL_ATON_Init+0x540>)
34018724:	21d6      	movs	r1, #214	@ 0xd6
34018726:	4880      	ldr	r0, [pc, #512]	@ (34018928 <LL_ATON_Init+0x534>)
34018728:	f003 f850 	bl	3401b7cc <__assert_func>
#endif

#ifdef ATON_DECUN_NUM
  ASSERT_UNITS_VERS_W_MSG(DECUN, t);
3401872c:	4b82      	ldr	r3, [pc, #520]	@ (34018938 <LL_ATON_Init+0x544>)
3401872e:	681b      	ldr	r3, [r3, #0]
34018730:	607b      	str	r3, [r7, #4]
34018732:	687b      	ldr	r3, [r7, #4]
34018734:	2b00      	cmp	r3, #0
34018736:	d0f9      	beq.n	3401872c <LL_ATON_Init+0x338>
34018738:	687b      	ldr	r3, [r7, #4]
3401873a:	b2db      	uxtb	r3, r3
3401873c:	2b19      	cmp	r3, #25
3401873e:	d10b      	bne.n	34018758 <LL_ATON_Init+0x364>
34018740:	687b      	ldr	r3, [r7, #4]
34018742:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
34018746:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401874a:	d105      	bne.n	34018758 <LL_ATON_Init+0x364>
3401874c:	687b      	ldr	r3, [r7, #4]
3401874e:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34018752:	f5b3 6f20 	cmp.w	r3, #2560	@ 0xa00
34018756:	d02f      	beq.n	340187b8 <LL_ATON_Init+0x3c4>
34018758:	f004 fa7c 	bl	3401cc54 <__errno>
3401875c:	4603      	mov	r3, r0
3401875e:	681b      	ldr	r3, [r3, #0]
34018760:	2b00      	cmp	r3, #0
34018762:	d008      	beq.n	34018776 <LL_ATON_Init+0x382>
34018764:	f004 fa76 	bl	3401cc54 <__errno>
34018768:	4603      	mov	r3, r0
3401876a:	681b      	ldr	r3, [r3, #0]
3401876c:	4618      	mov	r0, r3
3401876e:	f004 fa0b 	bl	3401cb88 <strerror>
34018772:	4603      	mov	r3, r0
34018774:	e000      	b.n	34018778 <LL_ATON_Init+0x384>
34018776:	4b6a      	ldr	r3, [pc, #424]	@ (34018920 <LL_ATON_Init+0x52c>)
34018778:	687a      	ldr	r2, [r7, #4]
3401877a:	b2d2      	uxtb	r2, r2
3401877c:	6879      	ldr	r1, [r7, #4]
3401877e:	0b09      	lsrs	r1, r1, #12
34018780:	f001 010f 	and.w	r1, r1, #15
34018784:	6878      	ldr	r0, [r7, #4]
34018786:	0a00      	lsrs	r0, r0, #8
34018788:	f000 000f 	and.w	r0, r0, #15
3401878c:	240a      	movs	r4, #10
3401878e:	9406      	str	r4, [sp, #24]
34018790:	2401      	movs	r4, #1
34018792:	9405      	str	r4, [sp, #20]
34018794:	2419      	movs	r4, #25
34018796:	9404      	str	r4, [sp, #16]
34018798:	9003      	str	r0, [sp, #12]
3401879a:	9102      	str	r1, [sp, #8]
3401879c:	9201      	str	r2, [sp, #4]
3401879e:	4a67      	ldr	r2, [pc, #412]	@ (3401893c <LL_ATON_Init+0x548>)
340187a0:	9200      	str	r2, [sp, #0]
340187a2:	22da      	movs	r2, #218	@ 0xda
340187a4:	4960      	ldr	r1, [pc, #384]	@ (34018928 <LL_ATON_Init+0x534>)
340187a6:	4861      	ldr	r0, [pc, #388]	@ (3401892c <LL_ATON_Init+0x538>)
340187a8:	f003 feb8 	bl	3401c51c <iprintf>
340187ac:	4b60      	ldr	r3, [pc, #384]	@ (34018930 <LL_ATON_Init+0x53c>)
340187ae:	4a61      	ldr	r2, [pc, #388]	@ (34018934 <LL_ATON_Init+0x540>)
340187b0:	21da      	movs	r1, #218	@ 0xda
340187b2:	485d      	ldr	r0, [pc, #372]	@ (34018928 <LL_ATON_Init+0x534>)
340187b4:	f003 f80a 	bl	3401b7cc <__assert_func>
#endif

#ifdef ATON_EPOCHCTRL_VERSION_TYPE_DT
  ASSERT_UNITS_VERS_W_MSG(EPOCHCTRL, t);
340187b8:	4b61      	ldr	r3, [pc, #388]	@ (34018940 <LL_ATON_Init+0x54c>)
340187ba:	681b      	ldr	r3, [r3, #0]
340187bc:	607b      	str	r3, [r7, #4]
340187be:	687b      	ldr	r3, [r7, #4]
340187c0:	2b00      	cmp	r3, #0
340187c2:	d0f9      	beq.n	340187b8 <LL_ATON_Init+0x3c4>
340187c4:	687b      	ldr	r3, [r7, #4]
340187c6:	b2db      	uxtb	r3, r3
340187c8:	2b21      	cmp	r3, #33	@ 0x21
340187ca:	d10b      	bne.n	340187e4 <LL_ATON_Init+0x3f0>
340187cc:	687b      	ldr	r3, [r7, #4]
340187ce:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
340187d2:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340187d6:	d105      	bne.n	340187e4 <LL_ATON_Init+0x3f0>
340187d8:	687b      	ldr	r3, [r7, #4]
340187da:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
340187de:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340187e2:	d02f      	beq.n	34018844 <LL_ATON_Init+0x450>
340187e4:	f004 fa36 	bl	3401cc54 <__errno>
340187e8:	4603      	mov	r3, r0
340187ea:	681b      	ldr	r3, [r3, #0]
340187ec:	2b00      	cmp	r3, #0
340187ee:	d008      	beq.n	34018802 <LL_ATON_Init+0x40e>
340187f0:	f004 fa30 	bl	3401cc54 <__errno>
340187f4:	4603      	mov	r3, r0
340187f6:	681b      	ldr	r3, [r3, #0]
340187f8:	4618      	mov	r0, r3
340187fa:	f004 f9c5 	bl	3401cb88 <strerror>
340187fe:	4603      	mov	r3, r0
34018800:	e000      	b.n	34018804 <LL_ATON_Init+0x410>
34018802:	4b47      	ldr	r3, [pc, #284]	@ (34018920 <LL_ATON_Init+0x52c>)
34018804:	687a      	ldr	r2, [r7, #4]
34018806:	b2d2      	uxtb	r2, r2
34018808:	6879      	ldr	r1, [r7, #4]
3401880a:	0b09      	lsrs	r1, r1, #12
3401880c:	f001 010f 	and.w	r1, r1, #15
34018810:	6878      	ldr	r0, [r7, #4]
34018812:	0a00      	lsrs	r0, r0, #8
34018814:	f000 000f 	and.w	r0, r0, #15
34018818:	2401      	movs	r4, #1
3401881a:	9406      	str	r4, [sp, #24]
3401881c:	2401      	movs	r4, #1
3401881e:	9405      	str	r4, [sp, #20]
34018820:	2421      	movs	r4, #33	@ 0x21
34018822:	9404      	str	r4, [sp, #16]
34018824:	9003      	str	r0, [sp, #12]
34018826:	9102      	str	r1, [sp, #8]
34018828:	9201      	str	r2, [sp, #4]
3401882a:	4a46      	ldr	r2, [pc, #280]	@ (34018944 <LL_ATON_Init+0x550>)
3401882c:	9200      	str	r2, [sp, #0]
3401882e:	22de      	movs	r2, #222	@ 0xde
34018830:	493d      	ldr	r1, [pc, #244]	@ (34018928 <LL_ATON_Init+0x534>)
34018832:	483e      	ldr	r0, [pc, #248]	@ (3401892c <LL_ATON_Init+0x538>)
34018834:	f003 fe72 	bl	3401c51c <iprintf>
34018838:	4b3d      	ldr	r3, [pc, #244]	@ (34018930 <LL_ATON_Init+0x53c>)
3401883a:	4a3e      	ldr	r2, [pc, #248]	@ (34018934 <LL_ATON_Init+0x540>)
3401883c:	21de      	movs	r1, #222	@ 0xde
3401883e:	483a      	ldr	r0, [pc, #232]	@ (34018928 <LL_ATON_Init+0x534>)
34018840:	f002 ffc4 	bl	3401b7cc <__assert_func>
#endif

#ifdef ATON_RECBUF_VERSION_TYPE_DT
  ASSERT_UNITS_VERS_W_MSG(RECBUF, t);
34018844:	4b40      	ldr	r3, [pc, #256]	@ (34018948 <LL_ATON_Init+0x554>)
34018846:	681b      	ldr	r3, [r3, #0]
34018848:	607b      	str	r3, [r7, #4]
3401884a:	687b      	ldr	r3, [r7, #4]
3401884c:	2b00      	cmp	r3, #0
3401884e:	d0f9      	beq.n	34018844 <LL_ATON_Init+0x450>
34018850:	687b      	ldr	r3, [r7, #4]
34018852:	b2db      	uxtb	r3, r3
34018854:	2b20      	cmp	r3, #32
34018856:	d10b      	bne.n	34018870 <LL_ATON_Init+0x47c>
34018858:	687b      	ldr	r3, [r7, #4]
3401885a:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
3401885e:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
34018862:	d105      	bne.n	34018870 <LL_ATON_Init+0x47c>
34018864:	687b      	ldr	r3, [r7, #4]
34018866:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3401886a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3401886e:	d02f      	beq.n	340188d0 <LL_ATON_Init+0x4dc>
34018870:	f004 f9f0 	bl	3401cc54 <__errno>
34018874:	4603      	mov	r3, r0
34018876:	681b      	ldr	r3, [r3, #0]
34018878:	2b00      	cmp	r3, #0
3401887a:	d008      	beq.n	3401888e <LL_ATON_Init+0x49a>
3401887c:	f004 f9ea 	bl	3401cc54 <__errno>
34018880:	4603      	mov	r3, r0
34018882:	681b      	ldr	r3, [r3, #0]
34018884:	4618      	mov	r0, r3
34018886:	f004 f97f 	bl	3401cb88 <strerror>
3401888a:	4603      	mov	r3, r0
3401888c:	e000      	b.n	34018890 <LL_ATON_Init+0x49c>
3401888e:	4b24      	ldr	r3, [pc, #144]	@ (34018920 <LL_ATON_Init+0x52c>)
34018890:	687a      	ldr	r2, [r7, #4]
34018892:	b2d2      	uxtb	r2, r2
34018894:	6879      	ldr	r1, [r7, #4]
34018896:	0b09      	lsrs	r1, r1, #12
34018898:	f001 010f 	and.w	r1, r1, #15
3401889c:	6878      	ldr	r0, [r7, #4]
3401889e:	0a00      	lsrs	r0, r0, #8
340188a0:	f000 000f 	and.w	r0, r0, #15
340188a4:	2402      	movs	r4, #2
340188a6:	9406      	str	r4, [sp, #24]
340188a8:	2403      	movs	r4, #3
340188aa:	9405      	str	r4, [sp, #20]
340188ac:	2420      	movs	r4, #32
340188ae:	9404      	str	r4, [sp, #16]
340188b0:	9003      	str	r0, [sp, #12]
340188b2:	9102      	str	r1, [sp, #8]
340188b4:	9201      	str	r2, [sp, #4]
340188b6:	4a25      	ldr	r2, [pc, #148]	@ (3401894c <LL_ATON_Init+0x558>)
340188b8:	9200      	str	r2, [sp, #0]
340188ba:	22e2      	movs	r2, #226	@ 0xe2
340188bc:	491a      	ldr	r1, [pc, #104]	@ (34018928 <LL_ATON_Init+0x534>)
340188be:	481b      	ldr	r0, [pc, #108]	@ (3401892c <LL_ATON_Init+0x538>)
340188c0:	f003 fe2c 	bl	3401c51c <iprintf>
340188c4:	4b1a      	ldr	r3, [pc, #104]	@ (34018930 <LL_ATON_Init+0x53c>)
340188c6:	4a1b      	ldr	r2, [pc, #108]	@ (34018934 <LL_ATON_Init+0x540>)
340188c8:	21e2      	movs	r1, #226	@ 0xe2
340188ca:	4817      	ldr	r0, [pc, #92]	@ (34018928 <LL_ATON_Init+0x534>)
340188cc:	f002 ff7e 	bl	3401b7cc <__assert_func>

#ifdef ATON_IMC_NUM
  ASSERT_UNITS_VERS_W_MSG(IMC, t);
#endif

  ASSERT_UNITS_VERS_W_MSG(CLKCTRL, t);
340188d0:	4b1f      	ldr	r3, [pc, #124]	@ (34018950 <LL_ATON_Init+0x55c>)
340188d2:	681b      	ldr	r3, [r3, #0]
340188d4:	607b      	str	r3, [r7, #4]
340188d6:	687b      	ldr	r3, [r7, #4]
340188d8:	2b00      	cmp	r3, #0
340188da:	d0f9      	beq.n	340188d0 <LL_ATON_Init+0x4dc>
340188dc:	687b      	ldr	r3, [r7, #4]
340188de:	b2db      	uxtb	r3, r3
340188e0:	2b1f      	cmp	r3, #31
340188e2:	d10b      	bne.n	340188fc <LL_ATON_Init+0x508>
340188e4:	687b      	ldr	r3, [r7, #4]
340188e6:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
340188ea:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340188ee:	d105      	bne.n	340188fc <LL_ATON_Init+0x508>
340188f0:	687b      	ldr	r3, [r7, #4]
340188f2:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
340188f6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
340188fa:	d04c      	beq.n	34018996 <LL_ATON_Init+0x5a2>
340188fc:	f004 f9aa 	bl	3401cc54 <__errno>
34018900:	4603      	mov	r3, r0
34018902:	681b      	ldr	r3, [r3, #0]
34018904:	2b00      	cmp	r3, #0
34018906:	d025      	beq.n	34018954 <LL_ATON_Init+0x560>
34018908:	f004 f9a4 	bl	3401cc54 <__errno>
3401890c:	4603      	mov	r3, r0
3401890e:	681b      	ldr	r3, [r3, #0]
34018910:	4618      	mov	r0, r3
34018912:	f004 f939 	bl	3401cb88 <strerror>
34018916:	4603      	mov	r3, r0
34018918:	e01d      	b.n	34018956 <LL_ATON_Init+0x562>
3401891a:	bf00      	nop
3401891c:	580f5004 	.word	0x580f5004
34018920:	3401f388 	.word	0x3401f388
34018924:	3401f418 	.word	0x3401f418
34018928:	3401f224 	.word	0x3401f224
3401892c:	3401f390 	.word	0x3401f390
34018930:	3401f3fc 	.word	0x3401f3fc
34018934:	3401ffec 	.word	0x3401ffec
34018938:	580f3004 	.word	0x580f3004
3401893c:	3401f420 	.word	0x3401f420
34018940:	580fe004 	.word	0x580fe004
34018944:	3401f428 	.word	0x3401f428
34018948:	580fd004 	.word	0x580fd004
3401894c:	3401f434 	.word	0x3401f434
34018950:	580e0004 	.word	0x580e0004
34018954:	4b85      	ldr	r3, [pc, #532]	@ (34018b6c <LL_ATON_Init+0x778>)
34018956:	687a      	ldr	r2, [r7, #4]
34018958:	b2d2      	uxtb	r2, r2
3401895a:	6879      	ldr	r1, [r7, #4]
3401895c:	0b09      	lsrs	r1, r1, #12
3401895e:	f001 010f 	and.w	r1, r1, #15
34018962:	6878      	ldr	r0, [r7, #4]
34018964:	0a00      	lsrs	r0, r0, #8
34018966:	f000 000f 	and.w	r0, r0, #15
3401896a:	2402      	movs	r4, #2
3401896c:	9406      	str	r4, [sp, #24]
3401896e:	2401      	movs	r4, #1
34018970:	9405      	str	r4, [sp, #20]
34018972:	241f      	movs	r4, #31
34018974:	9404      	str	r4, [sp, #16]
34018976:	9003      	str	r0, [sp, #12]
34018978:	9102      	str	r1, [sp, #8]
3401897a:	9201      	str	r2, [sp, #4]
3401897c:	4a7c      	ldr	r2, [pc, #496]	@ (34018b70 <LL_ATON_Init+0x77c>)
3401897e:	9200      	str	r2, [sp, #0]
34018980:	22f5      	movs	r2, #245	@ 0xf5
34018982:	497c      	ldr	r1, [pc, #496]	@ (34018b74 <LL_ATON_Init+0x780>)
34018984:	487c      	ldr	r0, [pc, #496]	@ (34018b78 <LL_ATON_Init+0x784>)
34018986:	f003 fdc9 	bl	3401c51c <iprintf>
3401898a:	4b7c      	ldr	r3, [pc, #496]	@ (34018b7c <LL_ATON_Init+0x788>)
3401898c:	4a7c      	ldr	r2, [pc, #496]	@ (34018b80 <LL_ATON_Init+0x78c>)
3401898e:	21f5      	movs	r1, #245	@ 0xf5
34018990:	4878      	ldr	r0, [pc, #480]	@ (34018b74 <LL_ATON_Init+0x780>)
34018992:	f002 ff1b 	bl	3401b7cc <__assert_func>

  ASSERT_UNITS_VERS_W_MSG(INTCTRL, t);
34018996:	4b7b      	ldr	r3, [pc, #492]	@ (34018b84 <LL_ATON_Init+0x790>)
34018998:	681b      	ldr	r3, [r3, #0]
3401899a:	607b      	str	r3, [r7, #4]
3401899c:	687b      	ldr	r3, [r7, #4]
3401899e:	2b00      	cmp	r3, #0
340189a0:	d0f9      	beq.n	34018996 <LL_ATON_Init+0x5a2>
340189a2:	687b      	ldr	r3, [r7, #4]
340189a4:	b2db      	uxtb	r3, r3
340189a6:	2b1e      	cmp	r3, #30
340189a8:	d10b      	bne.n	340189c2 <LL_ATON_Init+0x5ce>
340189aa:	687b      	ldr	r3, [r7, #4]
340189ac:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
340189b0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340189b4:	d105      	bne.n	340189c2 <LL_ATON_Init+0x5ce>
340189b6:	687b      	ldr	r3, [r7, #4]
340189b8:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
340189bc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340189c0:	d02f      	beq.n	34018a22 <LL_ATON_Init+0x62e>
340189c2:	f004 f947 	bl	3401cc54 <__errno>
340189c6:	4603      	mov	r3, r0
340189c8:	681b      	ldr	r3, [r3, #0]
340189ca:	2b00      	cmp	r3, #0
340189cc:	d008      	beq.n	340189e0 <LL_ATON_Init+0x5ec>
340189ce:	f004 f941 	bl	3401cc54 <__errno>
340189d2:	4603      	mov	r3, r0
340189d4:	681b      	ldr	r3, [r3, #0]
340189d6:	4618      	mov	r0, r3
340189d8:	f004 f8d6 	bl	3401cb88 <strerror>
340189dc:	4603      	mov	r3, r0
340189de:	e000      	b.n	340189e2 <LL_ATON_Init+0x5ee>
340189e0:	4b62      	ldr	r3, [pc, #392]	@ (34018b6c <LL_ATON_Init+0x778>)
340189e2:	687a      	ldr	r2, [r7, #4]
340189e4:	b2d2      	uxtb	r2, r2
340189e6:	6879      	ldr	r1, [r7, #4]
340189e8:	0b09      	lsrs	r1, r1, #12
340189ea:	f001 010f 	and.w	r1, r1, #15
340189ee:	6878      	ldr	r0, [r7, #4]
340189f0:	0a00      	lsrs	r0, r0, #8
340189f2:	f000 000f 	and.w	r0, r0, #15
340189f6:	2401      	movs	r4, #1
340189f8:	9406      	str	r4, [sp, #24]
340189fa:	2401      	movs	r4, #1
340189fc:	9405      	str	r4, [sp, #20]
340189fe:	241e      	movs	r4, #30
34018a00:	9404      	str	r4, [sp, #16]
34018a02:	9003      	str	r0, [sp, #12]
34018a04:	9102      	str	r1, [sp, #8]
34018a06:	9201      	str	r2, [sp, #4]
34018a08:	4a5f      	ldr	r2, [pc, #380]	@ (34018b88 <LL_ATON_Init+0x794>)
34018a0a:	9200      	str	r2, [sp, #0]
34018a0c:	22f7      	movs	r2, #247	@ 0xf7
34018a0e:	4959      	ldr	r1, [pc, #356]	@ (34018b74 <LL_ATON_Init+0x780>)
34018a10:	4859      	ldr	r0, [pc, #356]	@ (34018b78 <LL_ATON_Init+0x784>)
34018a12:	f003 fd83 	bl	3401c51c <iprintf>
34018a16:	4b59      	ldr	r3, [pc, #356]	@ (34018b7c <LL_ATON_Init+0x788>)
34018a18:	4a59      	ldr	r2, [pc, #356]	@ (34018b80 <LL_ATON_Init+0x78c>)
34018a1a:	21f7      	movs	r1, #247	@ 0xf7
34018a1c:	4855      	ldr	r0, [pc, #340]	@ (34018b74 <LL_ATON_Init+0x780>)
34018a1e:	f002 fed5 	bl	3401b7cc <__assert_func>

  ASSERT_UNITS_VERS_W_MSG(STRSWITCH, t);
34018a22:	4b5a      	ldr	r3, [pc, #360]	@ (34018b8c <LL_ATON_Init+0x798>)
34018a24:	681b      	ldr	r3, [r3, #0]
34018a26:	607b      	str	r3, [r7, #4]
34018a28:	687b      	ldr	r3, [r7, #4]
34018a2a:	2b00      	cmp	r3, #0
34018a2c:	d0f9      	beq.n	34018a22 <LL_ATON_Init+0x62e>
34018a2e:	687b      	ldr	r3, [r7, #4]
34018a30:	b2db      	uxtb	r3, r3
34018a32:	2b00      	cmp	r3, #0
34018a34:	d10b      	bne.n	34018a4e <LL_ATON_Init+0x65a>
34018a36:	687b      	ldr	r3, [r7, #4]
34018a38:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
34018a3c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34018a40:	d105      	bne.n	34018a4e <LL_ATON_Init+0x65a>
34018a42:	687b      	ldr	r3, [r7, #4]
34018a44:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34018a48:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
34018a4c:	d02f      	beq.n	34018aae <LL_ATON_Init+0x6ba>
34018a4e:	f004 f901 	bl	3401cc54 <__errno>
34018a52:	4603      	mov	r3, r0
34018a54:	681b      	ldr	r3, [r3, #0]
34018a56:	2b00      	cmp	r3, #0
34018a58:	d008      	beq.n	34018a6c <LL_ATON_Init+0x678>
34018a5a:	f004 f8fb 	bl	3401cc54 <__errno>
34018a5e:	4603      	mov	r3, r0
34018a60:	681b      	ldr	r3, [r3, #0]
34018a62:	4618      	mov	r0, r3
34018a64:	f004 f890 	bl	3401cb88 <strerror>
34018a68:	4603      	mov	r3, r0
34018a6a:	e000      	b.n	34018a6e <LL_ATON_Init+0x67a>
34018a6c:	4b3f      	ldr	r3, [pc, #252]	@ (34018b6c <LL_ATON_Init+0x778>)
34018a6e:	687a      	ldr	r2, [r7, #4]
34018a70:	b2d2      	uxtb	r2, r2
34018a72:	6879      	ldr	r1, [r7, #4]
34018a74:	0b09      	lsrs	r1, r1, #12
34018a76:	f001 010f 	and.w	r1, r1, #15
34018a7a:	6878      	ldr	r0, [r7, #4]
34018a7c:	0a00      	lsrs	r0, r0, #8
34018a7e:	f000 000f 	and.w	r0, r0, #15
34018a82:	2406      	movs	r4, #6
34018a84:	9406      	str	r4, [sp, #24]
34018a86:	2401      	movs	r4, #1
34018a88:	9405      	str	r4, [sp, #20]
34018a8a:	2400      	movs	r4, #0
34018a8c:	9404      	str	r4, [sp, #16]
34018a8e:	9003      	str	r0, [sp, #12]
34018a90:	9102      	str	r1, [sp, #8]
34018a92:	9201      	str	r2, [sp, #4]
34018a94:	4a3e      	ldr	r2, [pc, #248]	@ (34018b90 <LL_ATON_Init+0x79c>)
34018a96:	9200      	str	r2, [sp, #0]
34018a98:	22f9      	movs	r2, #249	@ 0xf9
34018a9a:	4936      	ldr	r1, [pc, #216]	@ (34018b74 <LL_ATON_Init+0x780>)
34018a9c:	4836      	ldr	r0, [pc, #216]	@ (34018b78 <LL_ATON_Init+0x784>)
34018a9e:	f003 fd3d 	bl	3401c51c <iprintf>
34018aa2:	4b36      	ldr	r3, [pc, #216]	@ (34018b7c <LL_ATON_Init+0x788>)
34018aa4:	4a36      	ldr	r2, [pc, #216]	@ (34018b80 <LL_ATON_Init+0x78c>)
34018aa6:	21f9      	movs	r1, #249	@ 0xf9
34018aa8:	4832      	ldr	r0, [pc, #200]	@ (34018b74 <LL_ATON_Init+0x780>)
34018aaa:	f002 fe8f 	bl	3401b7cc <__assert_func>

  ASSERT_UNITS_VERS_W_MSG(BUSIF, t);
34018aae:	4b39      	ldr	r3, [pc, #228]	@ (34018b94 <LL_ATON_Init+0x7a0>)
34018ab0:	681b      	ldr	r3, [r3, #0]
34018ab2:	607b      	str	r3, [r7, #4]
34018ab4:	687b      	ldr	r3, [r7, #4]
34018ab6:	2b00      	cmp	r3, #0
34018ab8:	d0f9      	beq.n	34018aae <LL_ATON_Init+0x6ba>
34018aba:	687b      	ldr	r3, [r7, #4]
34018abc:	b2db      	uxtb	r3, r3
34018abe:	2b1d      	cmp	r3, #29
34018ac0:	d10a      	bne.n	34018ad8 <LL_ATON_Init+0x6e4>
34018ac2:	687b      	ldr	r3, [r7, #4]
34018ac4:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
34018ac8:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
34018acc:	d104      	bne.n	34018ad8 <LL_ATON_Init+0x6e4>
34018ace:	687b      	ldr	r3, [r7, #4]
34018ad0:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34018ad4:	2b00      	cmp	r3, #0
34018ad6:	d02f      	beq.n	34018b38 <LL_ATON_Init+0x744>
34018ad8:	f004 f8bc 	bl	3401cc54 <__errno>
34018adc:	4603      	mov	r3, r0
34018ade:	681b      	ldr	r3, [r3, #0]
34018ae0:	2b00      	cmp	r3, #0
34018ae2:	d008      	beq.n	34018af6 <LL_ATON_Init+0x702>
34018ae4:	f004 f8b6 	bl	3401cc54 <__errno>
34018ae8:	4603      	mov	r3, r0
34018aea:	681b      	ldr	r3, [r3, #0]
34018aec:	4618      	mov	r0, r3
34018aee:	f004 f84b 	bl	3401cb88 <strerror>
34018af2:	4603      	mov	r3, r0
34018af4:	e000      	b.n	34018af8 <LL_ATON_Init+0x704>
34018af6:	4b1d      	ldr	r3, [pc, #116]	@ (34018b6c <LL_ATON_Init+0x778>)
34018af8:	687a      	ldr	r2, [r7, #4]
34018afa:	b2d2      	uxtb	r2, r2
34018afc:	6879      	ldr	r1, [r7, #4]
34018afe:	0b09      	lsrs	r1, r1, #12
34018b00:	f001 010f 	and.w	r1, r1, #15
34018b04:	6878      	ldr	r0, [r7, #4]
34018b06:	0a00      	lsrs	r0, r0, #8
34018b08:	f000 000f 	and.w	r0, r0, #15
34018b0c:	2400      	movs	r4, #0
34018b0e:	9406      	str	r4, [sp, #24]
34018b10:	2405      	movs	r4, #5
34018b12:	9405      	str	r4, [sp, #20]
34018b14:	241d      	movs	r4, #29
34018b16:	9404      	str	r4, [sp, #16]
34018b18:	9003      	str	r0, [sp, #12]
34018b1a:	9102      	str	r1, [sp, #8]
34018b1c:	9201      	str	r2, [sp, #4]
34018b1e:	4a1e      	ldr	r2, [pc, #120]	@ (34018b98 <LL_ATON_Init+0x7a4>)
34018b20:	9200      	str	r2, [sp, #0]
34018b22:	22fb      	movs	r2, #251	@ 0xfb
34018b24:	4913      	ldr	r1, [pc, #76]	@ (34018b74 <LL_ATON_Init+0x780>)
34018b26:	4814      	ldr	r0, [pc, #80]	@ (34018b78 <LL_ATON_Init+0x784>)
34018b28:	f003 fcf8 	bl	3401c51c <iprintf>
34018b2c:	4b13      	ldr	r3, [pc, #76]	@ (34018b7c <LL_ATON_Init+0x788>)
34018b2e:	4a14      	ldr	r2, [pc, #80]	@ (34018b80 <LL_ATON_Init+0x78c>)
34018b30:	21fb      	movs	r1, #251	@ 0xfb
34018b32:	4810      	ldr	r0, [pc, #64]	@ (34018b74 <LL_ATON_Init+0x780>)
34018b34:	f002 fe4a 	bl	3401b7cc <__assert_func>

  /* Enable Bus Interfaces */
  for (i = 0; i < ATON_BUSIF_NUM; i++)
34018b38:	2300      	movs	r3, #0
34018b3a:	603b      	str	r3, [r7, #0]
34018b3c:	e00a      	b.n	34018b54 <LL_ATON_Init+0x760>
  {
    ATON_BUSIF_CTRL_SET(i, 1);
34018b3e:	683b      	ldr	r3, [r7, #0]
34018b40:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018b44:	33e2      	adds	r3, #226	@ 0xe2
34018b46:	031b      	lsls	r3, r3, #12
34018b48:	461a      	mov	r2, r3
34018b4a:	2301      	movs	r3, #1
34018b4c:	6013      	str	r3, [r2, #0]
  for (i = 0; i < ATON_BUSIF_NUM; i++)
34018b4e:	683b      	ldr	r3, [r7, #0]
34018b50:	3301      	adds	r3, #1
34018b52:	603b      	str	r3, [r7, #0]
34018b54:	683b      	ldr	r3, [r7, #0]
34018b56:	2b01      	cmp	r3, #1
34018b58:	ddf1      	ble.n	34018b3e <LL_ATON_Init+0x74a>
  }

  /* Enable Interrupt Controller */
  ATON_INTCTRL_CTRL_SET(0, 1);
34018b5a:	4b10      	ldr	r3, [pc, #64]	@ (34018b9c <LL_ATON_Init+0x7a8>)
34018b5c:	2201      	movs	r2, #1
34018b5e:	601a      	str	r2, [r3, #0]

  return 0;
34018b60:	2300      	movs	r3, #0
}
34018b62:	4618      	mov	r0, r3
34018b64:	370c      	adds	r7, #12
34018b66:	46bd      	mov	sp, r7
34018b68:	bd90      	pop	{r4, r7, pc}
34018b6a:	bf00      	nop
34018b6c:	3401f388 	.word	0x3401f388
34018b70:	3401f43c 	.word	0x3401f43c
34018b74:	3401f224 	.word	0x3401f224
34018b78:	3401f390 	.word	0x3401f390
34018b7c:	3401f3fc 	.word	0x3401f3fc
34018b80:	3401ffec 	.word	0x3401ffec
34018b84:	580e1004 	.word	0x580e1004
34018b88:	3401f444 	.word	0x3401f444
34018b8c:	580e4004 	.word	0x580e4004
34018b90:	3401f44c 	.word	0x3401f44c
34018b94:	580e2004 	.word	0x580e2004
34018b98:	3401f458 	.word	0x3401f458
34018b9c:	580e1000 	.word	0x580e1000

34018ba0 <LL_ATON_DeInit>:
/**
 * @brief  ATON global de-initialization. Must be called at the very end
 * @retval Always zero
 */
int LL_ATON_DeInit(void)
{
34018ba0:	b480      	push	{r7}
34018ba2:	b083      	sub	sp, #12
34018ba4:	af00      	add	r7, sp, #0
  int i;

  /* Disable Interrupt Controller */
  ATON_INTCTRL_CTRL_SET(0, 0);
34018ba6:	4b13      	ldr	r3, [pc, #76]	@ (34018bf4 <LL_ATON_DeInit+0x54>)
34018ba8:	2200      	movs	r2, #0
34018baa:	601a      	str	r2, [r3, #0]

  /* Disable Bus Interfaces */
  for (i = 0; i < ATON_BUSIF_NUM; i++)
34018bac:	2300      	movs	r3, #0
34018bae:	607b      	str	r3, [r7, #4]
34018bb0:	e00a      	b.n	34018bc8 <LL_ATON_DeInit+0x28>
  {
    ATON_BUSIF_CTRL_SET(i, 0);
34018bb2:	687b      	ldr	r3, [r7, #4]
34018bb4:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018bb8:	33e2      	adds	r3, #226	@ 0xe2
34018bba:	031b      	lsls	r3, r3, #12
34018bbc:	461a      	mov	r2, r3
34018bbe:	2300      	movs	r3, #0
34018bc0:	6013      	str	r3, [r2, #0]
  for (i = 0; i < ATON_BUSIF_NUM; i++)
34018bc2:	687b      	ldr	r3, [r7, #4]
34018bc4:	3301      	adds	r3, #1
34018bc6:	607b      	str	r3, [r7, #4]
34018bc8:	687b      	ldr	r3, [r7, #4]
34018bca:	2b01      	cmp	r3, #1
34018bcc:	ddf1      	ble.n	34018bb2 <LL_ATON_DeInit+0x12>
  }

  /* Disable all ATON clocks */
  ATON_CLKCTRL_AGATES0_SET(0, 0);
34018bce:	4b0a      	ldr	r3, [pc, #40]	@ (34018bf8 <LL_ATON_DeInit+0x58>)
34018bd0:	2200      	movs	r2, #0
34018bd2:	601a      	str	r2, [r3, #0]
  ATON_CLKCTRL_AGATES1_SET(0, 0);
34018bd4:	4b09      	ldr	r3, [pc, #36]	@ (34018bfc <LL_ATON_DeInit+0x5c>)
34018bd6:	2200      	movs	r2, #0
34018bd8:	601a      	str	r2, [r3, #0]
  ATON_CLKCTRL_BGATES_SET(0, 0);
34018bda:	4b09      	ldr	r3, [pc, #36]	@ (34018c00 <LL_ATON_DeInit+0x60>)
34018bdc:	2200      	movs	r2, #0
34018bde:	601a      	str	r2, [r3, #0]
#ifdef ATON_CLKCTRL_BGATES1_OFFSET
  ATON_CLKCTRL_BGATES1_SET(0, 0);
#endif
  ATON_CLKCTRL_CTRL_SET(0, 0);
34018be0:	4b08      	ldr	r3, [pc, #32]	@ (34018c04 <LL_ATON_DeInit+0x64>)
34018be2:	2200      	movs	r2, #0
34018be4:	601a      	str	r2, [r3, #0]

  return 0;
34018be6:	2300      	movs	r3, #0
}
34018be8:	4618      	mov	r0, r3
34018bea:	370c      	adds	r7, #12
34018bec:	46bd      	mov	sp, r7
34018bee:	f85d 7b04 	ldr.w	r7, [sp], #4
34018bf2:	4770      	bx	lr
34018bf4:	580e1000 	.word	0x580e1000
34018bf8:	580e0008 	.word	0x580e0008
34018bfc:	580e000c 	.word	0x580e000c
34018c00:	580e0010 	.word	0x580e0010
34018c04:	580e0000 	.word	0x580e0000

34018c08 <LL_ATON_EnableUnits_Init>:
 * @param  n Lenght of the initialization array
 * @retval Error code
 * @todo   Add boundary checks
 */
int LL_ATON_EnableUnits_Init(const LL_ATON_EnableUnits_InitTypeDef *LL_ATON_EnableUnits_InitStruct, int n)
{
34018c08:	b480      	push	{r7}
34018c0a:	b08d      	sub	sp, #52	@ 0x34
34018c0c:	af00      	add	r7, sp, #0
34018c0e:	6078      	str	r0, [r7, #4]
34018c10:	6039      	str	r1, [r7, #0]
  int i;
  enum AccelUnitsType unitType;
  uint32_t unitId;

  for (i = 0; i < n; i++)
34018c12:	2300      	movs	r3, #0
34018c14:	62fb      	str	r3, [r7, #44]	@ 0x2c
34018c16:	e0a8      	b.n	34018d6a <LL_ATON_EnableUnits_Init+0x162>
  {
    unitType = LL_ATON_EnableUnits_InitStruct[i].unit.unit_type;
34018c18:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34018c1a:	009b      	lsls	r3, r3, #2
34018c1c:	687a      	ldr	r2, [r7, #4]
34018c1e:	4413      	add	r3, r2
34018c20:	781b      	ldrb	r3, [r3, #0]
34018c22:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
    unitId = LL_ATON_EnableUnits_InitStruct[i].unit.unit_num;
34018c26:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34018c28:	009b      	lsls	r3, r3, #2
34018c2a:	687a      	ldr	r2, [r7, #4]
34018c2c:	4413      	add	r3, r2
34018c2e:	885b      	ldrh	r3, [r3, #2]
34018c30:	627b      	str	r3, [r7, #36]	@ 0x24

    switch (unitType)
34018c32:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
34018c36:	2b08      	cmp	r3, #8
34018c38:	f200 8093 	bhi.w	34018d62 <LL_ATON_EnableUnits_Init+0x15a>
34018c3c:	a201      	add	r2, pc, #4	@ (adr r2, 34018c44 <LL_ATON_EnableUnits_Init+0x3c>)
34018c3e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34018c42:	bf00      	nop
34018c44:	34018c69 	.word	0x34018c69
34018c48:	34018d63 	.word	0x34018d63
34018c4c:	34018c91 	.word	0x34018c91
34018c50:	34018cad 	.word	0x34018cad
34018c54:	34018cd5 	.word	0x34018cd5
34018c58:	34018cfd 	.word	0x34018cfd
34018c5c:	34018d25 	.word	0x34018d25
34018c60:	34018d63 	.word	0x34018d63
34018c64:	34018d4d 	.word	0x34018d4d
    {
    case STRENG:
      ATON_ENABLE(STRENG, unitId);
34018c68:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34018c6a:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018c6e:	33e5      	adds	r3, #229	@ 0xe5
34018c70:	031b      	lsls	r3, r3, #12
34018c72:	681b      	ldr	r3, [r3, #0]
34018c74:	60fb      	str	r3, [r7, #12]
34018c76:	68fb      	ldr	r3, [r7, #12]
34018c78:	f043 0301 	orr.w	r3, r3, #1
34018c7c:	60fb      	str	r3, [r7, #12]
34018c7e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34018c80:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018c84:	33e5      	adds	r3, #229	@ 0xe5
34018c86:	031b      	lsls	r3, r3, #12
34018c88:	461a      	mov	r2, r3
34018c8a:	68fb      	ldr	r3, [r7, #12]
34018c8c:	6013      	str	r3, [r2, #0]
      break;
34018c8e:	e069      	b.n	34018d64 <LL_ATON_EnableUnits_Init+0x15c>
#ifdef ATON_CONVACC_NUM
    case CONVACC:
#if 0
      ATON_ENABLE(CONVACC, unitId);
#else
      ATON_CONVACC_CTRL_SET(unitId, ATON_CONVACC_CTRL_SET_EN(Conv_ctrl_bits[unitId], 1));
34018c90:	4a3c      	ldr	r2, [pc, #240]	@ (34018d84 <LL_ATON_EnableUnits_Init+0x17c>)
34018c92:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34018c94:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
34018c98:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34018c9a:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018c9e:	33ef      	adds	r3, #239	@ 0xef
34018ca0:	031b      	lsls	r3, r3, #12
34018ca2:	4619      	mov	r1, r3
34018ca4:	f042 0301 	orr.w	r3, r2, #1
34018ca8:	600b      	str	r3, [r1, #0]
#endif
      break;
34018caa:	e05b      	b.n	34018d64 <LL_ATON_EnableUnits_Init+0x15c>
#endif

#ifdef ATON_DECUN_NUM
    case DECUN:
      ATON_ENABLE(DECUN, unitId);
34018cac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34018cae:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018cb2:	33f3      	adds	r3, #243	@ 0xf3
34018cb4:	031b      	lsls	r3, r3, #12
34018cb6:	681b      	ldr	r3, [r3, #0]
34018cb8:	613b      	str	r3, [r7, #16]
34018cba:	693b      	ldr	r3, [r7, #16]
34018cbc:	f043 0301 	orr.w	r3, r3, #1
34018cc0:	613b      	str	r3, [r7, #16]
34018cc2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34018cc4:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018cc8:	33f3      	adds	r3, #243	@ 0xf3
34018cca:	031b      	lsls	r3, r3, #12
34018ccc:	461a      	mov	r2, r3
34018cce:	693b      	ldr	r3, [r7, #16]
34018cd0:	6013      	str	r3, [r2, #0]
      break;
34018cd2:	e047      	b.n	34018d64 <LL_ATON_EnableUnits_Init+0x15c>
#endif

#ifdef ATON_ACTIV_NUM
    case ACTIV:
      ATON_ENABLE(ACTIV, unitId);
34018cd4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34018cd6:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018cda:	33f5      	adds	r3, #245	@ 0xf5
34018cdc:	031b      	lsls	r3, r3, #12
34018cde:	681b      	ldr	r3, [r3, #0]
34018ce0:	617b      	str	r3, [r7, #20]
34018ce2:	697b      	ldr	r3, [r7, #20]
34018ce4:	f043 0301 	orr.w	r3, r3, #1
34018ce8:	617b      	str	r3, [r7, #20]
34018cea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34018cec:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018cf0:	33f5      	adds	r3, #245	@ 0xf5
34018cf2:	031b      	lsls	r3, r3, #12
34018cf4:	461a      	mov	r2, r3
34018cf6:	697b      	ldr	r3, [r7, #20]
34018cf8:	6013      	str	r3, [r2, #0]
      break;
34018cfa:	e033      	b.n	34018d64 <LL_ATON_EnableUnits_Init+0x15c>
#endif

#ifdef ATON_ARITH_NUM
    case ARITH:
      ATON_ENABLE(ARITH, unitId);
34018cfc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34018cfe:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018d02:	33f7      	adds	r3, #247	@ 0xf7
34018d04:	031b      	lsls	r3, r3, #12
34018d06:	681b      	ldr	r3, [r3, #0]
34018d08:	61bb      	str	r3, [r7, #24]
34018d0a:	69bb      	ldr	r3, [r7, #24]
34018d0c:	f043 0301 	orr.w	r3, r3, #1
34018d10:	61bb      	str	r3, [r7, #24]
34018d12:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34018d14:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018d18:	33f7      	adds	r3, #247	@ 0xf7
34018d1a:	031b      	lsls	r3, r3, #12
34018d1c:	461a      	mov	r2, r3
34018d1e:	69bb      	ldr	r3, [r7, #24]
34018d20:	6013      	str	r3, [r2, #0]
      break;
34018d22:	e01f      	b.n	34018d64 <LL_ATON_EnableUnits_Init+0x15c>
#ifdef ATON_POOL_NUM
    case POOL:
#ifdef POOL_RC14
      ATON_POOL_CTRL_SET(unitId, ATON_POOL_CTRL_SET_EN(ATON_POOL_CTRL_GET(unitId), 1));
#else  // !POOL_RC14
      ATON_ENABLE(POOL, unitId);
34018d24:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34018d26:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018d2a:	33fb      	adds	r3, #251	@ 0xfb
34018d2c:	031b      	lsls	r3, r3, #12
34018d2e:	681b      	ldr	r3, [r3, #0]
34018d30:	61fb      	str	r3, [r7, #28]
34018d32:	69fb      	ldr	r3, [r7, #28]
34018d34:	f043 0301 	orr.w	r3, r3, #1
34018d38:	61fb      	str	r3, [r7, #28]
34018d3a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34018d3c:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018d40:	33fb      	adds	r3, #251	@ 0xfb
34018d42:	031b      	lsls	r3, r3, #12
34018d44:	461a      	mov	r2, r3
34018d46:	69fb      	ldr	r3, [r7, #28]
34018d48:	6013      	str	r3, [r2, #0]
#endif // !POOL_RC14
      break;
34018d4a:	e00b      	b.n	34018d64 <LL_ATON_EnableUnits_Init+0x15c>
#endif
#ifdef ATON_RECBUF_NUM
    case RECBUF:
      ATON_ENABLE(RECBUF, unitId);
34018d4c:	4b0e      	ldr	r3, [pc, #56]	@ (34018d88 <LL_ATON_EnableUnits_Init+0x180>)
34018d4e:	681b      	ldr	r3, [r3, #0]
34018d50:	623b      	str	r3, [r7, #32]
34018d52:	6a3b      	ldr	r3, [r7, #32]
34018d54:	f043 0301 	orr.w	r3, r3, #1
34018d58:	623b      	str	r3, [r7, #32]
34018d5a:	4a0b      	ldr	r2, [pc, #44]	@ (34018d88 <LL_ATON_EnableUnits_Init+0x180>)
34018d5c:	6a3b      	ldr	r3, [r7, #32]
34018d5e:	6013      	str	r3, [r2, #0]
      break;
34018d60:	e000      	b.n	34018d64 <LL_ATON_EnableUnits_Init+0x15c>
#endif

    default:
      break;
34018d62:	bf00      	nop
  for (i = 0; i < n; i++)
34018d64:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34018d66:	3301      	adds	r3, #1
34018d68:	62fb      	str	r3, [r7, #44]	@ 0x2c
34018d6a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34018d6c:	683b      	ldr	r3, [r7, #0]
34018d6e:	429a      	cmp	r2, r3
34018d70:	f6ff af52 	blt.w	34018c18 <LL_ATON_EnableUnits_Init+0x10>
    }
  }

  return 0;
34018d74:	2300      	movs	r3, #0
}
34018d76:	4618      	mov	r0, r3
34018d78:	3734      	adds	r7, #52	@ 0x34
34018d7a:	46bd      	mov	sp, r7
34018d7c:	f85d 7b04 	ldr.w	r7, [sp], #4
34018d80:	4770      	bx	lr
34018d82:	bf00      	nop
34018d84:	34021390 	.word	0x34021390
34018d88:	580fd000 	.word	0x580fd000

34018d8c <LL_ATON_DisableUnits_Init>:
 * @param  LL_ATON_DisableUnits_InitTypeDef Array of units to disable
 * @param  n Length of the initialization array
 * @retval Error code
 */
int LL_ATON_DisableUnits_Init(const LL_ATON_DisableUnits_InitTypeDef *LL_ATON_DisableUnits_InitStruct, int n)
{
34018d8c:	b580      	push	{r7, lr}
34018d8e:	b086      	sub	sp, #24
34018d90:	af00      	add	r7, sp, #0
34018d92:	6078      	str	r0, [r7, #4]
34018d94:	6039      	str	r1, [r7, #0]
  int i;
  enum AccelUnitsType unitType;
  uint32_t unitId;
  uint32_t t;

  for (i = 0; i < n; i++)
34018d96:	2300      	movs	r3, #0
34018d98:	617b      	str	r3, [r7, #20]
34018d9a:	e1b1      	b.n	34019100 <LL_ATON_DisableUnits_Init+0x374>
  {
    unitType = LL_ATON_DisableUnits_InitStruct[i].unit.unit_type;
34018d9c:	697b      	ldr	r3, [r7, #20]
34018d9e:	009b      	lsls	r3, r3, #2
34018da0:	687a      	ldr	r2, [r7, #4]
34018da2:	4413      	add	r3, r2
34018da4:	781b      	ldrb	r3, [r3, #0]
34018da6:	74fb      	strb	r3, [r7, #19]
    unitId = LL_ATON_DisableUnits_InitStruct[i].unit.unit_num;
34018da8:	697b      	ldr	r3, [r7, #20]
34018daa:	009b      	lsls	r3, r3, #2
34018dac:	687a      	ldr	r2, [r7, #4]
34018dae:	4413      	add	r3, r2
34018db0:	885b      	ldrh	r3, [r3, #2]
34018db2:	60fb      	str	r3, [r7, #12]

    switch (unitType)
34018db4:	7cfb      	ldrb	r3, [r7, #19]
34018db6:	2b08      	cmp	r3, #8
34018db8:	f200 819c 	bhi.w	340190f4 <LL_ATON_DisableUnits_Init+0x368>
34018dbc:	a201      	add	r2, pc, #4	@ (adr r2, 34018dc4 <LL_ATON_DisableUnits_Init+0x38>)
34018dbe:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34018dc2:	bf00      	nop
34018dc4:	34018de9 	.word	0x34018de9
34018dc8:	340190f5 	.word	0x340190f5
34018dcc:	34018e59 	.word	0x34018e59
34018dd0:	34018ecd 	.word	0x34018ecd
34018dd4:	34018f41 	.word	0x34018f41
34018dd8:	34018fb5 	.word	0x34018fb5
34018ddc:	3401902d 	.word	0x3401902d
34018de0:	340190f5 	.word	0x340190f5
34018de4:	340190a5 	.word	0x340190a5
    {
#ifdef ATON_STRENG_NUM
    case STRENG:
      ATON_DISABLE_CLR_CONFCLR(STRENG, unitId);
34018de8:	2300      	movs	r3, #0
34018dea:	60bb      	str	r3, [r7, #8]
34018dec:	68bb      	ldr	r3, [r7, #8]
34018dee:	f023 0301 	bic.w	r3, r3, #1
34018df2:	60bb      	str	r3, [r7, #8]
34018df4:	68bb      	ldr	r3, [r7, #8]
34018df6:	f043 0302 	orr.w	r3, r3, #2
34018dfa:	60bb      	str	r3, [r7, #8]
34018dfc:	68fb      	ldr	r3, [r7, #12]
34018dfe:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018e02:	33e5      	adds	r3, #229	@ 0xe5
34018e04:	031b      	lsls	r3, r3, #12
34018e06:	461a      	mov	r2, r3
34018e08:	68bb      	ldr	r3, [r7, #8]
34018e0a:	6013      	str	r3, [r2, #0]
34018e0c:	68fb      	ldr	r3, [r7, #12]
34018e0e:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018e12:	33e5      	adds	r3, #229	@ 0xe5
34018e14:	031b      	lsls	r3, r3, #12
34018e16:	681b      	ldr	r3, [r3, #0]
34018e18:	f003 0302 	and.w	r3, r3, #2
34018e1c:	2b00      	cmp	r3, #0
34018e1e:	d1f5      	bne.n	34018e0c <LL_ATON_DisableUnits_Init+0x80>
34018e20:	2300      	movs	r3, #0
34018e22:	60bb      	str	r3, [r7, #8]
34018e24:	68bb      	ldr	r3, [r7, #8]
34018e26:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
34018e2a:	60bb      	str	r3, [r7, #8]
34018e2c:	68fb      	ldr	r3, [r7, #12]
34018e2e:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018e32:	33e5      	adds	r3, #229	@ 0xe5
34018e34:	031b      	lsls	r3, r3, #12
34018e36:	461a      	mov	r2, r3
34018e38:	68bb      	ldr	r3, [r7, #8]
34018e3a:	6013      	str	r3, [r2, #0]
34018e3c:	68fb      	ldr	r3, [r7, #12]
34018e3e:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018e42:	33e5      	adds	r3, #229	@ 0xe5
34018e44:	031b      	lsls	r3, r3, #12
34018e46:	681b      	ldr	r3, [r3, #0]
34018e48:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34018e4c:	2b00      	cmp	r3, #0
34018e4e:	d1f5      	bne.n	34018e3c <LL_ATON_DisableUnits_Init+0xb0>
      LL_ATON_DisableClock(ATON_STRENG_CLKB_CLK(unitId));
34018e50:	68f8      	ldr	r0, [r7, #12]
34018e52:	f001 fbfd 	bl	3401a650 <LL_ATON_DisableClock>
      break;
34018e56:	e150      	b.n	340190fa <LL_ATON_DisableUnits_Init+0x36e>
#endif

#ifdef ATON_CONVACC_NUM
    case CONVACC:
      ATON_DISABLE_CLR_CONFCLR(CONVACC, unitId);
34018e58:	2300      	movs	r3, #0
34018e5a:	60bb      	str	r3, [r7, #8]
34018e5c:	68bb      	ldr	r3, [r7, #8]
34018e5e:	f023 0301 	bic.w	r3, r3, #1
34018e62:	60bb      	str	r3, [r7, #8]
34018e64:	68bb      	ldr	r3, [r7, #8]
34018e66:	f043 0302 	orr.w	r3, r3, #2
34018e6a:	60bb      	str	r3, [r7, #8]
34018e6c:	68fb      	ldr	r3, [r7, #12]
34018e6e:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018e72:	33ef      	adds	r3, #239	@ 0xef
34018e74:	031b      	lsls	r3, r3, #12
34018e76:	461a      	mov	r2, r3
34018e78:	68bb      	ldr	r3, [r7, #8]
34018e7a:	6013      	str	r3, [r2, #0]
34018e7c:	68fb      	ldr	r3, [r7, #12]
34018e7e:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018e82:	33ef      	adds	r3, #239	@ 0xef
34018e84:	031b      	lsls	r3, r3, #12
34018e86:	681b      	ldr	r3, [r3, #0]
34018e88:	f003 0302 	and.w	r3, r3, #2
34018e8c:	2b00      	cmp	r3, #0
34018e8e:	d1f5      	bne.n	34018e7c <LL_ATON_DisableUnits_Init+0xf0>
34018e90:	2300      	movs	r3, #0
34018e92:	60bb      	str	r3, [r7, #8]
34018e94:	68bb      	ldr	r3, [r7, #8]
34018e96:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
34018e9a:	60bb      	str	r3, [r7, #8]
34018e9c:	68fb      	ldr	r3, [r7, #12]
34018e9e:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018ea2:	33ef      	adds	r3, #239	@ 0xef
34018ea4:	031b      	lsls	r3, r3, #12
34018ea6:	461a      	mov	r2, r3
34018ea8:	68bb      	ldr	r3, [r7, #8]
34018eaa:	6013      	str	r3, [r2, #0]
34018eac:	68fb      	ldr	r3, [r7, #12]
34018eae:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018eb2:	33ef      	adds	r3, #239	@ 0xef
34018eb4:	031b      	lsls	r3, r3, #12
34018eb6:	681b      	ldr	r3, [r3, #0]
34018eb8:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34018ebc:	2b00      	cmp	r3, #0
34018ebe:	d1f5      	bne.n	34018eac <LL_ATON_DisableUnits_Init+0x120>
      LL_ATON_DisableClock(ATON_CONVACC_CLKB_CLK(unitId));
34018ec0:	68fb      	ldr	r3, [r7, #12]
34018ec2:	330a      	adds	r3, #10
34018ec4:	4618      	mov	r0, r3
34018ec6:	f001 fbc3 	bl	3401a650 <LL_ATON_DisableClock>
      break;
34018eca:	e116      	b.n	340190fa <LL_ATON_DisableUnits_Init+0x36e>
#endif

#ifdef ATON_DECUN_NUM
    case DECUN:
      ATON_DISABLE_CLR_CONFCLR(DECUN, unitId);
34018ecc:	2300      	movs	r3, #0
34018ece:	60bb      	str	r3, [r7, #8]
34018ed0:	68bb      	ldr	r3, [r7, #8]
34018ed2:	f023 0301 	bic.w	r3, r3, #1
34018ed6:	60bb      	str	r3, [r7, #8]
34018ed8:	68bb      	ldr	r3, [r7, #8]
34018eda:	f043 0302 	orr.w	r3, r3, #2
34018ede:	60bb      	str	r3, [r7, #8]
34018ee0:	68fb      	ldr	r3, [r7, #12]
34018ee2:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018ee6:	33f3      	adds	r3, #243	@ 0xf3
34018ee8:	031b      	lsls	r3, r3, #12
34018eea:	461a      	mov	r2, r3
34018eec:	68bb      	ldr	r3, [r7, #8]
34018eee:	6013      	str	r3, [r2, #0]
34018ef0:	68fb      	ldr	r3, [r7, #12]
34018ef2:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018ef6:	33f3      	adds	r3, #243	@ 0xf3
34018ef8:	031b      	lsls	r3, r3, #12
34018efa:	681b      	ldr	r3, [r3, #0]
34018efc:	f003 0302 	and.w	r3, r3, #2
34018f00:	2b00      	cmp	r3, #0
34018f02:	d1f5      	bne.n	34018ef0 <LL_ATON_DisableUnits_Init+0x164>
34018f04:	2300      	movs	r3, #0
34018f06:	60bb      	str	r3, [r7, #8]
34018f08:	68bb      	ldr	r3, [r7, #8]
34018f0a:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
34018f0e:	60bb      	str	r3, [r7, #8]
34018f10:	68fb      	ldr	r3, [r7, #12]
34018f12:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018f16:	33f3      	adds	r3, #243	@ 0xf3
34018f18:	031b      	lsls	r3, r3, #12
34018f1a:	461a      	mov	r2, r3
34018f1c:	68bb      	ldr	r3, [r7, #8]
34018f1e:	6013      	str	r3, [r2, #0]
34018f20:	68fb      	ldr	r3, [r7, #12]
34018f22:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018f26:	33f3      	adds	r3, #243	@ 0xf3
34018f28:	031b      	lsls	r3, r3, #12
34018f2a:	681b      	ldr	r3, [r3, #0]
34018f2c:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34018f30:	2b00      	cmp	r3, #0
34018f32:	d1f5      	bne.n	34018f20 <LL_ATON_DisableUnits_Init+0x194>
      LL_ATON_DisableClock(ATON_DECUN_CLKB_CLK(unitId));
34018f34:	68fb      	ldr	r3, [r7, #12]
34018f36:	330e      	adds	r3, #14
34018f38:	4618      	mov	r0, r3
34018f3a:	f001 fb89 	bl	3401a650 <LL_ATON_DisableClock>
      break;
34018f3e:	e0dc      	b.n	340190fa <LL_ATON_DisableUnits_Init+0x36e>
#endif

#ifdef ATON_ACTIV_NUM
    case ACTIV:
      ATON_DISABLE_CLR_CONFCLR(ACTIV, unitId);
34018f40:	4b74      	ldr	r3, [pc, #464]	@ (34019114 <LL_ATON_DisableUnits_Init+0x388>)
34018f42:	60bb      	str	r3, [r7, #8]
34018f44:	68bb      	ldr	r3, [r7, #8]
34018f46:	f023 0301 	bic.w	r3, r3, #1
34018f4a:	60bb      	str	r3, [r7, #8]
34018f4c:	68bb      	ldr	r3, [r7, #8]
34018f4e:	f043 0302 	orr.w	r3, r3, #2
34018f52:	60bb      	str	r3, [r7, #8]
34018f54:	68fb      	ldr	r3, [r7, #12]
34018f56:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018f5a:	33f5      	adds	r3, #245	@ 0xf5
34018f5c:	031b      	lsls	r3, r3, #12
34018f5e:	461a      	mov	r2, r3
34018f60:	68bb      	ldr	r3, [r7, #8]
34018f62:	6013      	str	r3, [r2, #0]
34018f64:	68fb      	ldr	r3, [r7, #12]
34018f66:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018f6a:	33f5      	adds	r3, #245	@ 0xf5
34018f6c:	031b      	lsls	r3, r3, #12
34018f6e:	681b      	ldr	r3, [r3, #0]
34018f70:	f003 0302 	and.w	r3, r3, #2
34018f74:	2b00      	cmp	r3, #0
34018f76:	d1f5      	bne.n	34018f64 <LL_ATON_DisableUnits_Init+0x1d8>
34018f78:	4b66      	ldr	r3, [pc, #408]	@ (34019114 <LL_ATON_DisableUnits_Init+0x388>)
34018f7a:	60bb      	str	r3, [r7, #8]
34018f7c:	68bb      	ldr	r3, [r7, #8]
34018f7e:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
34018f82:	60bb      	str	r3, [r7, #8]
34018f84:	68fb      	ldr	r3, [r7, #12]
34018f86:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018f8a:	33f5      	adds	r3, #245	@ 0xf5
34018f8c:	031b      	lsls	r3, r3, #12
34018f8e:	461a      	mov	r2, r3
34018f90:	68bb      	ldr	r3, [r7, #8]
34018f92:	6013      	str	r3, [r2, #0]
34018f94:	68fb      	ldr	r3, [r7, #12]
34018f96:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018f9a:	33f5      	adds	r3, #245	@ 0xf5
34018f9c:	031b      	lsls	r3, r3, #12
34018f9e:	681b      	ldr	r3, [r3, #0]
34018fa0:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34018fa4:	2b00      	cmp	r3, #0
34018fa6:	d1f5      	bne.n	34018f94 <LL_ATON_DisableUnits_Init+0x208>
      LL_ATON_DisableClock(ATON_ACTIV_CLKB_CLK(unitId));
34018fa8:	68fb      	ldr	r3, [r7, #12]
34018faa:	3310      	adds	r3, #16
34018fac:	4618      	mov	r0, r3
34018fae:	f001 fb4f 	bl	3401a650 <LL_ATON_DisableClock>
      break;
34018fb2:	e0a2      	b.n	340190fa <LL_ATON_DisableUnits_Init+0x36e>
#endif

#ifdef ATON_ARITH_NUM
    case ARITH:
      ATON_DISABLE_CLR_CONFCLR(ARITH, unitId);
34018fb4:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
34018fb8:	60bb      	str	r3, [r7, #8]
34018fba:	68bb      	ldr	r3, [r7, #8]
34018fbc:	f023 0301 	bic.w	r3, r3, #1
34018fc0:	60bb      	str	r3, [r7, #8]
34018fc2:	68bb      	ldr	r3, [r7, #8]
34018fc4:	f043 0302 	orr.w	r3, r3, #2
34018fc8:	60bb      	str	r3, [r7, #8]
34018fca:	68fb      	ldr	r3, [r7, #12]
34018fcc:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018fd0:	33f7      	adds	r3, #247	@ 0xf7
34018fd2:	031b      	lsls	r3, r3, #12
34018fd4:	461a      	mov	r2, r3
34018fd6:	68bb      	ldr	r3, [r7, #8]
34018fd8:	6013      	str	r3, [r2, #0]
34018fda:	68fb      	ldr	r3, [r7, #12]
34018fdc:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34018fe0:	33f7      	adds	r3, #247	@ 0xf7
34018fe2:	031b      	lsls	r3, r3, #12
34018fe4:	681b      	ldr	r3, [r3, #0]
34018fe6:	f003 0302 	and.w	r3, r3, #2
34018fea:	2b00      	cmp	r3, #0
34018fec:	d1f5      	bne.n	34018fda <LL_ATON_DisableUnits_Init+0x24e>
34018fee:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
34018ff2:	60bb      	str	r3, [r7, #8]
34018ff4:	68bb      	ldr	r3, [r7, #8]
34018ff6:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
34018ffa:	60bb      	str	r3, [r7, #8]
34018ffc:	68fb      	ldr	r3, [r7, #12]
34018ffe:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34019002:	33f7      	adds	r3, #247	@ 0xf7
34019004:	031b      	lsls	r3, r3, #12
34019006:	461a      	mov	r2, r3
34019008:	68bb      	ldr	r3, [r7, #8]
3401900a:	6013      	str	r3, [r2, #0]
3401900c:	68fb      	ldr	r3, [r7, #12]
3401900e:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34019012:	33f7      	adds	r3, #247	@ 0xf7
34019014:	031b      	lsls	r3, r3, #12
34019016:	681b      	ldr	r3, [r3, #0]
34019018:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3401901c:	2b00      	cmp	r3, #0
3401901e:	d1f5      	bne.n	3401900c <LL_ATON_DisableUnits_Init+0x280>
      LL_ATON_DisableClock(ATON_ARITH_CLKB_CLK(unitId));
34019020:	68fb      	ldr	r3, [r7, #12]
34019022:	3312      	adds	r3, #18
34019024:	4618      	mov	r0, r3
34019026:	f001 fb13 	bl	3401a650 <LL_ATON_DisableClock>
      break;
3401902a:	e066      	b.n	340190fa <LL_ATON_DisableUnits_Init+0x36e>
#ifdef ATON_POOL_NUM
    case POOL:
#ifdef POOL_RC14
      ATON_POOL_CTRL_SET(unitId, ATON_POOL_CTRL_SET_EN(ATON_POOL_CTRL_GET(unitId), 0));
#else  // !POOL_RC14
      ATON_DISABLE_CLR_CONFCLR(POOL, unitId);
3401902c:	f44f 0384 	mov.w	r3, #4325376	@ 0x420000
34019030:	60bb      	str	r3, [r7, #8]
34019032:	68bb      	ldr	r3, [r7, #8]
34019034:	f023 0301 	bic.w	r3, r3, #1
34019038:	60bb      	str	r3, [r7, #8]
3401903a:	68bb      	ldr	r3, [r7, #8]
3401903c:	f043 0302 	orr.w	r3, r3, #2
34019040:	60bb      	str	r3, [r7, #8]
34019042:	68fb      	ldr	r3, [r7, #12]
34019044:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34019048:	33fb      	adds	r3, #251	@ 0xfb
3401904a:	031b      	lsls	r3, r3, #12
3401904c:	461a      	mov	r2, r3
3401904e:	68bb      	ldr	r3, [r7, #8]
34019050:	6013      	str	r3, [r2, #0]
34019052:	68fb      	ldr	r3, [r7, #12]
34019054:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34019058:	33fb      	adds	r3, #251	@ 0xfb
3401905a:	031b      	lsls	r3, r3, #12
3401905c:	681b      	ldr	r3, [r3, #0]
3401905e:	f003 0302 	and.w	r3, r3, #2
34019062:	2b00      	cmp	r3, #0
34019064:	d1f5      	bne.n	34019052 <LL_ATON_DisableUnits_Init+0x2c6>
34019066:	f44f 0384 	mov.w	r3, #4325376	@ 0x420000
3401906a:	60bb      	str	r3, [r7, #8]
3401906c:	68bb      	ldr	r3, [r7, #8]
3401906e:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
34019072:	60bb      	str	r3, [r7, #8]
34019074:	68fb      	ldr	r3, [r7, #12]
34019076:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
3401907a:	33fb      	adds	r3, #251	@ 0xfb
3401907c:	031b      	lsls	r3, r3, #12
3401907e:	461a      	mov	r2, r3
34019080:	68bb      	ldr	r3, [r7, #8]
34019082:	6013      	str	r3, [r2, #0]
34019084:	68fb      	ldr	r3, [r7, #12]
34019086:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
3401908a:	33fb      	adds	r3, #251	@ 0xfb
3401908c:	031b      	lsls	r3, r3, #12
3401908e:	681b      	ldr	r3, [r3, #0]
34019090:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34019094:	2b00      	cmp	r3, #0
34019096:	d1f5      	bne.n	34019084 <LL_ATON_DisableUnits_Init+0x2f8>
#endif // !POOL_RC14

      LL_ATON_DisableClock(ATON_POOL_CLKB_CLK(unitId));
34019098:	68fb      	ldr	r3, [r7, #12]
3401909a:	3316      	adds	r3, #22
3401909c:	4618      	mov	r0, r3
3401909e:	f001 fad7 	bl	3401a650 <LL_ATON_DisableClock>
      break;
340190a2:	e02a      	b.n	340190fa <LL_ATON_DisableUnits_Init+0x36e>
#endif

#ifdef ATON_RECBUF_NUM
    case RECBUF:
      ATON_DISABLE_CLR_CONFCLR(RECBUF, unitId);
340190a4:	2300      	movs	r3, #0
340190a6:	60bb      	str	r3, [r7, #8]
340190a8:	68bb      	ldr	r3, [r7, #8]
340190aa:	f023 0301 	bic.w	r3, r3, #1
340190ae:	60bb      	str	r3, [r7, #8]
340190b0:	68bb      	ldr	r3, [r7, #8]
340190b2:	f043 0302 	orr.w	r3, r3, #2
340190b6:	60bb      	str	r3, [r7, #8]
340190b8:	4a17      	ldr	r2, [pc, #92]	@ (34019118 <LL_ATON_DisableUnits_Init+0x38c>)
340190ba:	68bb      	ldr	r3, [r7, #8]
340190bc:	6013      	str	r3, [r2, #0]
340190be:	4b16      	ldr	r3, [pc, #88]	@ (34019118 <LL_ATON_DisableUnits_Init+0x38c>)
340190c0:	681b      	ldr	r3, [r3, #0]
340190c2:	f003 0302 	and.w	r3, r3, #2
340190c6:	2b00      	cmp	r3, #0
340190c8:	d1f9      	bne.n	340190be <LL_ATON_DisableUnits_Init+0x332>
340190ca:	2300      	movs	r3, #0
340190cc:	60bb      	str	r3, [r7, #8]
340190ce:	68bb      	ldr	r3, [r7, #8]
340190d0:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
340190d4:	60bb      	str	r3, [r7, #8]
340190d6:	4a10      	ldr	r2, [pc, #64]	@ (34019118 <LL_ATON_DisableUnits_Init+0x38c>)
340190d8:	68bb      	ldr	r3, [r7, #8]
340190da:	6013      	str	r3, [r2, #0]
340190dc:	4b0e      	ldr	r3, [pc, #56]	@ (34019118 <LL_ATON_DisableUnits_Init+0x38c>)
340190de:	681b      	ldr	r3, [r3, #0]
340190e0:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
340190e4:	2b00      	cmp	r3, #0
340190e6:	d1f9      	bne.n	340190dc <LL_ATON_DisableUnits_Init+0x350>
      LL_ATON_DisableClock(ATON_RECBUF_CLKB_CLK(unitId));
340190e8:	68fb      	ldr	r3, [r7, #12]
340190ea:	3318      	adds	r3, #24
340190ec:	4618      	mov	r0, r3
340190ee:	f001 faaf 	bl	3401a650 <LL_ATON_DisableClock>
      break;
340190f2:	e002      	b.n	340190fa <LL_ATON_DisableUnits_Init+0x36e>
#endif

    default:
      return LL_ATON_INVALID_PARAM;
340190f4:	f06f 0301 	mvn.w	r3, #1
340190f8:	e008      	b.n	3401910c <LL_ATON_DisableUnits_Init+0x380>
  for (i = 0; i < n; i++)
340190fa:	697b      	ldr	r3, [r7, #20]
340190fc:	3301      	adds	r3, #1
340190fe:	617b      	str	r3, [r7, #20]
34019100:	697a      	ldr	r2, [r7, #20]
34019102:	683b      	ldr	r3, [r7, #0]
34019104:	429a      	cmp	r2, r3
34019106:	f6ff ae49 	blt.w	34018d9c <LL_ATON_DisableUnits_Init+0x10>
    }
  }

  return LL_ATON_OK;
3401910a:	2300      	movs	r3, #0
}
3401910c:	4618      	mov	r0, r3
3401910e:	3718      	adds	r7, #24
34019110:	46bd      	mov	sp, r7
34019112:	bd80      	pop	{r7, pc}
34019114:	00881080 	.word	0x00881080
34019118:	580fd000 	.word	0x580fd000

3401911c <LL_Streng_TensorInit>:
 * @param  conf Pointer to structure(s) describing initialization parameters
 * @param  n Number of elements in initialization structure array
 * @retval error code. E.g.: Invalid ID, invalid parameters, not idle,..
 */
int LL_Streng_TensorInit(int id, const LL_Streng_TensorInitTypeDef *conf, int n)
{
3401911c:	b580      	push	{r7, lr}
3401911e:	b096      	sub	sp, #88	@ 0x58
34019120:	af00      	add	r7, sp, #0
34019122:	60f8      	str	r0, [r7, #12]
34019124:	60b9      	str	r1, [r7, #8]
34019126:	607a      	str	r2, [r7, #4]
  uint32_t t;

  /* deferred register values */
  uint32_t t_streng_strd = ATON_STRENG_STRD_DT;
34019128:	2300      	movs	r3, #0
3401912a:	653b      	str	r3, [r7, #80]	@ 0x50
  uint32_t t_streng_cid_cache = ATON_STRENG_CID_CACHE_DT;
3401912c:	2300      	movs	r3, #0
3401912e:	64fb      	str	r3, [r7, #76]	@ 0x4c
  uint32_t t_streng_event = ATON_STRENG_EVENT_DT;
34019130:	2300      	movs	r3, #0
34019132:	64bb      	str	r3, [r7, #72]	@ 0x48

  if (id >= ATON_STRENG_NUM)
34019134:	68fb      	ldr	r3, [r7, #12]
34019136:	2b09      	cmp	r3, #9
34019138:	dd02      	ble.n	34019140 <LL_Streng_TensorInit+0x24>
    return LL_ATON_INVALID_ID;
3401913a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
3401913e:	e342      	b.n	340197c6 <LL_Streng_TensorInit+0x6aa>

  LL_ATON_EnableClock(ATON_STRENG_CLKB_CLK(id));
34019140:	68fb      	ldr	r3, [r7, #12]
34019142:	4618      	mov	r0, r3
34019144:	f001 fa56 	bl	3401a5f4 <LL_ATON_EnableClock>

#define _LL_min(x, y) ((x) > (y) ? (y) : (x))

  if (n != 1)
34019148:	687b      	ldr	r3, [r7, #4]
3401914a:	2b01      	cmp	r3, #1
3401914c:	d002      	beq.n	34019154 <LL_Streng_TensorInit+0x38>
    return -1;
3401914e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
34019152:	e338      	b.n	340197c6 <LL_Streng_TensorInit+0x6aa>
    // if (conf->dir == 0 && (conf->nbits_in > conf->nbits_out)) return -1;
#ifndef ATON_IMC_NUM
  if (conf->nbits_in > 24 || conf->nbits_out > 24)
34019154:	68bb      	ldr	r3, [r7, #8]
34019156:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
3401915a:	2b18      	cmp	r3, #24
3401915c:	d804      	bhi.n	34019168 <LL_Streng_TensorInit+0x4c>
3401915e:	68bb      	ldr	r3, [r7, #8]
34019160:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
34019164:	2b18      	cmp	r3, #24
34019166:	d902      	bls.n	3401916e <LL_Streng_TensorInit+0x52>
    return -1;
34019168:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
3401916c:	e32b      	b.n	340197c6 <LL_Streng_TensorInit+0x6aa>
#endif

  t = ATON_STRENG_CTRL_DT;
3401916e:	2300      	movs	r3, #0
34019170:	657b      	str	r3, [r7, #84]	@ 0x54
  t = ATON_STRENG_CTRL_SET_DIR(t, (conf->dir != 0));
34019172:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019174:	f023 0208 	bic.w	r2, r3, #8
34019178:	68bb      	ldr	r3, [r7, #8]
3401917a:	781b      	ldrb	r3, [r3, #0]
3401917c:	00db      	lsls	r3, r3, #3
3401917e:	f003 0308 	and.w	r3, r3, #8
34019182:	4313      	orrs	r3, r2
34019184:	657b      	str	r3, [r7, #84]	@ 0x54
  t = ATON_STRENG_CTRL_SET_RAW(t, (conf->raw != 0));
34019186:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019188:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
3401918c:	68bb      	ldr	r3, [r7, #8]
3401918e:	781b      	ldrb	r3, [r3, #0]
34019190:	01db      	lsls	r3, r3, #7
34019192:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34019196:	4313      	orrs	r3, r2
34019198:	657b      	str	r3, [r7, #84]	@ 0x54
#ifdef ATON_STRENG_CTRL_SET_RAW_OUT
  t = ATON_STRENG_CTRL_SET_RAW_OUT(t, conf->raw_out);
3401919a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401919c:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
340191a0:	68bb      	ldr	r3, [r7, #8]
340191a2:	781b      	ldrb	r3, [r3, #0]
340191a4:	f3c3 0380 	ubfx	r3, r3, #2, #1
340191a8:	b2db      	uxtb	r3, r3
340191aa:	025b      	lsls	r3, r3, #9
340191ac:	f403 7300 	and.w	r3, r3, #512	@ 0x200
340191b0:	4313      	orrs	r3, r2
340191b2:	657b      	str	r3, [r7, #84]	@ 0x54
#else
  /* Hardware feature not supported */
  LL_ATON_ASSERT(conf->raw_out == 0);
#endif
  t = ATON_STRENG_CTRL_SET_NOBLK(t, (conf->noblk != 0));
340191b4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
340191b6:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
340191ba:	68bb      	ldr	r3, [r7, #8]
340191bc:	781b      	ldrb	r3, [r3, #0]
340191be:	01db      	lsls	r3, r3, #7
340191c0:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
340191c4:	4313      	orrs	r3, r2
340191c6:	657b      	str	r3, [r7, #84]	@ 0x54
  t = ATON_STRENG_CTRL_SET_NOINC(t, (conf->noinc == 1));
340191c8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
340191ca:	f023 0210 	bic.w	r2, r3, #16
340191ce:	68bb      	ldr	r3, [r7, #8]
340191d0:	781b      	ldrb	r3, [r3, #0]
340191d2:	085b      	lsrs	r3, r3, #1
340191d4:	b2db      	uxtb	r3, r3
340191d6:	f003 0310 	and.w	r3, r3, #16
340191da:	4313      	orrs	r3, r2
340191dc:	657b      	str	r3, [r7, #84]	@ 0x54
  t = ATON_STRENG_CTRL_SET_SINGLE(t, conf->frame_tot_cnt == 1);
340191de:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
340191e0:	f023 0304 	bic.w	r3, r3, #4
340191e4:	68ba      	ldr	r2, [r7, #8]
340191e6:	6b92      	ldr	r2, [r2, #56]	@ 0x38
340191e8:	2a01      	cmp	r2, #1
340191ea:	d101      	bne.n	340191f0 <LL_Streng_TensorInit+0xd4>
340191ec:	2204      	movs	r2, #4
340191ee:	e000      	b.n	340191f2 <LL_Streng_TensorInit+0xd6>
340191f0:	2200      	movs	r2, #0
340191f2:	4313      	orrs	r3, r2
340191f4:	657b      	str	r3, [r7, #84]	@ 0x54
  t = ATON_STRENG_CTRL_SET_CONT(t, conf->continuous == 1);
340191f6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
340191f8:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
340191fc:	68bb      	ldr	r3, [r7, #8]
340191fe:	781b      	ldrb	r3, [r3, #0]
34019200:	011b      	lsls	r3, r3, #4
34019202:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34019206:	4313      	orrs	r3, r2
34019208:	657b      	str	r3, [r7, #84]	@ 0x54
  t = ATON_STRENG_CTRL_SET_LSBMODE(t, conf->align_right == 1);
3401920a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401920c:	f423 4280 	bic.w	r2, r3, #16384	@ 0x4000
34019210:	68bb      	ldr	r3, [r7, #8]
34019212:	781b      	ldrb	r3, [r3, #0]
34019214:	021b      	lsls	r3, r3, #8
34019216:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3401921a:	4313      	orrs	r3, r2
3401921c:	657b      	str	r3, [r7, #84]	@ 0x54
  t = ATON_STRENG_CTRL_SET_SIGNEXT(t, conf->align_right == 1 && conf->nbits_unsigned == 0);
3401921e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019220:	f423 4200 	bic.w	r2, r3, #32768	@ 0x8000
34019224:	68bb      	ldr	r3, [r7, #8]
34019226:	781b      	ldrb	r3, [r3, #0]
34019228:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3401922c:	b2db      	uxtb	r3, r3
3401922e:	2b00      	cmp	r3, #0
34019230:	d008      	beq.n	34019244 <LL_Streng_TensorInit+0x128>
34019232:	68bb      	ldr	r3, [r7, #8]
34019234:	785b      	ldrb	r3, [r3, #1]
34019236:	f003 0302 	and.w	r3, r3, #2
3401923a:	b2db      	uxtb	r3, r3
3401923c:	2b00      	cmp	r3, #0
3401923e:	d101      	bne.n	34019244 <LL_Streng_TensorInit+0x128>
34019240:	2301      	movs	r3, #1
34019242:	e000      	b.n	34019246 <LL_Streng_TensorInit+0x12a>
34019244:	2300      	movs	r3, #0
34019246:	03db      	lsls	r3, r3, #15
34019248:	b29b      	uxth	r3, r3
3401924a:	4313      	orrs	r3, r2
3401924c:	657b      	str	r3, [r7, #84]	@ 0x54

  int ch_bits[3] = {0, 0, 0};
3401924e:	2300      	movs	r3, #0
34019250:	62fb      	str	r3, [r7, #44]	@ 0x2c
34019252:	2300      	movs	r3, #0
34019254:	633b      	str	r3, [r7, #48]	@ 0x30
34019256:	2300      	movs	r3, #0
34019258:	637b      	str	r3, [r7, #52]	@ 0x34
  int in_bits[3];
  int out_bits[3];
  int nbits_out = conf->nbits_out;
3401925a:	68bb      	ldr	r3, [r7, #8]
3401925c:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
34019260:	647b      	str	r3, [r7, #68]	@ 0x44
  int nbits_in = conf->nbits_in;
34019262:	68bb      	ldr	r3, [r7, #8]
34019264:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
34019268:	643b      	str	r3, [r7, #64]	@ 0x40
  // case 2: stream->bus  --> in_bits >= out_bits -> use lanes but valid for in_bits=8,16,24 for other bit length out is
  // right shifted by (8,16,24) - out_bits
  //                      |
  // case 3:              --> in_bits < out_bits -> use FRONT_GAP

  int io_case = ((conf->dir != 0) << 1);
3401926a:	68bb      	ldr	r3, [r7, #8]
3401926c:	781b      	ldrb	r3, [r3, #0]
3401926e:	005b      	lsls	r3, r3, #1
34019270:	f003 0302 	and.w	r3, r3, #2
34019274:	63fb      	str	r3, [r7, #60]	@ 0x3c
  io_case += (conf->dir == 0 ? (conf->nbits_in <= conf->nbits_out) : (conf->nbits_in < conf->nbits_out));
34019276:	68bb      	ldr	r3, [r7, #8]
34019278:	781b      	ldrb	r3, [r3, #0]
3401927a:	f003 0301 	and.w	r3, r3, #1
3401927e:	b2db      	uxtb	r3, r3
34019280:	2b00      	cmp	r3, #0
34019282:	d10c      	bne.n	3401929e <LL_Streng_TensorInit+0x182>
34019284:	68bb      	ldr	r3, [r7, #8]
34019286:	f893 203c 	ldrb.w	r2, [r3, #60]	@ 0x3c
3401928a:	68bb      	ldr	r3, [r7, #8]
3401928c:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
34019290:	429a      	cmp	r2, r3
34019292:	bf94      	ite	ls
34019294:	2301      	movls	r3, #1
34019296:	2300      	movhi	r3, #0
34019298:	b2db      	uxtb	r3, r3
3401929a:	461a      	mov	r2, r3
3401929c:	e00b      	b.n	340192b6 <LL_Streng_TensorInit+0x19a>
3401929e:	68bb      	ldr	r3, [r7, #8]
340192a0:	f893 203c 	ldrb.w	r2, [r3, #60]	@ 0x3c
340192a4:	68bb      	ldr	r3, [r7, #8]
340192a6:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
340192aa:	429a      	cmp	r2, r3
340192ac:	bf34      	ite	cc
340192ae:	2301      	movcc	r3, #1
340192b0:	2300      	movcs	r3, #0
340192b2:	b2db      	uxtb	r3, r3
340192b4:	461a      	mov	r2, r3
340192b6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340192b8:	4413      	add	r3, r2
340192ba:	63fb      	str	r3, [r7, #60]	@ 0x3c

  switch (io_case)
340192bc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340192be:	2b03      	cmp	r3, #3
340192c0:	f200 80c8 	bhi.w	34019454 <LL_Streng_TensorInit+0x338>
340192c4:	a201      	add	r2, pc, #4	@ (adr r2, 340192cc <LL_Streng_TensorInit+0x1b0>)
340192c6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
340192ca:	bf00      	nop
340192cc:	340192dd 	.word	0x340192dd
340192d0:	3401931d 	.word	0x3401931d
340192d4:	340193d9 	.word	0x340193d9
340192d8:	34019399 	.word	0x34019399
  {
  case 0: // in_bits > out_bits && bus->stream
          // must use FRONT_GAP
  {
    if (conf->mem_lsb)
340192dc:	68bb      	ldr	r3, [r7, #8]
340192de:	781b      	ldrb	r3, [r3, #0]
340192e0:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
340192e4:	b2db      	uxtb	r3, r3
340192e6:	2b00      	cmp	r3, #0
340192e8:	d00b      	beq.n	34019302 <LL_Streng_TensorInit+0x1e6>
      t_streng_strd = ATON_STRENG_STRD_SET_FGAP(t_streng_strd, (nbits_in - nbits_out));
340192ea:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
340192ec:	f423 127c 	bic.w	r2, r3, #4128768	@ 0x3f0000
340192f0:	6c39      	ldr	r1, [r7, #64]	@ 0x40
340192f2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
340192f4:	1acb      	subs	r3, r1, r3
340192f6:	041b      	lsls	r3, r3, #16
340192f8:	f403 137c 	and.w	r3, r3, #4128768	@ 0x3f0000
340192fc:	4313      	orrs	r3, r2
340192fe:	653b      	str	r3, [r7, #80]	@ 0x50
34019300:	e00a      	b.n	34019318 <LL_Streng_TensorInit+0x1fc>
    else
      t_streng_strd = ATON_STRENG_STRD_SET_BGAP(t_streng_strd, (nbits_in - nbits_out));
34019302:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34019304:	f023 527c 	bic.w	r2, r3, #1056964608	@ 0x3f000000
34019308:	6c39      	ldr	r1, [r7, #64]	@ 0x40
3401930a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3401930c:	1acb      	subs	r3, r1, r3
3401930e:	061b      	lsls	r3, r3, #24
34019310:	f003 537c 	and.w	r3, r3, #1056964608	@ 0x3f000000
34019314:	4313      	orrs	r3, r2
34019316:	653b      	str	r3, [r7, #80]	@ 0x50
    nbits_in = nbits_out;
34019318:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3401931a:	643b      	str	r3, [r7, #64]	@ 0x40
  }
  // intentional fall through
  case 1: // in_bits <= out_bits && bus->stream
    in_bits[0] = _LL_min(8, nbits_in);
3401931c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401931e:	2b08      	cmp	r3, #8
34019320:	bfa8      	it	ge
34019322:	2308      	movge	r3, #8
34019324:	623b      	str	r3, [r7, #32]
    in_bits[1] = nbits_in > 8 ? _LL_min(8, nbits_in - 8) : 0;
34019326:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34019328:	2b08      	cmp	r3, #8
3401932a:	dd05      	ble.n	34019338 <LL_Streng_TensorInit+0x21c>
3401932c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401932e:	2b10      	cmp	r3, #16
34019330:	bfa8      	it	ge
34019332:	2310      	movge	r3, #16
34019334:	3b08      	subs	r3, #8
34019336:	e000      	b.n	3401933a <LL_Streng_TensorInit+0x21e>
34019338:	2300      	movs	r3, #0
3401933a:	627b      	str	r3, [r7, #36]	@ 0x24
    in_bits[2] = nbits_in > 16 ? _LL_min(8, nbits_in - 16) : 0;
3401933c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401933e:	2b10      	cmp	r3, #16
34019340:	dd05      	ble.n	3401934e <LL_Streng_TensorInit+0x232>
34019342:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34019344:	2b18      	cmp	r3, #24
34019346:	bfa8      	it	ge
34019348:	2318      	movge	r3, #24
3401934a:	3b10      	subs	r3, #16
3401934c:	e000      	b.n	34019350 <LL_Streng_TensorInit+0x234>
3401934e:	2300      	movs	r3, #0
34019350:	62bb      	str	r3, [r7, #40]	@ 0x28
    if (conf->align_right)
34019352:	68bb      	ldr	r3, [r7, #8]
34019354:	781b      	ldrb	r3, [r3, #0]
34019356:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3401935a:	b2db      	uxtb	r3, r3
3401935c:	2b00      	cmp	r3, #0
3401935e:	d006      	beq.n	3401936e <LL_Streng_TensorInit+0x252>
    {
      ch_bits[0] = in_bits[0];
34019360:	6a3b      	ldr	r3, [r7, #32]
34019362:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ch_bits[1] = in_bits[1];
34019364:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34019366:	633b      	str	r3, [r7, #48]	@ 0x30
      ch_bits[2] = in_bits[2];
34019368:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401936a:	637b      	str	r3, [r7, #52]	@ 0x34
        ch_bits[0] = in_bits[1];
      } // N.B. the DMA stuffs the bits to the left of the channel
      else
        ch_bits[0] = in_bits[0];
    }
    break;
3401936c:	e072      	b.n	34019454 <LL_Streng_TensorInit+0x338>
      if (nbits_out > 16)
3401936e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34019370:	2b10      	cmp	r3, #16
34019372:	dd06      	ble.n	34019382 <LL_Streng_TensorInit+0x266>
        ch_bits[2] = in_bits[0];
34019374:	6a3b      	ldr	r3, [r7, #32]
34019376:	637b      	str	r3, [r7, #52]	@ 0x34
        ch_bits[1] = in_bits[1];
34019378:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401937a:	633b      	str	r3, [r7, #48]	@ 0x30
        ch_bits[0] = in_bits[2];
3401937c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401937e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34019380:	e068      	b.n	34019454 <LL_Streng_TensorInit+0x338>
      else if (nbits_out > 8)
34019382:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34019384:	2b08      	cmp	r3, #8
34019386:	dd04      	ble.n	34019392 <LL_Streng_TensorInit+0x276>
        ch_bits[1] = in_bits[0];
34019388:	6a3b      	ldr	r3, [r7, #32]
3401938a:	633b      	str	r3, [r7, #48]	@ 0x30
        ch_bits[0] = in_bits[1];
3401938c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401938e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34019390:	e060      	b.n	34019454 <LL_Streng_TensorInit+0x338>
        ch_bits[0] = in_bits[0];
34019392:	6a3b      	ldr	r3, [r7, #32]
34019394:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34019396:	e05d      	b.n	34019454 <LL_Streng_TensorInit+0x338>
  case 3: // in_bits < out_bits && stream->bus
  {
    if (conf->mem_lsb)
34019398:	68bb      	ldr	r3, [r7, #8]
3401939a:	781b      	ldrb	r3, [r3, #0]
3401939c:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
340193a0:	b2db      	uxtb	r3, r3
340193a2:	2b00      	cmp	r3, #0
340193a4:	d00b      	beq.n	340193be <LL_Streng_TensorInit+0x2a2>
      t_streng_strd = ATON_STRENG_STRD_SET_FGAP(t_streng_strd, (nbits_out - nbits_in));
340193a6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
340193a8:	f423 127c 	bic.w	r2, r3, #4128768	@ 0x3f0000
340193ac:	6c79      	ldr	r1, [r7, #68]	@ 0x44
340193ae:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
340193b0:	1acb      	subs	r3, r1, r3
340193b2:	041b      	lsls	r3, r3, #16
340193b4:	f403 137c 	and.w	r3, r3, #4128768	@ 0x3f0000
340193b8:	4313      	orrs	r3, r2
340193ba:	653b      	str	r3, [r7, #80]	@ 0x50
340193bc:	e00a      	b.n	340193d4 <LL_Streng_TensorInit+0x2b8>
    else
      t_streng_strd = ATON_STRENG_STRD_SET_BGAP(t_streng_strd, (nbits_out - nbits_in));
340193be:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
340193c0:	f023 527c 	bic.w	r2, r3, #1056964608	@ 0x3f000000
340193c4:	6c79      	ldr	r1, [r7, #68]	@ 0x44
340193c6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
340193c8:	1acb      	subs	r3, r1, r3
340193ca:	061b      	lsls	r3, r3, #24
340193cc:	f003 537c 	and.w	r3, r3, #1056964608	@ 0x3f000000
340193d0:	4313      	orrs	r3, r2
340193d2:	653b      	str	r3, [r7, #80]	@ 0x50
    nbits_out = nbits_in;
340193d4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
340193d6:	647b      	str	r3, [r7, #68]	@ 0x44
  }
  // intentional fall through
  case 2: // in_bits >= out_bits && stream->bus
    out_bits[0] = _LL_min(8, nbits_out);
340193d8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
340193da:	2b08      	cmp	r3, #8
340193dc:	bfa8      	it	ge
340193de:	2308      	movge	r3, #8
340193e0:	617b      	str	r3, [r7, #20]
    out_bits[1] = nbits_out > 8 ? _LL_min(8, nbits_out - 8) : 0;
340193e2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
340193e4:	2b08      	cmp	r3, #8
340193e6:	dd05      	ble.n	340193f4 <LL_Streng_TensorInit+0x2d8>
340193e8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
340193ea:	2b10      	cmp	r3, #16
340193ec:	bfa8      	it	ge
340193ee:	2310      	movge	r3, #16
340193f0:	3b08      	subs	r3, #8
340193f2:	e000      	b.n	340193f6 <LL_Streng_TensorInit+0x2da>
340193f4:	2300      	movs	r3, #0
340193f6:	61bb      	str	r3, [r7, #24]
    out_bits[2] = nbits_out > 16 ? _LL_min(8, nbits_out - 16) : 0;
340193f8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
340193fa:	2b10      	cmp	r3, #16
340193fc:	dd05      	ble.n	3401940a <LL_Streng_TensorInit+0x2ee>
340193fe:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34019400:	2b18      	cmp	r3, #24
34019402:	bfa8      	it	ge
34019404:	2318      	movge	r3, #24
34019406:	3b10      	subs	r3, #16
34019408:	e000      	b.n	3401940c <LL_Streng_TensorInit+0x2f0>
3401940a:	2300      	movs	r3, #0
3401940c:	61fb      	str	r3, [r7, #28]
    if (conf->align_right)
3401940e:	68bb      	ldr	r3, [r7, #8]
34019410:	781b      	ldrb	r3, [r3, #0]
34019412:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34019416:	b2db      	uxtb	r3, r3
34019418:	2b00      	cmp	r3, #0
3401941a:	d006      	beq.n	3401942a <LL_Streng_TensorInit+0x30e>
    {
      ch_bits[0] = out_bits[0];
3401941c:	697b      	ldr	r3, [r7, #20]
3401941e:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ch_bits[1] = out_bits[1];
34019420:	69bb      	ldr	r3, [r7, #24]
34019422:	633b      	str	r3, [r7, #48]	@ 0x30
      ch_bits[2] = out_bits[2];
34019424:	69fb      	ldr	r3, [r7, #28]
34019426:	637b      	str	r3, [r7, #52]	@ 0x34
        ch_bits[0] = out_bits[1];
      } // N.B. the DMA stuffs the bits to the left of the channel
      else
        ch_bits[0] = out_bits[0];
    }
    break;
34019428:	e013      	b.n	34019452 <LL_Streng_TensorInit+0x336>
      if (nbits_in > 16)
3401942a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401942c:	2b10      	cmp	r3, #16
3401942e:	dd06      	ble.n	3401943e <LL_Streng_TensorInit+0x322>
        ch_bits[2] = out_bits[0];
34019430:	697b      	ldr	r3, [r7, #20]
34019432:	637b      	str	r3, [r7, #52]	@ 0x34
        ch_bits[1] = out_bits[1];
34019434:	69bb      	ldr	r3, [r7, #24]
34019436:	633b      	str	r3, [r7, #48]	@ 0x30
        ch_bits[0] = out_bits[2];
34019438:	69fb      	ldr	r3, [r7, #28]
3401943a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
3401943c:	e009      	b.n	34019452 <LL_Streng_TensorInit+0x336>
      else if (nbits_in > 8)
3401943e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34019440:	2b08      	cmp	r3, #8
34019442:	dd04      	ble.n	3401944e <LL_Streng_TensorInit+0x332>
        ch_bits[1] = out_bits[0];
34019444:	697b      	ldr	r3, [r7, #20]
34019446:	633b      	str	r3, [r7, #48]	@ 0x30
        ch_bits[0] = out_bits[1];
34019448:	69bb      	ldr	r3, [r7, #24]
3401944a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
3401944c:	e001      	b.n	34019452 <LL_Streng_TensorInit+0x336>
        ch_bits[0] = out_bits[0];
3401944e:	697b      	ldr	r3, [r7, #20]
34019450:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34019452:	bf00      	nop
  }

/* Take care of N64 single size register. TODO: double check this  */
#ifdef ATON_STRENG_CTRL_SET_SIZE1
  t = ATON_STRENG_CTRL_SET_SIZE0(t, ch_bits[0]);
34019454:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019456:	f423 2270 	bic.w	r2, r3, #983040	@ 0xf0000
3401945a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401945c:	041b      	lsls	r3, r3, #16
3401945e:	f403 2370 	and.w	r3, r3, #983040	@ 0xf0000
34019462:	4313      	orrs	r3, r2
34019464:	657b      	str	r3, [r7, #84]	@ 0x54
  t = ATON_STRENG_CTRL_SET_SIZE1(t, ch_bits[1]);
34019466:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019468:	f423 0270 	bic.w	r2, r3, #15728640	@ 0xf00000
3401946c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3401946e:	051b      	lsls	r3, r3, #20
34019470:	f403 0370 	and.w	r3, r3, #15728640	@ 0xf00000
34019474:	4313      	orrs	r3, r2
34019476:	657b      	str	r3, [r7, #84]	@ 0x54
  t = ATON_STRENG_CTRL_SET_SIZE2(t, ch_bits[2]);
34019478:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401947a:	f023 6270 	bic.w	r2, r3, #251658240	@ 0xf000000
3401947e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34019480:	061b      	lsls	r3, r3, #24
34019482:	f003 6370 	and.w	r3, r3, #251658240	@ 0xf000000
34019486:	4313      	orrs	r3, r2
34019488:	657b      	str	r3, [r7, #84]	@ 0x54
    t = ATON_STRENG_CTRL_SET_SIZE0(t, conf->nbits_out);
  else
    t = ATON_STRENG_CTRL_SET_SIZE0(t, conf->nbits_in);
#endif

  ATON_STRENG_CTRL_SET(id, t);
3401948a:	68fb      	ldr	r3, [r7, #12]
3401948c:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34019490:	33e5      	adds	r3, #229	@ 0xe5
34019492:	031b      	lsls	r3, r3, #12
34019494:	461a      	mov	r2, r3
34019496:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019498:	6013      	str	r3, [r2, #0]

  // ATON_STRENG_ADDR_SET(id, conf->addr_start.i);
  ATON_REG_WRITE_RELOC(((volatile uint32_t *)(uintptr_t)ATON_STRENG_ADDR_ADDR(id)), conf->addr_base.i,
3401949a:	68bb      	ldr	r3, [r7, #8]
3401949c:	6859      	ldr	r1, [r3, #4]
3401949e:	68bb      	ldr	r3, [r7, #8]
340194a0:	689a      	ldr	r2, [r3, #8]
340194a2:	68fb      	ldr	r3, [r7, #12]
340194a4:	0318      	lsls	r0, r3, #12
340194a6:	4b2a      	ldr	r3, [pc, #168]	@ (34019550 <LL_Streng_TensorInit+0x434>)
340194a8:	4403      	add	r3, r0
340194aa:	4618      	mov	r0, r3
340194ac:	188b      	adds	r3, r1, r2
340194ae:	6003      	str	r3, [r0, #0]
                       conf->offset_start);

  if (conf->raw)
340194b0:	68bb      	ldr	r3, [r7, #8]
340194b2:	781b      	ldrb	r3, [r3, #0]
340194b4:	f003 0302 	and.w	r3, r3, #2
340194b8:	b2db      	uxtb	r3, r3
340194ba:	2b00      	cmp	r3, #0
340194bc:	d025      	beq.n	3401950a <LL_Streng_TensorInit+0x3ee>
  {
    if (conf->frame_count)
340194be:	68bb      	ldr	r3, [r7, #8]
340194c0:	695b      	ldr	r3, [r3, #20]
340194c2:	2b00      	cmp	r3, #0
340194c4:	d003      	beq.n	340194ce <LL_Streng_TensorInit+0x3b2>
      t = conf->frame_count;
340194c6:	68bb      	ldr	r3, [r7, #8]
340194c8:	695b      	ldr	r3, [r3, #20]
340194ca:	657b      	str	r3, [r7, #84]	@ 0x54
340194cc:	e015      	b.n	340194fa <LL_Streng_TensorInit+0x3de>
    else
    {
      // N.B. end - start must contain padding if nbits_in is not power of two
      t = (LL_Streng_len(conf) * 8) / (conf->dir == 0 ? conf->nbits_in : conf->nbits_out);
340194ce:	68b8      	ldr	r0, [r7, #8]
340194d0:	f7fe ff20 	bl	34018314 <LL_Streng_len>
340194d4:	4603      	mov	r3, r0
340194d6:	00db      	lsls	r3, r3, #3
340194d8:	68ba      	ldr	r2, [r7, #8]
340194da:	7812      	ldrb	r2, [r2, #0]
340194dc:	f3c2 0200 	ubfx	r2, r2, #0, #1
340194e0:	b2d2      	uxtb	r2, r2
340194e2:	2a00      	cmp	r2, #0
340194e4:	d003      	beq.n	340194ee <LL_Streng_TensorInit+0x3d2>
340194e6:	68ba      	ldr	r2, [r7, #8]
340194e8:	f892 203d 	ldrb.w	r2, [r2, #61]	@ 0x3d
340194ec:	e002      	b.n	340194f4 <LL_Streng_TensorInit+0x3d8>
340194ee:	68ba      	ldr	r2, [r7, #8]
340194f0:	f892 203c 	ldrb.w	r2, [r2, #60]	@ 0x3c
340194f4:	fbb3 f3f2 	udiv	r3, r3, r2
340194f8:	657b      	str	r3, [r7, #84]	@ 0x54
    }
    ATON_STRENG_FSIZE_SET(id, t);
340194fa:	68fb      	ldr	r3, [r7, #12]
340194fc:	031a      	lsls	r2, r3, #12
340194fe:	4b15      	ldr	r3, [pc, #84]	@ (34019554 <LL_Streng_TensorInit+0x438>)
34019500:	4413      	add	r3, r2
34019502:	461a      	mov	r2, r3
34019504:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019506:	6013      	str	r3, [r2, #0]
34019508:	e053      	b.n	340195b2 <LL_Streng_TensorInit+0x496>
  }
  else
  {
    t = ATON_STRENG_FSIZE_DT;
3401950a:	2300      	movs	r3, #0
3401950c:	657b      	str	r3, [r7, #84]	@ 0x54
    t = ATON_STRENG_FSIZE_SET_WIDTH(t, conf->fwidth);
3401950e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019510:	0c1b      	lsrs	r3, r3, #16
34019512:	041b      	lsls	r3, r3, #16
34019514:	68ba      	ldr	r2, [r7, #8]
34019516:	6992      	ldr	r2, [r2, #24]
34019518:	b292      	uxth	r2, r2
3401951a:	4313      	orrs	r3, r2
3401951c:	657b      	str	r3, [r7, #84]	@ 0x54
    t = ATON_STRENG_FSIZE_SET_HEIGHT(t, conf->fheight);
3401951e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019520:	b29a      	uxth	r2, r3
34019522:	68bb      	ldr	r3, [r7, #8]
34019524:	69db      	ldr	r3, [r3, #28]
34019526:	041b      	lsls	r3, r3, #16
34019528:	4313      	orrs	r3, r2
3401952a:	657b      	str	r3, [r7, #84]	@ 0x54
    ATON_STRENG_FSIZE_SET(id, t);
3401952c:	68fb      	ldr	r3, [r7, #12]
3401952e:	031a      	lsls	r2, r3, #12
34019530:	4b08      	ldr	r3, [pc, #32]	@ (34019554 <LL_Streng_TensorInit+0x438>)
34019532:	4413      	add	r3, r2
34019534:	461a      	mov	r2, r3
34019536:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019538:	6013      	str	r3, [r2, #0]

    uint32_t line_offset = conf->line_offset == 0 ? conf->fwidth * conf->batch_offset : conf->line_offset;
3401953a:	68bb      	ldr	r3, [r7, #8]
3401953c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401953e:	2b00      	cmp	r3, #0
34019540:	d10a      	bne.n	34019558 <LL_Streng_TensorInit+0x43c>
34019542:	68bb      	ldr	r3, [r7, #8]
34019544:	699b      	ldr	r3, [r3, #24]
34019546:	68ba      	ldr	r2, [r7, #8]
34019548:	6a52      	ldr	r2, [r2, #36]	@ 0x24
3401954a:	fb02 f303 	mul.w	r3, r2, r3
3401954e:	e005      	b.n	3401955c <LL_Streng_TensorInit+0x440>
34019550:	580e5008 	.word	0x580e5008
34019554:	580e500c 	.word	0x580e500c
34019558:	68bb      	ldr	r3, [r7, #8]
3401955a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401955c:	63bb      	str	r3, [r7, #56]	@ 0x38
    // if line_offset is left=0 then it's computed from the standard geometry of lines and batch
    t_streng_strd = ATON_STRENG_STRD_SET_LOFF(t_streng_strd, line_offset);
3401955e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34019560:	0c1b      	lsrs	r3, r3, #16
34019562:	041b      	lsls	r3, r3, #16
34019564:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34019566:	b292      	uxth	r2, r2
34019568:	4313      	orrs	r3, r2
3401956a:	653b      	str	r3, [r7, #80]	@ 0x50

#if defined(ATON_STRENG_CID_CACHE_SET_LOFF_MSB)
    t = t_streng_cid_cache;
3401956c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401956e:	657b      	str	r3, [r7, #84]	@ 0x54
    t = ATON_STRENG_CID_CACHE_SET_LOFF_MSB(t, (line_offset >> ATON_STRENG_STRD_LOFF_W));
34019570:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019572:	b29a      	uxth	r2, r3
34019574:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34019576:	0c1b      	lsrs	r3, r3, #16
34019578:	041b      	lsls	r3, r3, #16
3401957a:	4313      	orrs	r3, r2
3401957c:	657b      	str	r3, [r7, #84]	@ 0x54
    t_streng_cid_cache = t;
3401957e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019580:	64fb      	str	r3, [r7, #76]	@ 0x4c
#endif

    t = ATON_STRENG_DEPTH_DT;
34019582:	2300      	movs	r3, #0
34019584:	657b      	str	r3, [r7, #84]	@ 0x54
    t = ATON_STRENG_DEPTH_SET_SIZE(t, conf->batch_depth);
34019586:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019588:	0c1b      	lsrs	r3, r3, #16
3401958a:	041b      	lsls	r3, r3, #16
3401958c:	68ba      	ldr	r2, [r7, #8]
3401958e:	6a12      	ldr	r2, [r2, #32]
34019590:	b292      	uxth	r2, r2
34019592:	4313      	orrs	r3, r2
34019594:	657b      	str	r3, [r7, #84]	@ 0x54
    t = ATON_STRENG_DEPTH_SET_OFFSET(t, conf->batch_offset);
34019596:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019598:	b29a      	uxth	r2, r3
3401959a:	68bb      	ldr	r3, [r7, #8]
3401959c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401959e:	041b      	lsls	r3, r3, #16
340195a0:	4313      	orrs	r3, r2
340195a2:	657b      	str	r3, [r7, #84]	@ 0x54
    ATON_STRENG_DEPTH_SET(id, t);
340195a4:	68fb      	ldr	r3, [r7, #12]
340195a6:	031a      	lsls	r2, r3, #12
340195a8:	4b89      	ldr	r3, [pc, #548]	@ (340197d0 <LL_Streng_TensorInit+0x6b4>)
340195aa:	4413      	add	r3, r2
340195ac:	461a      	mov	r2, r3
340195ae:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
340195b0:	6013      	str	r3, [r2, #0]
  }

  ATON_STRENG_FRPTOFF_SET(id, conf->loop_offset);
340195b2:	68fb      	ldr	r3, [r7, #12]
340195b4:	031a      	lsls	r2, r3, #12
340195b6:	4b87      	ldr	r3, [pc, #540]	@ (340197d4 <LL_Streng_TensorInit+0x6b8>)
340195b8:	4413      	add	r3, r2
340195ba:	461a      	mov	r2, r3
340195bc:	68bb      	ldr	r3, [r7, #8]
340195be:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
340195c0:	6013      	str	r3, [r2, #0]
  ATON_STRENG_FRAME_RPT_SET(id, conf->frame_loop_cnt);
340195c2:	68fb      	ldr	r3, [r7, #12]
340195c4:	031a      	lsls	r2, r3, #12
340195c6:	4b84      	ldr	r3, [pc, #528]	@ (340197d8 <LL_Streng_TensorInit+0x6bc>)
340195c8:	4413      	add	r3, r2
340195ca:	461a      	mov	r2, r3
340195cc:	68bb      	ldr	r3, [r7, #8]
340195ce:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
340195d0:	6013      	str	r3, [r2, #0]
  ATON_STRENG_FOFFSET_SET(id, conf->frame_offset);
340195d2:	68fb      	ldr	r3, [r7, #12]
340195d4:	031a      	lsls	r2, r3, #12
340195d6:	4b81      	ldr	r3, [pc, #516]	@ (340197dc <LL_Streng_TensorInit+0x6c0>)
340195d8:	4413      	add	r3, r2
340195da:	461a      	mov	r2, r3
340195dc:	68bb      	ldr	r3, [r7, #8]
340195de:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
340195e0:	6013      	str	r3, [r2, #0]

  t = ATON_STRENG_LIMITEN_DT; // all other fields set to zero
340195e2:	2302      	movs	r3, #2
340195e4:	657b      	str	r3, [r7, #84]	@ 0x54
  t = ATON_STRENG_LIMITEN_SET_FRAMELIMIT(t, 1);
340195e6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
340195e8:	f043 0304 	orr.w	r3, r3, #4
340195ec:	657b      	str	r3, [r7, #84]	@ 0x54
#if defined(ATON_STRENG_LIMITEN_SET_DOFF_MSB)
  t = ATON_STRENG_LIMITEN_SET_DOFF_MSB(t, conf->batch_offset >> ATON_STRENG_DEPTH_OFFSET_W);
340195ee:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
340195f0:	b29a      	uxth	r2, r3
340195f2:	68bb      	ldr	r3, [r7, #8]
340195f4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340195f6:	0c1b      	lsrs	r3, r3, #16
340195f8:	041b      	lsls	r3, r3, #16
340195fa:	4313      	orrs	r3, r2
340195fc:	657b      	str	r3, [r7, #84]	@ 0x54
#endif
  ATON_STRENG_LIMITEN_SET(id, t);
340195fe:	68fb      	ldr	r3, [r7, #12]
34019600:	031a      	lsls	r2, r3, #12
34019602:	4b77      	ldr	r3, [pc, #476]	@ (340197e0 <LL_Streng_TensorInit+0x6c4>)
34019604:	4413      	add	r3, r2
34019606:	461a      	mov	r2, r3
34019608:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401960a:	6013      	str	r3, [r2, #0]

  if (/*(conf->dir == 0) && */ (conf->offset_limit != 0x0))
3401960c:	68bb      	ldr	r3, [r7, #8]
3401960e:	691b      	ldr	r3, [r3, #16]
34019610:	2b00      	cmp	r3, #0
34019612:	d01a      	beq.n	3401964a <LL_Streng_TensorInit+0x52e>
  {
    t = ATON_STRENG_LIMITEN_SET_ADDRLIMIT(t, 1);
34019614:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019616:	f043 0301 	orr.w	r3, r3, #1
3401961a:	657b      	str	r3, [r7, #84]	@ 0x54
    t = ATON_STRENG_LIMITEN_SET_STOPPREFTC(t, 1);
3401961c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401961e:	f043 0302 	orr.w	r3, r3, #2
34019622:	657b      	str	r3, [r7, #84]	@ 0x54
    ATON_STRENG_LIMITEN_SET(id, t);
34019624:	68fb      	ldr	r3, [r7, #12]
34019626:	031a      	lsls	r2, r3, #12
34019628:	4b6d      	ldr	r3, [pc, #436]	@ (340197e0 <LL_Streng_TensorInit+0x6c4>)
3401962a:	4413      	add	r3, r2
3401962c:	461a      	mov	r2, r3
3401962e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019630:	6013      	str	r3, [r2, #0]
    // NOTE: limiter is to be set to last accessible byte address
    // ATON_STRENG_LIMITADDR_SET(id, (conf->addr_limit.i - 1));
    ATON_REG_WRITE_RELOC(((volatile uint32_t *)(uintptr_t)ATON_STRENG_LIMITADDR_ADDR(id)), conf->addr_base.i,
34019632:	68bb      	ldr	r3, [r7, #8]
34019634:	685a      	ldr	r2, [r3, #4]
34019636:	68bb      	ldr	r3, [r7, #8]
34019638:	691b      	ldr	r3, [r3, #16]
3401963a:	441a      	add	r2, r3
3401963c:	68fb      	ldr	r3, [r7, #12]
3401963e:	0319      	lsls	r1, r3, #12
34019640:	4b68      	ldr	r3, [pc, #416]	@ (340197e4 <LL_Streng_TensorInit+0x6c8>)
34019642:	440b      	add	r3, r1
34019644:	4619      	mov	r1, r3
34019646:	1e53      	subs	r3, r2, #1
34019648:	600b      	str	r3, [r1, #0]
                         conf->offset_limit - 1);
  }

  ATON_STRENG_LIMIT_SET(id, conf->frame_tot_cnt);
3401964a:	68fb      	ldr	r3, [r7, #12]
3401964c:	031a      	lsls	r2, r3, #12
3401964e:	4b66      	ldr	r3, [pc, #408]	@ (340197e8 <LL_Streng_TensorInit+0x6cc>)
34019650:	4413      	add	r3, r2
34019652:	461a      	mov	r2, r3
34019654:	68bb      	ldr	r3, [r7, #8]
34019656:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34019658:	6013      	str	r3, [r2, #0]
  // LL_ATON_PRINTF("frame_tot_cnt=%d\n", conf->frame_tot_cnt);

#if defined(ATON_STRENG_CID_CACHE_SET_CID)
  t_streng_cid_cache = ATON_STRENG_CID_CACHE_SET_CID(t_streng_cid_cache, conf->bus_cid);
3401965a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401965c:	f023 0307 	bic.w	r3, r3, #7
34019660:	68ba      	ldr	r2, [r7, #8]
34019662:	7852      	ldrb	r2, [r2, #1]
34019664:	f3c2 0282 	ubfx	r2, r2, #2, #3
34019668:	b2d2      	uxtb	r2, r2
3401966a:	4313      	orrs	r3, r2
3401966c:	64fb      	str	r3, [r7, #76]	@ 0x4c
  t_streng_cid_cache = ATON_STRENG_CID_CACHE_SET_CACHEABLE(t_streng_cid_cache, conf->cacheable);
3401966e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34019670:	f023 0208 	bic.w	r2, r3, #8
34019674:	68bb      	ldr	r3, [r7, #8]
34019676:	785b      	ldrb	r3, [r3, #1]
34019678:	f3c3 1340 	ubfx	r3, r3, #5, #1
3401967c:	b2db      	uxtb	r3, r3
3401967e:	00db      	lsls	r3, r3, #3
34019680:	f003 0308 	and.w	r3, r3, #8
34019684:	4313      	orrs	r3, r2
34019686:	64fb      	str	r3, [r7, #76]	@ 0x4c
  t_streng_cid_cache = ATON_STRENG_CID_CACHE_SET_ALLOC(t_streng_cid_cache, conf->cache_allocate);
34019688:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401968a:	f023 0210 	bic.w	r2, r3, #16
3401968e:	68bb      	ldr	r3, [r7, #8]
34019690:	785b      	ldrb	r3, [r3, #1]
34019692:	f3c3 1380 	ubfx	r3, r3, #6, #1
34019696:	b2db      	uxtb	r3, r3
34019698:	011b      	lsls	r3, r3, #4
3401969a:	f003 0310 	and.w	r3, r3, #16
3401969e:	4313      	orrs	r3, r2
340196a0:	64fb      	str	r3, [r7, #76]	@ 0x4c
  t_streng_cid_cache = ATON_STRENG_CID_CACHE_SET_PFETCH(t_streng_cid_cache, conf->bus_pfetch);
340196a2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
340196a4:	f023 0220 	bic.w	r2, r3, #32
340196a8:	68bb      	ldr	r3, [r7, #8]
340196aa:	785b      	ldrb	r3, [r3, #1]
340196ac:	f3c3 13c0 	ubfx	r3, r3, #7, #1
340196b0:	b2db      	uxtb	r3, r3
340196b2:	015b      	lsls	r3, r3, #5
340196b4:	f003 0320 	and.w	r3, r3, #32
340196b8:	4313      	orrs	r3, r2
340196ba:	64fb      	str	r3, [r7, #76]	@ 0x4c
  t_streng_cid_cache = ATON_STRENG_CID_CACHE_SET_LINESIZE(t_streng_cid_cache, conf->cache_linesize);
340196bc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
340196be:	f023 02c0 	bic.w	r2, r3, #192	@ 0xc0
340196c2:	68bb      	ldr	r3, [r7, #8]
340196c4:	789b      	ldrb	r3, [r3, #2]
340196c6:	f3c3 0301 	ubfx	r3, r3, #0, #2
340196ca:	b2db      	uxtb	r3, r3
340196cc:	019b      	lsls	r3, r3, #6
340196ce:	b2db      	uxtb	r3, r3
340196d0:	4313      	orrs	r3, r2
340196d2:	64fb      	str	r3, [r7, #76]	@ 0x4c
#endif

  /* Enable event interrupts */
  if (conf->dir == 1)
340196d4:	68bb      	ldr	r3, [r7, #8]
340196d6:	781b      	ldrb	r3, [r3, #0]
340196d8:	f003 0301 	and.w	r3, r3, #1
340196dc:	b2db      	uxtb	r3, r3
340196de:	2b00      	cmp	r3, #0
340196e0:	d005      	beq.n	340196ee <LL_Streng_TensorInit+0x5d2>
  {
#if LL_ATON_EN_EVENT_IRQ
    t_streng_event = 0;
340196e2:	2300      	movs	r3, #0
340196e4:	64bb      	str	r3, [r7, #72]	@ 0x48
    t_streng_event = ATON_STRENG_EVENT_SET_EN_OFLOW_FRM(t_streng_event, 1); // enable frame overflow interrupt
340196e6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
340196e8:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
340196ec:	64bb      	str	r3, [r7, #72]	@ 0x48
#endif // LL_ATON_EN_EVENT_IRQ
  }

  /* Enable illegal configuration interrupts */
#if LL_ATON_EN_ERROR_IRQ
  t = t_streng_event;
340196ee:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
340196f0:	657b      	str	r3, [r7, #84]	@ 0x54
  t = ATON_STRENG_EVENT_SET_EN_ILLCFG(t, 1); // Enable Illegal Configuration interrupt
340196f2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
340196f4:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
340196f8:	657b      	str	r3, [r7, #84]	@ 0x54
  // t = ATON_STRENG_EVENT_SET_EN_FMTMM(t, 1); // Enable Format Mismatch interrupt (intentionally not enabled)
  t_streng_event = t;
340196fa:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
340196fc:	64bb      	str	r3, [r7, #72]	@ 0x48
#endif // LL_ATON_EN_ERROR_IRQ

  if ((conf->dir == 0) && conf->sync_with_other)
340196fe:	68bb      	ldr	r3, [r7, #8]
34019700:	781b      	ldrb	r3, [r3, #0]
34019702:	f003 0301 	and.w	r3, r3, #1
34019706:	b2db      	uxtb	r3, r3
34019708:	2b00      	cmp	r3, #0
3401970a:	d118      	bne.n	3401973e <LL_Streng_TensorInit+0x622>
3401970c:	68bb      	ldr	r3, [r7, #8]
3401970e:	785b      	ldrb	r3, [r3, #1]
34019710:	f003 0301 	and.w	r3, r3, #1
34019714:	b2db      	uxtb	r3, r3
34019716:	2b00      	cmp	r3, #0
34019718:	d011      	beq.n	3401973e <LL_Streng_TensorInit+0x622>
  {
    t = t_streng_event;
3401971a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3401971c:	657b      	str	r3, [r7, #84]	@ 0x54
    t = ATON_STRENG_EVENT_SET_FRMTRG_EN(t, 1);               // Enable synchronizations of frames with other dma
3401971e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019720:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
34019724:	657b      	str	r3, [r7, #84]	@ 0x54
    t = ATON_STRENG_EVENT_SET_FRMTRG_SRC(t, conf->sync_dma); // Enable synchronizations of frames with other dma
34019726:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019728:	f023 52f8 	bic.w	r2, r3, #520093696	@ 0x1f000000
3401972c:	68bb      	ldr	r3, [r7, #8]
3401972e:	78db      	ldrb	r3, [r3, #3]
34019730:	061b      	lsls	r3, r3, #24
34019732:	f003 53f8 	and.w	r3, r3, #520093696	@ 0x1f000000
34019736:	4313      	orrs	r3, r2
34019738:	657b      	str	r3, [r7, #84]	@ 0x54
    t_streng_event = t;
3401973a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401973c:	64bb      	str	r3, [r7, #72]	@ 0x48
  }

#if 1
  t = ATON_STRENG_POS_DT;
3401973e:	4b2b      	ldr	r3, [pc, #172]	@ (340197ec <LL_Streng_TensorInit+0x6d0>)
34019740:	657b      	str	r3, [r7, #84]	@ 0x54
  t = ATON_STRENG_POS_SET_GAPCYCLES(t, 0); // set interline gap cycle to 0, as it should be safe to do so
34019742:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019744:	b29b      	uxth	r3, r3
34019746:	657b      	str	r3, [r7, #84]	@ 0x54
  ATON_STRENG_POS_SET(id, t);
34019748:	68fb      	ldr	r3, [r7, #12]
3401974a:	031a      	lsls	r2, r3, #12
3401974c:	4b28      	ldr	r3, [pc, #160]	@ (340197f0 <LL_Streng_TensorInit+0x6d4>)
3401974e:	4413      	add	r3, r2
34019750:	461a      	mov	r2, r3
34019752:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019754:	6013      	str	r3, [r2, #0]
#endif

  /* deferred register setting */
  ATON_STRENG_STRD_SET(id, t_streng_strd);
34019756:	68fb      	ldr	r3, [r7, #12]
34019758:	031a      	lsls	r2, r3, #12
3401975a:	4b26      	ldr	r3, [pc, #152]	@ (340197f4 <LL_Streng_TensorInit+0x6d8>)
3401975c:	4413      	add	r3, r2
3401975e:	461a      	mov	r2, r3
34019760:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34019762:	6013      	str	r3, [r2, #0]
  ATON_STRENG_CID_CACHE_SET(id, t_streng_cid_cache);
34019764:	68fb      	ldr	r3, [r7, #12]
34019766:	031a      	lsls	r2, r3, #12
34019768:	4b23      	ldr	r3, [pc, #140]	@ (340197f8 <LL_Streng_TensorInit+0x6dc>)
3401976a:	4413      	add	r3, r2
3401976c:	461a      	mov	r2, r3
3401976e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34019770:	6013      	str	r3, [r2, #0]
  ATON_STRENG_EVENT_SET(id, t_streng_event);
34019772:	68fb      	ldr	r3, [r7, #12]
34019774:	031a      	lsls	r2, r3, #12
34019776:	4b21      	ldr	r3, [pc, #132]	@ (340197fc <LL_Streng_TensorInit+0x6e0>)
34019778:	4413      	add	r3, r2
3401977a:	461a      	mov	r2, r3
3401977c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3401977e:	6013      	str	r3, [r2, #0]

  /* Ciphering settings */
#if (ATON_STRENG_VERSION_ENCR_DT == 1)
  t = ATON_STRENG_ENCR_MSB_DT;
34019780:	2300      	movs	r3, #0
34019782:	657b      	str	r3, [r7, #84]	@ 0x54
  t = ATON_STRENG_ENCR_MSB_SET_EN(t, conf->cipher_en);
34019784:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34019786:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
3401978a:	68bb      	ldr	r3, [r7, #8]
3401978c:	789b      	ldrb	r3, [r3, #2]
3401978e:	f3c3 0380 	ubfx	r3, r3, #2, #1
34019792:	b2db      	uxtb	r3, r3
34019794:	031b      	lsls	r3, r3, #12
34019796:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3401979a:	4313      	orrs	r3, r2
3401979c:	657b      	str	r3, [r7, #84]	@ 0x54
  t = ATON_STRENG_ENCR_MSB_SET_KEY_SEL(t, conf->key_sel);
3401979e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
340197a0:	f423 4240 	bic.w	r2, r3, #49152	@ 0xc000
340197a4:	68bb      	ldr	r3, [r7, #8]
340197a6:	789b      	ldrb	r3, [r3, #2]
340197a8:	f3c3 03c0 	ubfx	r3, r3, #3, #1
340197ac:	b2db      	uxtb	r3, r3
340197ae:	039b      	lsls	r3, r3, #14
340197b0:	b29b      	uxth	r3, r3
340197b2:	4313      	orrs	r3, r2
340197b4:	657b      	str	r3, [r7, #84]	@ 0x54
  ATON_STRENG_ENCR_MSB_SET(id, t);
340197b6:	68fb      	ldr	r3, [r7, #12]
340197b8:	031a      	lsls	r2, r3, #12
340197ba:	4b11      	ldr	r3, [pc, #68]	@ (34019800 <LL_Streng_TensorInit+0x6e4>)
340197bc:	4413      	add	r3, r2
340197be:	461a      	mov	r2, r3
340197c0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
340197c2:	6013      	str	r3, [r2, #0]
#endif

  return 0;
340197c4:	2300      	movs	r3, #0
}
340197c6:	4618      	mov	r0, r3
340197c8:	3758      	adds	r7, #88	@ 0x58
340197ca:	46bd      	mov	sp, r7
340197cc:	bd80      	pop	{r7, pc}
340197ce:	bf00      	nop
340197d0:	580e5010 	.word	0x580e5010
340197d4:	580e5020 	.word	0x580e5020
340197d8:	580e501c 	.word	0x580e501c
340197dc:	580e5018 	.word	0x580e5018
340197e0:	580e5030 	.word	0x580e5030
340197e4:	580e5038 	.word	0x580e5038
340197e8:	580e5034 	.word	0x580e5034
340197ec:	00080024 	.word	0x00080024
340197f0:	580e5024 	.word	0x580e5024
340197f4:	580e5014 	.word	0x580e5014
340197f8:	580e5048 	.word	0x580e5048
340197fc:	580e5028 	.word	0x580e5028
34019800:	580e5044 	.word	0x580e5044

34019804 <__atonn_getSrcPortID>:
}
#endif

unsigned __atonn_getSrcPortID(enum SwitchUnitsType sut, unsigned char su_num, enum AccelUnitsType aut,
                              unsigned char au_num, unsigned char port)
{
34019804:	b590      	push	{r4, r7, lr}
34019806:	b083      	sub	sp, #12
34019808:	af00      	add	r7, sp, #0
3401980a:	4604      	mov	r4, r0
3401980c:	4608      	mov	r0, r1
3401980e:	4611      	mov	r1, r2
34019810:	461a      	mov	r2, r3
34019812:	4623      	mov	r3, r4
34019814:	71fb      	strb	r3, [r7, #7]
34019816:	4603      	mov	r3, r0
34019818:	71bb      	strb	r3, [r7, #6]
3401981a:	460b      	mov	r3, r1
3401981c:	717b      	strb	r3, [r7, #5]
3401981e:	4613      	mov	r3, r2
34019820:	713b      	strb	r3, [r7, #4]
  // FIXME
  LL_ATON_ASSERT(su_num == 0);
34019822:	79bb      	ldrb	r3, [r7, #6]
34019824:	2b00      	cmp	r3, #0
34019826:	d006      	beq.n	34019836 <__atonn_getSrcPortID+0x32>
34019828:	4b66      	ldr	r3, [pc, #408]	@ (340199c4 <__atonn_getSrcPortID+0x1c0>)
3401982a:	4a67      	ldr	r2, [pc, #412]	@ (340199c8 <__atonn_getSrcPortID+0x1c4>)
3401982c:	f240 313e 	movw	r1, #830	@ 0x33e
34019830:	4866      	ldr	r0, [pc, #408]	@ (340199cc <__atonn_getSrcPortID+0x1c8>)
34019832:	f001 ffcb 	bl	3401b7cc <__assert_func>
  switch (sut)
34019836:	79fb      	ldrb	r3, [r7, #7]
34019838:	2b02      	cmp	r3, #2
3401983a:	f000 80b6 	beq.w	340199aa <__atonn_getSrcPortID+0x1a6>
3401983e:	2b02      	cmp	r3, #2
34019840:	f300 80ba 	bgt.w	340199b8 <__atonn_getSrcPortID+0x1b4>
34019844:	2b00      	cmp	r3, #0
34019846:	d003      	beq.n	34019850 <__atonn_getSrcPortID+0x4c>
34019848:	2b01      	cmp	r3, #1
3401984a:	f000 80a7 	beq.w	3401999c <__atonn_getSrcPortID+0x198>
3401984e:	e0b3      	b.n	340199b8 <__atonn_getSrcPortID+0x1b4>
  {
  case STRSWITCH:
    switch (aut)
34019850:	797b      	ldrb	r3, [r7, #5]
34019852:	2b06      	cmp	r3, #6
34019854:	f200 809b 	bhi.w	3401998e <__atonn_getSrcPortID+0x18a>
34019858:	a201      	add	r2, pc, #4	@ (adr r2, 34019860 <__atonn_getSrcPortID+0x5c>)
3401985a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3401985e:	bf00      	nop
34019860:	3401987d 	.word	0x3401987d
34019864:	3401998f 	.word	0x3401998f
34019868:	340198a9 	.word	0x340198a9
3401986c:	340198d7 	.word	0x340198d7
34019870:	34019905 	.word	0x34019905
34019874:	34019933 	.word	0x34019933
34019878:	34019961 	.word	0x34019961
    {
#if defined(ATON_STRENG_NUM)
    case STRENG:
      LL_ATON_ASSERT(port == 0);
3401987c:	7e3b      	ldrb	r3, [r7, #24]
3401987e:	2b00      	cmp	r3, #0
34019880:	d006      	beq.n	34019890 <__atonn_getSrcPortID+0x8c>
34019882:	4b53      	ldr	r3, [pc, #332]	@ (340199d0 <__atonn_getSrcPortID+0x1cc>)
34019884:	4a50      	ldr	r2, [pc, #320]	@ (340199c8 <__atonn_getSrcPortID+0x1c4>)
34019886:	f240 3146 	movw	r1, #838	@ 0x346
3401988a:	4850      	ldr	r0, [pc, #320]	@ (340199cc <__atonn_getSrcPortID+0x1c8>)
3401988c:	f001 ff9e 	bl	3401b7cc <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_STRENG_NUM);
34019890:	793b      	ldrb	r3, [r7, #4]
34019892:	2b09      	cmp	r3, #9
34019894:	d906      	bls.n	340198a4 <__atonn_getSrcPortID+0xa0>
34019896:	4b4f      	ldr	r3, [pc, #316]	@ (340199d4 <__atonn_getSrcPortID+0x1d0>)
34019898:	4a4b      	ldr	r2, [pc, #300]	@ (340199c8 <__atonn_getSrcPortID+0x1c4>)
3401989a:	f240 3147 	movw	r1, #839	@ 0x347
3401989e:	484b      	ldr	r0, [pc, #300]	@ (340199cc <__atonn_getSrcPortID+0x1c8>)
340198a0:	f001 ff94 	bl	3401b7cc <__assert_func>
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, STRENG, 0, 0) + au_num;
340198a4:	793b      	ldrb	r3, [r7, #4]
340198a6:	e088      	b.n	340199ba <__atonn_getSrcPortID+0x1b6>
      break;
#endif
#if defined(ATON_CONVACC_NUM)
    case CONVACC:
      LL_ATON_ASSERT(port == 0);
340198a8:	7e3b      	ldrb	r3, [r7, #24]
340198aa:	2b00      	cmp	r3, #0
340198ac:	d006      	beq.n	340198bc <__atonn_getSrcPortID+0xb8>
340198ae:	4b48      	ldr	r3, [pc, #288]	@ (340199d0 <__atonn_getSrcPortID+0x1cc>)
340198b0:	4a45      	ldr	r2, [pc, #276]	@ (340199c8 <__atonn_getSrcPortID+0x1c4>)
340198b2:	f240 314d 	movw	r1, #845	@ 0x34d
340198b6:	4845      	ldr	r0, [pc, #276]	@ (340199cc <__atonn_getSrcPortID+0x1c8>)
340198b8:	f001 ff88 	bl	3401b7cc <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_CONVACC_NUM);
340198bc:	793b      	ldrb	r3, [r7, #4]
340198be:	2b03      	cmp	r3, #3
340198c0:	d906      	bls.n	340198d0 <__atonn_getSrcPortID+0xcc>
340198c2:	4b45      	ldr	r3, [pc, #276]	@ (340199d8 <__atonn_getSrcPortID+0x1d4>)
340198c4:	4a40      	ldr	r2, [pc, #256]	@ (340199c8 <__atonn_getSrcPortID+0x1c4>)
340198c6:	f240 314e 	movw	r1, #846	@ 0x34e
340198ca:	4840      	ldr	r0, [pc, #256]	@ (340199cc <__atonn_getSrcPortID+0x1c8>)
340198cc:	f001 ff7e 	bl	3401b7cc <__assert_func>
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, CONVACC, 0, 0) + au_num;
340198d0:	793b      	ldrb	r3, [r7, #4]
340198d2:	330a      	adds	r3, #10
340198d4:	e071      	b.n	340199ba <__atonn_getSrcPortID+0x1b6>
      break;
#endif
#if defined(ATON_DECUN_NUM)
    case DECUN:
      LL_ATON_ASSERT(port == 0);
340198d6:	7e3b      	ldrb	r3, [r7, #24]
340198d8:	2b00      	cmp	r3, #0
340198da:	d006      	beq.n	340198ea <__atonn_getSrcPortID+0xe6>
340198dc:	4b3c      	ldr	r3, [pc, #240]	@ (340199d0 <__atonn_getSrcPortID+0x1cc>)
340198de:	4a3a      	ldr	r2, [pc, #232]	@ (340199c8 <__atonn_getSrcPortID+0x1c4>)
340198e0:	f44f 7155 	mov.w	r1, #852	@ 0x354
340198e4:	4839      	ldr	r0, [pc, #228]	@ (340199cc <__atonn_getSrcPortID+0x1c8>)
340198e6:	f001 ff71 	bl	3401b7cc <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_DECUN_NUM);
340198ea:	793b      	ldrb	r3, [r7, #4]
340198ec:	2b01      	cmp	r3, #1
340198ee:	d906      	bls.n	340198fe <__atonn_getSrcPortID+0xfa>
340198f0:	4b3a      	ldr	r3, [pc, #232]	@ (340199dc <__atonn_getSrcPortID+0x1d8>)
340198f2:	4a35      	ldr	r2, [pc, #212]	@ (340199c8 <__atonn_getSrcPortID+0x1c4>)
340198f4:	f240 3155 	movw	r1, #853	@ 0x355
340198f8:	4834      	ldr	r0, [pc, #208]	@ (340199cc <__atonn_getSrcPortID+0x1c8>)
340198fa:	f001 ff67 	bl	3401b7cc <__assert_func>
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, DECUN, 0, 0) + au_num;
340198fe:	793b      	ldrb	r3, [r7, #4]
34019900:	330e      	adds	r3, #14
34019902:	e05a      	b.n	340199ba <__atonn_getSrcPortID+0x1b6>
      break;
#endif
#if defined(ATON_ACTIV_NUM)
    case ACTIV:
      LL_ATON_ASSERT(port == 0);
34019904:	7e3b      	ldrb	r3, [r7, #24]
34019906:	2b00      	cmp	r3, #0
34019908:	d006      	beq.n	34019918 <__atonn_getSrcPortID+0x114>
3401990a:	4b31      	ldr	r3, [pc, #196]	@ (340199d0 <__atonn_getSrcPortID+0x1cc>)
3401990c:	4a2e      	ldr	r2, [pc, #184]	@ (340199c8 <__atonn_getSrcPortID+0x1c4>)
3401990e:	f240 315b 	movw	r1, #859	@ 0x35b
34019912:	482e      	ldr	r0, [pc, #184]	@ (340199cc <__atonn_getSrcPortID+0x1c8>)
34019914:	f001 ff5a 	bl	3401b7cc <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_ACTIV_NUM);
34019918:	793b      	ldrb	r3, [r7, #4]
3401991a:	2b01      	cmp	r3, #1
3401991c:	d906      	bls.n	3401992c <__atonn_getSrcPortID+0x128>
3401991e:	4b2f      	ldr	r3, [pc, #188]	@ (340199dc <__atonn_getSrcPortID+0x1d8>)
34019920:	4a29      	ldr	r2, [pc, #164]	@ (340199c8 <__atonn_getSrcPortID+0x1c4>)
34019922:	f44f 7157 	mov.w	r1, #860	@ 0x35c
34019926:	4829      	ldr	r0, [pc, #164]	@ (340199cc <__atonn_getSrcPortID+0x1c8>)
34019928:	f001 ff50 	bl	3401b7cc <__assert_func>
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, ACTIV, 0, 0) + au_num;
3401992c:	793b      	ldrb	r3, [r7, #4]
3401992e:	3310      	adds	r3, #16
34019930:	e043      	b.n	340199ba <__atonn_getSrcPortID+0x1b6>
      break;
#endif
#if defined(ATON_ARITH_NUM)
    case ARITH:
      LL_ATON_ASSERT(port == 0);
34019932:	7e3b      	ldrb	r3, [r7, #24]
34019934:	2b00      	cmp	r3, #0
34019936:	d006      	beq.n	34019946 <__atonn_getSrcPortID+0x142>
34019938:	4b25      	ldr	r3, [pc, #148]	@ (340199d0 <__atonn_getSrcPortID+0x1cc>)
3401993a:	4a23      	ldr	r2, [pc, #140]	@ (340199c8 <__atonn_getSrcPortID+0x1c4>)
3401993c:	f240 3162 	movw	r1, #866	@ 0x362
34019940:	4822      	ldr	r0, [pc, #136]	@ (340199cc <__atonn_getSrcPortID+0x1c8>)
34019942:	f001 ff43 	bl	3401b7cc <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_ARITH_NUM);
34019946:	793b      	ldrb	r3, [r7, #4]
34019948:	2b03      	cmp	r3, #3
3401994a:	d906      	bls.n	3401995a <__atonn_getSrcPortID+0x156>
3401994c:	4b22      	ldr	r3, [pc, #136]	@ (340199d8 <__atonn_getSrcPortID+0x1d4>)
3401994e:	4a1e      	ldr	r2, [pc, #120]	@ (340199c8 <__atonn_getSrcPortID+0x1c4>)
34019950:	f240 3163 	movw	r1, #867	@ 0x363
34019954:	481d      	ldr	r0, [pc, #116]	@ (340199cc <__atonn_getSrcPortID+0x1c8>)
34019956:	f001 ff39 	bl	3401b7cc <__assert_func>
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, ARITH, 0, 0) + au_num;
3401995a:	793b      	ldrb	r3, [r7, #4]
3401995c:	3312      	adds	r3, #18
3401995e:	e02c      	b.n	340199ba <__atonn_getSrcPortID+0x1b6>
      break;
#endif
#if defined(ATON_POOL_NUM)
    case POOL:
      LL_ATON_ASSERT(port == 0);
34019960:	7e3b      	ldrb	r3, [r7, #24]
34019962:	2b00      	cmp	r3, #0
34019964:	d006      	beq.n	34019974 <__atonn_getSrcPortID+0x170>
34019966:	4b1a      	ldr	r3, [pc, #104]	@ (340199d0 <__atonn_getSrcPortID+0x1cc>)
34019968:	4a17      	ldr	r2, [pc, #92]	@ (340199c8 <__atonn_getSrcPortID+0x1c4>)
3401996a:	f240 3169 	movw	r1, #873	@ 0x369
3401996e:	4817      	ldr	r0, [pc, #92]	@ (340199cc <__atonn_getSrcPortID+0x1c8>)
34019970:	f001 ff2c 	bl	3401b7cc <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_POOL_NUM);
34019974:	793b      	ldrb	r3, [r7, #4]
34019976:	2b01      	cmp	r3, #1
34019978:	d906      	bls.n	34019988 <__atonn_getSrcPortID+0x184>
3401997a:	4b18      	ldr	r3, [pc, #96]	@ (340199dc <__atonn_getSrcPortID+0x1d8>)
3401997c:	4a12      	ldr	r2, [pc, #72]	@ (340199c8 <__atonn_getSrcPortID+0x1c4>)
3401997e:	f240 316a 	movw	r1, #874	@ 0x36a
34019982:	4812      	ldr	r0, [pc, #72]	@ (340199cc <__atonn_getSrcPortID+0x1c8>)
34019984:	f001 ff22 	bl	3401b7cc <__assert_func>
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, POOL, 0, 0) + au_num;
34019988:	793b      	ldrb	r3, [r7, #4]
3401998a:	3316      	adds	r3, #22
3401998c:	e015      	b.n	340199ba <__atonn_getSrcPortID+0x1b6>
      break;
#endif
    default:
      LL_ATON_ASSERT(0);
3401998e:	4b14      	ldr	r3, [pc, #80]	@ (340199e0 <__atonn_getSrcPortID+0x1dc>)
34019990:	4a0d      	ldr	r2, [pc, #52]	@ (340199c8 <__atonn_getSrcPortID+0x1c4>)
34019992:	f240 316f 	movw	r1, #879	@ 0x36f
34019996:	480d      	ldr	r0, [pc, #52]	@ (340199cc <__atonn_getSrcPortID+0x1c8>)
34019998:	f001 ff18 	bl	3401b7cc <__assert_func>
      break;
    }
    break;
  case STRSWITCH64:
    // TODO
    LL_ATON_ASSERT(0);
3401999c:	4b10      	ldr	r3, [pc, #64]	@ (340199e0 <__atonn_getSrcPortID+0x1dc>)
3401999e:	4a0a      	ldr	r2, [pc, #40]	@ (340199c8 <__atonn_getSrcPortID+0x1c4>)
340199a0:	f240 3175 	movw	r1, #885	@ 0x375
340199a4:	4809      	ldr	r0, [pc, #36]	@ (340199cc <__atonn_getSrcPortID+0x1c8>)
340199a6:	f001 ff11 	bl	3401b7cc <__assert_func>
    break;
  case STRSWITCH_VC:
    // TODO
    LL_ATON_ASSERT(0);
340199aa:	4b0d      	ldr	r3, [pc, #52]	@ (340199e0 <__atonn_getSrcPortID+0x1dc>)
340199ac:	4a06      	ldr	r2, [pc, #24]	@ (340199c8 <__atonn_getSrcPortID+0x1c4>)
340199ae:	f240 3179 	movw	r1, #889	@ 0x379
340199b2:	4806      	ldr	r0, [pc, #24]	@ (340199cc <__atonn_getSrcPortID+0x1c8>)
340199b4:	f001 ff0a 	bl	3401b7cc <__assert_func>
    break;
  }
  return 0;
340199b8:	2300      	movs	r3, #0
}
340199ba:	4618      	mov	r0, r3
340199bc:	370c      	adds	r7, #12
340199be:	46bd      	mov	sp, r7
340199c0:	bd90      	pop	{r4, r7, pc}
340199c2:	bf00      	nop
340199c4:	3401f478 	.word	0x3401f478
340199c8:	34020014 	.word	0x34020014
340199cc:	3401f224 	.word	0x3401f224
340199d0:	3401f484 	.word	0x3401f484
340199d4:	3401f490 	.word	0x3401f490
340199d8:	3401f49c 	.word	0x3401f49c
340199dc:	3401f4a8 	.word	0x3401f4a8
340199e0:	3401f3fc 	.word	0x3401f3fc

340199e4 <__atonn_getDstPortID>:

unsigned __atonn_getDstPortID(enum SwitchUnitsType sut, unsigned char su_num, enum AccelUnitsType aut,
                              unsigned char au_num, unsigned char port)
{
340199e4:	b590      	push	{r4, r7, lr}
340199e6:	b083      	sub	sp, #12
340199e8:	af00      	add	r7, sp, #0
340199ea:	4604      	mov	r4, r0
340199ec:	4608      	mov	r0, r1
340199ee:	4611      	mov	r1, r2
340199f0:	461a      	mov	r2, r3
340199f2:	4623      	mov	r3, r4
340199f4:	71fb      	strb	r3, [r7, #7]
340199f6:	4603      	mov	r3, r0
340199f8:	71bb      	strb	r3, [r7, #6]
340199fa:	460b      	mov	r3, r1
340199fc:	717b      	strb	r3, [r7, #5]
340199fe:	4613      	mov	r3, r2
34019a00:	713b      	strb	r3, [r7, #4]
  // FIXME
  LL_ATON_ASSERT(su_num == 0);
34019a02:	79bb      	ldrb	r3, [r7, #6]
34019a04:	2b00      	cmp	r3, #0
34019a06:	d006      	beq.n	34019a16 <__atonn_getDstPortID+0x32>
34019a08:	4b6f      	ldr	r3, [pc, #444]	@ (34019bc8 <__atonn_getDstPortID+0x1e4>)
34019a0a:	4a70      	ldr	r2, [pc, #448]	@ (34019bcc <__atonn_getDstPortID+0x1e8>)
34019a0c:	f240 3183 	movw	r1, #899	@ 0x383
34019a10:	486f      	ldr	r0, [pc, #444]	@ (34019bd0 <__atonn_getDstPortID+0x1ec>)
34019a12:	f001 fedb 	bl	3401b7cc <__assert_func>
  switch (sut)
34019a16:	79fb      	ldrb	r3, [r7, #7]
34019a18:	2b02      	cmp	r3, #2
34019a1a:	f000 80c8 	beq.w	34019bae <__atonn_getDstPortID+0x1ca>
34019a1e:	2b02      	cmp	r3, #2
34019a20:	f300 80cc 	bgt.w	34019bbc <__atonn_getDstPortID+0x1d8>
34019a24:	2b00      	cmp	r3, #0
34019a26:	d003      	beq.n	34019a30 <__atonn_getDstPortID+0x4c>
34019a28:	2b01      	cmp	r3, #1
34019a2a:	f000 80b9 	beq.w	34019ba0 <__atonn_getDstPortID+0x1bc>
34019a2e:	e0c5      	b.n	34019bbc <__atonn_getDstPortID+0x1d8>
  {
  case STRSWITCH:
    switch (aut)
34019a30:	797b      	ldrb	r3, [r7, #5]
34019a32:	2b06      	cmp	r3, #6
34019a34:	f200 80ad 	bhi.w	34019b92 <__atonn_getDstPortID+0x1ae>
34019a38:	a201      	add	r2, pc, #4	@ (adr r2, 34019a40 <__atonn_getDstPortID+0x5c>)
34019a3a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34019a3e:	bf00      	nop
34019a40:	34019a5d 	.word	0x34019a5d
34019a44:	34019b93 	.word	0x34019b93
34019a48:	34019a8d 	.word	0x34019a8d
34019a4c:	34019ac7 	.word	0x34019ac7
34019a50:	34019afd 	.word	0x34019afd
34019a54:	34019b2d 	.word	0x34019b2d
34019a58:	34019b63 	.word	0x34019b63
    {
#if defined(ATON_STRENG_NUM)
    case STRENG:
      LL_ATON_ASSERT(port == 0);
34019a5c:	7e3b      	ldrb	r3, [r7, #24]
34019a5e:	2b00      	cmp	r3, #0
34019a60:	d006      	beq.n	34019a70 <__atonn_getDstPortID+0x8c>
34019a62:	4b5c      	ldr	r3, [pc, #368]	@ (34019bd4 <__atonn_getDstPortID+0x1f0>)
34019a64:	4a59      	ldr	r2, [pc, #356]	@ (34019bcc <__atonn_getDstPortID+0x1e8>)
34019a66:	f240 318b 	movw	r1, #907	@ 0x38b
34019a6a:	4859      	ldr	r0, [pc, #356]	@ (34019bd0 <__atonn_getDstPortID+0x1ec>)
34019a6c:	f001 feae 	bl	3401b7cc <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_STRENG_NUM);
34019a70:	793b      	ldrb	r3, [r7, #4]
34019a72:	2b09      	cmp	r3, #9
34019a74:	d906      	bls.n	34019a84 <__atonn_getDstPortID+0xa0>
34019a76:	4b58      	ldr	r3, [pc, #352]	@ (34019bd8 <__atonn_getDstPortID+0x1f4>)
34019a78:	4a54      	ldr	r2, [pc, #336]	@ (34019bcc <__atonn_getDstPortID+0x1e8>)
34019a7a:	f44f 7163 	mov.w	r1, #908	@ 0x38c
34019a7e:	4854      	ldr	r0, [pc, #336]	@ (34019bd0 <__atonn_getDstPortID+0x1ec>)
34019a80:	f001 fea4 	bl	3401b7cc <__assert_func>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, STRENG, 0, 0) + (0x4 * au_num);
34019a84:	793b      	ldrb	r3, [r7, #4]
34019a86:	009b      	lsls	r3, r3, #2
34019a88:	3308      	adds	r3, #8
34019a8a:	e098      	b.n	34019bbe <__atonn_getDstPortID+0x1da>
      break;
#endif
#if defined(ATON_CONVACC_NUM)
    case CONVACC:
      LL_ATON_ASSERT(port < 3);
34019a8c:	7e3b      	ldrb	r3, [r7, #24]
34019a8e:	2b02      	cmp	r3, #2
34019a90:	d906      	bls.n	34019aa0 <__atonn_getDstPortID+0xbc>
34019a92:	4b52      	ldr	r3, [pc, #328]	@ (34019bdc <__atonn_getDstPortID+0x1f8>)
34019a94:	4a4d      	ldr	r2, [pc, #308]	@ (34019bcc <__atonn_getDstPortID+0x1e8>)
34019a96:	f240 3192 	movw	r1, #914	@ 0x392
34019a9a:	484d      	ldr	r0, [pc, #308]	@ (34019bd0 <__atonn_getDstPortID+0x1ec>)
34019a9c:	f001 fe96 	bl	3401b7cc <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_CONVACC_NUM);
34019aa0:	793b      	ldrb	r3, [r7, #4]
34019aa2:	2b03      	cmp	r3, #3
34019aa4:	d906      	bls.n	34019ab4 <__atonn_getDstPortID+0xd0>
34019aa6:	4b4e      	ldr	r3, [pc, #312]	@ (34019be0 <__atonn_getDstPortID+0x1fc>)
34019aa8:	4a48      	ldr	r2, [pc, #288]	@ (34019bcc <__atonn_getDstPortID+0x1e8>)
34019aaa:	f240 3193 	movw	r1, #915	@ 0x393
34019aae:	4848      	ldr	r0, [pc, #288]	@ (34019bd0 <__atonn_getDstPortID+0x1ec>)
34019ab0:	f001 fe8c 	bl	3401b7cc <__assert_func>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, CONVACC, 0, 0) + (0x4 * (3 * au_num + port));
34019ab4:	793a      	ldrb	r2, [r7, #4]
34019ab6:	4613      	mov	r3, r2
34019ab8:	005b      	lsls	r3, r3, #1
34019aba:	441a      	add	r2, r3
34019abc:	7e3b      	ldrb	r3, [r7, #24]
34019abe:	4413      	add	r3, r2
34019ac0:	009b      	lsls	r3, r3, #2
34019ac2:	3330      	adds	r3, #48	@ 0x30
34019ac4:	e07b      	b.n	34019bbe <__atonn_getDstPortID+0x1da>
      break;
#endif
#if defined(ATON_DECUN_NUM)
    case DECUN:
      LL_ATON_ASSERT(port < 2);
34019ac6:	7e3b      	ldrb	r3, [r7, #24]
34019ac8:	2b01      	cmp	r3, #1
34019aca:	d906      	bls.n	34019ada <__atonn_getDstPortID+0xf6>
34019acc:	4b45      	ldr	r3, [pc, #276]	@ (34019be4 <__atonn_getDstPortID+0x200>)
34019ace:	4a3f      	ldr	r2, [pc, #252]	@ (34019bcc <__atonn_getDstPortID+0x1e8>)
34019ad0:	f240 3199 	movw	r1, #921	@ 0x399
34019ad4:	483e      	ldr	r0, [pc, #248]	@ (34019bd0 <__atonn_getDstPortID+0x1ec>)
34019ad6:	f001 fe79 	bl	3401b7cc <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_DECUN_NUM);
34019ada:	793b      	ldrb	r3, [r7, #4]
34019adc:	2b01      	cmp	r3, #1
34019ade:	d906      	bls.n	34019aee <__atonn_getDstPortID+0x10a>
34019ae0:	4b41      	ldr	r3, [pc, #260]	@ (34019be8 <__atonn_getDstPortID+0x204>)
34019ae2:	4a3a      	ldr	r2, [pc, #232]	@ (34019bcc <__atonn_getDstPortID+0x1e8>)
34019ae4:	f240 319a 	movw	r1, #922	@ 0x39a
34019ae8:	4839      	ldr	r0, [pc, #228]	@ (34019bd0 <__atonn_getDstPortID+0x1ec>)
34019aea:	f001 fe6f 	bl	3401b7cc <__assert_func>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, DECUN, 0, 0) + (0x4 * (2 * au_num + port));
34019aee:	793b      	ldrb	r3, [r7, #4]
34019af0:	005a      	lsls	r2, r3, #1
34019af2:	7e3b      	ldrb	r3, [r7, #24]
34019af4:	4413      	add	r3, r2
34019af6:	009b      	lsls	r3, r3, #2
34019af8:	3360      	adds	r3, #96	@ 0x60
34019afa:	e060      	b.n	34019bbe <__atonn_getDstPortID+0x1da>
      break;
#endif
#if defined(ATON_ACTIV_NUM)
    case ACTIV:
      LL_ATON_ASSERT(port == 0);
34019afc:	7e3b      	ldrb	r3, [r7, #24]
34019afe:	2b00      	cmp	r3, #0
34019b00:	d006      	beq.n	34019b10 <__atonn_getDstPortID+0x12c>
34019b02:	4b34      	ldr	r3, [pc, #208]	@ (34019bd4 <__atonn_getDstPortID+0x1f0>)
34019b04:	4a31      	ldr	r2, [pc, #196]	@ (34019bcc <__atonn_getDstPortID+0x1e8>)
34019b06:	f44f 7168 	mov.w	r1, #928	@ 0x3a0
34019b0a:	4831      	ldr	r0, [pc, #196]	@ (34019bd0 <__atonn_getDstPortID+0x1ec>)
34019b0c:	f001 fe5e 	bl	3401b7cc <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_ACTIV_NUM);
34019b10:	793b      	ldrb	r3, [r7, #4]
34019b12:	2b01      	cmp	r3, #1
34019b14:	d906      	bls.n	34019b24 <__atonn_getDstPortID+0x140>
34019b16:	4b34      	ldr	r3, [pc, #208]	@ (34019be8 <__atonn_getDstPortID+0x204>)
34019b18:	4a2c      	ldr	r2, [pc, #176]	@ (34019bcc <__atonn_getDstPortID+0x1e8>)
34019b1a:	f240 31a1 	movw	r1, #929	@ 0x3a1
34019b1e:	482c      	ldr	r0, [pc, #176]	@ (34019bd0 <__atonn_getDstPortID+0x1ec>)
34019b20:	f001 fe54 	bl	3401b7cc <__assert_func>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, ACTIV, 0, 0) + (0x4 * au_num);
34019b24:	793b      	ldrb	r3, [r7, #4]
34019b26:	009b      	lsls	r3, r3, #2
34019b28:	3370      	adds	r3, #112	@ 0x70
34019b2a:	e048      	b.n	34019bbe <__atonn_getDstPortID+0x1da>
      break;
#endif
#if defined(ATON_ARITH_NUM)
    case ARITH:
      LL_ATON_ASSERT(port < 2);
34019b2c:	7e3b      	ldrb	r3, [r7, #24]
34019b2e:	2b01      	cmp	r3, #1
34019b30:	d906      	bls.n	34019b40 <__atonn_getDstPortID+0x15c>
34019b32:	4b2c      	ldr	r3, [pc, #176]	@ (34019be4 <__atonn_getDstPortID+0x200>)
34019b34:	4a25      	ldr	r2, [pc, #148]	@ (34019bcc <__atonn_getDstPortID+0x1e8>)
34019b36:	f240 31a7 	movw	r1, #935	@ 0x3a7
34019b3a:	4825      	ldr	r0, [pc, #148]	@ (34019bd0 <__atonn_getDstPortID+0x1ec>)
34019b3c:	f001 fe46 	bl	3401b7cc <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_ARITH_NUM);
34019b40:	793b      	ldrb	r3, [r7, #4]
34019b42:	2b03      	cmp	r3, #3
34019b44:	d906      	bls.n	34019b54 <__atonn_getDstPortID+0x170>
34019b46:	4b26      	ldr	r3, [pc, #152]	@ (34019be0 <__atonn_getDstPortID+0x1fc>)
34019b48:	4a20      	ldr	r2, [pc, #128]	@ (34019bcc <__atonn_getDstPortID+0x1e8>)
34019b4a:	f44f 716a 	mov.w	r1, #936	@ 0x3a8
34019b4e:	4820      	ldr	r0, [pc, #128]	@ (34019bd0 <__atonn_getDstPortID+0x1ec>)
34019b50:	f001 fe3c 	bl	3401b7cc <__assert_func>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, ARITH, 0, 0) + (0x4 * (2 * au_num + port));
34019b54:	793b      	ldrb	r3, [r7, #4]
34019b56:	005a      	lsls	r2, r3, #1
34019b58:	7e3b      	ldrb	r3, [r7, #24]
34019b5a:	4413      	add	r3, r2
34019b5c:	009b      	lsls	r3, r3, #2
34019b5e:	3378      	adds	r3, #120	@ 0x78
34019b60:	e02d      	b.n	34019bbe <__atonn_getDstPortID+0x1da>
      break;
#endif
#if defined(ATON_POOL_NUM)
    case POOL:
      LL_ATON_ASSERT(port == 0);
34019b62:	7e3b      	ldrb	r3, [r7, #24]
34019b64:	2b00      	cmp	r3, #0
34019b66:	d006      	beq.n	34019b76 <__atonn_getDstPortID+0x192>
34019b68:	4b1a      	ldr	r3, [pc, #104]	@ (34019bd4 <__atonn_getDstPortID+0x1f0>)
34019b6a:	4a18      	ldr	r2, [pc, #96]	@ (34019bcc <__atonn_getDstPortID+0x1e8>)
34019b6c:	f240 31ae 	movw	r1, #942	@ 0x3ae
34019b70:	4817      	ldr	r0, [pc, #92]	@ (34019bd0 <__atonn_getDstPortID+0x1ec>)
34019b72:	f001 fe2b 	bl	3401b7cc <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_POOL_NUM);
34019b76:	793b      	ldrb	r3, [r7, #4]
34019b78:	2b01      	cmp	r3, #1
34019b7a:	d906      	bls.n	34019b8a <__atonn_getDstPortID+0x1a6>
34019b7c:	4b1a      	ldr	r3, [pc, #104]	@ (34019be8 <__atonn_getDstPortID+0x204>)
34019b7e:	4a13      	ldr	r2, [pc, #76]	@ (34019bcc <__atonn_getDstPortID+0x1e8>)
34019b80:	f240 31af 	movw	r1, #943	@ 0x3af
34019b84:	4812      	ldr	r0, [pc, #72]	@ (34019bd0 <__atonn_getDstPortID+0x1ec>)
34019b86:	f001 fe21 	bl	3401b7cc <__assert_func>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, POOL, 0, 0) + (0x4 * au_num);
34019b8a:	793b      	ldrb	r3, [r7, #4]
34019b8c:	009b      	lsls	r3, r3, #2
34019b8e:	3398      	adds	r3, #152	@ 0x98
34019b90:	e015      	b.n	34019bbe <__atonn_getDstPortID+0x1da>
      break;
#endif
    default:
      LL_ATON_ASSERT(0);
34019b92:	4b16      	ldr	r3, [pc, #88]	@ (34019bec <__atonn_getDstPortID+0x208>)
34019b94:	4a0d      	ldr	r2, [pc, #52]	@ (34019bcc <__atonn_getDstPortID+0x1e8>)
34019b96:	f44f 716d 	mov.w	r1, #948	@ 0x3b4
34019b9a:	480d      	ldr	r0, [pc, #52]	@ (34019bd0 <__atonn_getDstPortID+0x1ec>)
34019b9c:	f001 fe16 	bl	3401b7cc <__assert_func>
      break;
    }
    break;
  case STRSWITCH64:
    // TODO
    LL_ATON_ASSERT(0);
34019ba0:	4b12      	ldr	r3, [pc, #72]	@ (34019bec <__atonn_getDstPortID+0x208>)
34019ba2:	4a0a      	ldr	r2, [pc, #40]	@ (34019bcc <__atonn_getDstPortID+0x1e8>)
34019ba4:	f240 31ba 	movw	r1, #954	@ 0x3ba
34019ba8:	4809      	ldr	r0, [pc, #36]	@ (34019bd0 <__atonn_getDstPortID+0x1ec>)
34019baa:	f001 fe0f 	bl	3401b7cc <__assert_func>
    break;
  case STRSWITCH_VC:
    // TODO
    LL_ATON_ASSERT(0);
34019bae:	4b0f      	ldr	r3, [pc, #60]	@ (34019bec <__atonn_getDstPortID+0x208>)
34019bb0:	4a06      	ldr	r2, [pc, #24]	@ (34019bcc <__atonn_getDstPortID+0x1e8>)
34019bb2:	f240 31be 	movw	r1, #958	@ 0x3be
34019bb6:	4806      	ldr	r0, [pc, #24]	@ (34019bd0 <__atonn_getDstPortID+0x1ec>)
34019bb8:	f001 fe08 	bl	3401b7cc <__assert_func>
    break;
  }
  return 0;
34019bbc:	2300      	movs	r3, #0
}
34019bbe:	4618      	mov	r0, r3
34019bc0:	370c      	adds	r7, #12
34019bc2:	46bd      	mov	sp, r7
34019bc4:	bd90      	pop	{r4, r7, pc}
34019bc6:	bf00      	nop
34019bc8:	3401f478 	.word	0x3401f478
34019bcc:	3402002c 	.word	0x3402002c
34019bd0:	3401f224 	.word	0x3401f224
34019bd4:	3401f484 	.word	0x3401f484
34019bd8:	3401f490 	.word	0x3401f490
34019bdc:	3401f4b4 	.word	0x3401f4b4
34019be0:	3401f49c 	.word	0x3401f49c
34019be4:	3401f4c0 	.word	0x3401f4c0
34019be8:	3401f4a8 	.word	0x3401f4a8
34019bec:	3401f3fc 	.word	0x3401f3fc

34019bf0 <LL_Switch_Init_NoReset>:
 * @param  LL_Switch_InitStruct Pointer to structure(s) describing ports to be connected
 * @param  n Number of entries in configuration array
 * @retval Error code
 */
int LL_Switch_Init_NoReset(const LL_Switch_InitTypeDef *LL_Switch_InitStruct, int n)
{
34019bf0:	b480      	push	{r7}
34019bf2:	b08f      	sub	sp, #60	@ 0x3c
34019bf4:	af00      	add	r7, sp, #0
34019bf6:	6078      	str	r0, [r7, #4]
34019bf8:	6039      	str	r1, [r7, #0]
  int i;
  volatile uint32_t *reg;
  uint32_t t;
  unsigned int en_shift[ATON_SWITCH_CONTEXT_NUM] = {ATON_STRSWITCH_DST_EN0_LSB, ATON_STRSWITCH_DST_EN1_LSB};
34019bfa:	2300      	movs	r3, #0
34019bfc:	627b      	str	r3, [r7, #36]	@ 0x24
34019bfe:	2310      	movs	r3, #16
34019c00:	62bb      	str	r3, [r7, #40]	@ 0x28
  unsigned int link_shift[ATON_SWITCH_CONTEXT_NUM] = {ATON_STRSWITCH_DST_LINK0_LSB, ATON_STRSWITCH_DST_LINK1_LSB};
34019c02:	4a4e      	ldr	r2, [pc, #312]	@ (34019d3c <LL_Switch_Init_NoReset+0x14c>)
34019c04:	f107 031c 	add.w	r3, r7, #28
34019c08:	e892 0003 	ldmia.w	r2, {r0, r1}
34019c0c:	e883 0003 	stmia.w	r3, {r0, r1}
  unsigned int fnr_shift[ATON_SWITCH_CONTEXT_NUM] = {ATON_STRSWITCH_DST_FNR0_LSB, ATON_STRSWITCH_DST_FNR1_LSB};
34019c10:	4a4b      	ldr	r2, [pc, #300]	@ (34019d40 <LL_Switch_Init_NoReset+0x150>)
34019c12:	f107 0314 	add.w	r3, r7, #20
34019c16:	e892 0003 	ldmia.w	r2, {r0, r1}
34019c1a:	e883 0003 	stmia.w	r3, {r0, r1}
  unsigned int fnr_mask[ATON_SWITCH_CONTEXT_NUM] = {ATON_STRSWITCH_DST_FNR0_MASK, ATON_STRSWITCH_DST_FNR1_MASK};
34019c1e:	4a49      	ldr	r2, [pc, #292]	@ (34019d44 <LL_Switch_Init_NoReset+0x154>)
34019c20:	f107 030c 	add.w	r3, r7, #12
34019c24:	e892 0003 	ldmia.w	r2, {r0, r1}
34019c28:	e883 0003 	stmia.w	r3, {r0, r1}

  /* Enable Switch */
  t = ATON_STRSWITCH_CTRL_DT;
34019c2c:	2300      	movs	r3, #0
34019c2e:	633b      	str	r3, [r7, #48]	@ 0x30
  t = ATON_STRSWITCH_CTRL_SET_EN(t, 1);
34019c30:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34019c32:	f043 0301 	orr.w	r3, r3, #1
34019c36:	633b      	str	r3, [r7, #48]	@ 0x30
  ATON_STRSWITCH_CTRL_SET(0, t);
34019c38:	4a43      	ldr	r2, [pc, #268]	@ (34019d48 <LL_Switch_Init_NoReset+0x158>)
34019c3a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34019c3c:	6013      	str	r3, [r2, #0]

  for (i = 0; i < n; i++)
34019c3e:	2300      	movs	r3, #0
34019c40:	637b      	str	r3, [r7, #52]	@ 0x34
34019c42:	e06f      	b.n	34019d24 <LL_Switch_Init_NoReset+0x134>
  {
    /* Compute target destination configuration register */
    reg = (uint32_t *)(ATON_STRSWITCH_BASE(0) + ATONN_DSTPORT_ID(LL_Switch_InitStruct[i].dest));
34019c44:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34019c46:	011b      	lsls	r3, r3, #4
34019c48:	687a      	ldr	r2, [r7, #4]
34019c4a:	4413      	add	r3, r2
34019c4c:	689b      	ldr	r3, [r3, #8]
34019c4e:	f103 43b0 	add.w	r3, r3, #1476395008	@ 0x58000000
34019c52:	f503 2364 	add.w	r3, r3, #933888	@ 0xe4000
34019c56:	62fb      	str	r3, [r7, #44]	@ 0x2c
    t = 0;
34019c58:	2300      	movs	r3, #0
34019c5a:	633b      	str	r3, [r7, #48]	@ 0x30
    /* Enable Context and create link */
#if ATON_SWITCH_CONTEXT_NUM == 2
    t |= ((LL_Switch_InitStruct[i].context0 != 0) << en_shift[0]);
34019c5c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34019c5e:	011b      	lsls	r3, r3, #4
34019c60:	687a      	ldr	r2, [r7, #4]
34019c62:	4413      	add	r3, r2
34019c64:	7b9b      	ldrb	r3, [r3, #14]
34019c66:	f003 0301 	and.w	r3, r3, #1
34019c6a:	b2db      	uxtb	r3, r3
34019c6c:	2b00      	cmp	r3, #0
34019c6e:	bf14      	ite	ne
34019c70:	2301      	movne	r3, #1
34019c72:	2300      	moveq	r3, #0
34019c74:	b2db      	uxtb	r3, r3
34019c76:	461a      	mov	r2, r3
34019c78:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34019c7a:	fa02 f303 	lsl.w	r3, r2, r3
34019c7e:	461a      	mov	r2, r3
34019c80:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34019c82:	4313      	orrs	r3, r2
34019c84:	633b      	str	r3, [r7, #48]	@ 0x30
    t |= (ATONN_SRCPORT_ID(LL_Switch_InitStruct[i].source0) << link_shift[0]);
34019c86:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34019c88:	011b      	lsls	r3, r3, #4
34019c8a:	687a      	ldr	r2, [r7, #4]
34019c8c:	4413      	add	r3, r2
34019c8e:	681a      	ldr	r2, [r3, #0]
34019c90:	69fb      	ldr	r3, [r7, #28]
34019c92:	fa02 f303 	lsl.w	r3, r2, r3
34019c96:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
34019c98:	4313      	orrs	r3, r2
34019c9a:	633b      	str	r3, [r7, #48]	@ 0x30
    t |= ((LL_Switch_InitStruct[i].frames0 << fnr_shift[0]) & fnr_mask[0]);
34019c9c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34019c9e:	011b      	lsls	r3, r3, #4
34019ca0:	687a      	ldr	r2, [r7, #4]
34019ca2:	4413      	add	r3, r2
34019ca4:	7b1b      	ldrb	r3, [r3, #12]
34019ca6:	461a      	mov	r2, r3
34019ca8:	697b      	ldr	r3, [r7, #20]
34019caa:	fa02 f303 	lsl.w	r3, r2, r3
34019cae:	461a      	mov	r2, r3
34019cb0:	68fb      	ldr	r3, [r7, #12]
34019cb2:	4013      	ands	r3, r2
34019cb4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
34019cb6:	4313      	orrs	r3, r2
34019cb8:	633b      	str	r3, [r7, #48]	@ 0x30
    t |= ((LL_Switch_InitStruct[i].context1 != 0) << en_shift[1]);
34019cba:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34019cbc:	011b      	lsls	r3, r3, #4
34019cbe:	687a      	ldr	r2, [r7, #4]
34019cc0:	4413      	add	r3, r2
34019cc2:	7b9b      	ldrb	r3, [r3, #14]
34019cc4:	f003 0302 	and.w	r3, r3, #2
34019cc8:	b2db      	uxtb	r3, r3
34019cca:	2b00      	cmp	r3, #0
34019ccc:	bf14      	ite	ne
34019cce:	2301      	movne	r3, #1
34019cd0:	2300      	moveq	r3, #0
34019cd2:	b2db      	uxtb	r3, r3
34019cd4:	461a      	mov	r2, r3
34019cd6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34019cd8:	fa02 f303 	lsl.w	r3, r2, r3
34019cdc:	461a      	mov	r2, r3
34019cde:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34019ce0:	4313      	orrs	r3, r2
34019ce2:	633b      	str	r3, [r7, #48]	@ 0x30
    t |= (ATONN_SRCPORT_ID(LL_Switch_InitStruct[i].source1) << link_shift[1]);
34019ce4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34019ce6:	011b      	lsls	r3, r3, #4
34019ce8:	687a      	ldr	r2, [r7, #4]
34019cea:	4413      	add	r3, r2
34019cec:	685a      	ldr	r2, [r3, #4]
34019cee:	6a3b      	ldr	r3, [r7, #32]
34019cf0:	fa02 f303 	lsl.w	r3, r2, r3
34019cf4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
34019cf6:	4313      	orrs	r3, r2
34019cf8:	633b      	str	r3, [r7, #48]	@ 0x30
    t |= ((LL_Switch_InitStruct[i].frames1 << fnr_shift[1]) & fnr_mask[1]);
34019cfa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34019cfc:	011b      	lsls	r3, r3, #4
34019cfe:	687a      	ldr	r2, [r7, #4]
34019d00:	4413      	add	r3, r2
34019d02:	7b5b      	ldrb	r3, [r3, #13]
34019d04:	461a      	mov	r2, r3
34019d06:	69bb      	ldr	r3, [r7, #24]
34019d08:	fa02 f303 	lsl.w	r3, r2, r3
34019d0c:	461a      	mov	r2, r3
34019d0e:	693b      	ldr	r3, [r7, #16]
34019d10:	4013      	ands	r3, r2
34019d12:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
34019d14:	4313      	orrs	r3, r2
34019d16:	633b      	str	r3, [r7, #48]	@ 0x30
      t |= (ATONN_SRCPORT_ID(LL_Switch_InitStruct[i].source[c]) << link_shift[c]);
      t |= ((LL_Switch_InitStruct[i].frames[c] << fnr_shift[c]) & fnr_mask[c]);
    }
#endif

    ATON_REG_WRITE(reg, t);
34019d18:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34019d1a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
34019d1c:	601a      	str	r2, [r3, #0]
  for (i = 0; i < n; i++)
34019d1e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34019d20:	3301      	adds	r3, #1
34019d22:	637b      	str	r3, [r7, #52]	@ 0x34
34019d24:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34019d26:	683b      	ldr	r3, [r7, #0]
34019d28:	429a      	cmp	r2, r3
34019d2a:	db8b      	blt.n	34019c44 <LL_Switch_Init_NoReset+0x54>
  }

  return 0;
34019d2c:	2300      	movs	r3, #0
}
34019d2e:	4618      	mov	r0, r3
34019d30:	373c      	adds	r7, #60	@ 0x3c
34019d32:	46bd      	mov	sp, r7
34019d34:	f85d 7b04 	ldr.w	r7, [sp], #4
34019d38:	4770      	bx	lr
34019d3a:	bf00      	nop
34019d3c:	3401f4cc 	.word	0x3401f4cc
34019d40:	3401f4d4 	.word	0x3401f4d4
34019d44:	3401f4dc 	.word	0x3401f4dc
34019d48:	580e4000 	.word	0x580e4000

34019d4c <LL_Switch_Init>:
 * @param  LL_Switch_InitStruct Pointer to structure(s) describing ports to be connected
 * @param  n Number of entries in configuration array
 * @retval Error code
 */
int LL_Switch_Init(const LL_Switch_InitTypeDef *LL_Switch_InitStruct, int n)
{
34019d4c:	b580      	push	{r7, lr}
34019d4e:	b084      	sub	sp, #16
34019d50:	af00      	add	r7, sp, #0
34019d52:	6078      	str	r0, [r7, #4]
34019d54:	6039      	str	r1, [r7, #0]
#if (LL_ATON_PLATFORM == LL_ATON_PLAT_EC_TRACE)
  ll_aton_static_checks();
#endif

  /* Clear Configuration */
  ATON_DISABLE_CLR_CONFCLR(STRSWITCH, 0);
34019d56:	2300      	movs	r3, #0
34019d58:	60fb      	str	r3, [r7, #12]
34019d5a:	68fb      	ldr	r3, [r7, #12]
34019d5c:	f023 0301 	bic.w	r3, r3, #1
34019d60:	60fb      	str	r3, [r7, #12]
34019d62:	68fb      	ldr	r3, [r7, #12]
34019d64:	f043 0302 	orr.w	r3, r3, #2
34019d68:	60fb      	str	r3, [r7, #12]
34019d6a:	4a10      	ldr	r2, [pc, #64]	@ (34019dac <LL_Switch_Init+0x60>)
34019d6c:	68fb      	ldr	r3, [r7, #12]
34019d6e:	6013      	str	r3, [r2, #0]
34019d70:	4b0e      	ldr	r3, [pc, #56]	@ (34019dac <LL_Switch_Init+0x60>)
34019d72:	681b      	ldr	r3, [r3, #0]
34019d74:	f003 0302 	and.w	r3, r3, #2
34019d78:	2b00      	cmp	r3, #0
34019d7a:	d1f9      	bne.n	34019d70 <LL_Switch_Init+0x24>
34019d7c:	2300      	movs	r3, #0
34019d7e:	60fb      	str	r3, [r7, #12]
34019d80:	68fb      	ldr	r3, [r7, #12]
34019d82:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
34019d86:	60fb      	str	r3, [r7, #12]
34019d88:	4a08      	ldr	r2, [pc, #32]	@ (34019dac <LL_Switch_Init+0x60>)
34019d8a:	68fb      	ldr	r3, [r7, #12]
34019d8c:	6013      	str	r3, [r2, #0]
34019d8e:	4b07      	ldr	r3, [pc, #28]	@ (34019dac <LL_Switch_Init+0x60>)
34019d90:	681b      	ldr	r3, [r3, #0]
34019d92:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34019d96:	2b00      	cmp	r3, #0
34019d98:	d1f9      	bne.n	34019d8e <LL_Switch_Init+0x42>

  return LL_Switch_Init_NoReset(LL_Switch_InitStruct, n);
34019d9a:	6839      	ldr	r1, [r7, #0]
34019d9c:	6878      	ldr	r0, [r7, #4]
34019d9e:	f7ff ff27 	bl	34019bf0 <LL_Switch_Init_NoReset>
34019da2:	4603      	mov	r3, r0
}
34019da4:	4618      	mov	r0, r3
34019da6:	3710      	adds	r7, #16
34019da8:	46bd      	mov	sp, r7
34019daa:	bd80      	pop	{r7, pc}
34019dac:	580e4000 	.word	0x580e4000

34019db0 <LL_Switch_Deinit>:
 * @param  LL_Switch_InitStruct Pointer to structure(s) describing ports to be disconnected
 * @param  n Number of entries in configuration array
 * @retval Error code
 */
int LL_Switch_Deinit(const LL_Switch_InitTypeDef *LL_Switch_InitStruct, int n)
{
34019db0:	b480      	push	{r7}
34019db2:	b085      	sub	sp, #20
34019db4:	af00      	add	r7, sp, #0
34019db6:	6078      	str	r0, [r7, #4]
34019db8:	6039      	str	r1, [r7, #0]
  int i;
  volatile uint32_t *reg;

  for (i = 0; i < n; i++)
34019dba:	2300      	movs	r3, #0
34019dbc:	60fb      	str	r3, [r7, #12]
34019dbe:	e00f      	b.n	34019de0 <LL_Switch_Deinit+0x30>
  {
    /* Compute target destination configuration register */
    reg = (uint32_t *)(ATON_STRSWITCH_BASE(0) + ATONN_DSTPORT_ID(LL_Switch_InitStruct[i].dest));
34019dc0:	68fb      	ldr	r3, [r7, #12]
34019dc2:	011b      	lsls	r3, r3, #4
34019dc4:	687a      	ldr	r2, [r7, #4]
34019dc6:	4413      	add	r3, r2
34019dc8:	689b      	ldr	r3, [r3, #8]
34019dca:	f103 43b0 	add.w	r3, r3, #1476395008	@ 0x58000000
34019dce:	f503 2364 	add.w	r3, r3, #933888	@ 0xe4000
34019dd2:	60bb      	str	r3, [r7, #8]

    /* Disable contexts */
    ATON_REG_WRITE(reg, 0);
34019dd4:	68bb      	ldr	r3, [r7, #8]
34019dd6:	2200      	movs	r2, #0
34019dd8:	601a      	str	r2, [r3, #0]
  for (i = 0; i < n; i++)
34019dda:	68fb      	ldr	r3, [r7, #12]
34019ddc:	3301      	adds	r3, #1
34019dde:	60fb      	str	r3, [r7, #12]
34019de0:	68fa      	ldr	r2, [r7, #12]
34019de2:	683b      	ldr	r3, [r7, #0]
34019de4:	429a      	cmp	r2, r3
34019de6:	dbeb      	blt.n	34019dc0 <LL_Switch_Deinit+0x10>
  }

  return 0;
34019de8:	2300      	movs	r3, #0
}
34019dea:	4618      	mov	r0, r3
34019dec:	3714      	adds	r7, #20
34019dee:	46bd      	mov	sp, r7
34019df0:	f85d 7b04 	ldr.w	r7, [sp], #4
34019df4:	4770      	bx	lr
	...

34019df8 <LL_Convacc_Init>:
 * @param  id Convolutional Accelerator identifier [0, ATON_CONVACC_NUM-1]
 * @param  Convacc_InitStruct Structure describing initialization parameters
 * @retval Error code E.g.: Invalid ID, invalid parameters, not idle,..
 */
int LL_Convacc_Init(int id, const LL_Convacc_InitTypeDef *conf)
{
34019df8:	b580      	push	{r7, lr}
34019dfa:	b08c      	sub	sp, #48	@ 0x30
34019dfc:	af00      	add	r7, sp, #0
34019dfe:	6078      	str	r0, [r7, #4]
34019e00:	6039      	str	r1, [r7, #0]
  uint32_t t;

  if (id >= ATON_CONVACC_NUM)
34019e02:	687b      	ldr	r3, [r7, #4]
34019e04:	2b03      	cmp	r3, #3
34019e06:	dd02      	ble.n	34019e0e <LL_Convacc_Init+0x16>
    return LL_ATON_INVALID_ID;
34019e08:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
34019e0c:	e3a8      	b.n	3401a560 <LL_Convacc_Init+0x768>

  LL_ATON_EnableClock(ATON_CONVACC_CLKB_CLK(id));
34019e0e:	687b      	ldr	r3, [r7, #4]
34019e10:	330a      	adds	r3, #10
34019e12:	4618      	mov	r0, r3
34019e14:	f000 fbee 	bl	3401a5f4 <LL_ATON_EnableClock>

  t = ATON_CONVACC_CTRL_DT;
34019e18:	2300      	movs	r3, #0
34019e1a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_CTRL_SET_NOSUM(t, (conf->accumulate == 0));
34019e1c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34019e1e:	f023 0304 	bic.w	r3, r3, #4
34019e22:	683a      	ldr	r2, [r7, #0]
34019e24:	7852      	ldrb	r2, [r2, #1]
34019e26:	f3c2 1280 	ubfx	r2, r2, #6, #1
34019e2a:	b2d2      	uxtb	r2, r2
34019e2c:	2a00      	cmp	r2, #0
34019e2e:	d001      	beq.n	34019e34 <LL_Convacc_Init+0x3c>
34019e30:	2200      	movs	r2, #0
34019e32:	e000      	b.n	34019e36 <LL_Convacc_Init+0x3e>
34019e34:	2204      	movs	r2, #4
34019e36:	4313      	orrs	r3, r2
34019e38:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_CTRL_SET_NO1SUM(t, (conf->accumulate_first == 0));
34019e3a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34019e3c:	f023 0310 	bic.w	r3, r3, #16
34019e40:	683a      	ldr	r2, [r7, #0]
34019e42:	7852      	ldrb	r2, [r2, #1]
34019e44:	f3c2 12c0 	ubfx	r2, r2, #7, #1
34019e48:	b2d2      	uxtb	r2, r2
34019e4a:	2a00      	cmp	r2, #0
34019e4c:	d001      	beq.n	34019e52 <LL_Convacc_Init+0x5a>
34019e4e:	2200      	movs	r2, #0
34019e50:	e000      	b.n	34019e54 <LL_Convacc_Init+0x5c>
34019e52:	2210      	movs	r2, #16
34019e54:	4313      	orrs	r3, r2
34019e56:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_CTRL_SET_GEN1SUM(t, (conf->accumulate_gen_first != 0));
34019e58:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34019e5a:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
34019e5e:	683b      	ldr	r3, [r7, #0]
34019e60:	789b      	ldrb	r3, [r3, #2]
34019e62:	029b      	lsls	r3, r3, #10
34019e64:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34019e68:	4313      	orrs	r3, r2
34019e6a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_CTRL_SET_AFILTMODE(t, conf->afilt_mode);
34019e6c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34019e6e:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
34019e72:	683b      	ldr	r3, [r7, #0]
34019e74:	f893 302a 	ldrb.w	r3, [r3, #42]	@ 0x2a
34019e78:	021b      	lsls	r3, r3, #8
34019e7a:	f403 7340 	and.w	r3, r3, #768	@ 0x300
34019e7e:	4313      	orrs	r3, r2
34019e80:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_CTRL_SET_SIMD(t, (conf->simd));
34019e82:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34019e84:	f023 0260 	bic.w	r2, r3, #96	@ 0x60
34019e88:	683b      	ldr	r3, [r7, #0]
34019e8a:	785b      	ldrb	r3, [r3, #1]
34019e8c:	f3c3 1301 	ubfx	r3, r3, #4, #2
34019e90:	b2db      	uxtb	r3, r3
34019e92:	015b      	lsls	r3, r3, #5
34019e94:	f003 0360 	and.w	r3, r3, #96	@ 0x60
34019e98:	4313      	orrs	r3, r2
34019e9a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_CTRL_SET_KT1(t, (conf->kt1_mode != 0));
34019e9c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34019e9e:	f023 0208 	bic.w	r2, r3, #8
34019ea2:	683b      	ldr	r3, [r7, #0]
34019ea4:	789b      	ldrb	r3, [r3, #2]
34019ea6:	f003 0308 	and.w	r3, r3, #8
34019eaa:	4313      	orrs	r3, r2
34019eac:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_CTRL_SET_KSETEN(t, conf->kseten);
34019eae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34019eb0:	f423 0240 	bic.w	r2, r3, #12582912	@ 0xc00000
34019eb4:	683b      	ldr	r3, [r7, #0]
34019eb6:	78db      	ldrb	r3, [r3, #3]
34019eb8:	f3c3 0301 	ubfx	r3, r3, #0, #2
34019ebc:	b2db      	uxtb	r3, r3
34019ebe:	059b      	lsls	r3, r3, #22
34019ec0:	f403 0340 	and.w	r3, r3, #12582912	@ 0xc00000
34019ec4:	4313      	orrs	r3, r2
34019ec6:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_CTRL_SET_FUNSIGNED(t, conf->f_unsigned);
34019ec8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34019eca:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
34019ece:	683b      	ldr	r3, [r7, #0]
34019ed0:	789b      	ldrb	r3, [r3, #2]
34019ed2:	f3c3 1380 	ubfx	r3, r3, #6, #1
34019ed6:	b2db      	uxtb	r3, r3
34019ed8:	051b      	lsls	r3, r3, #20
34019eda:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
34019ede:	4313      	orrs	r3, r2
34019ee0:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_CTRL_SET_KUNSIGNED(t, conf->k_unsigned);
34019ee2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34019ee4:	f423 1200 	bic.w	r2, r3, #2097152	@ 0x200000
34019ee8:	683b      	ldr	r3, [r7, #0]
34019eea:	789b      	ldrb	r3, [r3, #2]
34019eec:	f3c3 13c0 	ubfx	r3, r3, #7, #1
34019ef0:	b2db      	uxtb	r3, r3
34019ef2:	055b      	lsls	r3, r3, #21
34019ef4:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34019ef8:	4313      	orrs	r3, r2
34019efa:	62fb      	str	r3, [r7, #44]	@ 0x2c
#if defined(ATON_CONVACC_CTRL_SET_FSTAT)
  t = ATON_CONVACC_CTRL_SET_FSTAT(t, (conf->fstat != 0));
34019efc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34019efe:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34019f02:	683b      	ldr	r3, [r7, #0]
34019f04:	789b      	ldrb	r3, [r3, #2]
34019f06:	05db      	lsls	r3, r3, #23
34019f08:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34019f0c:	4313      	orrs	r3, r2
34019f0e:	62fb      	str	r3, [r7, #44]	@ 0x2c
#endif

#if defined(ATON_CONVACC_CTRL_GET_DEEPMODE)
  t = ATON_CONVACC_CTRL_SET_DEEPMODE(t, (conf->deepmode != 0));
34019f10:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34019f12:	f023 5280 	bic.w	r2, r3, #268435456	@ 0x10000000
34019f16:	683b      	ldr	r3, [r7, #0]
34019f18:	789b      	ldrb	r3, [r3, #2]
34019f1a:	061b      	lsls	r3, r3, #24
34019f1c:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
34019f20:	4313      	orrs	r3, r2
34019f22:	62fb      	str	r3, [r7, #44]	@ 0x2c
#if defined(ATON_CONVACC_CTRL_SET_FSTAT)
  // deepmode and feature stats are incompatible
  if ((conf->fstat != 0) && (conf->deepmode != 0))
34019f24:	683b      	ldr	r3, [r7, #0]
34019f26:	789b      	ldrb	r3, [r3, #2]
34019f28:	f003 0302 	and.w	r3, r3, #2
34019f2c:	b2db      	uxtb	r3, r3
34019f2e:	2b00      	cmp	r3, #0
34019f30:	d009      	beq.n	34019f46 <LL_Convacc_Init+0x14e>
34019f32:	683b      	ldr	r3, [r7, #0]
34019f34:	789b      	ldrb	r3, [r3, #2]
34019f36:	f003 0310 	and.w	r3, r3, #16
34019f3a:	b2db      	uxtb	r3, r3
34019f3c:	2b00      	cmp	r3, #0
34019f3e:	d002      	beq.n	34019f46 <LL_Convacc_Init+0x14e>
  {
    return LL_ATON_INVALID_PARAM;
34019f40:	f06f 0301 	mvn.w	r3, #1
34019f44:	e30c      	b.n	3401a560 <LL_Convacc_Init+0x768>
  }
#endif
#endif

#if defined(ATON_CONVACC_CTRL_GET_DSS2MODE)
  t = ATON_CONVACC_CTRL_SET_DSS2MODE(t, (conf->dss2mode != 0));
34019f46:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34019f48:	f023 5200 	bic.w	r2, r3, #536870912	@ 0x20000000
34019f4c:	683b      	ldr	r3, [r7, #0]
34019f4e:	789b      	ldrb	r3, [r3, #2]
34019f50:	061b      	lsls	r3, r3, #24
34019f52:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
34019f56:	4313      	orrs	r3, r2
34019f58:	62fb      	str	r3, [r7, #44]	@ 0x2c
#if defined(ATON_CONVACC_CTRL_SET_FSTAT)
  // deepmode and feature stats are incompatible
  if ((conf->fstat != 0) && (conf->dss2mode != 0))
34019f5a:	683b      	ldr	r3, [r7, #0]
34019f5c:	789b      	ldrb	r3, [r3, #2]
34019f5e:	f003 0302 	and.w	r3, r3, #2
34019f62:	b2db      	uxtb	r3, r3
34019f64:	2b00      	cmp	r3, #0
34019f66:	d009      	beq.n	34019f7c <LL_Convacc_Init+0x184>
34019f68:	683b      	ldr	r3, [r7, #0]
34019f6a:	789b      	ldrb	r3, [r3, #2]
34019f6c:	f003 0320 	and.w	r3, r3, #32
34019f70:	b2db      	uxtb	r3, r3
34019f72:	2b00      	cmp	r3, #0
34019f74:	d002      	beq.n	34019f7c <LL_Convacc_Init+0x184>
  {
    return LL_ATON_INVALID_PARAM;
34019f76:	f06f 0301 	mvn.w	r3, #1
34019f7a:	e2f1      	b.n	3401a560 <LL_Convacc_Init+0x768>
#endif
#endif

#if defined(ATON_CONVACC_CTRL_SET_DSS2MODE) && defined(ATON_CONVACC_CTRL_SET_DEEPMODE)
  // deepmode and dss2mode stats are incompatible
  if ((conf->dss2mode != 0) && (conf->deepmode != 0))
34019f7c:	683b      	ldr	r3, [r7, #0]
34019f7e:	789b      	ldrb	r3, [r3, #2]
34019f80:	f003 0320 	and.w	r3, r3, #32
34019f84:	b2db      	uxtb	r3, r3
34019f86:	2b00      	cmp	r3, #0
34019f88:	d009      	beq.n	34019f9e <LL_Convacc_Init+0x1a6>
34019f8a:	683b      	ldr	r3, [r7, #0]
34019f8c:	789b      	ldrb	r3, [r3, #2]
34019f8e:	f003 0310 	and.w	r3, r3, #16
34019f92:	b2db      	uxtb	r3, r3
34019f94:	2b00      	cmp	r3, #0
34019f96:	d002      	beq.n	34019f9e <LL_Convacc_Init+0x1a6>
  {
    return LL_ATON_INVALID_PARAM;
34019f98:	f06f 0301 	mvn.w	r3, #1
34019f9c:	e2e0      	b.n	3401a560 <LL_Convacc_Init+0x768>
  }
#endif

  ATON_CONVACC_CTRL_SET(id, t);
34019f9e:	687b      	ldr	r3, [r7, #4]
34019fa0:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34019fa4:	33ef      	adds	r3, #239	@ 0xef
34019fa6:	031b      	lsls	r3, r3, #12
34019fa8:	461a      	mov	r2, r3
34019faa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34019fac:	6013      	str	r3, [r2, #0]
  Conv_ctrl_bits[id] = t;
34019fae:	49ac      	ldr	r1, [pc, #688]	@ (3401a260 <LL_Convacc_Init+0x468>)
34019fb0:	687b      	ldr	r3, [r7, #4]
34019fb2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34019fb4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

  if (conf->afilt_mode != AFILT_MODE_NONE)
34019fb8:	683b      	ldr	r3, [r7, #0]
34019fba:	f893 302a 	ldrb.w	r3, [r3, #42]	@ 0x2a
34019fbe:	2b00      	cmp	r3, #0
34019fc0:	d025      	beq.n	3401a00e <LL_Convacc_Init+0x216>
  {
    t = ATON_CONVACC_AFILT_DT;
34019fc2:	2301      	movs	r3, #1
34019fc4:	62fb      	str	r3, [r7, #44]	@ 0x2c
    t = ATON_CONVACC_AFILT_SET_TOT(t, conf->afilt_tot);
34019fc6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34019fc8:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
34019fcc:	683a      	ldr	r2, [r7, #0]
34019fce:	f892 202b 	ldrb.w	r2, [r2, #43]	@ 0x2b
34019fd2:	4313      	orrs	r3, r2
34019fd4:	62fb      	str	r3, [r7, #44]	@ 0x2c
    t = ATON_CONVACC_AFILT_SET_FIRST(t, conf->afilt_first);
34019fd6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34019fd8:	f423 427f 	bic.w	r2, r3, #65280	@ 0xff00
34019fdc:	683b      	ldr	r3, [r7, #0]
34019fde:	f893 302c 	ldrb.w	r3, [r3, #44]	@ 0x2c
34019fe2:	021b      	lsls	r3, r3, #8
34019fe4:	b29b      	uxth	r3, r3
34019fe6:	4313      	orrs	r3, r2
34019fe8:	62fb      	str	r3, [r7, #44]	@ 0x2c
    t = ATON_CONVACC_AFILT_SET_LAST(t, conf->afilt_last);
34019fea:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34019fec:	f423 027f 	bic.w	r2, r3, #16711680	@ 0xff0000
34019ff0:	683b      	ldr	r3, [r7, #0]
34019ff2:	f893 302d 	ldrb.w	r3, [r3, #45]	@ 0x2d
34019ff6:	041b      	lsls	r3, r3, #16
34019ff8:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
34019ffc:	4313      	orrs	r3, r2
34019ffe:	62fb      	str	r3, [r7, #44]	@ 0x2c
    ATON_CONVACC_AFILT_SET(id, t);
3401a000:	687b      	ldr	r3, [r7, #4]
3401a002:	031a      	lsls	r2, r3, #12
3401a004:	4b97      	ldr	r3, [pc, #604]	@ (3401a264 <LL_Convacc_Init+0x46c>)
3401a006:	4413      	add	r3, r2
3401a008:	461a      	mov	r2, r3
3401a00a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a00c:	6013      	str	r3, [r2, #0]
  }

  if (conf->kfilt_tot > 0)
3401a00e:	683b      	ldr	r3, [r7, #0]
3401a010:	f893 302e 	ldrb.w	r3, [r3, #46]	@ 0x2e
3401a014:	2b00      	cmp	r3, #0
3401a016:	d025      	beq.n	3401a064 <LL_Convacc_Init+0x26c>
  {
    t = ATON_CONVACC_KFILT_DT;
3401a018:	2301      	movs	r3, #1
3401a01a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    t = ATON_CONVACC_KFILT_SET_TOT(t, conf->kfilt_tot);
3401a01c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a01e:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
3401a022:	683a      	ldr	r2, [r7, #0]
3401a024:	f892 202e 	ldrb.w	r2, [r2, #46]	@ 0x2e
3401a028:	4313      	orrs	r3, r2
3401a02a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    t = ATON_CONVACC_KFILT_SET_FIRST(t, conf->kfilt_first);
3401a02c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a02e:	f423 427f 	bic.w	r2, r3, #65280	@ 0xff00
3401a032:	683b      	ldr	r3, [r7, #0]
3401a034:	f893 302f 	ldrb.w	r3, [r3, #47]	@ 0x2f
3401a038:	021b      	lsls	r3, r3, #8
3401a03a:	b29b      	uxth	r3, r3
3401a03c:	4313      	orrs	r3, r2
3401a03e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    t = ATON_CONVACC_KFILT_SET_LAST(t, conf->kfilt_last);
3401a040:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a042:	f423 027f 	bic.w	r2, r3, #16711680	@ 0xff0000
3401a046:	683b      	ldr	r3, [r7, #0]
3401a048:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
3401a04c:	041b      	lsls	r3, r3, #16
3401a04e:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
3401a052:	4313      	orrs	r3, r2
3401a054:	62fb      	str	r3, [r7, #44]	@ 0x2c
    ATON_CONVACC_KFILT_SET(id, t);
3401a056:	687b      	ldr	r3, [r7, #4]
3401a058:	031a      	lsls	r2, r3, #12
3401a05a:	4b83      	ldr	r3, [pc, #524]	@ (3401a268 <LL_Convacc_Init+0x470>)
3401a05c:	4413      	add	r3, r2
3401a05e:	461a      	mov	r2, r3
3401a060:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a062:	6013      	str	r3, [r2, #0]
  }

  t = ATON_CONVACC_DFORMAT_DT;
3401a064:	4b81      	ldr	r3, [pc, #516]	@ (3401a26c <LL_Convacc_Init+0x474>)
3401a066:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_DFORMAT_SET_FROUND(t, conf->rounding_f);
3401a068:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a06a:	f023 4280 	bic.w	r2, r3, #1073741824	@ 0x40000000
3401a06e:	683b      	ldr	r3, [r7, #0]
3401a070:	781b      	ldrb	r3, [r3, #0]
3401a072:	f3c3 0300 	ubfx	r3, r3, #0, #1
3401a076:	b2db      	uxtb	r3, r3
3401a078:	079b      	lsls	r3, r3, #30
3401a07a:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3401a07e:	4313      	orrs	r3, r2
3401a080:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_DFORMAT_SET_FSAT(t, conf->saturation_f);
3401a082:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a084:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
3401a088:	683b      	ldr	r3, [r7, #0]
3401a08a:	781b      	ldrb	r3, [r3, #0]
3401a08c:	f3c3 0340 	ubfx	r3, r3, #1, #1
3401a090:	b2db      	uxtb	r3, r3
3401a092:	07db      	lsls	r3, r3, #31
3401a094:	4313      	orrs	r3, r2
3401a096:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_DFORMAT_SET_FRNDMODE(t, conf->round_mode_f);
3401a098:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a09a:	f023 02c0 	bic.w	r2, r3, #192	@ 0xc0
3401a09e:	683b      	ldr	r3, [r7, #0]
3401a0a0:	781b      	ldrb	r3, [r3, #0]
3401a0a2:	f3c3 0381 	ubfx	r3, r3, #2, #2
3401a0a6:	b2db      	uxtb	r3, r3
3401a0a8:	019b      	lsls	r3, r3, #6
3401a0aa:	b2db      	uxtb	r3, r3
3401a0ac:	4313      	orrs	r3, r2
3401a0ae:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_DFORMAT_SET_FBYTES(t, conf->inbytes_f);
3401a0b0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a0b2:	f423 0240 	bic.w	r2, r3, #12582912	@ 0xc00000
3401a0b6:	683b      	ldr	r3, [r7, #0]
3401a0b8:	781b      	ldrb	r3, [r3, #0]
3401a0ba:	f3c3 1301 	ubfx	r3, r3, #4, #2
3401a0be:	b2db      	uxtb	r3, r3
3401a0c0:	059b      	lsls	r3, r3, #22
3401a0c2:	f403 0340 	and.w	r3, r3, #12582912	@ 0xc00000
3401a0c6:	4313      	orrs	r3, r2
3401a0c8:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_DFORMAT_SET_FSHIFT(t, ATON_SHIFT(conf->shift_f));
3401a0ca:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a0cc:	f023 527c 	bic.w	r2, r3, #1056964608	@ 0x3f000000
3401a0d0:	683b      	ldr	r3, [r7, #0]
3401a0d2:	791b      	ldrb	r3, [r3, #4]
3401a0d4:	3310      	adds	r3, #16
3401a0d6:	061b      	lsls	r3, r3, #24
3401a0d8:	f003 537c 	and.w	r3, r3, #1056964608	@ 0x3f000000
3401a0dc:	4313      	orrs	r3, r2
3401a0de:	62fb      	str	r3, [r7, #44]	@ 0x2c

  t = ATON_CONVACC_DFORMAT_SET_ROUND(t, conf->rounding_o);
3401a0e0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a0e2:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
3401a0e6:	683b      	ldr	r3, [r7, #0]
3401a0e8:	781b      	ldrb	r3, [r3, #0]
3401a0ea:	f3c3 1380 	ubfx	r3, r3, #6, #1
3401a0ee:	b2db      	uxtb	r3, r3
3401a0f0:	041b      	lsls	r3, r3, #16
3401a0f2:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3401a0f6:	4313      	orrs	r3, r2
3401a0f8:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_DFORMAT_SET_SAT(t, conf->saturation_o);
3401a0fa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a0fc:	f423 3200 	bic.w	r2, r3, #131072	@ 0x20000
3401a100:	683b      	ldr	r3, [r7, #0]
3401a102:	781b      	ldrb	r3, [r3, #0]
3401a104:	f3c3 13c0 	ubfx	r3, r3, #7, #1
3401a108:	b2db      	uxtb	r3, r3
3401a10a:	045b      	lsls	r3, r3, #17
3401a10c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
3401a110:	4313      	orrs	r3, r2
3401a112:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_DFORMAT_SET_ORNDMODE(t, (conf->relu_mode_o << 1) | conf->round_mode_o);
3401a114:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a116:	f423 4240 	bic.w	r2, r3, #49152	@ 0xc000
3401a11a:	683b      	ldr	r3, [r7, #0]
3401a11c:	785b      	ldrb	r3, [r3, #1]
3401a11e:	f3c3 0340 	ubfx	r3, r3, #1, #1
3401a122:	b2db      	uxtb	r3, r3
3401a124:	005b      	lsls	r3, r3, #1
3401a126:	6839      	ldr	r1, [r7, #0]
3401a128:	7849      	ldrb	r1, [r1, #1]
3401a12a:	f3c1 0100 	ubfx	r1, r1, #0, #1
3401a12e:	b2c9      	uxtb	r1, r1
3401a130:	430b      	orrs	r3, r1
3401a132:	039b      	lsls	r3, r3, #14
3401a134:	b29b      	uxth	r3, r3
3401a136:	4313      	orrs	r3, r2
3401a138:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_DFORMAT_SET_OBYTES(t, conf->outbytes_o);
3401a13a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a13c:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
3401a140:	683b      	ldr	r3, [r7, #0]
3401a142:	785b      	ldrb	r3, [r3, #1]
3401a144:	f3c3 0381 	ubfx	r3, r3, #2, #2
3401a148:	b2db      	uxtb	r3, r3
3401a14a:	051b      	lsls	r3, r3, #20
3401a14c:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
3401a150:	4313      	orrs	r3, r2
3401a152:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_DFORMAT_SET_OUTSHIFT(t, conf->shift_o); // shift right only
3401a154:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a156:	f423 527c 	bic.w	r2, r3, #16128	@ 0x3f00
3401a15a:	683b      	ldr	r3, [r7, #0]
3401a15c:	799b      	ldrb	r3, [r3, #6]
3401a15e:	021b      	lsls	r3, r3, #8
3401a160:	f403 537c 	and.w	r3, r3, #16128	@ 0x3f00
3401a164:	4313      	orrs	r3, r2
3401a166:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_DFORMAT_SET_RAW(t, conf->raw_o);
3401a168:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a16a:	f423 2280 	bic.w	r2, r3, #262144	@ 0x40000
3401a16e:	683b      	ldr	r3, [r7, #0]
3401a170:	789b      	ldrb	r3, [r3, #2]
3401a172:	f3c3 0380 	ubfx	r3, r3, #2, #1
3401a176:	b2db      	uxtb	r3, r3
3401a178:	049b      	lsls	r3, r3, #18
3401a17a:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
3401a17e:	4313      	orrs	r3, r2
3401a180:	62fb      	str	r3, [r7, #44]	@ 0x2c

  t = ATON_CONVACC_DFORMAT_SET_INSHIFT(t, conf->shift_a); // accumulator shift left really (macro name is misleading)
3401a182:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a184:	f023 023f 	bic.w	r2, r3, #63	@ 0x3f
3401a188:	683b      	ldr	r3, [r7, #0]
3401a18a:	795b      	ldrb	r3, [r3, #5]
3401a18c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
3401a190:	4313      	orrs	r3, r2
3401a192:	62fb      	str	r3, [r7, #44]	@ 0x2c
  ATON_CONVACC_DFORMAT_SET(id, t);
3401a194:	687b      	ldr	r3, [r7, #4]
3401a196:	031a      	lsls	r2, r3, #12
3401a198:	4b35      	ldr	r3, [pc, #212]	@ (3401a270 <LL_Convacc_Init+0x478>)
3401a19a:	4413      	add	r3, r2
3401a19c:	461a      	mov	r2, r3
3401a19e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a1a0:	6013      	str	r3, [r2, #0]

  t = ATON_CONVACC_FFORMAT_DT;
3401a1a2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
3401a1a6:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_FFORMAT_SET_WIDTH(t, conf->fWidth * conf->batchDepth);
3401a1a8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a1aa:	0c1b      	lsrs	r3, r3, #16
3401a1ac:	041b      	lsls	r3, r3, #16
3401a1ae:	683a      	ldr	r2, [r7, #0]
3401a1b0:	6892      	ldr	r2, [r2, #8]
3401a1b2:	6839      	ldr	r1, [r7, #0]
3401a1b4:	8a89      	ldrh	r1, [r1, #20]
3401a1b6:	fb01 f202 	mul.w	r2, r1, r2
3401a1ba:	b292      	uxth	r2, r2
3401a1bc:	4313      	orrs	r3, r2
3401a1be:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_FFORMAT_SET_HEIGHT(t, conf->fHeight);
3401a1c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a1c2:	b29a      	uxth	r2, r3
3401a1c4:	683b      	ldr	r3, [r7, #0]
3401a1c6:	68db      	ldr	r3, [r3, #12]
3401a1c8:	041b      	lsls	r3, r3, #16
3401a1ca:	4313      	orrs	r3, r2
3401a1cc:	62fb      	str	r3, [r7, #44]	@ 0x2c
  ATON_CONVACC_FFORMAT_SET(id, t);
3401a1ce:	687b      	ldr	r3, [r7, #4]
3401a1d0:	031a      	lsls	r2, r3, #12
3401a1d2:	4b28      	ldr	r3, [pc, #160]	@ (3401a274 <LL_Convacc_Init+0x47c>)
3401a1d4:	4413      	add	r3, r2
3401a1d6:	461a      	mov	r2, r3
3401a1d8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a1da:	6013      	str	r3, [r2, #0]

  t = ATON_CONVACC_KFORMAT_DT;
3401a1dc:	4b26      	ldr	r3, [pc, #152]	@ (3401a278 <LL_Convacc_Init+0x480>)
3401a1de:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_KFORMAT_SET_WIDTH(t, conf->kernelWidth);
3401a1e0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a1e2:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
3401a1e6:	683a      	ldr	r2, [r7, #0]
3401a1e8:	7c12      	ldrb	r2, [r2, #16]
3401a1ea:	4313      	orrs	r3, r2
3401a1ec:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_KFORMAT_SET_HEIGHT(t, conf->kernelHeight);
3401a1ee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a1f0:	f423 427f 	bic.w	r2, r3, #65280	@ 0xff00
3401a1f4:	683b      	ldr	r3, [r7, #0]
3401a1f6:	7c5b      	ldrb	r3, [r3, #17]
3401a1f8:	021b      	lsls	r3, r3, #8
3401a1fa:	b29b      	uxth	r3, r3
3401a1fc:	4313      	orrs	r3, r2
3401a1fe:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_KFORMAT_SET_BTCDEPTH(t, conf->batchDepth);
3401a200:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a202:	f423 027f 	bic.w	r2, r3, #16711680	@ 0xff0000
3401a206:	683b      	ldr	r3, [r7, #0]
3401a208:	8a9b      	ldrh	r3, [r3, #20]
3401a20a:	041b      	lsls	r3, r3, #16
3401a20c:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
3401a210:	4313      	orrs	r3, r2
3401a212:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_KFORMAT_SET_NR(t, conf->nKernels);
3401a214:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a216:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
3401a21a:	683b      	ldr	r3, [r7, #0]
3401a21c:	7c9b      	ldrb	r3, [r3, #18]
3401a21e:	061b      	lsls	r3, r3, #24
3401a220:	4313      	orrs	r3, r2
3401a222:	62fb      	str	r3, [r7, #44]	@ 0x2c
  ATON_CONVACC_KFORMAT_SET(id, t);
3401a224:	687b      	ldr	r3, [r7, #4]
3401a226:	031a      	lsls	r2, r3, #12
3401a228:	4b14      	ldr	r3, [pc, #80]	@ (3401a27c <LL_Convacc_Init+0x484>)
3401a22a:	4413      	add	r3, r2
3401a22c:	461a      	mov	r2, r3
3401a22e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a230:	6013      	str	r3, [r2, #0]

//   LL_ATON_PRINTF("depth=%d k_w=%d k_h=%d\n",conf->batchDepth,conf->kernelWidth,conf->kernelHeight);
//   LL_ATON_PRINTF("pad_t=%d pad_b=%d pad_l=%d pad_r=%d\n",conf->top_padding,conf->bot_padding,conf->left_padding,conf->right_padding);

  int p_top = (conf->top_padding < conf->kernelHeight ? conf->top_padding : conf->kernelHeight - 1);
3401a232:	683b      	ldr	r3, [r7, #0]
3401a234:	8b9b      	ldrh	r3, [r3, #28]
3401a236:	683a      	ldr	r2, [r7, #0]
3401a238:	7c52      	ldrb	r2, [r2, #17]
3401a23a:	4293      	cmp	r3, r2
3401a23c:	d202      	bcs.n	3401a244 <LL_Convacc_Init+0x44c>
3401a23e:	683b      	ldr	r3, [r7, #0]
3401a240:	8b9b      	ldrh	r3, [r3, #28]
3401a242:	e002      	b.n	3401a24a <LL_Convacc_Init+0x452>
3401a244:	683b      	ldr	r3, [r7, #0]
3401a246:	7c5b      	ldrb	r3, [r3, #17]
3401a248:	3b01      	subs	r3, #1
3401a24a:	62bb      	str	r3, [r7, #40]	@ 0x28
  int p_bot = (conf->bot_padding < conf->kernelHeight ? conf->bot_padding : conf->kernelHeight - 1);
3401a24c:	683b      	ldr	r3, [r7, #0]
3401a24e:	8bdb      	ldrh	r3, [r3, #30]
3401a250:	683a      	ldr	r2, [r7, #0]
3401a252:	7c52      	ldrb	r2, [r2, #17]
3401a254:	4293      	cmp	r3, r2
3401a256:	d213      	bcs.n	3401a280 <LL_Convacc_Init+0x488>
3401a258:	683b      	ldr	r3, [r7, #0]
3401a25a:	8bdb      	ldrh	r3, [r3, #30]
3401a25c:	e013      	b.n	3401a286 <LL_Convacc_Init+0x48e>
3401a25e:	bf00      	nop
3401a260:	34021390 	.word	0x34021390
3401a264:	580ef024 	.word	0x580ef024
3401a268:	580ef020 	.word	0x580ef020
3401a26c:	10b00808 	.word	0x10b00808
3401a270:	580ef010 	.word	0x580ef010
3401a274:	580ef014 	.word	0x580ef014
3401a278:	01010303 	.word	0x01010303
3401a27c:	580ef008 	.word	0x580ef008
3401a280:	683b      	ldr	r3, [r7, #0]
3401a282:	7c5b      	ldrb	r3, [r3, #17]
3401a284:	3b01      	subs	r3, #1
3401a286:	627b      	str	r3, [r7, #36]	@ 0x24
  int p_left = (conf->left_padding < conf->kernelWidth ? conf->left_padding : conf->kernelWidth - 1);
3401a288:	683b      	ldr	r3, [r7, #0]
3401a28a:	8b1b      	ldrh	r3, [r3, #24]
3401a28c:	683a      	ldr	r2, [r7, #0]
3401a28e:	7c12      	ldrb	r2, [r2, #16]
3401a290:	4293      	cmp	r3, r2
3401a292:	d202      	bcs.n	3401a29a <LL_Convacc_Init+0x4a2>
3401a294:	683b      	ldr	r3, [r7, #0]
3401a296:	8b1b      	ldrh	r3, [r3, #24]
3401a298:	e002      	b.n	3401a2a0 <LL_Convacc_Init+0x4a8>
3401a29a:	683b      	ldr	r3, [r7, #0]
3401a29c:	7c1b      	ldrb	r3, [r3, #16]
3401a29e:	3b01      	subs	r3, #1
3401a2a0:	623b      	str	r3, [r7, #32]
  int p_right = (conf->right_padding < conf->kernelWidth ? conf->right_padding : conf->kernelWidth - 1);
3401a2a2:	683b      	ldr	r3, [r7, #0]
3401a2a4:	8b5b      	ldrh	r3, [r3, #26]
3401a2a6:	683a      	ldr	r2, [r7, #0]
3401a2a8:	7c12      	ldrb	r2, [r2, #16]
3401a2aa:	4293      	cmp	r3, r2
3401a2ac:	d202      	bcs.n	3401a2b4 <LL_Convacc_Init+0x4bc>
3401a2ae:	683b      	ldr	r3, [r7, #0]
3401a2b0:	8b5b      	ldrh	r3, [r3, #26]
3401a2b2:	e002      	b.n	3401a2ba <LL_Convacc_Init+0x4c2>
3401a2b4:	683b      	ldr	r3, [r7, #0]
3401a2b6:	7c1b      	ldrb	r3, [r3, #16]
3401a2b8:	3b01      	subs	r3, #1
3401a2ba:	61fb      	str	r3, [r7, #28]

  p_top = (p_top <= 2 ? p_top : 2);
3401a2bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401a2be:	2b02      	cmp	r3, #2
3401a2c0:	bfa8      	it	ge
3401a2c2:	2302      	movge	r3, #2
3401a2c4:	62bb      	str	r3, [r7, #40]	@ 0x28
  p_bot = (p_bot <= 2 ? p_bot : 2);
3401a2c6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401a2c8:	2b02      	cmp	r3, #2
3401a2ca:	bfa8      	it	ge
3401a2cc:	2302      	movge	r3, #2
3401a2ce:	627b      	str	r3, [r7, #36]	@ 0x24
  p_left = (p_left <= 2 ? p_left : 2);
3401a2d0:	6a3b      	ldr	r3, [r7, #32]
3401a2d2:	2b02      	cmp	r3, #2
3401a2d4:	bfa8      	it	ge
3401a2d6:	2302      	movge	r3, #2
3401a2d8:	623b      	str	r3, [r7, #32]
  p_right = (p_right <= 2 ? p_right : 2);
3401a2da:	69fb      	ldr	r3, [r7, #28]
3401a2dc:	2b02      	cmp	r3, #2
3401a2de:	bfa8      	it	ge
3401a2e0:	2302      	movge	r3, #2
3401a2e2:	61fb      	str	r3, [r7, #28]
  // LL_ATON_PRINTF("p_t=%d p_b=%d p_l=%d p_r=%d\n",p_top,p_bot,p_left,p_right);

#if defined(ATON_CONVACC_CTRL_GET_DEEPMODE)
  // no pad mode available in 1x1 deepmode
  // will accomodate padding only with zframe below
  if (conf->deepmode != 0)
3401a2e4:	683b      	ldr	r3, [r7, #0]
3401a2e6:	789b      	ldrb	r3, [r3, #2]
3401a2e8:	f003 0310 	and.w	r3, r3, #16
3401a2ec:	b2db      	uxtb	r3, r3
3401a2ee:	2b00      	cmp	r3, #0
3401a2f0:	d007      	beq.n	3401a302 <LL_Convacc_Init+0x50a>
    p_top = p_bot = p_left = p_right = 0;
3401a2f2:	2300      	movs	r3, #0
3401a2f4:	61fb      	str	r3, [r7, #28]
3401a2f6:	69fb      	ldr	r3, [r7, #28]
3401a2f8:	623b      	str	r3, [r7, #32]
3401a2fa:	6a3b      	ldr	r3, [r7, #32]
3401a2fc:	627b      	str	r3, [r7, #36]	@ 0x24
3401a2fe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401a300:	62bb      	str	r3, [r7, #40]	@ 0x28
#endif
#if defined(ATON_CONVACC_CTRL_GET_DSS2MODE)
  // no pad mode available in dss2mode
  // will accomodate padding only with zframe below
  if (conf->dss2mode != 0)
3401a302:	683b      	ldr	r3, [r7, #0]
3401a304:	789b      	ldrb	r3, [r3, #2]
3401a306:	f003 0320 	and.w	r3, r3, #32
3401a30a:	b2db      	uxtb	r3, r3
3401a30c:	2b00      	cmp	r3, #0
3401a30e:	d007      	beq.n	3401a320 <LL_Convacc_Init+0x528>
    p_top = p_bot = p_left = p_right = 0;
3401a310:	2300      	movs	r3, #0
3401a312:	61fb      	str	r3, [r7, #28]
3401a314:	69fb      	ldr	r3, [r7, #28]
3401a316:	623b      	str	r3, [r7, #32]
3401a318:	6a3b      	ldr	r3, [r7, #32]
3401a31a:	627b      	str	r3, [r7, #36]	@ 0x24
3401a31c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401a31e:	62bb      	str	r3, [r7, #40]	@ 0x28
#endif
#if defined(ATON_CONVACC_ZFBIAS_SET)
  // no pad mode available if zfbias is set
  // will accomodate padding only with zframe below
  if (conf->zfbias != 0)
3401a320:	683b      	ldr	r3, [r7, #0]
3401a322:	f9b3 3038 	ldrsh.w	r3, [r3, #56]	@ 0x38
3401a326:	2b00      	cmp	r3, #0
3401a328:	d007      	beq.n	3401a33a <LL_Convacc_Init+0x542>
    p_top = p_bot = p_left = p_right = 0;
3401a32a:	2300      	movs	r3, #0
3401a32c:	61fb      	str	r3, [r7, #28]
3401a32e:	69fb      	ldr	r3, [r7, #28]
3401a330:	623b      	str	r3, [r7, #32]
3401a332:	6a3b      	ldr	r3, [r7, #32]
3401a334:	627b      	str	r3, [r7, #36]	@ 0x24
3401a336:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401a338:	62bb      	str	r3, [r7, #40]	@ 0x28
#endif

  int z_top = (conf->top_padding - p_top);
3401a33a:	683b      	ldr	r3, [r7, #0]
3401a33c:	8b9b      	ldrh	r3, [r3, #28]
3401a33e:	461a      	mov	r2, r3
3401a340:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401a342:	1ad3      	subs	r3, r2, r3
3401a344:	61bb      	str	r3, [r7, #24]
  int z_bot = (conf->bot_padding - p_bot);
3401a346:	683b      	ldr	r3, [r7, #0]
3401a348:	8bdb      	ldrh	r3, [r3, #30]
3401a34a:	461a      	mov	r2, r3
3401a34c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401a34e:	1ad3      	subs	r3, r2, r3
3401a350:	617b      	str	r3, [r7, #20]
  int z_left = (conf->left_padding - p_left);
3401a352:	683b      	ldr	r3, [r7, #0]
3401a354:	8b1b      	ldrh	r3, [r3, #24]
3401a356:	461a      	mov	r2, r3
3401a358:	6a3b      	ldr	r3, [r7, #32]
3401a35a:	1ad3      	subs	r3, r2, r3
3401a35c:	613b      	str	r3, [r7, #16]
  int z_right = (conf->right_padding - p_right);
3401a35e:	683b      	ldr	r3, [r7, #0]
3401a360:	8b5b      	ldrh	r3, [r3, #26]
3401a362:	461a      	mov	r2, r3
3401a364:	69fb      	ldr	r3, [r7, #28]
3401a366:	1ad3      	subs	r3, r2, r3
3401a368:	60fb      	str	r3, [r7, #12]
  // LL_ATON_PRINTF("z_t=%d z_b=%d z_l=%d z_r=%d\n",z_top,z_bot,z_left*conf->batchDepth,z_right*conf->batchDepth);

  t = ATON_CONVACC_ZFRAME_DT;
3401a36a:	2300      	movs	r3, #0
3401a36c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_ZFRAME_SET_TOP(t, z_top);
3401a36e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a370:	f423 027f 	bic.w	r2, r3, #16711680	@ 0xff0000
3401a374:	69bb      	ldr	r3, [r7, #24]
3401a376:	041b      	lsls	r3, r3, #16
3401a378:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
3401a37c:	4313      	orrs	r3, r2
3401a37e:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_ZFRAME_SET_BOTTOM(t, z_bot);
3401a380:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a382:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
3401a386:	697b      	ldr	r3, [r7, #20]
3401a388:	061b      	lsls	r3, r3, #24
3401a38a:	4313      	orrs	r3, r2
3401a38c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_ZFRAME_SET_LEFT(t, z_left * conf->batchDepth);
3401a38e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a390:	f023 02ff 	bic.w	r2, r3, #255	@ 0xff
3401a394:	683b      	ldr	r3, [r7, #0]
3401a396:	8a9b      	ldrh	r3, [r3, #20]
3401a398:	4619      	mov	r1, r3
3401a39a:	693b      	ldr	r3, [r7, #16]
3401a39c:	fb01 f303 	mul.w	r3, r1, r3
3401a3a0:	b2db      	uxtb	r3, r3
3401a3a2:	4313      	orrs	r3, r2
3401a3a4:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_ZFRAME_SET_RIGHT(t, z_right * conf->batchDepth);
3401a3a6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a3a8:	f423 427f 	bic.w	r2, r3, #65280	@ 0xff00
3401a3ac:	683b      	ldr	r3, [r7, #0]
3401a3ae:	8a9b      	ldrh	r3, [r3, #20]
3401a3b0:	4619      	mov	r1, r3
3401a3b2:	68fb      	ldr	r3, [r7, #12]
3401a3b4:	fb01 f303 	mul.w	r3, r1, r3
3401a3b8:	021b      	lsls	r3, r3, #8
3401a3ba:	b29b      	uxth	r3, r3
3401a3bc:	4313      	orrs	r3, r2
3401a3be:	62fb      	str	r3, [r7, #44]	@ 0x2c
  ATON_CONVACC_ZFRAME_SET(id, t);
3401a3c0:	687b      	ldr	r3, [r7, #4]
3401a3c2:	031a      	lsls	r2, r3, #12
3401a3c4:	4b68      	ldr	r3, [pc, #416]	@ (3401a568 <LL_Convacc_Init+0x770>)
3401a3c6:	4413      	add	r3, r2
3401a3c8:	461a      	mov	r2, r3
3401a3ca:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a3cc:	6013      	str	r3, [r2, #0]

  t = ATON_CONVACC_SAMPLE_DT;
3401a3ce:	f44f 5388 	mov.w	r3, #4352	@ 0x1100
3401a3d2:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_SAMPLE_SET_TPAD(t, p_top);
3401a3d4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a3d6:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
3401a3da:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401a3dc:	011b      	lsls	r3, r3, #4
3401a3de:	f003 0330 	and.w	r3, r3, #48	@ 0x30
3401a3e2:	4313      	orrs	r3, r2
3401a3e4:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_SAMPLE_SET_BPAD(t, p_bot);
3401a3e6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a3e8:	f023 02c0 	bic.w	r2, r3, #192	@ 0xc0
3401a3ec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401a3ee:	019b      	lsls	r3, r3, #6
3401a3f0:	b2db      	uxtb	r3, r3
3401a3f2:	4313      	orrs	r3, r2
3401a3f4:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_SAMPLE_SET_LPAD(t, p_left);
3401a3f6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a3f8:	f023 0203 	bic.w	r2, r3, #3
3401a3fc:	6a3b      	ldr	r3, [r7, #32]
3401a3fe:	f003 0303 	and.w	r3, r3, #3
3401a402:	4313      	orrs	r3, r2
3401a404:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_SAMPLE_SET_RPAD(t, p_right);
3401a406:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a408:	f023 020c 	bic.w	r2, r3, #12
3401a40c:	69fb      	ldr	r3, [r7, #28]
3401a40e:	009b      	lsls	r3, r3, #2
3401a410:	f003 030c 	and.w	r3, r3, #12
3401a414:	4313      	orrs	r3, r2
3401a416:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_SAMPLE_SET_HSTRD(t, conf->hstride);
3401a418:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a41a:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
3401a41e:	683b      	ldr	r3, [r7, #0]
3401a420:	7d9b      	ldrb	r3, [r3, #22]
3401a422:	021b      	lsls	r3, r3, #8
3401a424:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
3401a428:	4313      	orrs	r3, r2
3401a42a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  t = ATON_CONVACC_SAMPLE_SET_VSTRD(t, conf->vstride);
3401a42c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a42e:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
3401a432:	683b      	ldr	r3, [r7, #0]
3401a434:	7ddb      	ldrb	r3, [r3, #23]
3401a436:	031b      	lsls	r3, r3, #12
3401a438:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
3401a43c:	4313      	orrs	r3, r2
3401a43e:	62fb      	str	r3, [r7, #44]	@ 0x2c
#if defined(ATON_CONVACC_SAMPLE_SET_FSTATCNT)
  if (conf->fstat != 0)
3401a440:	683b      	ldr	r3, [r7, #0]
3401a442:	789b      	ldrb	r3, [r3, #2]
3401a444:	f003 0302 	and.w	r3, r3, #2
3401a448:	b2db      	uxtb	r3, r3
3401a44a:	2b00      	cmp	r3, #0
3401a44c:	d006      	beq.n	3401a45c <LL_Convacc_Init+0x664>
    t = ATON_CONVACC_SAMPLE_SET_FSTATCNT(t, conf->fstatcnt);
3401a44e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a450:	b29a      	uxth	r2, r3
3401a452:	683b      	ldr	r3, [r7, #0]
3401a454:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3401a456:	041b      	lsls	r3, r3, #16
3401a458:	4313      	orrs	r3, r2
3401a45a:	62fb      	str	r3, [r7, #44]	@ 0x2c
#endif
  ATON_CONVACC_SAMPLE_SET(id, t);
3401a45c:	687b      	ldr	r3, [r7, #4]
3401a45e:	031a      	lsls	r2, r3, #12
3401a460:	4b42      	ldr	r3, [pc, #264]	@ (3401a56c <LL_Convacc_Init+0x774>)
3401a462:	4413      	add	r3, r2
3401a464:	461a      	mov	r2, r3
3401a466:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a468:	6013      	str	r3, [r2, #0]

  // LL_ATON_PRINTF("crop_t=%d crop_b=%d crop_l=%d crop_r=%d\n",z_top,z_bot,z_left,z_right);
  t = ATON_CONVACC_FHCROP_DT;
3401a46a:	4b41      	ldr	r3, [pc, #260]	@ (3401a570 <LL_Convacc_Init+0x778>)
3401a46c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  if (conf->left_crop > 0)
3401a46e:	683b      	ldr	r3, [r7, #0]
3401a470:	8c1b      	ldrh	r3, [r3, #32]
3401a472:	2b00      	cmp	r3, #0
3401a474:	d00c      	beq.n	3401a490 <LL_Convacc_Init+0x698>
    t = ATON_CONVACC_FHCROP_SET_LEFT(t, conf->left_crop * conf->batchDepth);
3401a476:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a478:	0c1b      	lsrs	r3, r3, #16
3401a47a:	041b      	lsls	r3, r3, #16
3401a47c:	683a      	ldr	r2, [r7, #0]
3401a47e:	8c12      	ldrh	r2, [r2, #32]
3401a480:	4611      	mov	r1, r2
3401a482:	683a      	ldr	r2, [r7, #0]
3401a484:	8a92      	ldrh	r2, [r2, #20]
3401a486:	fb01 f202 	mul.w	r2, r1, r2
3401a48a:	b292      	uxth	r2, r2
3401a48c:	4313      	orrs	r3, r2
3401a48e:	62fb      	str	r3, [r7, #44]	@ 0x2c
  if (conf->right_crop > 0)
3401a490:	683b      	ldr	r3, [r7, #0]
3401a492:	8c5b      	ldrh	r3, [r3, #34]	@ 0x22
3401a494:	2b00      	cmp	r3, #0
3401a496:	d00f      	beq.n	3401a4b8 <LL_Convacc_Init+0x6c0>
    t = ATON_CONVACC_FHCROP_SET_RIGHT(t, conf->right_crop * conf->batchDepth + (conf->batchDepth - 1));
3401a498:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a49a:	b29a      	uxth	r2, r3
3401a49c:	683b      	ldr	r3, [r7, #0]
3401a49e:	8c5b      	ldrh	r3, [r3, #34]	@ 0x22
3401a4a0:	4619      	mov	r1, r3
3401a4a2:	683b      	ldr	r3, [r7, #0]
3401a4a4:	8a9b      	ldrh	r3, [r3, #20]
3401a4a6:	fb03 f101 	mul.w	r1, r3, r1
3401a4aa:	683b      	ldr	r3, [r7, #0]
3401a4ac:	8a9b      	ldrh	r3, [r3, #20]
3401a4ae:	3b01      	subs	r3, #1
3401a4b0:	440b      	add	r3, r1
3401a4b2:	041b      	lsls	r3, r3, #16
3401a4b4:	4313      	orrs	r3, r2
3401a4b6:	62fb      	str	r3, [r7, #44]	@ 0x2c
  ATON_CONVACC_FHCROP_SET(id, t);
3401a4b8:	687b      	ldr	r3, [r7, #4]
3401a4ba:	031a      	lsls	r2, r3, #12
3401a4bc:	4b2d      	ldr	r3, [pc, #180]	@ (3401a574 <LL_Convacc_Init+0x77c>)
3401a4be:	4413      	add	r3, r2
3401a4c0:	461a      	mov	r2, r3
3401a4c2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a4c4:	6013      	str	r3, [r2, #0]

  t = ATON_CONVACC_FVCROP_DT;
3401a4c6:	4b2a      	ldr	r3, [pc, #168]	@ (3401a570 <LL_Convacc_Init+0x778>)
3401a4c8:	62fb      	str	r3, [r7, #44]	@ 0x2c
  if (conf->top_crop > 0)
3401a4ca:	683b      	ldr	r3, [r7, #0]
3401a4cc:	8c9b      	ldrh	r3, [r3, #36]	@ 0x24
3401a4ce:	2b00      	cmp	r3, #0
3401a4d0:	d006      	beq.n	3401a4e0 <LL_Convacc_Init+0x6e8>
    t = ATON_CONVACC_FVCROP_SET_TOP(t, conf->top_crop);
3401a4d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a4d4:	0c1b      	lsrs	r3, r3, #16
3401a4d6:	041b      	lsls	r3, r3, #16
3401a4d8:	683a      	ldr	r2, [r7, #0]
3401a4da:	8c92      	ldrh	r2, [r2, #36]	@ 0x24
3401a4dc:	4313      	orrs	r3, r2
3401a4de:	62fb      	str	r3, [r7, #44]	@ 0x2c
  if (conf->bot_crop > 0)
3401a4e0:	683b      	ldr	r3, [r7, #0]
3401a4e2:	8cdb      	ldrh	r3, [r3, #38]	@ 0x26
3401a4e4:	2b00      	cmp	r3, #0
3401a4e6:	d006      	beq.n	3401a4f6 <LL_Convacc_Init+0x6fe>
    t = ATON_CONVACC_FVCROP_SET_BOTTOM(t, conf->bot_crop);
3401a4e8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a4ea:	b29a      	uxth	r2, r3
3401a4ec:	683b      	ldr	r3, [r7, #0]
3401a4ee:	8cdb      	ldrh	r3, [r3, #38]	@ 0x26
3401a4f0:	041b      	lsls	r3, r3, #16
3401a4f2:	4313      	orrs	r3, r2
3401a4f4:	62fb      	str	r3, [r7, #44]	@ 0x2c
  ATON_CONVACC_FVCROP_SET(id, t);
3401a4f6:	687b      	ldr	r3, [r7, #4]
3401a4f8:	031a      	lsls	r2, r3, #12
3401a4fa:	4b1f      	ldr	r3, [pc, #124]	@ (3401a578 <LL_Convacc_Init+0x780>)
3401a4fc:	4413      	add	r3, r2
3401a4fe:	461a      	mov	r2, r3
3401a500:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a502:	6013      	str	r3, [r2, #0]
  // LL_ATON_PRINTF("c_t=%d c_b=%d c_l=%d c_r=%d\n",conf->top_crop,conf->bot_crop,conf->left_crop  *
  // conf->batchDepth,conf->right_crop  * conf->batchDepth + (conf->batchDepth - 1));

#if defined(ATON_CONVACC_FSUB_SET)
  if (conf->fsub != 0)
3401a504:	683b      	ldr	r3, [r7, #0]
3401a506:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3401a508:	2b00      	cmp	r3, #0
3401a50a:	d011      	beq.n	3401a530 <LL_Convacc_Init+0x738>
  {
    t = ATON_CONVACC_FSUB_DT;
3401a50c:	2300      	movs	r3, #0
3401a50e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    t = ATON_CONVACC_FSUB_SET_FSUB(t, conf->fsub);
3401a510:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a512:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
3401a516:	683b      	ldr	r3, [r7, #0]
3401a518:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3401a51a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3401a51e:	4313      	orrs	r3, r2
3401a520:	62fb      	str	r3, [r7, #44]	@ 0x2c
    ATON_CONVACC_FSUB_SET(id, t);
3401a522:	687b      	ldr	r3, [r7, #4]
3401a524:	031a      	lsls	r2, r3, #12
3401a526:	4b15      	ldr	r3, [pc, #84]	@ (3401a57c <LL_Convacc_Init+0x784>)
3401a528:	4413      	add	r3, r2
3401a52a:	461a      	mov	r2, r3
3401a52c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a52e:	6013      	str	r3, [r2, #0]
  }
#endif
#if defined(ATON_CONVACC_ZFBIAS_SET)
  t = ATON_CONVACC_ZFBIAS_DT;
3401a530:	2300      	movs	r3, #0
3401a532:	62fb      	str	r3, [r7, #44]	@ 0x2c
  if (conf->zfbias != 0)
3401a534:	683b      	ldr	r3, [r7, #0]
3401a536:	f9b3 3038 	ldrsh.w	r3, [r3, #56]	@ 0x38
3401a53a:	2b00      	cmp	r3, #0
3401a53c:	d008      	beq.n	3401a550 <LL_Convacc_Init+0x758>
  {
    t = ATON_CONVACC_ZFBIAS_SET_ZFBIAS(t, conf->zfbias);
3401a53e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a540:	0c1b      	lsrs	r3, r3, #16
3401a542:	041b      	lsls	r3, r3, #16
3401a544:	683a      	ldr	r2, [r7, #0]
3401a546:	f9b2 2038 	ldrsh.w	r2, [r2, #56]	@ 0x38
3401a54a:	b292      	uxth	r2, r2
3401a54c:	4313      	orrs	r3, r2
3401a54e:	62fb      	str	r3, [r7, #44]	@ 0x2c
#if defined(ATON_CONVACC_ZFBIAS_SET_ZFLEFTMSB)
  t = ATON_CONVACC_ZFBIAS_SET_ZFLEFTMSB(t, (z_left * conf->batchDepth) >> ATON_CONVACC_ZFRAME_LEFT_W);
  t = ATON_CONVACC_ZFBIAS_SET_ZFRIGHTMSB(t, (z_right * conf->batchDepth) >> ATON_CONVACC_ZFRAME_RIGHT_W);
#endif

  ATON_CONVACC_ZFBIAS_SET(id, t);
3401a550:	687b      	ldr	r3, [r7, #4]
3401a552:	031a      	lsls	r2, r3, #12
3401a554:	4b0a      	ldr	r3, [pc, #40]	@ (3401a580 <LL_Convacc_Init+0x788>)
3401a556:	4413      	add	r3, r2
3401a558:	461a      	mov	r2, r3
3401a55a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401a55c:	6013      	str	r3, [r2, #0]
#endif

  return 0;
3401a55e:	2300      	movs	r3, #0
}
3401a560:	4618      	mov	r0, r3
3401a562:	3730      	adds	r7, #48	@ 0x30
3401a564:	46bd      	mov	sp, r7
3401a566:	bd80      	pop	{r7, pc}
3401a568:	580ef028 	.word	0x580ef028
3401a56c:	580ef00c 	.word	0x580ef00c
3401a570:	ffff0000 	.word	0xffff0000
3401a574:	580ef018 	.word	0x580ef018
3401a578:	580ef01c 	.word	0x580ef01c
3401a57c:	580ef030 	.word	0x580ef030
3401a580:	580ef034 	.word	0x580ef034

3401a584 <LL_EpochCtrl_Init>:
 * @param  id Epoch Controller identifier [0..ATON_EPOCHCTRL_NUM-1]
 * @param  conf Structure describing Epoch Controller initialization parameters
 * @retval Error code
 */
int LL_EpochCtrl_Init(int id, const LL_EpochCtrl_InitTypeDef *conf)
{
3401a584:	b580      	push	{r7, lr}
3401a586:	b084      	sub	sp, #16
3401a588:	af00      	add	r7, sp, #0
3401a58a:	6078      	str	r0, [r7, #4]
3401a58c:	6039      	str	r1, [r7, #0]
  uint32_t t;

  if (id >= ATON_EPOCHCTRL_NUM)
3401a58e:	687b      	ldr	r3, [r7, #4]
3401a590:	2b00      	cmp	r3, #0
3401a592:	dd02      	ble.n	3401a59a <LL_EpochCtrl_Init+0x16>
    return LL_ATON_INVALID_ID;
3401a594:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
3401a598:	e024      	b.n	3401a5e4 <LL_EpochCtrl_Init+0x60>

  LL_ATON_EnableClock(ATON_EPOCHCTRL_CLKB_CLK(id));
3401a59a:	687b      	ldr	r3, [r7, #4]
3401a59c:	3319      	adds	r3, #25
3401a59e:	4618      	mov	r0, r3
3401a5a0:	f000 f828 	bl	3401a5f4 <LL_ATON_EnableClock>

  /* Configure CTRL register */
  t = ATON_EPOCHCTRL_CTRL_DT;
3401a5a4:	2300      	movs	r3, #0
3401a5a6:	60fb      	str	r3, [r7, #12]
  t = ATON_EPOCHCTRL_CTRL_SET_SM(t, conf->stepmode);
3401a5a8:	68fb      	ldr	r3, [r7, #12]
3401a5aa:	f023 0208 	bic.w	r2, r3, #8
3401a5ae:	683b      	ldr	r3, [r7, #0]
3401a5b0:	791b      	ldrb	r3, [r3, #4]
3401a5b2:	f3c3 0300 	ubfx	r3, r3, #0, #1
3401a5b6:	b2db      	uxtb	r3, r3
3401a5b8:	00db      	lsls	r3, r3, #3
3401a5ba:	f003 0308 	and.w	r3, r3, #8
3401a5be:	4313      	orrs	r3, r2
3401a5c0:	60fb      	str	r3, [r7, #12]
  ATON_EPOCHCTRL_CTRL_SET(id, t);
3401a5c2:	4a0a      	ldr	r2, [pc, #40]	@ (3401a5ec <LL_EpochCtrl_Init+0x68>)
3401a5c4:	68fb      	ldr	r3, [r7, #12]
3401a5c6:	6013      	str	r3, [r2, #0]

  /* Check address is 8 byte aligned */
  if (conf->blobaddr & 0x7)
3401a5c8:	683b      	ldr	r3, [r7, #0]
3401a5ca:	681b      	ldr	r3, [r3, #0]
3401a5cc:	f003 0307 	and.w	r3, r3, #7
3401a5d0:	2b00      	cmp	r3, #0
3401a5d2:	d002      	beq.n	3401a5da <LL_EpochCtrl_Init+0x56>
    return LL_ATON_INVALID_PARAM;
3401a5d4:	f06f 0301 	mvn.w	r3, #1
3401a5d8:	e004      	b.n	3401a5e4 <LL_EpochCtrl_Init+0x60>

  ATON_EPOCHCTRL_ADDR_SET(id, conf->blobaddr);
3401a5da:	4a05      	ldr	r2, [pc, #20]	@ (3401a5f0 <LL_EpochCtrl_Init+0x6c>)
3401a5dc:	683b      	ldr	r3, [r7, #0]
3401a5de:	681b      	ldr	r3, [r3, #0]
3401a5e0:	6013      	str	r3, [r2, #0]

  return LL_ATON_OK;
3401a5e2:	2300      	movs	r3, #0
}
3401a5e4:	4618      	mov	r0, r3
3401a5e6:	3710      	adds	r7, #16
3401a5e8:	46bd      	mov	sp, r7
3401a5ea:	bd80      	pop	{r7, pc}
3401a5ec:	580fe000 	.word	0x580fe000
3401a5f0:	580fe008 	.word	0x580fe008

3401a5f4 <LL_ATON_EnableClock>:
  return bloblines * 4;
}
#endif // ATON_EPOCHCTRL_NUM

void LL_ATON_EnableClock(unsigned int clock)
{
3401a5f4:	b490      	push	{r4, r7}
3401a5f6:	b084      	sub	sp, #16
3401a5f8:	af00      	add	r7, sp, #0
3401a5fa:	6078      	str	r0, [r7, #4]
#if (LL_ATON_ENABLE_CLOCK_GATING == 1)
  ATON_REG_WRITE_FIELD_RANGE(CLKCTRL, 0, BGATES, clock, 1, 1);
3401a5fc:	4b13      	ldr	r3, [pc, #76]	@ (3401a64c <LL_ATON_EnableClock+0x58>)
3401a5fe:	681b      	ldr	r3, [r3, #0]
3401a600:	60fb      	str	r3, [r7, #12]
3401a602:	f04f 0201 	mov.w	r2, #1
3401a606:	f04f 0300 	mov.w	r3, #0
3401a60a:	6879      	ldr	r1, [r7, #4]
3401a60c:	ea52 130d 	orrs.w	r3, r2, sp, lsl #4
3401a610:	4613      	mov	r3, r2
3401a612:	43da      	mvns	r2, r3
3401a614:	68fb      	ldr	r3, [r7, #12]
3401a616:	ea02 0103 	and.w	r1, r2, r3
3401a61a:	2201      	movs	r2, #1
3401a61c:	687b      	ldr	r3, [r7, #4]
3401a61e:	fa02 f303 	lsl.w	r3, r2, r3
3401a622:	461c      	mov	r4, r3
3401a624:	f04f 0201 	mov.w	r2, #1
3401a628:	f04f 0300 	mov.w	r3, #0
3401a62c:	6878      	ldr	r0, [r7, #4]
3401a62e:	ea52 030d 	orrs.w	r3, r2, sp
3401a632:	4613      	mov	r3, r2
3401a634:	4023      	ands	r3, r4
3401a636:	430b      	orrs	r3, r1
3401a638:	60fb      	str	r3, [r7, #12]
3401a63a:	4a04      	ldr	r2, [pc, #16]	@ (3401a64c <LL_ATON_EnableClock+0x58>)
3401a63c:	68fb      	ldr	r3, [r7, #12]
3401a63e:	6013      	str	r3, [r2, #0]
#endif
}
3401a640:	bf00      	nop
3401a642:	3710      	adds	r7, #16
3401a644:	46bd      	mov	sp, r7
3401a646:	bc90      	pop	{r4, r7}
3401a648:	4770      	bx	lr
3401a64a:	bf00      	nop
3401a64c:	580e0010 	.word	0x580e0010

3401a650 <LL_ATON_DisableClock>:

void LL_ATON_DisableClock(unsigned int clock)
{
3401a650:	b480      	push	{r7}
3401a652:	b085      	sub	sp, #20
3401a654:	af00      	add	r7, sp, #0
3401a656:	6078      	str	r0, [r7, #4]
#if (LL_ATON_ENABLE_CLOCK_GATING == 1)
  ATON_REG_WRITE_FIELD_RANGE(CLKCTRL, 0, BGATES, clock, 1, 0);
3401a658:	4b0b      	ldr	r3, [pc, #44]	@ (3401a688 <LL_ATON_DisableClock+0x38>)
3401a65a:	681b      	ldr	r3, [r3, #0]
3401a65c:	60fb      	str	r3, [r7, #12]
3401a65e:	f04f 0201 	mov.w	r2, #1
3401a662:	f04f 0300 	mov.w	r3, #0
3401a666:	6879      	ldr	r1, [r7, #4]
3401a668:	ea52 130d 	orrs.w	r3, r2, sp, lsl #4
3401a66c:	4613      	mov	r3, r2
3401a66e:	43db      	mvns	r3, r3
3401a670:	68fa      	ldr	r2, [r7, #12]
3401a672:	4013      	ands	r3, r2
3401a674:	60fb      	str	r3, [r7, #12]
3401a676:	4a04      	ldr	r2, [pc, #16]	@ (3401a688 <LL_ATON_DisableClock+0x38>)
3401a678:	68fb      	ldr	r3, [r7, #12]
3401a67a:	6013      	str	r3, [r2, #0]
#endif
}
3401a67c:	bf00      	nop
3401a67e:	3714      	adds	r7, #20
3401a680:	46bd      	mov	sp, r7
3401a682:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a686:	4770      	bx	lr
3401a688:	580e0010 	.word	0x580e0010

3401a68c <LL_ATON_RT_Main>:
 *                         and the network interface, or macros
 *                         `LL_ATON_DECLARE_NAMED_NN_INTERFACE()` & `LL_ATON_DECLARE_NAMED_NN_INSTANCE()` to
 *                         create/instantiate the objects separately.
 */
void LL_ATON_RT_Main(NN_Instance_TypeDef *network_instance)
{
3401a68c:	b580      	push	{r7, lr}
3401a68e:	b084      	sub	sp, #16
3401a690:	af00      	add	r7, sp, #0
3401a692:	6078      	str	r0, [r7, #4]

  /*** Start of user initialization code ***/

  /*** End of user initialization code ***/

  LL_ATON_ASSERT(network_instance != NULL);
3401a694:	687b      	ldr	r3, [r7, #4]
3401a696:	2b00      	cmp	r3, #0
3401a698:	d105      	bne.n	3401a6a6 <LL_ATON_RT_Main+0x1a>
3401a69a:	4b16      	ldr	r3, [pc, #88]	@ (3401a6f4 <LL_ATON_RT_Main+0x68>)
3401a69c:	4a16      	ldr	r2, [pc, #88]	@ (3401a6f8 <LL_ATON_RT_Main+0x6c>)
3401a69e:	213c      	movs	r1, #60	@ 0x3c
3401a6a0:	4816      	ldr	r0, [pc, #88]	@ (3401a6fc <LL_ATON_RT_Main+0x70>)
3401a6a2:	f001 f893 	bl	3401b7cc <__assert_func>
  LL_ATON_ASSERT(network_instance->network != NULL);
3401a6a6:	687b      	ldr	r3, [r7, #4]
3401a6a8:	681b      	ldr	r3, [r3, #0]
3401a6aa:	2b00      	cmp	r3, #0
3401a6ac:	d105      	bne.n	3401a6ba <LL_ATON_RT_Main+0x2e>
3401a6ae:	4b14      	ldr	r3, [pc, #80]	@ (3401a700 <LL_ATON_RT_Main+0x74>)
3401a6b0:	4a11      	ldr	r2, [pc, #68]	@ (3401a6f8 <LL_ATON_RT_Main+0x6c>)
3401a6b2:	213d      	movs	r1, #61	@ 0x3d
3401a6b4:	4811      	ldr	r0, [pc, #68]	@ (3401a6fc <LL_ATON_RT_Main+0x70>)
3401a6b6:	f001 f889 	bl	3401b7cc <__assert_func>
  LL_ATON_RT_RuntimeInit();                  // Initialize runtime
3401a6ba:	f000 fd13 	bl	3401b0e4 <LL_ATON_RT_RuntimeInit>
  LL_ATON_RT_Init_Network(network_instance); // Initialize passed network instance object
3401a6be:	6878      	ldr	r0, [r7, #4]
3401a6c0:	f000 fc98 	bl	3401aff4 <LL_ATON_RT_Init_Network>
  size_t epochCount = 0;
3401a6c4:	2300      	movs	r3, #0
3401a6c6:	60fb      	str	r3, [r7, #12]
  do
  {
    /* Execute first/next step of Cube.AI/ATON runtime */
    ll_aton_rt_ret = LL_ATON_RT_RunEpochBlock(network_instance);
3401a6c8:	6878      	ldr	r0, [r7, #4]
3401a6ca:	f000 fd83 	bl	3401b1d4 <LL_ATON_RT_RunEpochBlock>
3401a6ce:	4603      	mov	r3, r0
3401a6d0:	72fb      	strb	r3, [r7, #11]
    /*** Start of user event handling code ***/

    /*** End of user event handling code ***/

    /* Wait for next event */
    if (ll_aton_rt_ret == LL_ATON_RT_WFE)
3401a6d2:	7afb      	ldrb	r3, [r7, #11]
3401a6d4:	2b01      	cmp	r3, #1
3401a6d6:	d100      	bne.n	3401a6da <LL_ATON_RT_Main+0x4e>
    { /*** subject to change to fit also user code requirements ***/
      LL_ATON_OSAL_WFE();
3401a6d8:	bf20      	wfe
    }
//    printf("Epoch: %5d, Return: %d\n\r", epochCount, ll_aton_rt_ret);
//    epochCount++;
  } while (ll_aton_rt_ret != LL_ATON_RT_DONE); /*** subject to change to fit also user code requirements ***/
3401a6da:	7afb      	ldrb	r3, [r7, #11]
3401a6dc:	2b02      	cmp	r3, #2
3401a6de:	d1f3      	bne.n	3401a6c8 <LL_ATON_RT_Main+0x3c>

  LL_ATON_RT_DeInit_Network(network_instance); // De-initialize the network instance object
3401a6e0:	6878      	ldr	r0, [r7, #4]
3401a6e2:	f000 fcc1 	bl	3401b068 <LL_ATON_RT_DeInit_Network>
  LL_ATON_RT_RuntimeDeInit();                  // De-initialize runtime
3401a6e6:	f000 fd59 	bl	3401b19c <LL_ATON_RT_RuntimeDeInit>

  /*** Start of user de-initialization code ***/

  /*** End of user de-initialization code ***/
}
3401a6ea:	bf00      	nop
3401a6ec:	3710      	adds	r7, #16
3401a6ee:	46bd      	mov	sp, r7
3401a6f0:	bd80      	pop	{r7, pc}
3401a6f2:	bf00      	nop
3401a6f4:	3401f51c 	.word	0x3401f51c
3401a6f8:	34020044 	.word	0x34020044
3401a6fc:	3401f53c 	.word	0x3401f53c
3401a700:	3401f5d4 	.word	0x3401f5d4

3401a704 <__NVIC_EnableIRQ>:
{
3401a704:	b480      	push	{r7}
3401a706:	b083      	sub	sp, #12
3401a708:	af00      	add	r7, sp, #0
3401a70a:	4603      	mov	r3, r0
3401a70c:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
3401a70e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3401a712:	2b00      	cmp	r3, #0
3401a714:	db0b      	blt.n	3401a72e <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
3401a716:	88fb      	ldrh	r3, [r7, #6]
3401a718:	f003 021f 	and.w	r2, r3, #31
3401a71c:	4907      	ldr	r1, [pc, #28]	@ (3401a73c <__NVIC_EnableIRQ+0x38>)
3401a71e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3401a722:	095b      	lsrs	r3, r3, #5
3401a724:	2001      	movs	r0, #1
3401a726:	fa00 f202 	lsl.w	r2, r0, r2
3401a72a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
3401a72e:	bf00      	nop
3401a730:	370c      	adds	r7, #12
3401a732:	46bd      	mov	sp, r7
3401a734:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a738:	4770      	bx	lr
3401a73a:	bf00      	nop
3401a73c:	e000e100 	.word	0xe000e100

3401a740 <__NVIC_DisableIRQ>:
{
3401a740:	b480      	push	{r7}
3401a742:	b083      	sub	sp, #12
3401a744:	af00      	add	r7, sp, #0
3401a746:	4603      	mov	r3, r0
3401a748:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
3401a74a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3401a74e:	2b00      	cmp	r3, #0
3401a750:	db12      	blt.n	3401a778 <__NVIC_DisableIRQ+0x38>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
3401a752:	88fb      	ldrh	r3, [r7, #6]
3401a754:	f003 021f 	and.w	r2, r3, #31
3401a758:	490a      	ldr	r1, [pc, #40]	@ (3401a784 <__NVIC_DisableIRQ+0x44>)
3401a75a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3401a75e:	095b      	lsrs	r3, r3, #5
3401a760:	2001      	movs	r0, #1
3401a762:	fa00 f202 	lsl.w	r2, r0, r2
3401a766:	3320      	adds	r3, #32
3401a768:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
3401a76c:	f3bf 8f4f 	dsb	sy
}
3401a770:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
3401a772:	f3bf 8f6f 	isb	sy
}
3401a776:	bf00      	nop
}
3401a778:	bf00      	nop
3401a77a:	370c      	adds	r7, #12
3401a77c:	46bd      	mov	sp, r7
3401a77e:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a782:	4770      	bx	lr
3401a784:	e000e100 	.word	0xe000e100

3401a788 <EpochBlock_IsLastEpochBlock>:
  /**
   * @}
   */

  static inline bool EpochBlock_IsLastEpochBlock(const EpochBlock_ItemTypeDef *eb)
  {
3401a788:	b480      	push	{r7}
3401a78a:	b083      	sub	sp, #12
3401a78c:	af00      	add	r7, sp, #0
3401a78e:	6078      	str	r0, [r7, #4]
    return ((eb->flags & EpochBlock_Flags_last_eb) != 0);
3401a790:	687b      	ldr	r3, [r7, #4]
3401a792:	8a1b      	ldrh	r3, [r3, #16]
3401a794:	f003 0308 	and.w	r3, r3, #8
3401a798:	2b00      	cmp	r3, #0
3401a79a:	bf14      	ite	ne
3401a79c:	2301      	movne	r3, #1
3401a79e:	2300      	moveq	r3, #0
3401a7a0:	b2db      	uxtb	r3, r3
  }
3401a7a2:	4618      	mov	r0, r3
3401a7a4:	370c      	adds	r7, #12
3401a7a6:	46bd      	mov	sp, r7
3401a7a8:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a7ac:	4770      	bx	lr

3401a7ae <EpochBlock_IsEpochStart>:

  static inline bool EpochBlock_IsEpochStart(const EpochBlock_ItemTypeDef *eb)
  {
3401a7ae:	b480      	push	{r7}
3401a7b0:	b083      	sub	sp, #12
3401a7b2:	af00      	add	r7, sp, #0
3401a7b4:	6078      	str	r0, [r7, #4]
    return ((eb->flags & EpochBlock_Flags_epoch_start) != 0);
3401a7b6:	687b      	ldr	r3, [r7, #4]
3401a7b8:	8a1b      	ldrh	r3, [r3, #16]
3401a7ba:	f003 0301 	and.w	r3, r3, #1
3401a7be:	2b00      	cmp	r3, #0
3401a7c0:	bf14      	ite	ne
3401a7c2:	2301      	movne	r3, #1
3401a7c4:	2300      	moveq	r3, #0
3401a7c6:	b2db      	uxtb	r3, r3
  }
3401a7c8:	4618      	mov	r0, r3
3401a7ca:	370c      	adds	r7, #12
3401a7cc:	46bd      	mov	sp, r7
3401a7ce:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a7d2:	4770      	bx	lr

3401a7d4 <EpochBlock_IsEpochBlob>:
  {
    return ((eb->flags & EpochBlock_Flags_epoch_end) != 0);
  }

  static inline bool EpochBlock_IsEpochBlob(const EpochBlock_ItemTypeDef *eb)
  {
3401a7d4:	b480      	push	{r7}
3401a7d6:	b083      	sub	sp, #12
3401a7d8:	af00      	add	r7, sp, #0
3401a7da:	6078      	str	r0, [r7, #4]
    return ((eb->flags & EpochBlock_Flags_blob) != 0);
3401a7dc:	687b      	ldr	r3, [r7, #4]
3401a7de:	8a1b      	ldrh	r3, [r3, #16]
3401a7e0:	f003 0304 	and.w	r3, r3, #4
3401a7e4:	2b00      	cmp	r3, #0
3401a7e6:	bf14      	ite	ne
3401a7e8:	2301      	movne	r3, #1
3401a7ea:	2300      	moveq	r3, #0
3401a7ec:	b2db      	uxtb	r3, r3
  }
3401a7ee:	4618      	mov	r0, r3
3401a7f0:	370c      	adds	r7, #12
3401a7f2:	46bd      	mov	sp, r7
3401a7f4:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a7f8:	4770      	bx	lr

3401a7fa <EpochBlock_IsEpochPureHW>:
  {
    return ((eb->flags & EpochBlock_Flags_pure_sw) != 0);
  }

  static inline bool EpochBlock_IsEpochPureHW(const EpochBlock_ItemTypeDef *eb)
  {
3401a7fa:	b480      	push	{r7}
3401a7fc:	b083      	sub	sp, #12
3401a7fe:	af00      	add	r7, sp, #0
3401a800:	6078      	str	r0, [r7, #4]
    return ((eb->flags & EpochBlock_Flags_pure_hw) != 0);
3401a802:	687b      	ldr	r3, [r7, #4]
3401a804:	8a1b      	ldrh	r3, [r3, #16]
3401a806:	f003 0310 	and.w	r3, r3, #16
3401a80a:	2b00      	cmp	r3, #0
3401a80c:	bf14      	ite	ne
3401a80e:	2301      	movne	r3, #1
3401a810:	2300      	moveq	r3, #0
3401a812:	b2db      	uxtb	r3, r3
  }
3401a814:	4618      	mov	r0, r3
3401a816:	370c      	adds	r7, #12
3401a818:	46bd      	mov	sp, r7
3401a81a:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a81e:	4770      	bx	lr

3401a820 <EpochBlock_IsEpochHybrid>:

  static inline bool EpochBlock_IsEpochHybrid(const EpochBlock_ItemTypeDef *eb)
  {
3401a820:	b480      	push	{r7}
3401a822:	b083      	sub	sp, #12
3401a824:	af00      	add	r7, sp, #0
3401a826:	6078      	str	r0, [r7, #4]
    return ((eb->flags & EpochBlock_Flags_hybrid) != 0);
3401a828:	687b      	ldr	r3, [r7, #4]
3401a82a:	8a1b      	ldrh	r3, [r3, #16]
3401a82c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3401a830:	2b00      	cmp	r3, #0
3401a832:	bf14      	ite	ne
3401a834:	2301      	movne	r3, #1
3401a836:	2300      	moveq	r3, #0
3401a838:	b2db      	uxtb	r3, r3
  }
3401a83a:	4618      	mov	r0, r3
3401a83c:	370c      	adds	r7, #12
3401a83e:	46bd      	mov	sp, r7
3401a840:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a844:	4770      	bx	lr

3401a846 <EpochBlock_IsEpochInternal>:

  static inline bool EpochBlock_IsEpochInternal(const EpochBlock_ItemTypeDef *eb)
  {
3401a846:	b480      	push	{r7}
3401a848:	b083      	sub	sp, #12
3401a84a:	af00      	add	r7, sp, #0
3401a84c:	6078      	str	r0, [r7, #4]
    return ((eb->flags & EpochBlock_Flags_internal) != 0);
3401a84e:	687b      	ldr	r3, [r7, #4]
3401a850:	8a1b      	ldrh	r3, [r3, #16]
3401a852:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3401a856:	2b00      	cmp	r3, #0
3401a858:	bf14      	ite	ne
3401a85a:	2301      	movne	r3, #1
3401a85c:	2300      	moveq	r3, #0
3401a85e:	b2db      	uxtb	r3, r3
  }
3401a860:	4618      	mov	r0, r3
3401a862:	370c      	adds	r7, #12
3401a864:	46bd      	mov	sp, r7
3401a866:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a86a:	4770      	bx	lr

3401a86c <EpochBlock_EpochControllerUnit>:

  static inline uint32_t EpochBlock_EpochControllerUnit(const EpochBlock_ItemTypeDef *eb)
  {
3401a86c:	b580      	push	{r7, lr}
3401a86e:	b082      	sub	sp, #8
3401a870:	af00      	add	r7, sp, #0
3401a872:	6078      	str	r0, [r7, #4]
    LL_ATON_ASSERT(EpochBlock_IsEpochBlob(eb));
3401a874:	6878      	ldr	r0, [r7, #4]
3401a876:	f7ff ffad 	bl	3401a7d4 <EpochBlock_IsEpochBlob>
3401a87a:	4603      	mov	r3, r0
3401a87c:	2b00      	cmp	r3, #0
3401a87e:	d106      	bne.n	3401a88e <EpochBlock_EpochControllerUnit+0x22>
3401a880:	4b06      	ldr	r3, [pc, #24]	@ (3401a89c <EpochBlock_EpochControllerUnit+0x30>)
3401a882:	4a07      	ldr	r2, [pc, #28]	@ (3401a8a0 <EpochBlock_EpochControllerUnit+0x34>)
3401a884:	f240 212f 	movw	r1, #559	@ 0x22f
3401a888:	4806      	ldr	r0, [pc, #24]	@ (3401a8a4 <EpochBlock_EpochControllerUnit+0x38>)
3401a88a:	f000 ff9f 	bl	3401b7cc <__assert_func>
    return eb->wait_mask;
3401a88e:	687b      	ldr	r3, [r7, #4]
3401a890:	68db      	ldr	r3, [r3, #12]
  }
3401a892:	4618      	mov	r0, r3
3401a894:	3708      	adds	r7, #8
3401a896:	46bd      	mov	sp, r7
3401a898:	bd80      	pop	{r7, pc}
3401a89a:	bf00      	nop
3401a89c:	3401f600 	.word	0x3401f600
3401a8a0:	34020164 	.word	0x34020164
3401a8a4:	3401f61c 	.word	0x3401f61c

3401a8a8 <EpochBlock_EpochBlobAddr>:

  static inline uintptr_t EpochBlock_EpochBlobAddr(const EpochBlock_ItemTypeDef *eb)
  {
3401a8a8:	b580      	push	{r7, lr}
3401a8aa:	b082      	sub	sp, #8
3401a8ac:	af00      	add	r7, sp, #0
3401a8ae:	6078      	str	r0, [r7, #4]
    LL_ATON_ASSERT(EpochBlock_IsEpochBlob(eb));
3401a8b0:	6878      	ldr	r0, [r7, #4]
3401a8b2:	f7ff ff8f 	bl	3401a7d4 <EpochBlock_IsEpochBlob>
3401a8b6:	4603      	mov	r3, r0
3401a8b8:	2b00      	cmp	r3, #0
3401a8ba:	d106      	bne.n	3401a8ca <EpochBlock_EpochBlobAddr+0x22>
3401a8bc:	4b06      	ldr	r3, [pc, #24]	@ (3401a8d8 <EpochBlock_EpochBlobAddr+0x30>)
3401a8be:	4a07      	ldr	r2, [pc, #28]	@ (3401a8dc <EpochBlock_EpochBlobAddr+0x34>)
3401a8c0:	f240 2135 	movw	r1, #565	@ 0x235
3401a8c4:	4806      	ldr	r0, [pc, #24]	@ (3401a8e0 <EpochBlock_EpochBlobAddr+0x38>)
3401a8c6:	f000 ff81 	bl	3401b7cc <__assert_func>
    return eb->blob_address;
3401a8ca:	687b      	ldr	r3, [r7, #4]
3401a8cc:	689b      	ldr	r3, [r3, #8]
  }
3401a8ce:	4618      	mov	r0, r3
3401a8d0:	3708      	adds	r7, #8
3401a8d2:	46bd      	mov	sp, r7
3401a8d4:	bd80      	pop	{r7, pc}
3401a8d6:	bf00      	nop
3401a8d8:	3401f600 	.word	0x3401f600
3401a8dc:	34020184 	.word	0x34020184
3401a8e0:	3401f61c 	.word	0x3401f61c

3401a8e4 <__ll_set_aton_owner>:
  typedef EpochBlock_ItemTypeDef LL_ATON_RT_EpochBlockItem_t;

  /*** Helper Functions ***/

  static inline void __ll_set_aton_owner(NN_Instance_TypeDef *new_owner)
  {
3401a8e4:	b580      	push	{r7, lr}
3401a8e6:	b082      	sub	sp, #8
3401a8e8:	af00      	add	r7, sp, #0
3401a8ea:	6078      	str	r0, [r7, #4]
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;
    LL_ATON_ASSERT(new_owner != __ll_current_aton_ip_owner);
3401a8ec:	4b12      	ldr	r3, [pc, #72]	@ (3401a938 <__ll_set_aton_owner+0x54>)
3401a8ee:	681b      	ldr	r3, [r3, #0]
3401a8f0:	687a      	ldr	r2, [r7, #4]
3401a8f2:	429a      	cmp	r2, r3
3401a8f4:	d105      	bne.n	3401a902 <__ll_set_aton_owner+0x1e>
3401a8f6:	4b11      	ldr	r3, [pc, #68]	@ (3401a93c <__ll_set_aton_owner+0x58>)
3401a8f8:	4a11      	ldr	r2, [pc, #68]	@ (3401a940 <__ll_set_aton_owner+0x5c>)
3401a8fa:	2131      	movs	r1, #49	@ 0x31
3401a8fc:	4811      	ldr	r0, [pc, #68]	@ (3401a944 <__ll_set_aton_owner+0x60>)
3401a8fe:	f000 ff65 	bl	3401b7cc <__assert_func>

    LL_ATON_OSAL_LOCK_ATON();

    LL_ATON_ASSERT(__ll_current_aton_ip_owner == NULL);
3401a902:	4b0d      	ldr	r3, [pc, #52]	@ (3401a938 <__ll_set_aton_owner+0x54>)
3401a904:	681b      	ldr	r3, [r3, #0]
3401a906:	2b00      	cmp	r3, #0
3401a908:	d005      	beq.n	3401a916 <__ll_set_aton_owner+0x32>
3401a90a:	4b0f      	ldr	r3, [pc, #60]	@ (3401a948 <__ll_set_aton_owner+0x64>)
3401a90c:	4a0c      	ldr	r2, [pc, #48]	@ (3401a940 <__ll_set_aton_owner+0x5c>)
3401a90e:	2135      	movs	r1, #53	@ 0x35
3401a910:	480c      	ldr	r0, [pc, #48]	@ (3401a944 <__ll_set_aton_owner+0x60>)
3401a912:	f000 ff5b 	bl	3401b7cc <__assert_func>

#ifndef NDEBUG
    extern uint32_t volatile __ll_current_wait_mask;
    LL_ATON_ASSERT(__ll_current_wait_mask == 0);
3401a916:	4b0d      	ldr	r3, [pc, #52]	@ (3401a94c <__ll_set_aton_owner+0x68>)
3401a918:	681b      	ldr	r3, [r3, #0]
3401a91a:	2b00      	cmp	r3, #0
3401a91c:	d005      	beq.n	3401a92a <__ll_set_aton_owner+0x46>
3401a91e:	4b0c      	ldr	r3, [pc, #48]	@ (3401a950 <__ll_set_aton_owner+0x6c>)
3401a920:	4a07      	ldr	r2, [pc, #28]	@ (3401a940 <__ll_set_aton_owner+0x5c>)
3401a922:	2139      	movs	r1, #57	@ 0x39
3401a924:	4807      	ldr	r0, [pc, #28]	@ (3401a944 <__ll_set_aton_owner+0x60>)
3401a926:	f000 ff51 	bl	3401b7cc <__assert_func>
#endif // NDEBUG

    __ll_current_aton_ip_owner = new_owner;
3401a92a:	4a03      	ldr	r2, [pc, #12]	@ (3401a938 <__ll_set_aton_owner+0x54>)
3401a92c:	687b      	ldr	r3, [r7, #4]
3401a92e:	6013      	str	r3, [r2, #0]
  }
3401a930:	bf00      	nop
3401a932:	3708      	adds	r7, #8
3401a934:	46bd      	mov	sp, r7
3401a936:	bd80      	pop	{r7, pc}
3401a938:	340213a4 	.word	0x340213a4
3401a93c:	3401f6bc 	.word	0x3401f6bc
3401a940:	34020134 	.word	0x34020134
3401a944:	3401f6e4 	.word	0x3401f6e4
3401a948:	3401f77c 	.word	0x3401f77c
3401a94c:	340213a8 	.word	0x340213a8
3401a950:	3401f7a8 	.word	0x3401f7a8

3401a954 <__ll_clear_aton_owner>:

  static inline void __ll_clear_aton_owner(NN_Instance_TypeDef *current_owner)
  {
3401a954:	b580      	push	{r7, lr}
3401a956:	b082      	sub	sp, #8
3401a958:	af00      	add	r7, sp, #0
3401a95a:	6078      	str	r0, [r7, #4]
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;
    LL_ATON_ASSERT(current_owner == __ll_current_aton_ip_owner);
3401a95c:	4b0d      	ldr	r3, [pc, #52]	@ (3401a994 <__ll_clear_aton_owner+0x40>)
3401a95e:	681b      	ldr	r3, [r3, #0]
3401a960:	687a      	ldr	r2, [r7, #4]
3401a962:	429a      	cmp	r2, r3
3401a964:	d005      	beq.n	3401a972 <__ll_clear_aton_owner+0x1e>
3401a966:	4b0c      	ldr	r3, [pc, #48]	@ (3401a998 <__ll_clear_aton_owner+0x44>)
3401a968:	4a0c      	ldr	r2, [pc, #48]	@ (3401a99c <__ll_clear_aton_owner+0x48>)
3401a96a:	2142      	movs	r1, #66	@ 0x42
3401a96c:	480c      	ldr	r0, [pc, #48]	@ (3401a9a0 <__ll_clear_aton_owner+0x4c>)
3401a96e:	f000 ff2d 	bl	3401b7cc <__assert_func>

#ifndef NDEBUG
    extern uint32_t volatile __ll_current_wait_mask;
    LL_ATON_ASSERT(__ll_current_wait_mask == 0);
3401a972:	4b0c      	ldr	r3, [pc, #48]	@ (3401a9a4 <__ll_clear_aton_owner+0x50>)
3401a974:	681b      	ldr	r3, [r3, #0]
3401a976:	2b00      	cmp	r3, #0
3401a978:	d005      	beq.n	3401a986 <__ll_clear_aton_owner+0x32>
3401a97a:	4b0b      	ldr	r3, [pc, #44]	@ (3401a9a8 <__ll_clear_aton_owner+0x54>)
3401a97c:	4a07      	ldr	r2, [pc, #28]	@ (3401a99c <__ll_clear_aton_owner+0x48>)
3401a97e:	2146      	movs	r1, #70	@ 0x46
3401a980:	4807      	ldr	r0, [pc, #28]	@ (3401a9a0 <__ll_clear_aton_owner+0x4c>)
3401a982:	f000 ff23 	bl	3401b7cc <__assert_func>
#endif // NDEBUG

    __ll_current_aton_ip_owner = NULL;
3401a986:	4b03      	ldr	r3, [pc, #12]	@ (3401a994 <__ll_clear_aton_owner+0x40>)
3401a988:	2200      	movs	r2, #0
3401a98a:	601a      	str	r2, [r3, #0]
    LL_ATON_OSAL_UNLOCK_ATON();
  }
3401a98c:	bf00      	nop
3401a98e:	3708      	adds	r7, #8
3401a990:	46bd      	mov	sp, r7
3401a992:	bd80      	pop	{r7, pc}
3401a994:	340213a4 	.word	0x340213a4
3401a998:	3401f7c4 	.word	0x3401f7c4
3401a99c:	34020094 	.word	0x34020094
3401a9a0:	3401f6e4 	.word	0x3401f6e4
3401a9a4:	340213a8 	.word	0x340213a8
3401a9a8:	3401f7a8 	.word	0x3401f7a8

3401a9ac <__LL_ATON_RT_Start_AtoNN_Epoch>:
   *  Note: the following function may only be called at the beginning of
   *       `LL_ATON_Start_EpochBlock<n>()` functions, assuming also that at that point
   *       no streaming engine interrupts might trigger (anymore)!
   **/
  static inline void __LL_ATON_RT_Start_AtoNN_Epoch(NN_Instance_TypeDef *nn_instance)
  {
3401a9ac:	b580      	push	{r7, lr}
3401a9ae:	b082      	sub	sp, #8
3401a9b0:	af00      	add	r7, sp, #0
3401a9b2:	6078      	str	r0, [r7, #4]
    LL_ATON_ASSERT(nn_instance != NULL);
3401a9b4:	687b      	ldr	r3, [r7, #4]
3401a9b6:	2b00      	cmp	r3, #0
3401a9b8:	d105      	bne.n	3401a9c6 <__LL_ATON_RT_Start_AtoNN_Epoch+0x1a>
3401a9ba:	4b0a      	ldr	r3, [pc, #40]	@ (3401a9e4 <__LL_ATON_RT_Start_AtoNN_Epoch+0x38>)
3401a9bc:	4a0a      	ldr	r2, [pc, #40]	@ (3401a9e8 <__LL_ATON_RT_Start_AtoNN_Epoch+0x3c>)
3401a9be:	2154      	movs	r1, #84	@ 0x54
3401a9c0:	480a      	ldr	r0, [pc, #40]	@ (3401a9ec <__LL_ATON_RT_Start_AtoNN_Epoch+0x40>)
3401a9c2:	f000 ff03 	bl	3401b7cc <__assert_func>
#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
    LL_ATON_ASSERT(nn_instance->exec_state.triggered_events ==
3401a9c6:	687b      	ldr	r3, [r7, #4]
3401a9c8:	69db      	ldr	r3, [r3, #28]
3401a9ca:	2b00      	cmp	r3, #0
3401a9cc:	d005      	beq.n	3401a9da <__LL_ATON_RT_Start_AtoNN_Epoch+0x2e>
3401a9ce:	4b08      	ldr	r3, [pc, #32]	@ (3401a9f0 <__LL_ATON_RT_Start_AtoNN_Epoch+0x44>)
3401a9d0:	4a05      	ldr	r2, [pc, #20]	@ (3401a9e8 <__LL_ATON_RT_Start_AtoNN_Epoch+0x3c>)
3401a9d2:	2156      	movs	r1, #86	@ 0x56
3401a9d4:	4805      	ldr	r0, [pc, #20]	@ (3401a9ec <__LL_ATON_RT_Start_AtoNN_Epoch+0x40>)
3401a9d6:	f000 fef9 	bl	3401b7cc <__assert_func>
                   0x0); // with the removal of parallel SW/HW epochs execution all triggered events must have been
                         // cleared at this point in time!
#endif
  }
3401a9da:	bf00      	nop
3401a9dc:	3708      	adds	r7, #8
3401a9de:	46bd      	mov	sp, r7
3401a9e0:	bd80      	pop	{r7, pc}
3401a9e2:	bf00      	nop
3401a9e4:	3401f7f0 	.word	0x3401f7f0
3401a9e8:	34020114 	.word	0x34020114
3401a9ec:	3401f6e4 	.word	0x3401f6e4
3401a9f0:	3401f80c 	.word	0x3401f80c

3401a9f4 <__LL_ATON_RT_SetWaitMask>:
    nn_instance->exec_state.current_epoch_block = &nn_instance->exec_state.first_epoch_block[index];
  }

  /* set wait mask(s) in interrupt controller */
  static inline void __LL_ATON_RT_SetWaitMask(uint32_t wait_mask)
  {
3401a9f4:	b580      	push	{r7, lr}
3401a9f6:	b082      	sub	sp, #8
3401a9f8:	af00      	add	r7, sp, #0
3401a9fa:	6078      	str	r0, [r7, #4]
#ifndef NDEBUG
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;
    LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
3401a9fc:	4b0a      	ldr	r3, [pc, #40]	@ (3401aa28 <__LL_ATON_RT_SetWaitMask+0x34>)
3401a9fe:	681b      	ldr	r3, [r3, #0]
3401aa00:	2b00      	cmp	r3, #0
3401aa02:	d105      	bne.n	3401aa10 <__LL_ATON_RT_SetWaitMask+0x1c>
3401aa04:	4b09      	ldr	r3, [pc, #36]	@ (3401aa2c <__LL_ATON_RT_SetWaitMask+0x38>)
3401aa06:	4a0a      	ldr	r2, [pc, #40]	@ (3401aa30 <__LL_ATON_RT_SetWaitMask+0x3c>)
3401aa08:	2175      	movs	r1, #117	@ 0x75
3401aa0a:	480a      	ldr	r0, [pc, #40]	@ (3401aa34 <__LL_ATON_RT_SetWaitMask+0x40>)
3401aa0c:	f000 fede 	bl	3401b7cc <__assert_func>

    extern uint32_t volatile __ll_current_wait_mask;
    __ll_current_wait_mask = wait_mask;
3401aa10:	4a09      	ldr	r2, [pc, #36]	@ (3401aa38 <__LL_ATON_RT_SetWaitMask+0x44>)
3401aa12:	687b      	ldr	r3, [r7, #4]
3401aa14:	6013      	str	r3, [r2, #0]

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
    wait_mask <<= ATON_STRENG_INT(0);
#ifndef LL_ATON_RT_USE_IRQ_OR_MASK
    /* configure interrupt controller AND mask for epoch block */
    ATON_INTCTRL_STD_INTANDMSK_SET(~wait_mask);
3401aa16:	4a09      	ldr	r2, [pc, #36]	@ (3401aa3c <__LL_ATON_RT_SetWaitMask+0x48>)
3401aa18:	687b      	ldr	r3, [r7, #4]
3401aa1a:	43db      	mvns	r3, r3
3401aa1c:	6013      	str	r3, [r2, #0]
                                                                // (all other events & errors are enabled)
    val &= ~wait_mask;
    ATON_INTCTRL_STD_INTORMSK_SET(val);
#endif // LL_ATON_RT_USE_IRQ_OR_MASK
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  }
3401aa1e:	bf00      	nop
3401aa20:	3708      	adds	r7, #8
3401aa22:	46bd      	mov	sp, r7
3401aa24:	bd80      	pop	{r7, pc}
3401aa26:	bf00      	nop
3401aa28:	340213a4 	.word	0x340213a4
3401aa2c:	3401f83c 	.word	0x3401f83c
3401aa30:	34020148 	.word	0x34020148
3401aa34:	3401f6e4 	.word	0x3401f6e4
3401aa38:	340213a8 	.word	0x340213a8
3401aa3c:	580e1024 	.word	0x580e1024

3401aa40 <__LL_ATON_RT_RetFromLibEpochBlockArray>:

  /* return from inserted epoch block */
  static inline void __LL_ATON_RT_RetFromLibEpochBlockArray(bool unlock, NN_Instance_TypeDef *nn_instance)
  {
3401aa40:	b580      	push	{r7, lr}
3401aa42:	b082      	sub	sp, #8
3401aa44:	af00      	add	r7, sp, #0
3401aa46:	4603      	mov	r3, r0
3401aa48:	6039      	str	r1, [r7, #0]
3401aa4a:	71fb      	strb	r3, [r7, #7]
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;

    if (!unlock)
3401aa4c:	79fb      	ldrb	r3, [r7, #7]
3401aa4e:	f083 0301 	eor.w	r3, r3, #1
3401aa52:	b2db      	uxtb	r3, r3
3401aa54:	2b00      	cmp	r3, #0
3401aa56:	d015      	beq.n	3401aa84 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x44>
    {
      LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
3401aa58:	4b38      	ldr	r3, [pc, #224]	@ (3401ab3c <__LL_ATON_RT_RetFromLibEpochBlockArray+0xfc>)
3401aa5a:	681b      	ldr	r3, [r3, #0]
3401aa5c:	2b00      	cmp	r3, #0
3401aa5e:	d105      	bne.n	3401aa6c <__LL_ATON_RT_RetFromLibEpochBlockArray+0x2c>
3401aa60:	4b37      	ldr	r3, [pc, #220]	@ (3401ab40 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x100>)
3401aa62:	4a38      	ldr	r2, [pc, #224]	@ (3401ab44 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x104>)
3401aa64:	2191      	movs	r1, #145	@ 0x91
3401aa66:	4838      	ldr	r0, [pc, #224]	@ (3401ab48 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x108>)
3401aa68:	f000 feb0 	bl	3401b7cc <__assert_func>
      LL_ATON_ASSERT(nn_instance == NULL);
3401aa6c:	683b      	ldr	r3, [r7, #0]
3401aa6e:	2b00      	cmp	r3, #0
3401aa70:	d005      	beq.n	3401aa7e <__LL_ATON_RT_RetFromLibEpochBlockArray+0x3e>
3401aa72:	4b36      	ldr	r3, [pc, #216]	@ (3401ab4c <__LL_ATON_RT_RetFromLibEpochBlockArray+0x10c>)
3401aa74:	4a33      	ldr	r2, [pc, #204]	@ (3401ab44 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x104>)
3401aa76:	2192      	movs	r1, #146	@ 0x92
3401aa78:	4833      	ldr	r0, [pc, #204]	@ (3401ab48 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x108>)
3401aa7a:	f000 fea7 	bl	3401b7cc <__assert_func>

      nn_instance = __ll_current_aton_ip_owner;
3401aa7e:	4b2f      	ldr	r3, [pc, #188]	@ (3401ab3c <__LL_ATON_RT_RetFromLibEpochBlockArray+0xfc>)
3401aa80:	681b      	ldr	r3, [r3, #0]
3401aa82:	603b      	str	r3, [r7, #0]
    }

    LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
3401aa84:	4b2d      	ldr	r3, [pc, #180]	@ (3401ab3c <__LL_ATON_RT_RetFromLibEpochBlockArray+0xfc>)
3401aa86:	681b      	ldr	r3, [r3, #0]
3401aa88:	2b00      	cmp	r3, #0
3401aa8a:	d105      	bne.n	3401aa98 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x58>
3401aa8c:	4b2c      	ldr	r3, [pc, #176]	@ (3401ab40 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x100>)
3401aa8e:	4a2d      	ldr	r2, [pc, #180]	@ (3401ab44 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x104>)
3401aa90:	2197      	movs	r1, #151	@ 0x97
3401aa92:	482d      	ldr	r0, [pc, #180]	@ (3401ab48 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x108>)
3401aa94:	f000 fe9a 	bl	3401b7cc <__assert_func>
    LL_ATON_ASSERT(unlock ? EpochBlock_IsLastEpochBlock(nn_instance->exec_state.current_epoch_block)
3401aa98:	79fb      	ldrb	r3, [r7, #7]
3401aa9a:	2b00      	cmp	r3, #0
3401aa9c:	d006      	beq.n	3401aaac <__LL_ATON_RT_RetFromLibEpochBlockArray+0x6c>
3401aa9e:	683b      	ldr	r3, [r7, #0]
3401aaa0:	685b      	ldr	r3, [r3, #4]
3401aaa2:	4618      	mov	r0, r3
3401aaa4:	f7ff fe70 	bl	3401a788 <EpochBlock_IsLastEpochBlock>
3401aaa8:	4603      	mov	r3, r0
3401aaaa:	e005      	b.n	3401aab8 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x78>
3401aaac:	683b      	ldr	r3, [r7, #0]
3401aaae:	685b      	ldr	r3, [r3, #4]
3401aab0:	4618      	mov	r0, r3
3401aab2:	f7ff fec8 	bl	3401a846 <EpochBlock_IsEpochInternal>
3401aab6:	4603      	mov	r3, r0
3401aab8:	2b00      	cmp	r3, #0
3401aaba:	d105      	bne.n	3401aac8 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x88>
3401aabc:	4b24      	ldr	r3, [pc, #144]	@ (3401ab50 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x110>)
3401aabe:	4a21      	ldr	r2, [pc, #132]	@ (3401ab44 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x104>)
3401aac0:	2198      	movs	r1, #152	@ 0x98
3401aac2:	4821      	ldr	r0, [pc, #132]	@ (3401ab48 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x108>)
3401aac4:	f000 fe82 	bl	3401b7cc <__assert_func>
                          : EpochBlock_IsEpochInternal(nn_instance->exec_state.current_epoch_block));
    LL_ATON_ASSERT(EpochBlock_IsEpochHybrid(nn_instance->exec_state.saved_current_epoch_block));
3401aac8:	683b      	ldr	r3, [r7, #0]
3401aaca:	691b      	ldr	r3, [r3, #16]
3401aacc:	4618      	mov	r0, r3
3401aace:	f7ff fea7 	bl	3401a820 <EpochBlock_IsEpochHybrid>
3401aad2:	4603      	mov	r3, r0
3401aad4:	2b00      	cmp	r3, #0
3401aad6:	d105      	bne.n	3401aae4 <__LL_ATON_RT_RetFromLibEpochBlockArray+0xa4>
3401aad8:	4b1e      	ldr	r3, [pc, #120]	@ (3401ab54 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x114>)
3401aada:	4a1a      	ldr	r2, [pc, #104]	@ (3401ab44 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x104>)
3401aadc:	219a      	movs	r1, #154	@ 0x9a
3401aade:	481a      	ldr	r0, [pc, #104]	@ (3401ab48 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x108>)
3401aae0:	f000 fe74 	bl	3401b7cc <__assert_func>

    /* Clear owner */
    if (unlock)
3401aae4:	79fb      	ldrb	r3, [r7, #7]
3401aae6:	2b00      	cmp	r3, #0
3401aae8:	d004      	beq.n	3401aaf4 <__LL_ATON_RT_RetFromLibEpochBlockArray+0xb4>
    {
      __ll_clear_aton_owner(__ll_current_aton_ip_owner);
3401aaea:	4b14      	ldr	r3, [pc, #80]	@ (3401ab3c <__LL_ATON_RT_RetFromLibEpochBlockArray+0xfc>)
3401aaec:	681b      	ldr	r3, [r3, #0]
3401aaee:	4618      	mov	r0, r3
3401aaf0:	f7ff ff30 	bl	3401a954 <__ll_clear_aton_owner>
    }

    /* set old context */
    LL_ATON_ASSERT(nn_instance->exec_state.next_epoch_block == NULL);
3401aaf4:	683b      	ldr	r3, [r7, #0]
3401aaf6:	68db      	ldr	r3, [r3, #12]
3401aaf8:	2b00      	cmp	r3, #0
3401aafa:	d005      	beq.n	3401ab08 <__LL_ATON_RT_RetFromLibEpochBlockArray+0xc8>
3401aafc:	4b16      	ldr	r3, [pc, #88]	@ (3401ab58 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x118>)
3401aafe:	4a11      	ldr	r2, [pc, #68]	@ (3401ab44 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x104>)
3401ab00:	21a3      	movs	r1, #163	@ 0xa3
3401ab02:	4811      	ldr	r0, [pc, #68]	@ (3401ab48 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x108>)
3401ab04:	f000 fe62 	bl	3401b7cc <__assert_func>
    nn_instance->exec_state.current_epoch_block = nn_instance->exec_state.saved_current_epoch_block;
3401ab08:	683b      	ldr	r3, [r7, #0]
3401ab0a:	691a      	ldr	r2, [r3, #16]
3401ab0c:	683b      	ldr	r3, [r7, #0]
3401ab0e:	605a      	str	r2, [r3, #4]
    nn_instance->exec_state.first_epoch_block = nn_instance->exec_state.saved_first_epoch_block;
3401ab10:	683b      	ldr	r3, [r7, #0]
3401ab12:	695a      	ldr	r2, [r3, #20]
3401ab14:	683b      	ldr	r3, [r7, #0]
3401ab16:	609a      	str	r2, [r3, #8]

#ifndef NDEBUG
    nn_instance->exec_state.nr_of_epoch_blocks = nn_instance->exec_state.saved_nr_of_epoch_blocks;
3401ab18:	683b      	ldr	r3, [r7, #0]
3401ab1a:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3401ab1c:	683b      	ldr	r3, [r7, #0]
3401ab1e:	625a      	str	r2, [r3, #36]	@ 0x24
#endif

    /* reset saved context */
    nn_instance->exec_state.saved_current_epoch_block = NULL;
3401ab20:	683b      	ldr	r3, [r7, #0]
3401ab22:	2200      	movs	r2, #0
3401ab24:	611a      	str	r2, [r3, #16]
    nn_instance->exec_state.saved_first_epoch_block = NULL;
3401ab26:	683b      	ldr	r3, [r7, #0]
3401ab28:	2200      	movs	r2, #0
3401ab2a:	615a      	str	r2, [r3, #20]
#ifndef NDEBUG
    nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
3401ab2c:	683b      	ldr	r3, [r7, #0]
3401ab2e:	2200      	movs	r2, #0
3401ab30:	629a      	str	r2, [r3, #40]	@ 0x28
#endif
  }
3401ab32:	bf00      	nop
3401ab34:	3708      	adds	r7, #8
3401ab36:	46bd      	mov	sp, r7
3401ab38:	bd80      	pop	{r7, pc}
3401ab3a:	bf00      	nop
3401ab3c:	340213a4 	.word	0x340213a4
3401ab40:	3401f83c 	.word	0x3401f83c
3401ab44:	340200c8 	.word	0x340200c8
3401ab48:	3401f6e4 	.word	0x3401f6e4
3401ab4c:	3401f868 	.word	0x3401f868
3401ab50:	3401f884 	.word	0x3401f884
3401ab54:	3401f920 	.word	0x3401f920
3401ab58:	3401f96c 	.word	0x3401f96c

3401ab5c <dump_dma_state>:
#error current ATON runtime supports only up to 32 epoch controllers!
#endif // (ATON_EPOCHCTRL_NUM > 32)

#endif // `ATON_INT_NR` and `ATON_STRENG_NUM` are defined

LL_ATON_WEAK void dump_dma_state(void){};
3401ab5c:	b480      	push	{r7}
3401ab5e:	af00      	add	r7, sp, #0
3401ab60:	bf00      	nop
3401ab62:	46bd      	mov	sp, r7
3401ab64:	f85d 7b04 	ldr.w	r7, [sp], #4
3401ab68:	4770      	bx	lr

3401ab6a <__LL_ATON_RT_CntEpochBlocks>:

/*** Helper Functions ***/

#ifndef NDEBUG
static uint32_t __LL_ATON_RT_CntEpochBlocks(const LL_ATON_RT_EpochBlockItem_t *list)
{
3401ab6a:	b580      	push	{r7, lr}
3401ab6c:	b084      	sub	sp, #16
3401ab6e:	af00      	add	r7, sp, #0
3401ab70:	6078      	str	r0, [r7, #4]
  int i = 0;
3401ab72:	2300      	movs	r3, #0
3401ab74:	60fb      	str	r3, [r7, #12]

  if (list != NULL)
3401ab76:	687b      	ldr	r3, [r7, #4]
3401ab78:	2b00      	cmp	r3, #0
3401ab7a:	d011      	beq.n	3401aba0 <__LL_ATON_RT_CntEpochBlocks+0x36>
  {
    for (i = 1; !EpochBlock_IsLastEpochBlock(list); i++)
3401ab7c:	2301      	movs	r3, #1
3401ab7e:	60fb      	str	r3, [r7, #12]
3401ab80:	e005      	b.n	3401ab8e <__LL_ATON_RT_CntEpochBlocks+0x24>
    { // Note: also terminating empty epoch block is counted
      list++;
3401ab82:	687b      	ldr	r3, [r7, #4]
3401ab84:	3314      	adds	r3, #20
3401ab86:	607b      	str	r3, [r7, #4]
    for (i = 1; !EpochBlock_IsLastEpochBlock(list); i++)
3401ab88:	68fb      	ldr	r3, [r7, #12]
3401ab8a:	3301      	adds	r3, #1
3401ab8c:	60fb      	str	r3, [r7, #12]
3401ab8e:	6878      	ldr	r0, [r7, #4]
3401ab90:	f7ff fdfa 	bl	3401a788 <EpochBlock_IsLastEpochBlock>
3401ab94:	4603      	mov	r3, r0
3401ab96:	f083 0301 	eor.w	r3, r3, #1
3401ab9a:	b2db      	uxtb	r3, r3
3401ab9c:	2b00      	cmp	r3, #0
3401ab9e:	d1f0      	bne.n	3401ab82 <__LL_ATON_RT_CntEpochBlocks+0x18>
    }
  }

  return i;
3401aba0:	68fb      	ldr	r3, [r7, #12]
}
3401aba2:	4618      	mov	r0, r3
3401aba4:	3710      	adds	r7, #16
3401aba6:	46bd      	mov	sp, r7
3401aba8:	bd80      	pop	{r7, pc}
	...

3401abac <__LL_ATON_RT_ExecStartEpochBlock>:
#endif

static inline void __LL_ATON_RT_ExecStartEpochBlock(const LL_ATON_RT_EpochBlockItem_t *eb,
                                                    NN_Instance_TypeDef *nn_instance)
{
3401abac:	b580      	push	{r7, lr}
3401abae:	b086      	sub	sp, #24
3401abb0:	af00      	add	r7, sp, #0
3401abb2:	6078      	str	r0, [r7, #4]
3401abb4:	6039      	str	r1, [r7, #0]
  LL_ATON_ASSERT(nn_instance->exec_state.next_epoch_block == NULL);
3401abb6:	683b      	ldr	r3, [r7, #0]
3401abb8:	68db      	ldr	r3, [r3, #12]
3401abba:	2b00      	cmp	r3, #0
3401abbc:	d005      	beq.n	3401abca <__LL_ATON_RT_ExecStartEpochBlock+0x1e>
3401abbe:	4b4a      	ldr	r3, [pc, #296]	@ (3401ace8 <__LL_ATON_RT_ExecStartEpochBlock+0x13c>)
3401abc0:	4a4a      	ldr	r2, [pc, #296]	@ (3401acec <__LL_ATON_RT_ExecStartEpochBlock+0x140>)
3401abc2:	2161      	movs	r1, #97	@ 0x61
3401abc4:	484a      	ldr	r0, [pc, #296]	@ (3401acf0 <__LL_ATON_RT_ExecStartEpochBlock+0x144>)
3401abc6:	f000 fe01 	bl	3401b7cc <__assert_func>

  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401abca:	683b      	ldr	r3, [r7, #0]
3401abcc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401abce:	2b00      	cmp	r3, #0
3401abd0:	d005      	beq.n	3401abde <__LL_ATON_RT_ExecStartEpochBlock+0x32>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_PRE_START, nn_instance, eb);
3401abd2:	683b      	ldr	r3, [r7, #0]
3401abd4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401abd6:	687a      	ldr	r2, [r7, #4]
3401abd8:	6839      	ldr	r1, [r7, #0]
3401abda:	2000      	movs	r0, #0
3401abdc:	4798      	blx	r3

  /* Is it the first epoch block in an AtoNN epoch? */
  if (EpochBlock_IsEpochStart(eb))
3401abde:	6878      	ldr	r0, [r7, #4]
3401abe0:	f7ff fde5 	bl	3401a7ae <EpochBlock_IsEpochStart>
3401abe4:	4603      	mov	r3, r0
3401abe6:	2b00      	cmp	r3, #0
3401abe8:	d002      	beq.n	3401abf0 <__LL_ATON_RT_ExecStartEpochBlock+0x44>
  {
    __LL_ATON_RT_Start_AtoNN_Epoch(nn_instance);
3401abea:	6838      	ldr	r0, [r7, #0]
3401abec:	f7ff fede 	bl	3401a9ac <__LL_ATON_RT_Start_AtoNN_Epoch>
  }

  /* Grab ATON IP lock in case not a pure SW or internal epoch */
  if (EpochBlock_IsEpochPureHW(eb) ||
3401abf0:	6878      	ldr	r0, [r7, #4]
3401abf2:	f7ff fe02 	bl	3401a7fa <EpochBlock_IsEpochPureHW>
3401abf6:	4603      	mov	r3, r0
3401abf8:	2b00      	cmp	r3, #0
3401abfa:	d105      	bne.n	3401ac08 <__LL_ATON_RT_ExecStartEpochBlock+0x5c>
      EpochBlock_IsEpochHybrid(eb)) // epoch blobs are flagged as pure HW, so checking for epoch blob is not necessary
3401abfc:	6878      	ldr	r0, [r7, #4]
3401abfe:	f7ff fe0f 	bl	3401a820 <EpochBlock_IsEpochHybrid>
3401ac02:	4603      	mov	r3, r0
  if (EpochBlock_IsEpochPureHW(eb) ||
3401ac04:	2b00      	cmp	r3, #0
3401ac06:	d002      	beq.n	3401ac0e <__LL_ATON_RT_ExecStartEpochBlock+0x62>
  {
    __ll_set_aton_owner(nn_instance);
3401ac08:	6838      	ldr	r0, [r7, #0]
3401ac0a:	f7ff fe6b 	bl	3401a8e4 <__ll_set_aton_owner>
  }

  if (!EpochBlock_IsEpochBlob(eb))
3401ac0e:	6878      	ldr	r0, [r7, #4]
3401ac10:	f7ff fde0 	bl	3401a7d4 <EpochBlock_IsEpochBlob>
3401ac14:	4603      	mov	r3, r0
3401ac16:	f083 0301 	eor.w	r3, r3, #1
3401ac1a:	b2db      	uxtb	r3, r3
3401ac1c:	2b00      	cmp	r3, #0
3401ac1e:	d01c      	beq.n	3401ac5a <__LL_ATON_RT_ExecStartEpochBlock+0xae>
  { // standard epoch block handling based on streaming engines
    /* set wait mask(s) in interrupt controller */
    if (EpochBlock_IsEpochPureHW(eb) || EpochBlock_IsEpochInternal(eb))
3401ac20:	6878      	ldr	r0, [r7, #4]
3401ac22:	f7ff fdea 	bl	3401a7fa <EpochBlock_IsEpochPureHW>
3401ac26:	4603      	mov	r3, r0
3401ac28:	2b00      	cmp	r3, #0
3401ac2a:	d105      	bne.n	3401ac38 <__LL_ATON_RT_ExecStartEpochBlock+0x8c>
3401ac2c:	6878      	ldr	r0, [r7, #4]
3401ac2e:	f7ff fe0a 	bl	3401a846 <EpochBlock_IsEpochInternal>
3401ac32:	4603      	mov	r3, r0
3401ac34:	2b00      	cmp	r3, #0
3401ac36:	d014      	beq.n	3401ac62 <__LL_ATON_RT_ExecStartEpochBlock+0xb6>
    {
      LL_ATON_ASSERT(__ll_current_aton_ip_owner == nn_instance);
3401ac38:	4b2e      	ldr	r3, [pc, #184]	@ (3401acf4 <__LL_ATON_RT_ExecStartEpochBlock+0x148>)
3401ac3a:	681b      	ldr	r3, [r3, #0]
3401ac3c:	683a      	ldr	r2, [r7, #0]
3401ac3e:	429a      	cmp	r2, r3
3401ac40:	d005      	beq.n	3401ac4e <__LL_ATON_RT_ExecStartEpochBlock+0xa2>
3401ac42:	4b2d      	ldr	r3, [pc, #180]	@ (3401acf8 <__LL_ATON_RT_ExecStartEpochBlock+0x14c>)
3401ac44:	4a29      	ldr	r2, [pc, #164]	@ (3401acec <__LL_ATON_RT_ExecStartEpochBlock+0x140>)
3401ac46:	2178      	movs	r1, #120	@ 0x78
3401ac48:	4829      	ldr	r0, [pc, #164]	@ (3401acf0 <__LL_ATON_RT_ExecStartEpochBlock+0x144>)
3401ac4a:	f000 fdbf 	bl	3401b7cc <__assert_func>
      __LL_ATON_RT_SetWaitMask(eb->wait_mask);
3401ac4e:	687b      	ldr	r3, [r7, #4]
3401ac50:	68db      	ldr	r3, [r3, #12]
3401ac52:	4618      	mov	r0, r3
3401ac54:	f7ff fece 	bl	3401a9f4 <__LL_ATON_RT_SetWaitMask>
3401ac58:	e003      	b.n	3401ac62 <__LL_ATON_RT_ExecStartEpochBlock+0xb6>
  else
  { // epoch blob handling based on epoch controller
#if defined(ATON_EPOCHCTRL_NUM) &&                                                                                     \
    (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC) // Polling mode is not allowed/supported when using the epoch controller
    /* reset wait mask(s) in interrupt controller, but ignore stream engine completion event interrupts */
    __LL_ATON_RT_SetWaitMask(ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0));
3401ac5a:	f240 30ff 	movw	r0, #1023	@ 0x3ff
3401ac5e:	f7ff fec9 	bl	3401a9f4 <__LL_ATON_RT_SetWaitMask>
#endif // ATON_PLAT_HAS_FFLUSH
    LL_ATON_ASSERT(false); // may never happen
#endif // !ATON_EPOCHCTRL_NUM || LL_ATON_RT_POLLING
  }

  if (eb->start_epoch_block != NULL)
3401ac62:	687b      	ldr	r3, [r7, #4]
3401ac64:	681b      	ldr	r3, [r3, #0]
3401ac66:	2b00      	cmp	r3, #0
3401ac68:	d003      	beq.n	3401ac72 <__LL_ATON_RT_ExecStartEpochBlock+0xc6>
    else
    {
      eb->start_epoch_block((const void *)eb);
    }
#else
    eb->start_epoch_block((const void *)eb);
3401ac6a:	687b      	ldr	r3, [r7, #4]
3401ac6c:	681b      	ldr	r3, [r3, #0]
3401ac6e:	6878      	ldr	r0, [r7, #4]
3401ac70:	4798      	blx	r3
#endif
  }

  if (EpochBlock_IsEpochBlob(eb))
3401ac72:	6878      	ldr	r0, [r7, #4]
3401ac74:	f7ff fdae 	bl	3401a7d4 <EpochBlock_IsEpochBlob>
3401ac78:	4603      	mov	r3, r0
3401ac7a:	2b00      	cmp	r3, #0
3401ac7c:	d026      	beq.n	3401accc <__LL_ATON_RT_ExecStartEpochBlock+0x120>
  {
#if defined(ATON_EPOCHCTRL_NUM)
    /* configure epoch controller */
    uint32_t ecId = EpochBlock_EpochControllerUnit(eb);
3401ac7e:	6878      	ldr	r0, [r7, #4]
3401ac80:	f7ff fdf4 	bl	3401a86c <EpochBlock_EpochControllerUnit>
3401ac84:	6178      	str	r0, [r7, #20]
    LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3401ac86:	697b      	ldr	r3, [r7, #20]
3401ac88:	2b00      	cmp	r3, #0
3401ac8a:	d005      	beq.n	3401ac98 <__LL_ATON_RT_ExecStartEpochBlock+0xec>
3401ac8c:	4b1b      	ldr	r3, [pc, #108]	@ (3401acfc <__LL_ATON_RT_ExecStartEpochBlock+0x150>)
3401ac8e:	4a17      	ldr	r2, [pc, #92]	@ (3401acec <__LL_ATON_RT_ExecStartEpochBlock+0x140>)
3401ac90:	21a4      	movs	r1, #164	@ 0xa4
3401ac92:	4817      	ldr	r0, [pc, #92]	@ (3401acf0 <__LL_ATON_RT_ExecStartEpochBlock+0x144>)
3401ac94:	f000 fd9a 	bl	3401b7cc <__assert_func>

    LL_EpochCtrl_InitTypeDef conf;
    conf.stepmode = 0;
3401ac98:	7b3b      	ldrb	r3, [r7, #12]
3401ac9a:	f023 0301 	bic.w	r3, r3, #1
3401ac9e:	733b      	strb	r3, [r7, #12]
    conf.blobaddr = EpochBlock_EpochBlobAddr(eb);
3401aca0:	6878      	ldr	r0, [r7, #4]
3401aca2:	f7ff fe01 	bl	3401a8a8 <EpochBlock_EpochBlobAddr>
3401aca6:	4603      	mov	r3, r0
3401aca8:	60bb      	str	r3, [r7, #8]

    LL_EpochCtrl_Init(ecId, &conf);
3401acaa:	697b      	ldr	r3, [r7, #20]
3401acac:	f107 0208 	add.w	r2, r7, #8
3401acb0:	4611      	mov	r1, r2
3401acb2:	4618      	mov	r0, r3
3401acb4:	f7ff fc66 	bl	3401a584 <LL_EpochCtrl_Init>

    /* start/enable epoch controller */
    ATON_ENABLE(EPOCHCTRL, ecId);
3401acb8:	4b11      	ldr	r3, [pc, #68]	@ (3401ad00 <__LL_ATON_RT_ExecStartEpochBlock+0x154>)
3401acba:	681b      	ldr	r3, [r3, #0]
3401acbc:	613b      	str	r3, [r7, #16]
3401acbe:	693b      	ldr	r3, [r7, #16]
3401acc0:	f043 0301 	orr.w	r3, r3, #1
3401acc4:	613b      	str	r3, [r7, #16]
3401acc6:	4a0e      	ldr	r2, [pc, #56]	@ (3401ad00 <__LL_ATON_RT_ExecStartEpochBlock+0x154>)
3401acc8:	693b      	ldr	r3, [r7, #16]
3401acca:	6013      	str	r3, [r2, #0]
#else  // !ATON_EPOCHCTRL_NUM
    LL_ATON_ASSERT(false); // may never happen
#endif // !ATON_EPOCHCTRL_NUM
  }

  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401accc:	683b      	ldr	r3, [r7, #0]
3401acce:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401acd0:	2b00      	cmp	r3, #0
3401acd2:	d005      	beq.n	3401ace0 <__LL_ATON_RT_ExecStartEpochBlock+0x134>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_POST_START, nn_instance, eb);
3401acd4:	683b      	ldr	r3, [r7, #0]
3401acd6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401acd8:	687a      	ldr	r2, [r7, #4]
3401acda:	6839      	ldr	r1, [r7, #0]
3401acdc:	2001      	movs	r0, #1
3401acde:	4798      	blx	r3
}
3401ace0:	bf00      	nop
3401ace2:	3718      	adds	r7, #24
3401ace4:	46bd      	mov	sp, r7
3401ace6:	bd80      	pop	{r7, pc}
3401ace8:	3401f96c 	.word	0x3401f96c
3401acec:	340200f0 	.word	0x340200f0
3401acf0:	3401f9a4 	.word	0x3401f9a4
3401acf4:	340213a4 	.word	0x340213a4
3401acf8:	3401fa3c 	.word	0x3401fa3c
3401acfc:	3401fa68 	.word	0x3401fa68
3401ad00:	580fe000 	.word	0x580fe000

3401ad04 <__LL_ATON_RT_ExecEndEpochBlock>:

static inline void __LL_ATON_RT_ExecEndEpochBlock(const LL_ATON_RT_EpochBlockItem_t *eb,
                                                  NN_Instance_TypeDef *nn_instance)
{
3401ad04:	b580      	push	{r7, lr}
3401ad06:	b084      	sub	sp, #16
3401ad08:	af00      	add	r7, sp, #0
3401ad0a:	6078      	str	r0, [r7, #4]
3401ad0c:	6039      	str	r1, [r7, #0]
  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401ad0e:	683b      	ldr	r3, [r7, #0]
3401ad10:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401ad12:	2b00      	cmp	r3, #0
3401ad14:	d005      	beq.n	3401ad22 <__LL_ATON_RT_ExecEndEpochBlock+0x1e>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_PRE_END, nn_instance, eb);
3401ad16:	683b      	ldr	r3, [r7, #0]
3401ad18:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401ad1a:	687a      	ldr	r2, [r7, #4]
3401ad1c:	6839      	ldr	r1, [r7, #0]
3401ad1e:	2002      	movs	r0, #2
3401ad20:	4798      	blx	r3

  if (EpochBlock_IsEpochBlob(eb))
3401ad22:	6878      	ldr	r0, [r7, #4]
3401ad24:	f7ff fd56 	bl	3401a7d4 <EpochBlock_IsEpochBlob>
3401ad28:	4603      	mov	r3, r0
3401ad2a:	2b00      	cmp	r3, #0
3401ad2c:	d033      	beq.n	3401ad96 <__LL_ATON_RT_ExecEndEpochBlock+0x92>
  {
#if defined(ATON_EPOCHCTRL_NUM)
    /* stop/disable epoch controller */
    uint32_t ecId = EpochBlock_EpochControllerUnit(eb);
3401ad2e:	6878      	ldr	r0, [r7, #4]
3401ad30:	f7ff fd9c 	bl	3401a86c <EpochBlock_EpochControllerUnit>
3401ad34:	60f8      	str	r0, [r7, #12]
    LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3401ad36:	68fb      	ldr	r3, [r7, #12]
3401ad38:	2b00      	cmp	r3, #0
3401ad3a:	d005      	beq.n	3401ad48 <__LL_ATON_RT_ExecEndEpochBlock+0x44>
3401ad3c:	4b48      	ldr	r3, [pc, #288]	@ (3401ae60 <__LL_ATON_RT_ExecEndEpochBlock+0x15c>)
3401ad3e:	4a49      	ldr	r2, [pc, #292]	@ (3401ae64 <__LL_ATON_RT_ExecEndEpochBlock+0x160>)
3401ad40:	21c2      	movs	r1, #194	@ 0xc2
3401ad42:	4849      	ldr	r0, [pc, #292]	@ (3401ae68 <__LL_ATON_RT_ExecEndEpochBlock+0x164>)
3401ad44:	f000 fd42 	bl	3401b7cc <__assert_func>
    uint32_t t;
    ATON_DISABLE_CLR_CONFCLR(EPOCHCTRL, ecId);
3401ad48:	2300      	movs	r3, #0
3401ad4a:	60bb      	str	r3, [r7, #8]
3401ad4c:	68bb      	ldr	r3, [r7, #8]
3401ad4e:	f023 0301 	bic.w	r3, r3, #1
3401ad52:	60bb      	str	r3, [r7, #8]
3401ad54:	68bb      	ldr	r3, [r7, #8]
3401ad56:	f043 0302 	orr.w	r3, r3, #2
3401ad5a:	60bb      	str	r3, [r7, #8]
3401ad5c:	4a43      	ldr	r2, [pc, #268]	@ (3401ae6c <__LL_ATON_RT_ExecEndEpochBlock+0x168>)
3401ad5e:	68bb      	ldr	r3, [r7, #8]
3401ad60:	6013      	str	r3, [r2, #0]
3401ad62:	4b42      	ldr	r3, [pc, #264]	@ (3401ae6c <__LL_ATON_RT_ExecEndEpochBlock+0x168>)
3401ad64:	681b      	ldr	r3, [r3, #0]
3401ad66:	f003 0302 	and.w	r3, r3, #2
3401ad6a:	2b00      	cmp	r3, #0
3401ad6c:	d1f9      	bne.n	3401ad62 <__LL_ATON_RT_ExecEndEpochBlock+0x5e>
3401ad6e:	2300      	movs	r3, #0
3401ad70:	60bb      	str	r3, [r7, #8]
3401ad72:	68bb      	ldr	r3, [r7, #8]
3401ad74:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
3401ad78:	60bb      	str	r3, [r7, #8]
3401ad7a:	4a3c      	ldr	r2, [pc, #240]	@ (3401ae6c <__LL_ATON_RT_ExecEndEpochBlock+0x168>)
3401ad7c:	68bb      	ldr	r3, [r7, #8]
3401ad7e:	6013      	str	r3, [r2, #0]
3401ad80:	4b3a      	ldr	r3, [pc, #232]	@ (3401ae6c <__LL_ATON_RT_ExecEndEpochBlock+0x168>)
3401ad82:	681b      	ldr	r3, [r3, #0]
3401ad84:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3401ad88:	2b00      	cmp	r3, #0
3401ad8a:	d1f9      	bne.n	3401ad80 <__LL_ATON_RT_ExecEndEpochBlock+0x7c>

    /* disable epoch controller clock */
    LL_ATON_DisableClock(ATON_EPOCHCTRL_CLKB_CLK(ecId));
3401ad8c:	68fb      	ldr	r3, [r7, #12]
3401ad8e:	3319      	adds	r3, #25
3401ad90:	4618      	mov	r0, r3
3401ad92:	f7ff fc5d 	bl	3401a650 <LL_ATON_DisableClock>
#else  // !ATON_EPOCHCTRL_NUM
    LL_ATON_ASSERT(false); // may never happen
#endif // !ATON_EPOCHCTRL_NUM
  }

  if (eb->end_epoch_block != NULL)
3401ad96:	687b      	ldr	r3, [r7, #4]
3401ad98:	685b      	ldr	r3, [r3, #4]
3401ad9a:	2b00      	cmp	r3, #0
3401ad9c:	d003      	beq.n	3401ada6 <__LL_ATON_RT_ExecEndEpochBlock+0xa2>
    else
    {
      eb->end_epoch_block((const void *)eb);
    }
#else
    eb->end_epoch_block((const void *)eb);
3401ad9e:	687b      	ldr	r3, [r7, #4]
3401ada0:	685b      	ldr	r3, [r3, #4]
3401ada2:	6878      	ldr	r0, [r7, #4]
3401ada4:	4798      	blx	r3
#endif
  }

  /* Reset wait mask */
  if (EpochBlock_IsEpochPureHW(eb) ||
3401ada6:	6878      	ldr	r0, [r7, #4]
3401ada8:	f7ff fd27 	bl	3401a7fa <EpochBlock_IsEpochPureHW>
3401adac:	4603      	mov	r3, r0
3401adae:	2b00      	cmp	r3, #0
3401adb0:	d105      	bne.n	3401adbe <__LL_ATON_RT_ExecEndEpochBlock+0xba>
      EpochBlock_IsEpochInternal(eb)) // epoch blobs are flagged as pure HW, so checking for epoch blob is not necessary
3401adb2:	6878      	ldr	r0, [r7, #4]
3401adb4:	f7ff fd47 	bl	3401a846 <EpochBlock_IsEpochInternal>
3401adb8:	4603      	mov	r3, r0
  if (EpochBlock_IsEpochPureHW(eb) ||
3401adba:	2b00      	cmp	r3, #0
3401adbc:	d00d      	beq.n	3401adda <__LL_ATON_RT_ExecEndEpochBlock+0xd6>
  {
    LL_ATON_ASSERT(nn_instance == __ll_current_aton_ip_owner);
3401adbe:	4b2c      	ldr	r3, [pc, #176]	@ (3401ae70 <__LL_ATON_RT_ExecEndEpochBlock+0x16c>)
3401adc0:	681b      	ldr	r3, [r3, #0]
3401adc2:	683a      	ldr	r2, [r7, #0]
3401adc4:	429a      	cmp	r2, r3
3401adc6:	d005      	beq.n	3401add4 <__LL_ATON_RT_ExecEndEpochBlock+0xd0>
3401adc8:	4b2a      	ldr	r3, [pc, #168]	@ (3401ae74 <__LL_ATON_RT_ExecEndEpochBlock+0x170>)
3401adca:	4a26      	ldr	r2, [pc, #152]	@ (3401ae64 <__LL_ATON_RT_ExecEndEpochBlock+0x160>)
3401adcc:	21e1      	movs	r1, #225	@ 0xe1
3401adce:	4826      	ldr	r0, [pc, #152]	@ (3401ae68 <__LL_ATON_RT_ExecEndEpochBlock+0x164>)
3401add0:	f000 fcfc 	bl	3401b7cc <__assert_func>
    __LL_ATON_RT_SetWaitMask(0);
3401add4:	2000      	movs	r0, #0
3401add6:	f7ff fe0d 	bl	3401a9f4 <__LL_ATON_RT_SetWaitMask>
  }

  /* Release ATON IP unlock in case it's a pure HW epoch */
  if (EpochBlock_IsEpochPureHW(eb) || ((EpochBlock_IsEpochHybrid(eb) || EpochBlock_IsEpochInternal(eb)) &&
3401adda:	6878      	ldr	r0, [r7, #4]
3401addc:	f7ff fd0d 	bl	3401a7fa <EpochBlock_IsEpochPureHW>
3401ade0:	4603      	mov	r3, r0
3401ade2:	2b00      	cmp	r3, #0
3401ade4:	d113      	bne.n	3401ae0e <__LL_ATON_RT_ExecEndEpochBlock+0x10a>
3401ade6:	6878      	ldr	r0, [r7, #4]
3401ade8:	f7ff fd1a 	bl	3401a820 <EpochBlock_IsEpochHybrid>
3401adec:	4603      	mov	r3, r0
3401adee:	2b00      	cmp	r3, #0
3401adf0:	d105      	bne.n	3401adfe <__LL_ATON_RT_ExecEndEpochBlock+0xfa>
3401adf2:	6878      	ldr	r0, [r7, #4]
3401adf4:	f7ff fd27 	bl	3401a846 <EpochBlock_IsEpochInternal>
3401adf8:	4603      	mov	r3, r0
3401adfa:	2b00      	cmp	r3, #0
3401adfc:	d00a      	beq.n	3401ae14 <__LL_ATON_RT_ExecEndEpochBlock+0x110>
                                       (nn_instance->exec_state.saved_current_epoch_block == NULL) &&
3401adfe:	683b      	ldr	r3, [r7, #0]
3401ae00:	691b      	ldr	r3, [r3, #16]
  if (EpochBlock_IsEpochPureHW(eb) || ((EpochBlock_IsEpochHybrid(eb) || EpochBlock_IsEpochInternal(eb)) &&
3401ae02:	2b00      	cmp	r3, #0
3401ae04:	d106      	bne.n	3401ae14 <__LL_ATON_RT_ExecEndEpochBlock+0x110>
                                       (nn_instance->exec_state.next_epoch_block ==
3401ae06:	683b      	ldr	r3, [r7, #0]
3401ae08:	68db      	ldr	r3, [r3, #12]
                                       (nn_instance->exec_state.saved_current_epoch_block == NULL) &&
3401ae0a:	2b00      	cmp	r3, #0
3401ae0c:	d102      	bne.n	3401ae14 <__LL_ATON_RT_ExecEndEpochBlock+0x110>
                                        NULL))) /* hybrid has finished after that last part has been executed in SW */
  {
    __ll_clear_aton_owner(nn_instance);
3401ae0e:	6838      	ldr	r0, [r7, #0]
3401ae10:	f7ff fda0 	bl	3401a954 <__ll_clear_aton_owner>
  }
  LL_ATON_ASSERT(EpochBlock_IsEpochInternal(eb) || EpochBlock_IsEpochHybrid(eb) ||
3401ae14:	6878      	ldr	r0, [r7, #4]
3401ae16:	f7ff fd16 	bl	3401a846 <EpochBlock_IsEpochInternal>
3401ae1a:	4603      	mov	r3, r0
3401ae1c:	2b00      	cmp	r3, #0
3401ae1e:	d110      	bne.n	3401ae42 <__LL_ATON_RT_ExecEndEpochBlock+0x13e>
3401ae20:	6878      	ldr	r0, [r7, #4]
3401ae22:	f7ff fcfd 	bl	3401a820 <EpochBlock_IsEpochHybrid>
3401ae26:	4603      	mov	r3, r0
3401ae28:	2b00      	cmp	r3, #0
3401ae2a:	d10a      	bne.n	3401ae42 <__LL_ATON_RT_ExecEndEpochBlock+0x13e>
3401ae2c:	4b10      	ldr	r3, [pc, #64]	@ (3401ae70 <__LL_ATON_RT_ExecEndEpochBlock+0x16c>)
3401ae2e:	681b      	ldr	r3, [r3, #0]
3401ae30:	683a      	ldr	r2, [r7, #0]
3401ae32:	429a      	cmp	r2, r3
3401ae34:	d105      	bne.n	3401ae42 <__LL_ATON_RT_ExecEndEpochBlock+0x13e>
3401ae36:	4b10      	ldr	r3, [pc, #64]	@ (3401ae78 <__LL_ATON_RT_ExecEndEpochBlock+0x174>)
3401ae38:	4a0a      	ldr	r2, [pc, #40]	@ (3401ae64 <__LL_ATON_RT_ExecEndEpochBlock+0x160>)
3401ae3a:	21ed      	movs	r1, #237	@ 0xed
3401ae3c:	480a      	ldr	r0, [pc, #40]	@ (3401ae68 <__LL_ATON_RT_ExecEndEpochBlock+0x164>)
3401ae3e:	f000 fcc5 	bl	3401b7cc <__assert_func>
                 (__ll_current_aton_ip_owner != nn_instance));

  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401ae42:	683b      	ldr	r3, [r7, #0]
3401ae44:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401ae46:	2b00      	cmp	r3, #0
3401ae48:	d005      	beq.n	3401ae56 <__LL_ATON_RT_ExecEndEpochBlock+0x152>
  {
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_POST_END, nn_instance, eb);
3401ae4a:	683b      	ldr	r3, [r7, #0]
3401ae4c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401ae4e:	687a      	ldr	r2, [r7, #4]
3401ae50:	6839      	ldr	r1, [r7, #0]
3401ae52:	2003      	movs	r0, #3
3401ae54:	4798      	blx	r3
  }
}
3401ae56:	bf00      	nop
3401ae58:	3710      	adds	r7, #16
3401ae5a:	46bd      	mov	sp, r7
3401ae5c:	bd80      	pop	{r7, pc}
3401ae5e:	bf00      	nop
3401ae60:	3401fa68 	.word	0x3401fa68
3401ae64:	340201a0 	.word	0x340201a0
3401ae68:	3401f9a4 	.word	0x3401f9a4
3401ae6c:	580fe000 	.word	0x580fe000
3401ae70:	340213a4 	.word	0x340213a4
3401ae74:	3401fa74 	.word	0x3401fa74
3401ae78:	3401faa0 	.word	0x3401faa0

3401ae7c <__LL_ATON_RT_DetermineNextEpochBlock>:

static void __LL_ATON_RT_DetermineNextEpochBlock(NN_Instance_TypeDef *nn_instance)
{
3401ae7c:	b580      	push	{r7, lr}
3401ae7e:	b082      	sub	sp, #8
3401ae80:	af00      	add	r7, sp, #0
3401ae82:	6078      	str	r0, [r7, #4]
  LL_ATON_ASSERT(nn_instance != NULL);
3401ae84:	687b      	ldr	r3, [r7, #4]
3401ae86:	2b00      	cmp	r3, #0
3401ae88:	d105      	bne.n	3401ae96 <__LL_ATON_RT_DetermineNextEpochBlock+0x1a>
3401ae8a:	4b26      	ldr	r3, [pc, #152]	@ (3401af24 <__LL_ATON_RT_DetermineNextEpochBlock+0xa8>)
3401ae8c:	4a26      	ldr	r2, [pc, #152]	@ (3401af28 <__LL_ATON_RT_DetermineNextEpochBlock+0xac>)
3401ae8e:	21f8      	movs	r1, #248	@ 0xf8
3401ae90:	4826      	ldr	r0, [pc, #152]	@ (3401af2c <__LL_ATON_RT_DetermineNextEpochBlock+0xb0>)
3401ae92:	f000 fc9b 	bl	3401b7cc <__assert_func>
#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  LL_ATON_ASSERT(nn_instance->exec_state.triggered_events ==
3401ae96:	687b      	ldr	r3, [r7, #4]
3401ae98:	69db      	ldr	r3, [r3, #28]
3401ae9a:	2b00      	cmp	r3, #0
3401ae9c:	d005      	beq.n	3401aeaa <__LL_ATON_RT_DetermineNextEpochBlock+0x2e>
3401ae9e:	4b24      	ldr	r3, [pc, #144]	@ (3401af30 <__LL_ATON_RT_DetermineNextEpochBlock+0xb4>)
3401aea0:	4a21      	ldr	r2, [pc, #132]	@ (3401af28 <__LL_ATON_RT_DetermineNextEpochBlock+0xac>)
3401aea2:	21fa      	movs	r1, #250	@ 0xfa
3401aea4:	4821      	ldr	r0, [pc, #132]	@ (3401af2c <__LL_ATON_RT_DetermineNextEpochBlock+0xb0>)
3401aea6:	f000 fc91 	bl	3401b7cc <__assert_func>
                 0x0); // with the removal of parallel SW/HW epochs execution all triggered events must have been
                       // cleared at this point in time!
#endif                 // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

  /* Determine if there is a new inserted epoch block array */
  if ((nn_instance->exec_state.next_epoch_block != NULL))
3401aeaa:	687b      	ldr	r3, [r7, #4]
3401aeac:	68db      	ldr	r3, [r3, #12]
3401aeae:	2b00      	cmp	r3, #0
3401aeb0:	d02a      	beq.n	3401af08 <__LL_ATON_RT_DetermineNextEpochBlock+0x8c>
  {
    LL_ATON_ASSERT(nn_instance->exec_state.saved_current_epoch_block == NULL);
3401aeb2:	687b      	ldr	r3, [r7, #4]
3401aeb4:	691b      	ldr	r3, [r3, #16]
3401aeb6:	2b00      	cmp	r3, #0
3401aeb8:	d006      	beq.n	3401aec8 <__LL_ATON_RT_DetermineNextEpochBlock+0x4c>
3401aeba:	4b1e      	ldr	r3, [pc, #120]	@ (3401af34 <__LL_ATON_RT_DetermineNextEpochBlock+0xb8>)
3401aebc:	4a1a      	ldr	r2, [pc, #104]	@ (3401af28 <__LL_ATON_RT_DetermineNextEpochBlock+0xac>)
3401aebe:	f44f 7181 	mov.w	r1, #258	@ 0x102
3401aec2:	481a      	ldr	r0, [pc, #104]	@ (3401af2c <__LL_ATON_RT_DetermineNextEpochBlock+0xb0>)
3401aec4:	f000 fc82 	bl	3401b7cc <__assert_func>

    /* save current context */
    nn_instance->exec_state.saved_current_epoch_block = nn_instance->exec_state.current_epoch_block;
3401aec8:	687b      	ldr	r3, [r7, #4]
3401aeca:	685a      	ldr	r2, [r3, #4]
3401aecc:	687b      	ldr	r3, [r7, #4]
3401aece:	611a      	str	r2, [r3, #16]
    nn_instance->exec_state.saved_first_epoch_block = nn_instance->exec_state.first_epoch_block;
3401aed0:	687b      	ldr	r3, [r7, #4]
3401aed2:	689a      	ldr	r2, [r3, #8]
3401aed4:	687b      	ldr	r3, [r7, #4]
3401aed6:	615a      	str	r2, [r3, #20]
#ifndef NDEBUG
    nn_instance->exec_state.saved_nr_of_epoch_blocks = nn_instance->exec_state.nr_of_epoch_blocks;
3401aed8:	687b      	ldr	r3, [r7, #4]
3401aeda:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
3401aedc:	687b      	ldr	r3, [r7, #4]
3401aede:	629a      	str	r2, [r3, #40]	@ 0x28
#endif

    /* set new context */
    nn_instance->exec_state.current_epoch_block = nn_instance->exec_state.next_epoch_block;
3401aee0:	687b      	ldr	r3, [r7, #4]
3401aee2:	68da      	ldr	r2, [r3, #12]
3401aee4:	687b      	ldr	r3, [r7, #4]
3401aee6:	605a      	str	r2, [r3, #4]
    nn_instance->exec_state.first_epoch_block = nn_instance->exec_state.next_epoch_block;
3401aee8:	687b      	ldr	r3, [r7, #4]
3401aeea:	68da      	ldr	r2, [r3, #12]
3401aeec:	687b      	ldr	r3, [r7, #4]
3401aeee:	609a      	str	r2, [r3, #8]
#ifndef NDEBUG
    nn_instance->exec_state.nr_of_epoch_blocks = __LL_ATON_RT_CntEpochBlocks(nn_instance->exec_state.first_epoch_block);
3401aef0:	687b      	ldr	r3, [r7, #4]
3401aef2:	689b      	ldr	r3, [r3, #8]
3401aef4:	4618      	mov	r0, r3
3401aef6:	f7ff fe38 	bl	3401ab6a <__LL_ATON_RT_CntEpochBlocks>
3401aefa:	4602      	mov	r2, r0
3401aefc:	687b      	ldr	r3, [r7, #4]
3401aefe:	625a      	str	r2, [r3, #36]	@ 0x24
#endif

    /* reset next epoch block */
    nn_instance->exec_state.next_epoch_block = NULL;
3401af00:	687b      	ldr	r3, [r7, #4]
3401af02:	2200      	movs	r2, #0
3401af04:	60da      	str	r2, [r3, #12]
3401af06:	e005      	b.n	3401af14 <__LL_ATON_RT_DetermineNextEpochBlock+0x98>
  }
  else
  {
    nn_instance->exec_state.current_epoch_block++;
3401af08:	687b      	ldr	r3, [r7, #4]
3401af0a:	685b      	ldr	r3, [r3, #4]
3401af0c:	f103 0214 	add.w	r2, r3, #20
3401af10:	687b      	ldr	r3, [r7, #4]
3401af12:	605a      	str	r2, [r3, #4]
  }

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  nn_instance->exec_state.current_epoch_block_started = false;
3401af14:	687b      	ldr	r3, [r7, #4]
3401af16:	2200      	movs	r2, #0
3401af18:	f883 2020 	strb.w	r2, [r3, #32]
#endif
}
3401af1c:	bf00      	nop
3401af1e:	3708      	adds	r7, #8
3401af20:	46bd      	mov	sp, r7
3401af22:	bd80      	pop	{r7, pc}
3401af24:	3401f7f0 	.word	0x3401f7f0
3401af28:	34020054 	.word	0x34020054
3401af2c:	3401f9a4 	.word	0x3401f9a4
3401af30:	3401f80c 	.word	0x3401f80c
3401af34:	3401fb10 	.word	0x3401fb10

3401af38 <__LL_ATON_RT_GetWaitMask>:

static inline uint32_t __LL_ATON_RT_GetWaitMask(const LL_ATON_RT_EpochBlockItem_t *eb)
{
3401af38:	b580      	push	{r7, lr}
3401af3a:	b082      	sub	sp, #8
3401af3c:	af00      	add	r7, sp, #0
3401af3e:	6078      	str	r0, [r7, #4]
  if (EpochBlock_IsEpochBlob(eb))
3401af40:	6878      	ldr	r0, [r7, #4]
3401af42:	f7ff fc47 	bl	3401a7d4 <EpochBlock_IsEpochBlob>
3401af46:	4603      	mov	r3, r0
3401af48:	2b00      	cmp	r3, #0
3401af4a:	d007      	beq.n	3401af5c <__LL_ATON_RT_GetWaitMask+0x24>
  {
    // in case of epoch blob `wait_mask` contains unit number of epoch controller to use
    return (1 << EpochBlock_EpochControllerUnit(eb));
3401af4c:	6878      	ldr	r0, [r7, #4]
3401af4e:	f7ff fc8d 	bl	3401a86c <EpochBlock_EpochControllerUnit>
3401af52:	4603      	mov	r3, r0
3401af54:	2201      	movs	r2, #1
3401af56:	fa02 f303 	lsl.w	r3, r2, r3
3401af5a:	e001      	b.n	3401af60 <__LL_ATON_RT_GetWaitMask+0x28>
  }
  else
  {
    return eb->wait_mask; // in case of "normal" epoch block `wait_mask` contains bitmask of (output) stream engines to
3401af5c:	687b      	ldr	r3, [r7, #4]
3401af5e:	68db      	ldr	r3, [r3, #12]
                          // wait for
  }
}
3401af60:	4618      	mov	r0, r3
3401af62:	3708      	adds	r7, #8
3401af64:	46bd      	mov	sp, r7
3401af66:	bd80      	pop	{r7, pc}

3401af68 <__LL_ATON_RT_Init_Network>:

static inline void __LL_ATON_RT_Init_Network(NN_Instance_TypeDef *nn_instance)
{
3401af68:	b580      	push	{r7, lr}
3401af6a:	b084      	sub	sp, #16
3401af6c:	af00      	add	r7, sp, #0
3401af6e:	6078      	str	r0, [r7, #4]
  /** Exit if `nn_instance` is equal to NULL **/
  if (nn_instance == NULL)
3401af70:	687b      	ldr	r3, [r7, #4]
3401af72:	2b00      	cmp	r3, #0
3401af74:	d037      	beq.n	3401afe6 <__LL_ATON_RT_Init_Network+0x7e>
  {
    return;
  }

  /** Exit if `nn_instance->network` is equal to NULL **/
  if (nn_instance->network == NULL)
3401af76:	687b      	ldr	r3, [r7, #4]
3401af78:	681b      	ldr	r3, [r3, #0]
3401af7a:	2b00      	cmp	r3, #0
3401af7c:	d035      	beq.n	3401afea <__LL_ATON_RT_Init_Network+0x82>
  else
  {
    eb_list = nn_instance->network->epoch_block_items();
  }
#else
  const LL_ATON_RT_EpochBlockItem_t *eb_list = nn_instance->network->epoch_block_items();
3401af7e:	687b      	ldr	r3, [r7, #4]
3401af80:	681b      	ldr	r3, [r3, #0]
3401af82:	69db      	ldr	r3, [r3, #28]
3401af84:	4798      	blx	r3
3401af86:	60f8      	str	r0, [r7, #12]
#endif
  nn_instance->exec_state.current_epoch_block = eb_list;
3401af88:	687b      	ldr	r3, [r7, #4]
3401af8a:	68fa      	ldr	r2, [r7, #12]
3401af8c:	605a      	str	r2, [r3, #4]
  nn_instance->exec_state.first_epoch_block = eb_list;
3401af8e:	687b      	ldr	r3, [r7, #4]
3401af90:	68fa      	ldr	r2, [r7, #12]
3401af92:	609a      	str	r2, [r3, #8]
  nn_instance->exec_state.next_epoch_block = NULL;
3401af94:	687b      	ldr	r3, [r7, #4]
3401af96:	2200      	movs	r2, #0
3401af98:	60da      	str	r2, [r3, #12]

  /* set saved context */
  nn_instance->exec_state.saved_current_epoch_block = NULL;
3401af9a:	687b      	ldr	r3, [r7, #4]
3401af9c:	2200      	movs	r2, #0
3401af9e:	611a      	str	r2, [r3, #16]
  nn_instance->exec_state.saved_first_epoch_block = NULL;
3401afa0:	687b      	ldr	r3, [r7, #4]
3401afa2:	2200      	movs	r2, #0
3401afa4:	615a      	str	r2, [r3, #20]
#ifndef NDEBUG
  nn_instance->exec_state.nr_of_epoch_blocks = __LL_ATON_RT_CntEpochBlocks(nn_instance->exec_state.current_epoch_block);
3401afa6:	687b      	ldr	r3, [r7, #4]
3401afa8:	685b      	ldr	r3, [r3, #4]
3401afaa:	4618      	mov	r0, r3
3401afac:	f7ff fddd 	bl	3401ab6a <__LL_ATON_RT_CntEpochBlocks>
3401afb0:	4602      	mov	r2, r0
3401afb2:	687b      	ldr	r3, [r7, #4]
3401afb4:	625a      	str	r2, [r3, #36]	@ 0x24
  nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
3401afb6:	687b      	ldr	r3, [r7, #4]
3401afb8:	2200      	movs	r2, #0
3401afba:	629a      	str	r2, [r3, #40]	@ 0x28
#endif

  /* set information about running inference */
  nn_instance->exec_state.inference_started = false;
3401afbc:	687b      	ldr	r3, [r7, #4]
3401afbe:	2200      	movs	r2, #0
3401afc0:	761a      	strb	r2, [r3, #24]

  /* set asynchronous status variables */
#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  nn_instance->exec_state.triggered_events = 0x0;
3401afc2:	687b      	ldr	r3, [r7, #4]
3401afc4:	2200      	movs	r2, #0
3401afc6:	61da      	str	r2, [r3, #28]
  nn_instance->exec_state.current_epoch_block_started = false;
3401afc8:	687b      	ldr	r3, [r7, #4]
3401afca:	2200      	movs	r2, #0
3401afcc:	f883 2020 	strb.w	r2, [r3, #32]
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

  /** Call epoch callback with callback type `LL_ATON_RT_Callbacktype_NN_Init` and network instance **/
  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401afd0:	687b      	ldr	r3, [r7, #4]
3401afd2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401afd4:	2b00      	cmp	r3, #0
3401afd6:	d009      	beq.n	3401afec <__LL_ATON_RT_Init_Network+0x84>
  {
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_NN_Init, nn_instance, NULL);
3401afd8:	687b      	ldr	r3, [r7, #4]
3401afda:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401afdc:	2200      	movs	r2, #0
3401afde:	6879      	ldr	r1, [r7, #4]
3401afe0:	2004      	movs	r0, #4
3401afe2:	4798      	blx	r3
3401afe4:	e002      	b.n	3401afec <__LL_ATON_RT_Init_Network+0x84>
    return;
3401afe6:	bf00      	nop
3401afe8:	e000      	b.n	3401afec <__LL_ATON_RT_Init_Network+0x84>
    return;
3401afea:	bf00      	nop
  }
}
3401afec:	3710      	adds	r7, #16
3401afee:	46bd      	mov	sp, r7
3401aff0:	bd80      	pop	{r7, pc}
	...

3401aff4 <LL_ATON_RT_Init_Network>:
/**
 * @brief Initialize a network instance
 * @param nn_instance Pointer to network instance to initialize
 */
void LL_ATON_RT_Init_Network(NN_Instance_TypeDef *nn_instance)
{
3401aff4:	b580      	push	{r7, lr}
3401aff6:	b084      	sub	sp, #16
3401aff8:	af00      	add	r7, sp, #0
3401affa:	6078      	str	r0, [r7, #4]
  /** Exit if `nn_instance` is equal to NULL **/
  if (nn_instance == NULL)
3401affc:	687b      	ldr	r3, [r7, #4]
3401affe:	2b00      	cmp	r3, #0
3401b000:	d023      	beq.n	3401b04a <LL_ATON_RT_Init_Network+0x56>
  {
    return;
  }

  /** Exit if `nn_instance->network` is equal to NULL **/
  if (nn_instance->network == NULL)
3401b002:	687b      	ldr	r3, [r7, #4]
3401b004:	681b      	ldr	r3, [r3, #0]
3401b006:	2b00      	cmp	r3, #0
3401b008:	d021      	beq.n	3401b04e <LL_ATON_RT_Init_Network+0x5a>
  {
    LL_ATON_ASSERT(nn_instance->network->ec_network_init != NULL);
    ret = nn_instance->network->ec_network_init();
  }
#else
  LL_ATON_ASSERT(nn_instance->network->ec_network_init != NULL);
3401b00a:	687b      	ldr	r3, [r7, #4]
3401b00c:	681b      	ldr	r3, [r3, #0]
3401b00e:	685b      	ldr	r3, [r3, #4]
3401b010:	2b00      	cmp	r3, #0
3401b012:	d106      	bne.n	3401b022 <LL_ATON_RT_Init_Network+0x2e>
3401b014:	4b10      	ldr	r3, [pc, #64]	@ (3401b058 <LL_ATON_RT_Init_Network+0x64>)
3401b016:	4a11      	ldr	r2, [pc, #68]	@ (3401b05c <LL_ATON_RT_Init_Network+0x68>)
3401b018:	f44f 71d3 	mov.w	r1, #422	@ 0x1a6
3401b01c:	4810      	ldr	r0, [pc, #64]	@ (3401b060 <LL_ATON_RT_Init_Network+0x6c>)
3401b01e:	f000 fbd5 	bl	3401b7cc <__assert_func>
  bool ret = nn_instance->network->ec_network_init();
3401b022:	687b      	ldr	r3, [r7, #4]
3401b024:	681b      	ldr	r3, [r3, #0]
3401b026:	685b      	ldr	r3, [r3, #4]
3401b028:	4798      	blx	r3
3401b02a:	4603      	mov	r3, r0
3401b02c:	73fb      	strb	r3, [r7, #15]
#endif
  LL_ATON_ASSERT(ret == true);
3401b02e:	7bfb      	ldrb	r3, [r7, #15]
3401b030:	2b01      	cmp	r3, #1
3401b032:	d006      	beq.n	3401b042 <LL_ATON_RT_Init_Network+0x4e>
3401b034:	4b0b      	ldr	r3, [pc, #44]	@ (3401b064 <LL_ATON_RT_Init_Network+0x70>)
3401b036:	4a09      	ldr	r2, [pc, #36]	@ (3401b05c <LL_ATON_RT_Init_Network+0x68>)
3401b038:	f240 11a9 	movw	r1, #425	@ 0x1a9
3401b03c:	4808      	ldr	r0, [pc, #32]	@ (3401b060 <LL_ATON_RT_Init_Network+0x6c>)
3401b03e:	f000 fbc5 	bl	3401b7cc <__assert_func>
  LL_ATON_LIB_UNUSED(ret);

  /* Call actual network instance initialization */
  __LL_ATON_RT_Init_Network(nn_instance);
3401b042:	6878      	ldr	r0, [r7, #4]
3401b044:	f7ff ff90 	bl	3401af68 <__LL_ATON_RT_Init_Network>
3401b048:	e002      	b.n	3401b050 <LL_ATON_RT_Init_Network+0x5c>
    return;
3401b04a:	bf00      	nop
3401b04c:	e000      	b.n	3401b050 <LL_ATON_RT_Init_Network+0x5c>
    return;
3401b04e:	bf00      	nop
}
3401b050:	3710      	adds	r7, #16
3401b052:	46bd      	mov	sp, r7
3401b054:	bd80      	pop	{r7, pc}
3401b056:	bf00      	nop
3401b058:	3401fb54 	.word	0x3401fb54
3401b05c:	3402007c 	.word	0x3402007c
3401b060:	3401f9a4 	.word	0x3401f9a4
3401b064:	3401fb8c 	.word	0x3401fb8c

3401b068 <LL_ATON_RT_DeInit_Network>:
/**
 * @brief De-initialize a network instance
 * @param nn_instance Pointer to network instance to de-initialize
 */
void LL_ATON_RT_DeInit_Network(NN_Instance_TypeDef *nn_instance)
{
3401b068:	b580      	push	{r7, lr}
3401b06a:	b084      	sub	sp, #16
3401b06c:	af00      	add	r7, sp, #0
3401b06e:	6078      	str	r0, [r7, #4]
  /** Exit if `nn_instance` is equal to NULL **/
  if (nn_instance == NULL)
3401b070:	687b      	ldr	r3, [r7, #4]
3401b072:	2b00      	cmp	r3, #0
3401b074:	d030      	beq.n	3401b0d8 <LL_ATON_RT_DeInit_Network+0x70>
  {
    return;
  }

  /** Call epoch callback with callback type `LL_ATON_RT_Callbacktype_NN_DeInit` and network instance **/
  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401b076:	687b      	ldr	r3, [r7, #4]
3401b078:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401b07a:	2b00      	cmp	r3, #0
3401b07c:	d005      	beq.n	3401b08a <LL_ATON_RT_DeInit_Network+0x22>
  {
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_NN_DeInit, nn_instance, NULL);
3401b07e:	687b      	ldr	r3, [r7, #4]
3401b080:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401b082:	2200      	movs	r2, #0
3401b084:	6879      	ldr	r1, [r7, #4]
3401b086:	2005      	movs	r0, #5
3401b088:	4798      	blx	r3
  }

  /** Re-set ATON IP owner */
  if (nn_instance == __ll_current_aton_ip_owner)
3401b08a:	4b15      	ldr	r3, [pc, #84]	@ (3401b0e0 <LL_ATON_RT_DeInit_Network+0x78>)
3401b08c:	681b      	ldr	r3, [r3, #0]
3401b08e:	687a      	ldr	r2, [r7, #4]
3401b090:	429a      	cmp	r2, r3
3401b092:	d102      	bne.n	3401b09a <LL_ATON_RT_DeInit_Network+0x32>
  { // In case this function gets called while an ATON lib internal EpochBlock (used to implement hybrid epochs) is
    // under execution we might still be owner of the ATON IP
    __ll_clear_aton_owner(nn_instance);
3401b094:	6878      	ldr	r0, [r7, #4]
3401b096:	f7ff fc5d 	bl	3401a954 <__ll_clear_aton_owner>
  }

  /** De-initialize static variables **/
  /* re-set context */
  const LL_ATON_RT_EpochBlockItem_t *eb_list = NULL;
3401b09a:	2300      	movs	r3, #0
3401b09c:	60fb      	str	r3, [r7, #12]
  nn_instance->exec_state.current_epoch_block = eb_list;
3401b09e:	687b      	ldr	r3, [r7, #4]
3401b0a0:	68fa      	ldr	r2, [r7, #12]
3401b0a2:	605a      	str	r2, [r3, #4]
  nn_instance->exec_state.first_epoch_block = eb_list;
3401b0a4:	687b      	ldr	r3, [r7, #4]
3401b0a6:	68fa      	ldr	r2, [r7, #12]
3401b0a8:	609a      	str	r2, [r3, #8]
  nn_instance->exec_state.next_epoch_block = NULL;
3401b0aa:	687b      	ldr	r3, [r7, #4]
3401b0ac:	2200      	movs	r2, #0
3401b0ae:	60da      	str	r2, [r3, #12]

  /* re-set saved context */
  nn_instance->exec_state.saved_current_epoch_block = NULL;
3401b0b0:	687b      	ldr	r3, [r7, #4]
3401b0b2:	2200      	movs	r2, #0
3401b0b4:	611a      	str	r2, [r3, #16]
  nn_instance->exec_state.saved_first_epoch_block = NULL;
3401b0b6:	687b      	ldr	r3, [r7, #4]
3401b0b8:	2200      	movs	r2, #0
3401b0ba:	615a      	str	r2, [r3, #20]
#ifndef NDEBUG
  nn_instance->exec_state.nr_of_epoch_blocks = 0;
3401b0bc:	687b      	ldr	r3, [r7, #4]
3401b0be:	2200      	movs	r2, #0
3401b0c0:	625a      	str	r2, [r3, #36]	@ 0x24
  nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
3401b0c2:	687b      	ldr	r3, [r7, #4]
3401b0c4:	2200      	movs	r2, #0
3401b0c6:	629a      	str	r2, [r3, #40]	@ 0x28

  /* intentional do not re-set information about running inference `nn_instance->exec_state.inference_started` */

  /* re-set asynchronous status variables */
#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  nn_instance->exec_state.triggered_events = 0x0;
3401b0c8:	687b      	ldr	r3, [r7, #4]
3401b0ca:	2200      	movs	r2, #0
3401b0cc:	61da      	str	r2, [r3, #28]
  nn_instance->exec_state.current_epoch_block_started = false;
3401b0ce:	687b      	ldr	r3, [r7, #4]
3401b0d0:	2200      	movs	r2, #0
3401b0d2:	f883 2020 	strb.w	r2, [r3, #32]
3401b0d6:	e000      	b.n	3401b0da <LL_ATON_RT_DeInit_Network+0x72>
    return;
3401b0d8:	bf00      	nop
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
}
3401b0da:	3710      	adds	r7, #16
3401b0dc:	46bd      	mov	sp, r7
3401b0de:	bd80      	pop	{r7, pc}
3401b0e0:	340213a4 	.word	0x340213a4

3401b0e4 <LL_ATON_RT_RuntimeInit>:

/**
 * @brief Initialize the ATON runtime
 */
void LL_ATON_RT_RuntimeInit(void)
{
3401b0e4:	b580      	push	{r7, lr}
3401b0e6:	b082      	sub	sp, #8
3401b0e8:	af00      	add	r7, sp, #0
  /** Initialize ATON IPs **/
  LL_ATON_Init();
3401b0ea:	f7fd f983 	bl	340183f4 <LL_ATON_Init>
  /** Initialize IRQ Context **/
  {
    uint32_t t;

    /* Disable & Clear interrupt controller */
    ATON_DISABLE_CLR_CONFCLR(INTCTRL, 0);
3401b0ee:	2300      	movs	r3, #0
3401b0f0:	607b      	str	r3, [r7, #4]
3401b0f2:	687b      	ldr	r3, [r7, #4]
3401b0f4:	f023 0301 	bic.w	r3, r3, #1
3401b0f8:	607b      	str	r3, [r7, #4]
3401b0fa:	687b      	ldr	r3, [r7, #4]
3401b0fc:	f043 0302 	orr.w	r3, r3, #2
3401b100:	607b      	str	r3, [r7, #4]
3401b102:	4a22      	ldr	r2, [pc, #136]	@ (3401b18c <LL_ATON_RT_RuntimeInit+0xa8>)
3401b104:	687b      	ldr	r3, [r7, #4]
3401b106:	6013      	str	r3, [r2, #0]
3401b108:	4b20      	ldr	r3, [pc, #128]	@ (3401b18c <LL_ATON_RT_RuntimeInit+0xa8>)
3401b10a:	681b      	ldr	r3, [r3, #0]
3401b10c:	f003 0302 	and.w	r3, r3, #2
3401b110:	2b00      	cmp	r3, #0
3401b112:	d1f9      	bne.n	3401b108 <LL_ATON_RT_RuntimeInit+0x24>
3401b114:	2300      	movs	r3, #0
3401b116:	607b      	str	r3, [r7, #4]
3401b118:	687b      	ldr	r3, [r7, #4]
3401b11a:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
3401b11e:	607b      	str	r3, [r7, #4]
3401b120:	4a1a      	ldr	r2, [pc, #104]	@ (3401b18c <LL_ATON_RT_RuntimeInit+0xa8>)
3401b122:	687b      	ldr	r3, [r7, #4]
3401b124:	6013      	str	r3, [r2, #0]
3401b126:	4b19      	ldr	r3, [pc, #100]	@ (3401b18c <LL_ATON_RT_RuntimeInit+0xa8>)
3401b128:	681b      	ldr	r3, [r3, #0]
3401b12a:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3401b12e:	2b00      	cmp	r3, #0
3401b130:	d1f9      	bne.n	3401b126 <LL_ATON_RT_RuntimeInit+0x42>

    /* Preset Interrupt Controller masks */
    ATON_INTCTRL_STD_INTORMSK_SET(ATON_STRENG_INT_MASK(
3401b132:	4b17      	ldr	r3, [pc, #92]	@ (3401b190 <LL_ATON_RT_RuntimeInit+0xac>)
3401b134:	f240 32ff 	movw	r2, #1023	@ 0x3ff
3401b138:	601a      	str	r2, [r3, #0]
        ATON_STRENG_NUM, 0, 0)); // OR-mask: disable all streaming engine events and enable all other events & errors
    ATON_INTCTRL_STD_INTANDMSK_SET(0xFFFFFFFF); // AND-mask: disable all events & errors
3401b13a:	4b16      	ldr	r3, [pc, #88]	@ (3401b194 <LL_ATON_RT_RuntimeInit+0xb0>)
3401b13c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
3401b140:	601a      	str	r2, [r3, #0]
    ATON_INTCTRL_STD_INTORMSK_H_SET(0);           // OR-mask: enable all events & errors
    ATON_INTCTRL_STD_INTANDMSK_H_SET(0xFFFFFFFF); // AND-mask: disable all events & errors
#endif

    /* Enable Interrupt Controller (again) */
    ATON_ENABLE(INTCTRL, 0);
3401b142:	4b12      	ldr	r3, [pc, #72]	@ (3401b18c <LL_ATON_RT_RuntimeInit+0xa8>)
3401b144:	681b      	ldr	r3, [r3, #0]
3401b146:	603b      	str	r3, [r7, #0]
3401b148:	683b      	ldr	r3, [r7, #0]
3401b14a:	f043 0301 	orr.w	r3, r3, #1
3401b14e:	603b      	str	r3, [r7, #0]
3401b150:	4a0e      	ldr	r2, [pc, #56]	@ (3401b18c <LL_ATON_RT_RuntimeInit+0xa8>)
3401b152:	683b      	ldr	r3, [r7, #0]
3401b154:	6013      	str	r3, [r2, #0]

  /** Initialize OSAL layer **/
  LL_ATON_OSAL_INIT();

  /** Disable all four ATON interrupts **/
  LL_ATON_DISABLE_ALL_IRQs();
3401b156:	2035      	movs	r0, #53	@ 0x35
3401b158:	f7ff faf2 	bl	3401a740 <__NVIC_DisableIRQ>
3401b15c:	2036      	movs	r0, #54	@ 0x36
3401b15e:	f7ff faef 	bl	3401a740 <__NVIC_DisableIRQ>
3401b162:	2037      	movs	r0, #55	@ 0x37
3401b164:	f7ff faec 	bl	3401a740 <__NVIC_DisableIRQ>
3401b168:	2038      	movs	r0, #56	@ 0x38
3401b16a:	f7ff fae9 	bl	3401a740 <__NVIC_DisableIRQ>

  /** Install IRQ handler **/
  LL_ATON_OSAL_INSTALL_IRQ(ATON_STD_IRQ_LINE, ATON_STD_IRQHandler);

  /** Enable ATON `ATON_STD_IRQ_LINE` interrupt **/
  LL_ATON_OSAL_ENABLE_IRQ(ATON_STD_IRQ_LINE);
3401b16e:	2035      	movs	r0, #53	@ 0x35
3401b170:	f7ff fac8 	bl	3401a704 <__NVIC_EnableIRQ>

  /** After having initialized ATON call callback (which among others might initialize further subsystems) */
  if (ll_aton_init_deinit_trace)
3401b174:	4b08      	ldr	r3, [pc, #32]	@ (3401b198 <LL_ATON_RT_RuntimeInit+0xb4>)
3401b176:	681b      	ldr	r3, [r3, #0]
3401b178:	2b00      	cmp	r3, #0
3401b17a:	d003      	beq.n	3401b184 <LL_ATON_RT_RuntimeInit+0xa0>
    ll_aton_init_deinit_trace(LL_ATON_RT_Callbacktype_RT_Init);
3401b17c:	4b06      	ldr	r3, [pc, #24]	@ (3401b198 <LL_ATON_RT_RuntimeInit+0xb4>)
3401b17e:	681b      	ldr	r3, [r3, #0]
3401b180:	2006      	movs	r0, #6
3401b182:	4798      	blx	r3
}
3401b184:	bf00      	nop
3401b186:	3708      	adds	r7, #8
3401b188:	46bd      	mov	sp, r7
3401b18a:	bd80      	pop	{r7, pc}
3401b18c:	580e1000 	.word	0x580e1000
3401b190:	580e1014 	.word	0x580e1014
3401b194:	580e1024 	.word	0x580e1024
3401b198:	340213ac 	.word	0x340213ac

3401b19c <LL_ATON_RT_RuntimeDeInit>:
 * @brief De-initialize the ATON runtime
 * @param nn_instance Pointer to network instance to de-initialize (optional - i.e. may be `NULL`, see
 * `LL_ATON_RT_DeInit_Network()`)
 */
void LL_ATON_RT_RuntimeDeInit(void)
{
3401b19c:	b580      	push	{r7, lr}
3401b19e:	af00      	add	r7, sp, #0
  /* Call runtime de-init callback */
  if (ll_aton_init_deinit_trace)
3401b1a0:	4b0b      	ldr	r3, [pc, #44]	@ (3401b1d0 <LL_ATON_RT_RuntimeDeInit+0x34>)
3401b1a2:	681b      	ldr	r3, [r3, #0]
3401b1a4:	2b00      	cmp	r3, #0
3401b1a6:	d003      	beq.n	3401b1b0 <LL_ATON_RT_RuntimeDeInit+0x14>
    ll_aton_init_deinit_trace(LL_ATON_RT_Callbacktype_RT_Deinit);
3401b1a8:	4b09      	ldr	r3, [pc, #36]	@ (3401b1d0 <LL_ATON_RT_RuntimeDeInit+0x34>)
3401b1aa:	681b      	ldr	r3, [r3, #0]
3401b1ac:	2007      	movs	r0, #7
3401b1ae:	4798      	blx	r3

  /* Disable all four ATON interrupts */
  LL_ATON_DISABLE_ALL_IRQs();
3401b1b0:	2035      	movs	r0, #53	@ 0x35
3401b1b2:	f7ff fac5 	bl	3401a740 <__NVIC_DisableIRQ>
3401b1b6:	2036      	movs	r0, #54	@ 0x36
3401b1b8:	f7ff fac2 	bl	3401a740 <__NVIC_DisableIRQ>
3401b1bc:	2037      	movs	r0, #55	@ 0x37
3401b1be:	f7ff fabf 	bl	3401a740 <__NVIC_DisableIRQ>
3401b1c2:	2038      	movs	r0, #56	@ 0x38
3401b1c4:	f7ff fabc 	bl	3401a740 <__NVIC_DisableIRQ>

  /* De-initialize OSAL layer */
  LL_ATON_OSAL_DEINIT();

  /* De-initialize ATON IPs */
  LL_ATON_DeInit();
3401b1c8:	f7fd fcea 	bl	34018ba0 <LL_ATON_DeInit>
}
3401b1cc:	bf00      	nop
3401b1ce:	bd80      	pop	{r7, pc}
3401b1d0:	340213ac 	.word	0x340213ac

3401b1d4 <LL_ATON_RT_RunEpochBlock>:
 *                            same thread!
 *                            It is entirely the user's responsibility to comply with this restriction!
 * @retval LL_ATON_RT_DONE    NN execution finished
 */
LL_ATON_RT_RetValues_t LL_ATON_RT_RunEpochBlock(NN_Instance_TypeDef *nn_instance)
{
3401b1d4:	b580      	push	{r7, lr}
3401b1d6:	b084      	sub	sp, #16
3401b1d8:	af00      	add	r7, sp, #0
3401b1da:	6078      	str	r0, [r7, #4]
  LL_ATON_ASSERT(nn_instance != NULL);
3401b1dc:	687b      	ldr	r3, [r7, #4]
3401b1de:	2b00      	cmp	r3, #0
3401b1e0:	d106      	bne.n	3401b1f0 <LL_ATON_RT_RunEpochBlock+0x1c>
3401b1e2:	4b63      	ldr	r3, [pc, #396]	@ (3401b370 <LL_ATON_RT_RunEpochBlock+0x19c>)
3401b1e4:	4a63      	ldr	r2, [pc, #396]	@ (3401b374 <LL_ATON_RT_RunEpochBlock+0x1a0>)
3401b1e6:	f44f 7110 	mov.w	r1, #576	@ 0x240
3401b1ea:	4863      	ldr	r0, [pc, #396]	@ (3401b378 <LL_ATON_RT_RunEpochBlock+0x1a4>)
3401b1ec:	f000 faee 	bl	3401b7cc <__assert_func>

  /* Test for wrong/missing initialization */
  LL_ATON_ASSERT(nn_instance->exec_state.current_epoch_block != NULL); // should never happen
3401b1f0:	687b      	ldr	r3, [r7, #4]
3401b1f2:	685b      	ldr	r3, [r3, #4]
3401b1f4:	2b00      	cmp	r3, #0
3401b1f6:	d106      	bne.n	3401b206 <LL_ATON_RT_RunEpochBlock+0x32>
3401b1f8:	4b60      	ldr	r3, [pc, #384]	@ (3401b37c <LL_ATON_RT_RunEpochBlock+0x1a8>)
3401b1fa:	4a5e      	ldr	r2, [pc, #376]	@ (3401b374 <LL_ATON_RT_RunEpochBlock+0x1a0>)
3401b1fc:	f240 2143 	movw	r1, #579	@ 0x243
3401b200:	485d      	ldr	r0, [pc, #372]	@ (3401b378 <LL_ATON_RT_RunEpochBlock+0x1a4>)
3401b202:	f000 fae3 	bl	3401b7cc <__assert_func>

  /* Check if network is starting a new inference */
  if (nn_instance->exec_state.inference_started == false)
3401b206:	687b      	ldr	r3, [r7, #4]
3401b208:	7e1b      	ldrb	r3, [r3, #24]
3401b20a:	f083 0301 	eor.w	r3, r3, #1
3401b20e:	b2db      	uxtb	r3, r3
3401b210:	2b00      	cmp	r3, #0
3401b212:	d022      	beq.n	3401b25a <LL_ATON_RT_RunEpochBlock+0x86>
    {
      LL_ATON_ASSERT((nn_instance->network != NULL) && (nn_instance->network->ec_inference_init != NULL));
      ret = nn_instance->network->ec_inference_init();
    }
#else
    LL_ATON_ASSERT((nn_instance->network != NULL) && (nn_instance->network->ec_inference_init != NULL));
3401b214:	687b      	ldr	r3, [r7, #4]
3401b216:	681b      	ldr	r3, [r3, #0]
3401b218:	2b00      	cmp	r3, #0
3401b21a:	d004      	beq.n	3401b226 <LL_ATON_RT_RunEpochBlock+0x52>
3401b21c:	687b      	ldr	r3, [r7, #4]
3401b21e:	681b      	ldr	r3, [r3, #0]
3401b220:	689b      	ldr	r3, [r3, #8]
3401b222:	2b00      	cmp	r3, #0
3401b224:	d106      	bne.n	3401b234 <LL_ATON_RT_RunEpochBlock+0x60>
3401b226:	4b56      	ldr	r3, [pc, #344]	@ (3401b380 <LL_ATON_RT_RunEpochBlock+0x1ac>)
3401b228:	4a52      	ldr	r2, [pc, #328]	@ (3401b374 <LL_ATON_RT_RunEpochBlock+0x1a0>)
3401b22a:	f240 2155 	movw	r1, #597	@ 0x255
3401b22e:	4852      	ldr	r0, [pc, #328]	@ (3401b378 <LL_ATON_RT_RunEpochBlock+0x1a4>)
3401b230:	f000 facc 	bl	3401b7cc <__assert_func>
    bool ret = nn_instance->network->ec_inference_init();
3401b234:	687b      	ldr	r3, [r7, #4]
3401b236:	681b      	ldr	r3, [r3, #0]
3401b238:	689b      	ldr	r3, [r3, #8]
3401b23a:	4798      	blx	r3
3401b23c:	4603      	mov	r3, r0
3401b23e:	73bb      	strb	r3, [r7, #14]
#endif

    LL_ATON_ASSERT(ret == true);
3401b240:	7bbb      	ldrb	r3, [r7, #14]
3401b242:	2b01      	cmp	r3, #1
3401b244:	d006      	beq.n	3401b254 <LL_ATON_RT_RunEpochBlock+0x80>
3401b246:	4b4f      	ldr	r3, [pc, #316]	@ (3401b384 <LL_ATON_RT_RunEpochBlock+0x1b0>)
3401b248:	4a4a      	ldr	r2, [pc, #296]	@ (3401b374 <LL_ATON_RT_RunEpochBlock+0x1a0>)
3401b24a:	f240 2159 	movw	r1, #601	@ 0x259
3401b24e:	484a      	ldr	r0, [pc, #296]	@ (3401b378 <LL_ATON_RT_RunEpochBlock+0x1a4>)
3401b250:	f000 fabc 	bl	3401b7cc <__assert_func>
    LL_ATON_LIB_UNUSED(ret);

    /* Set inference started flag to `true` */
    nn_instance->exec_state.inference_started = true;
3401b254:	687b      	ldr	r3, [r7, #4]
3401b256:	2201      	movs	r2, #1
3401b258:	761a      	strb	r2, [r3, #24]
    /* Placeholder for things which need to be done before starting an inference */
    /* ==> here <== */
  }

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  bool this_run_executed_end_epoch = false;
3401b25a:	2300      	movs	r3, #0
3401b25c:	73fb      	strb	r3, [r7, #15]

  while (true)
  {
#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
    /* wait for current epoch block to finish */
    uint32_t _wait_mask = __LL_ATON_RT_GetWaitMask(nn_instance->exec_state.current_epoch_block);
3401b25e:	687b      	ldr	r3, [r7, #4]
3401b260:	685b      	ldr	r3, [r3, #4]
3401b262:	4618      	mov	r0, r3
3401b264:	f7ff fe68 	bl	3401af38 <__LL_ATON_RT_GetWaitMask>
3401b268:	60b8      	str	r0, [r7, #8]
    if (nn_instance->exec_state.current_epoch_block_started && (_wait_mask != 0))
3401b26a:	687b      	ldr	r3, [r7, #4]
3401b26c:	f893 3020 	ldrb.w	r3, [r3, #32]
3401b270:	b2db      	uxtb	r3, r3
3401b272:	2b00      	cmp	r3, #0
3401b274:	d030      	beq.n	3401b2d8 <LL_ATON_RT_RunEpochBlock+0x104>
3401b276:	68bb      	ldr	r3, [r7, #8]
3401b278:	2b00      	cmp	r3, #0
3401b27a:	d02d      	beq.n	3401b2d8 <LL_ATON_RT_RunEpochBlock+0x104>
    {
      if ((nn_instance->exec_state.triggered_events & _wait_mask) == _wait_mask)
3401b27c:	687b      	ldr	r3, [r7, #4]
3401b27e:	69da      	ldr	r2, [r3, #28]
3401b280:	68bb      	ldr	r3, [r7, #8]
3401b282:	4013      	ands	r3, r2
3401b284:	68ba      	ldr	r2, [r7, #8]
3401b286:	429a      	cmp	r2, r3
3401b288:	d124      	bne.n	3401b2d4 <LL_ATON_RT_RunEpochBlock+0x100>
      {
        /* Enter critical section */
        LL_ATON_ASSERT(__ll_current_aton_ip_owner ==
3401b28a:	4b3f      	ldr	r3, [pc, #252]	@ (3401b388 <LL_ATON_RT_RunEpochBlock+0x1b4>)
3401b28c:	681b      	ldr	r3, [r3, #0]
3401b28e:	687a      	ldr	r2, [r7, #4]
3401b290:	429a      	cmp	r2, r3
3401b292:	d006      	beq.n	3401b2a2 <LL_ATON_RT_RunEpochBlock+0xce>
3401b294:	4b3d      	ldr	r3, [pc, #244]	@ (3401b38c <LL_ATON_RT_RunEpochBlock+0x1b8>)
3401b296:	4a37      	ldr	r2, [pc, #220]	@ (3401b374 <LL_ATON_RT_RunEpochBlock+0x1a0>)
3401b298:	f240 2171 	movw	r1, #625	@ 0x271
3401b29c:	4836      	ldr	r0, [pc, #216]	@ (3401b378 <LL_ATON_RT_RunEpochBlock+0x1a4>)
3401b29e:	f000 fa95 	bl	3401b7cc <__assert_func>
                       nn_instance); // when entering a critical section we MUST hold the ATON IP lock
        LL_ATON_OSAL_ENTER_CS();
3401b2a2:	2035      	movs	r0, #53	@ 0x35
3401b2a4:	f7ff fa4c 	bl	3401a740 <__NVIC_DisableIRQ>

        /* reset triggered events */
        nn_instance->exec_state.triggered_events &= ~_wait_mask;
3401b2a8:	687b      	ldr	r3, [r7, #4]
3401b2aa:	69da      	ldr	r2, [r3, #28]
3401b2ac:	68bb      	ldr	r3, [r7, #8]
3401b2ae:	43db      	mvns	r3, r3
3401b2b0:	401a      	ands	r2, r3
3401b2b2:	687b      	ldr	r3, [r7, #4]
3401b2b4:	61da      	str	r2, [r3, #28]

        /* Exit critical section */
        LL_ATON_OSAL_EXIT_CS();
3401b2b6:	2035      	movs	r0, #53	@ 0x35
3401b2b8:	f7ff fa24 	bl	3401a704 <__NVIC_EnableIRQ>

        /* end/clean-up epoch block */
        __LL_ATON_RT_ExecEndEpochBlock(nn_instance->exec_state.current_epoch_block, nn_instance);
3401b2bc:	687b      	ldr	r3, [r7, #4]
3401b2be:	685b      	ldr	r3, [r3, #4]
3401b2c0:	6879      	ldr	r1, [r7, #4]
3401b2c2:	4618      	mov	r0, r3
3401b2c4:	f7ff fd1e 	bl	3401ad04 <__LL_ATON_RT_ExecEndEpochBlock>
        this_run_executed_end_epoch = true;
3401b2c8:	2301      	movs	r3, #1
3401b2ca:	73fb      	strb	r3, [r7, #15]

        /* advance epoch block */
        __LL_ATON_RT_DetermineNextEpochBlock(nn_instance);
3401b2cc:	6878      	ldr	r0, [r7, #4]
3401b2ce:	f7ff fdd5 	bl	3401ae7c <__LL_ATON_RT_DetermineNextEpochBlock>
3401b2d2:	e001      	b.n	3401b2d8 <LL_ATON_RT_RunEpochBlock+0x104>
      }
      else
      {
        /* Return to main loop */
        return LL_ATON_RT_WFE;
3401b2d4:	2301      	movs	r3, #1
3401b2d6:	e047      	b.n	3401b368 <LL_ATON_RT_RunEpochBlock+0x194>
      }
    }
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

    /* test for last epoch block */
    if (EpochBlock_IsLastEpochBlock(nn_instance->exec_state.current_epoch_block))
3401b2d8:	687b      	ldr	r3, [r7, #4]
3401b2da:	685b      	ldr	r3, [r3, #4]
3401b2dc:	4618      	mov	r0, r3
3401b2de:	f7ff fa53 	bl	3401a788 <EpochBlock_IsLastEpochBlock>
3401b2e2:	4603      	mov	r3, r0
3401b2e4:	2b00      	cmp	r3, #0
3401b2e6:	d011      	beq.n	3401b30c <LL_ATON_RT_RunEpochBlock+0x138>
    {
      if (nn_instance->exec_state.saved_current_epoch_block != NULL)
3401b2e8:	687b      	ldr	r3, [r7, #4]
3401b2ea:	691b      	ldr	r3, [r3, #16]
3401b2ec:	2b00      	cmp	r3, #0
3401b2ee:	d00b      	beq.n	3401b308 <LL_ATON_RT_RunEpochBlock+0x134>
      {
        /* return from inserted epoch block */
        __LL_ATON_RT_RetFromLibEpochBlockArray(true, nn_instance);
3401b2f0:	6879      	ldr	r1, [r7, #4]
3401b2f2:	2001      	movs	r0, #1
3401b2f4:	f7ff fba4 	bl	3401aa40 <__LL_ATON_RT_RetFromLibEpochBlockArray>

        /* advance epoch block */
        nn_instance->exec_state.current_epoch_block++;
3401b2f8:	687b      	ldr	r3, [r7, #4]
3401b2fa:	685b      	ldr	r3, [r3, #4]
3401b2fc:	f103 0214 	add.w	r2, r3, #20
3401b300:	687b      	ldr	r3, [r7, #4]
3401b302:	605a      	str	r2, [r3, #4]

        /* Return to main loop (but do NOT call `LL_ATON_OSAL_WFE())`) */
        return LL_ATON_RT_NO_WFE;
3401b304:	2300      	movs	r3, #0
3401b306:	e02f      	b.n	3401b368 <LL_ATON_RT_RunEpochBlock+0x194>
      }
      else
      {
        /* Reached end of execution */
        return LL_ATON_RT_DONE;
3401b308:	2302      	movs	r3, #2
3401b30a:	e02d      	b.n	3401b368 <LL_ATON_RT_RunEpochBlock+0x194>
      }
    }

    /* run/start current epoch block */
#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
    if (this_run_executed_end_epoch)
3401b30c:	7bfb      	ldrb	r3, [r7, #15]
3401b30e:	2b00      	cmp	r3, #0
3401b310:	d001      	beq.n	3401b316 <LL_ATON_RT_RunEpochBlock+0x142>
    { // alow reset of network (see function `LL_ATON_RT_Reset_Network()`)
      /* Return to main loop (but do NOT call `LL_ATON_OSAL_WFE())`) */
      return LL_ATON_RT_NO_WFE;
3401b312:	2300      	movs	r3, #0
3401b314:	e028      	b.n	3401b368 <LL_ATON_RT_RunEpochBlock+0x194>
    }

    if (!nn_instance->exec_state.current_epoch_block_started)
3401b316:	687b      	ldr	r3, [r7, #4]
3401b318:	f893 3020 	ldrb.w	r3, [r3, #32]
3401b31c:	b2db      	uxtb	r3, r3
3401b31e:	f083 0301 	eor.w	r3, r3, #1
3401b322:	b2db      	uxtb	r3, r3
3401b324:	2b00      	cmp	r3, #0
3401b326:	d009      	beq.n	3401b33c <LL_ATON_RT_RunEpochBlock+0x168>
    {
      nn_instance->exec_state.current_epoch_block_started = true;
3401b328:	687b      	ldr	r3, [r7, #4]
3401b32a:	2201      	movs	r2, #1
3401b32c:	f883 2020 	strb.w	r2, [r3, #32]

      __LL_ATON_RT_ExecStartEpochBlock(nn_instance->exec_state.current_epoch_block, nn_instance);
3401b330:	687b      	ldr	r3, [r7, #4]
3401b332:	685b      	ldr	r3, [r3, #4]
3401b334:	6879      	ldr	r1, [r7, #4]
3401b336:	4618      	mov	r0, r3
3401b338:	f7ff fc38 	bl	3401abac <__LL_ATON_RT_ExecStartEpochBlock>
    }

    /* End epoch block and advance to next one */
    if (__LL_ATON_RT_GetWaitMask(nn_instance->exec_state.current_epoch_block) == 0x0)
3401b33c:	687b      	ldr	r3, [r7, #4]
3401b33e:	685b      	ldr	r3, [r3, #4]
3401b340:	4618      	mov	r0, r3
3401b342:	f7ff fdf9 	bl	3401af38 <__LL_ATON_RT_GetWaitMask>
3401b346:	4603      	mov	r3, r0
3401b348:	2b00      	cmp	r3, #0
3401b34a:	d10c      	bne.n	3401b366 <LL_ATON_RT_RunEpochBlock+0x192>
    {
      /* end/clean-up epoch block */
      __LL_ATON_RT_ExecEndEpochBlock(nn_instance->exec_state.current_epoch_block, nn_instance);
3401b34c:	687b      	ldr	r3, [r7, #4]
3401b34e:	685b      	ldr	r3, [r3, #4]
3401b350:	6879      	ldr	r1, [r7, #4]
3401b352:	4618      	mov	r0, r3
3401b354:	f7ff fcd6 	bl	3401ad04 <__LL_ATON_RT_ExecEndEpochBlock>
      this_run_executed_end_epoch = true; // has no effect (just for cosmetics)
3401b358:	2301      	movs	r3, #1
3401b35a:	73fb      	strb	r3, [r7, #15]

      /* advance epoch block */
      __LL_ATON_RT_DetermineNextEpochBlock(nn_instance);
3401b35c:	6878      	ldr	r0, [r7, #4]
3401b35e:	f7ff fd8d 	bl	3401ae7c <__LL_ATON_RT_DetermineNextEpochBlock>

      /* Return to main loop (but do NOT call `LL_ATON_OSAL_WFE())`) */
      return LL_ATON_RT_NO_WFE;
3401b362:	2300      	movs	r3, #0
3401b364:	e000      	b.n	3401b368 <LL_ATON_RT_RunEpochBlock+0x194>
    }
    else
    {
      /* Return to main loop */
      return LL_ATON_RT_WFE;
3401b366:	2301      	movs	r3, #1
    /* Return to main loop (but do NOT call `LL_ATON_OSAL_WFE())`) */
    return LL_ATON_RT_NO_WFE;

#endif // (LL_ATON_RT_MODE == LL_ATON_RT_POLLING)
  }
}
3401b368:	4618      	mov	r0, r3
3401b36a:	3710      	adds	r7, #16
3401b36c:	46bd      	mov	sp, r7
3401b36e:	bd80      	pop	{r7, pc}
3401b370:	3401f7f0 	.word	0x3401f7f0
3401b374:	340200ac 	.word	0x340200ac
3401b378:	3401f9a4 	.word	0x3401f9a4
3401b37c:	3401fb98 	.word	0x3401fb98
3401b380:	3401fbd4 	.word	0x3401fbd4
3401b384:	3401fb8c 	.word	0x3401fb8c
3401b388:	340213a4 	.word	0x340213a4
3401b38c:	3401fa3c 	.word	0x3401fa3c

3401b390 <__LL_ATON_RT_IrqErr>:
#if (ATON_INT_NR > 32)
static void __LL_ATON_RT_IrqErr(uint64_t irqs)
#else  //(ATON_INT_NR <= 32)
static void __LL_ATON_RT_IrqErr(uint32_t irqs)
#endif //(ATON_INT_NR <= 32)
{
3401b390:	b5b0      	push	{r4, r5, r7, lr}
3401b392:	b086      	sub	sp, #24
3401b394:	af00      	add	r7, sp, #0
3401b396:	6078      	str	r0, [r7, #4]
  extern void dump_dma_state(void);
  int32_t i;

  if (!irqs)
3401b398:	687b      	ldr	r3, [r7, #4]
3401b39a:	2b00      	cmp	r3, #0
3401b39c:	f000 8095 	beq.w	3401b4ca <__LL_ATON_RT_IrqErr+0x13a>
    return;

#ifdef ATON_STRENG_NUM
  /* Streaming Engine Error interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_STRENG_ERR_INT_MASK, ATON_STRENG_NUM))
3401b3a0:	687a      	ldr	r2, [r7, #4]
3401b3a2:	4b4c      	ldr	r3, [pc, #304]	@ (3401b4d4 <__LL_ATON_RT_IrqErr+0x144>)
3401b3a4:	4013      	ands	r3, r2
3401b3a6:	2b00      	cmp	r3, #0
3401b3a8:	d013      	beq.n	3401b3d2 <__LL_ATON_RT_IrqErr+0x42>
    int64_t masked_irqs; // must be signed for two's compliment `(-masked_irqs)`
#else                    //(ATON_INT_NR <= 32)
    int32_t masked_irqs; // must be signed for two's compliment `(-masked_irqs)`
#endif                   //(ATON_INT_NR <= 32)

    masked_irqs = (irqs & ATON_INT_GET_MASK(ATON_STRENG_ERR_INT_MASK, ATON_STRENG_NUM));
3401b3aa:	687a      	ldr	r2, [r7, #4]
3401b3ac:	4b49      	ldr	r3, [pc, #292]	@ (3401b4d4 <__LL_ATON_RT_IrqErr+0x144>)
3401b3ae:	4013      	ands	r3, r2
3401b3b0:	613b      	str	r3, [r7, #16]

    // assumes that stream engine interrupts are assigned in the order of their engine number and to consecutive bits
    // within the `INTREG` register
    uint32_t streaming_engine_nr = (uint32_t)(masked_irqs & (-masked_irqs));
3401b3b2:	693b      	ldr	r3, [r7, #16]
3401b3b4:	425a      	negs	r2, r3
3401b3b6:	693b      	ldr	r3, [r7, #16]
3401b3b8:	4013      	ands	r3, r2
3401b3ba:	60fb      	str	r3, [r7, #12]
    streaming_engine_nr -= ATON_STRENG_INT(0);

#ifndef NDEBUG
    uint32_t streng_err = ATON_STRENG_IRQ_GET(streaming_engine_nr);
3401b3bc:	68fb      	ldr	r3, [r7, #12]
3401b3be:	031a      	lsls	r2, r3, #12
3401b3c0:	4b45      	ldr	r3, [pc, #276]	@ (3401b4d8 <__LL_ATON_RT_IrqErr+0x148>)
3401b3c2:	4413      	add	r3, r2
3401b3c4:	681b      	ldr	r3, [r3, #0]
3401b3c6:	60bb      	str	r3, [r7, #8]
    LL_ATON_PRINTF("Streaming engine #%u error interrupt: 0x%" PRIx32 "\n", streaming_engine_nr, streng_err);
3401b3c8:	68ba      	ldr	r2, [r7, #8]
3401b3ca:	68f9      	ldr	r1, [r7, #12]
3401b3cc:	4843      	ldr	r0, [pc, #268]	@ (3401b4dc <__LL_ATON_RT_IrqErr+0x14c>)
3401b3ce:	f001 f8a5 	bl	3401c51c <iprintf>
#endif // NDEBUG
  }
  /* Streaming Engine interrupts */
  if (irqs & ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0))
3401b3d2:	687b      	ldr	r3, [r7, #4]
3401b3d4:	f3c3 0309 	ubfx	r3, r3, #0, #10
3401b3d8:	2b00      	cmp	r3, #0
3401b3da:	d002      	beq.n	3401b3e2 <__LL_ATON_RT_IrqErr+0x52>
  {
    LL_ATON_PRINTF("Streaming engine completion interrupt\n");
3401b3dc:	4840      	ldr	r0, [pc, #256]	@ (3401b4e0 <__LL_ATON_RT_IrqErr+0x150>)
3401b3de:	f001 f905 	bl	3401c5ec <puts>
  }
#endif // ATON_STRENG_NUM

#ifdef ATON_CONVACC_NUM
  /* Convolutional accelerators interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_CONVACC_INT_MASK, ATON_CONVACC_NUM))
3401b3e2:	687b      	ldr	r3, [r7, #4]
3401b3e4:	f403 0370 	and.w	r3, r3, #15728640	@ 0xf00000
3401b3e8:	2b00      	cmp	r3, #0
3401b3ea:	d002      	beq.n	3401b3f2 <__LL_ATON_RT_IrqErr+0x62>
  {
    LL_ATON_PRINTF("Convolutional accelerator interrupt\n");
3401b3ec:	483d      	ldr	r0, [pc, #244]	@ (3401b4e4 <__LL_ATON_RT_IrqErr+0x154>)
3401b3ee:	f001 f8fd 	bl	3401c5ec <puts>
  }
#endif // ATON_CONVACC_NUM

#if defined(ATON_RECBUF_NUM)
  /* Reconfigurable buffer interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_RECBUF_INT_MASK, ATON_RECBUF_NUM))
3401b3f2:	687b      	ldr	r3, [r7, #4]
3401b3f4:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
3401b3f8:	2b00      	cmp	r3, #0
3401b3fa:	d002      	beq.n	3401b402 <__LL_ATON_RT_IrqErr+0x72>
  {
    LL_ATON_PRINTF("Reconfigurable buffer interrupt\n");
3401b3fc:	483a      	ldr	r0, [pc, #232]	@ (3401b4e8 <__LL_ATON_RT_IrqErr+0x158>)
3401b3fe:	f001 f8f5 	bl	3401c5ec <puts>
  }
#endif // ATON_RECBUF_NUM

#ifdef ATON_BUSIF_NUM
  /* Bus interface interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_BUSIF_INT_MASK, ATON_BUSIF_NUM))
3401b402:	687b      	ldr	r3, [r7, #4]
3401b404:	f003 63c0 	and.w	r3, r3, #100663296	@ 0x6000000
3401b408:	2b00      	cmp	r3, #0
3401b40a:	d015      	beq.n	3401b438 <__LL_ATON_RT_IrqErr+0xa8>
  {
    LL_ATON_PRINTF("Bus interface interrupt\n");
3401b40c:	4837      	ldr	r0, [pc, #220]	@ (3401b4ec <__LL_ATON_RT_IrqErr+0x15c>)
3401b40e:	f001 f8ed 	bl	3401c5ec <puts>

    /* Report offending stream engine */
    for (i = 0; i < ATON_BUSIF_NUM; i++)
3401b412:	2300      	movs	r3, #0
3401b414:	617b      	str	r3, [r7, #20]
3401b416:	e00c      	b.n	3401b432 <__LL_ATON_RT_IrqErr+0xa2>
      LL_ATON_PRINTF("BUSIF%" PRId32 " ERR: 0x%" PRIx32 "\n", i, ATON_BUSIF_ERR_GET(i));
3401b418:	697b      	ldr	r3, [r7, #20]
3401b41a:	031a      	lsls	r2, r3, #12
3401b41c:	4b34      	ldr	r3, [pc, #208]	@ (3401b4f0 <__LL_ATON_RT_IrqErr+0x160>)
3401b41e:	4413      	add	r3, r2
3401b420:	681b      	ldr	r3, [r3, #0]
3401b422:	461a      	mov	r2, r3
3401b424:	6979      	ldr	r1, [r7, #20]
3401b426:	4833      	ldr	r0, [pc, #204]	@ (3401b4f4 <__LL_ATON_RT_IrqErr+0x164>)
3401b428:	f001 f878 	bl	3401c51c <iprintf>
    for (i = 0; i < ATON_BUSIF_NUM; i++)
3401b42c:	697b      	ldr	r3, [r7, #20]
3401b42e:	3301      	adds	r3, #1
3401b430:	617b      	str	r3, [r7, #20]
3401b432:	697b      	ldr	r3, [r7, #20]
3401b434:	2b01      	cmp	r3, #1
3401b436:	ddef      	ble.n	3401b418 <__LL_ATON_RT_IrqErr+0x88>
  }
#endif // ATON_BUSIF_NUM

#if defined(ATON_STRSWITCH_NUM)
  /* Stream switch interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_STRSWITCH_INT_MASK, ATON_STRSWITCH_NUM))
3401b438:	687b      	ldr	r3, [r7, #4]
3401b43a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3401b43e:	2b00      	cmp	r3, #0
3401b440:	d002      	beq.n	3401b448 <__LL_ATON_RT_IrqErr+0xb8>
  {
    LL_ATON_PRINTF("Stream switch interrupt\n");
3401b442:	482d      	ldr	r0, [pc, #180]	@ (3401b4f8 <__LL_ATON_RT_IrqErr+0x168>)
3401b444:	f001 f8d2 	bl	3401c5ec <puts>
  }
#endif // ATON_STRSWITCH_NUM

#if defined(ATON_EPOCHCTRL_NUM)
  /* Epoch Controller interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_ERR_INT_MASK, ATON_EPOCHCTRL_NUM))
3401b448:	687b      	ldr	r3, [r7, #4]
3401b44a:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3401b44e:	2b00      	cmp	r3, #0
3401b450:	d011      	beq.n	3401b476 <__LL_ATON_RT_IrqErr+0xe6>
  {
    LL_ATON_PRINTF("Epoch Controller ERROR interrupt: EC_IRQ = 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_IRQ_GET(0));
3401b452:	4b2a      	ldr	r3, [pc, #168]	@ (3401b4fc <__LL_ATON_RT_IrqErr+0x16c>)
3401b454:	681b      	ldr	r3, [r3, #0]
3401b456:	4619      	mov	r1, r3
3401b458:	4829      	ldr	r0, [pc, #164]	@ (3401b500 <__LL_ATON_RT_IrqErr+0x170>)
3401b45a:	f001 f85f 	bl	3401c51c <iprintf>
    LL_ATON_PRINTF("Epoch Controller opcode counter: 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_BC_GET(0));
3401b45e:	4b29      	ldr	r3, [pc, #164]	@ (3401b504 <__LL_ATON_RT_IrqErr+0x174>)
3401b460:	681b      	ldr	r3, [r3, #0]
3401b462:	4619      	mov	r1, r3
3401b464:	4828      	ldr	r0, [pc, #160]	@ (3401b508 <__LL_ATON_RT_IrqErr+0x178>)
3401b466:	f001 f859 	bl	3401c51c <iprintf>
    LL_ATON_PRINTF("Epoch Controller label: 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_LABEL_GET(0));
3401b46a:	4b28      	ldr	r3, [pc, #160]	@ (3401b50c <__LL_ATON_RT_IrqErr+0x17c>)
3401b46c:	681b      	ldr	r3, [r3, #0]
3401b46e:	4619      	mov	r1, r3
3401b470:	4827      	ldr	r0, [pc, #156]	@ (3401b510 <__LL_ATON_RT_IrqErr+0x180>)
3401b472:	f001 f853 	bl	3401c51c <iprintf>
  }
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_NOACK_INT_MASK, ATON_EPOCHCTRL_NUM))
3401b476:	687b      	ldr	r3, [r7, #4]
3401b478:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
3401b47c:	2b00      	cmp	r3, #0
3401b47e:	d002      	beq.n	3401b486 <__LL_ATON_RT_IrqErr+0xf6>
  {
    LL_ATON_PRINTF("Epoch Controller NOACK interrupt\n");
3401b480:	4824      	ldr	r0, [pc, #144]	@ (3401b514 <__LL_ATON_RT_IrqErr+0x184>)
3401b482:	f001 f8b3 	bl	3401c5ec <puts>
  }
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_INT_MASK, ATON_EPOCHCTRL_NUM))
3401b486:	687b      	ldr	r3, [r7, #4]
3401b488:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
3401b48c:	2b00      	cmp	r3, #0
3401b48e:	d002      	beq.n	3401b496 <__LL_ATON_RT_IrqErr+0x106>
  {
    LL_ATON_PRINTF("Epoch Controller interrupt\n");
3401b490:	4821      	ldr	r0, [pc, #132]	@ (3401b518 <__LL_ATON_RT_IrqErr+0x188>)
3401b492:	f001 f8ab 	bl	3401c5ec <puts>
  }
#endif // ATON_EPOCHCTRL_NUM

  /* default error handling */
  dump_dma_state();
3401b496:	f7ff fb61 	bl	3401ab5c <dump_dma_state>
  IRQ_ERR_MSG(); // just for debug
3401b49a:	687b      	ldr	r3, [r7, #4]
3401b49c:	2200      	movs	r2, #0
3401b49e:	461c      	mov	r4, r3
3401b4a0:	4615      	mov	r5, r2
3401b4a2:	4622      	mov	r2, r4
3401b4a4:	462b      	mov	r3, r5
3401b4a6:	f240 314a 	movw	r1, #842	@ 0x34a
3401b4aa:	481c      	ldr	r0, [pc, #112]	@ (3401b51c <__LL_ATON_RT_IrqErr+0x18c>)
3401b4ac:	f001 f836 	bl	3401c51c <iprintf>
//#if (ATON_PLAT_HAS_FFLUSH)
  LL_ATON_FFLUSH(stdout);
3401b4b0:	4b1b      	ldr	r3, [pc, #108]	@ (3401b520 <__LL_ATON_RT_IrqErr+0x190>)
3401b4b2:	681b      	ldr	r3, [r3, #0]
3401b4b4:	689b      	ldr	r3, [r3, #8]
3401b4b6:	4618      	mov	r0, r3
3401b4b8:	f000 ff48 	bl	3401c34c <fflush>
//#endif
  LL_ATON_ASSERT(false); // may never happen
3401b4bc:	4b19      	ldr	r3, [pc, #100]	@ (3401b524 <__LL_ATON_RT_IrqErr+0x194>)
3401b4be:	4a1a      	ldr	r2, [pc, #104]	@ (3401b528 <__LL_ATON_RT_IrqErr+0x198>)
3401b4c0:	f240 314e 	movw	r1, #846	@ 0x34e
3401b4c4:	4819      	ldr	r0, [pc, #100]	@ (3401b52c <__LL_ATON_RT_IrqErr+0x19c>)
3401b4c6:	f000 f981 	bl	3401b7cc <__assert_func>
    return;
3401b4ca:	bf00      	nop
  // All of the above not handled interrupts should be changed in a way that allows both a return from
  // this IRQ handler (w/o immediate re-entry) and to return control back to the user's main loop e.g. by using an
  // internal flag/variable to signal the error, then performing a `LL_ATON_RT_RuntimeDeInit()`, and returning with a
  // respective (new) return value (of type `LL_ATON_RT_RetValues_t`), reporting about the error, from the latest
  // call to `LL_ATON_RT_RunEpochBlock()`
}
3401b4cc:	3718      	adds	r7, #24
3401b4ce:	46bd      	mov	sp, r7
3401b4d0:	bdb0      	pop	{r4, r5, r7, pc}
3401b4d2:	bf00      	nop
3401b4d4:	000ffc00 	.word	0x000ffc00
3401b4d8:	580e503c 	.word	0x580e503c
3401b4dc:	3401fc38 	.word	0x3401fc38
3401b4e0:	3401fc68 	.word	0x3401fc68
3401b4e4:	3401fc90 	.word	0x3401fc90
3401b4e8:	3401fcb4 	.word	0x3401fcb4
3401b4ec:	3401fcd4 	.word	0x3401fcd4
3401b4f0:	580e2010 	.word	0x580e2010
3401b4f4:	3401fcec 	.word	0x3401fcec
3401b4f8:	3401fd04 	.word	0x3401fd04
3401b4fc:	580fe00c 	.word	0x580fe00c
3401b500:	3401fd1c 	.word	0x3401fd1c
3401b504:	580fe020 	.word	0x580fe020
3401b508:	3401fd50 	.word	0x3401fd50
3401b50c:	580fe01c 	.word	0x580fe01c
3401b510:	3401fd7c 	.word	0x3401fd7c
3401b514:	3401fda0 	.word	0x3401fda0
3401b518:	3401fdc4 	.word	0x3401fdc4
3401b51c:	3401fde0 	.word	0x3401fde0
3401b520:	34020c6c 	.word	0x34020c6c
3401b524:	3401fe08 	.word	0x3401fe08
3401b528:	340201c0 	.word	0x340201c0
3401b52c:	3401f9a4 	.word	0x3401f9a4

3401b530 <__LL_ATON_RT_IrqEpochBlock>:
#if (ATON_INT_NR > 32)
static inline void __LL_ATON_RT_IrqEpochBlock(uint64_t irqs)
#else  //(ATON_INT_NR <= 32)
static inline void __LL_ATON_RT_IrqEpochBlock(uint32_t irqs)
#endif //(ATON_INT_NR <= 32)
{
3401b530:	b480      	push	{r7}
3401b532:	b087      	sub	sp, #28
3401b534:	af00      	add	r7, sp, #0
3401b536:	6078      	str	r0, [r7, #4]
   * consecutive bits within the `INTREG` register (and within all other interrupt controller registers, like e.g.
   * status/mask/clear)! */
  irqs >>= ATON_STRENG_INT(0);
  wait_irqs =
      irqs &
      __ll_current_aton_ip_owner->exec_state.current_epoch_block
3401b538:	4b1e      	ldr	r3, [pc, #120]	@ (3401b5b4 <__LL_ATON_RT_IrqEpochBlock+0x84>)
3401b53a:	681b      	ldr	r3, [r3, #0]
3401b53c:	685b      	ldr	r3, [r3, #4]
          ->wait_mask; /* treat only IRQs we are currently waiting for
3401b53e:	68db      	ldr	r3, [r3, #12]
  wait_irqs =
3401b540:	687a      	ldr	r2, [r7, #4]
3401b542:	4013      	ands	r3, r2
3401b544:	60fb      	str	r3, [r7, #12]
                          (Note: we might be running in a hybrid function which uses DMAs in parallel with a "normal"
                          ATON execution and we must not clear the IRQs of this "normal" ATON execution here) */
  if (wait_irqs)
3401b546:	68fb      	ldr	r3, [r7, #12]
3401b548:	2b00      	cmp	r3, #0
3401b54a:	d02d      	beq.n	3401b5a8 <__LL_ATON_RT_IrqEpochBlock+0x78>
  {
    uint32_t _tmp_triggered_events = __ll_current_aton_ip_owner->exec_state.triggered_events;
3401b54c:	4b19      	ldr	r3, [pc, #100]	@ (3401b5b4 <__LL_ATON_RT_IrqEpochBlock+0x84>)
3401b54e:	681b      	ldr	r3, [r3, #0]
3401b550:	69db      	ldr	r3, [r3, #28]
3401b552:	613b      	str	r3, [r7, #16]
    for (i = 0; i < ATON_STRENG_NUM; i++)
3401b554:	2300      	movs	r3, #0
3401b556:	617b      	str	r3, [r7, #20]
3401b558:	e01f      	b.n	3401b59a <__LL_ATON_RT_IrqEpochBlock+0x6a>
    {
      /* Handle event interrupts */
      if ((wait_irqs >> i) & 1)
3401b55a:	68fa      	ldr	r2, [r7, #12]
3401b55c:	697b      	ldr	r3, [r7, #20]
3401b55e:	fa22 f303 	lsr.w	r3, r2, r3
3401b562:	f003 0301 	and.w	r3, r3, #1
3401b566:	2b00      	cmp	r3, #0
3401b568:	d014      	beq.n	3401b594 <__LL_ATON_RT_IrqEpochBlock+0x64>
      { /* more future-proofed but less efficient alternative:
           `if (wait_irqs & ATON_STRENG_INT_MASK(i, 0, 0))`
         */
        uint32_t strengIrqs = ATON_STRENG_IRQ_GET(i);
3401b56a:	697b      	ldr	r3, [r7, #20]
3401b56c:	031a      	lsls	r2, r3, #12
3401b56e:	4b12      	ldr	r3, [pc, #72]	@ (3401b5b8 <__LL_ATON_RT_IrqEpochBlock+0x88>)
3401b570:	4413      	add	r3, r2
3401b572:	681b      	ldr	r3, [r3, #0]
3401b574:	60bb      	str	r3, [r7, #8]
        ATON_STRENG_IRQ_SET(
3401b576:	697b      	ldr	r3, [r7, #20]
3401b578:	031a      	lsls	r2, r3, #12
3401b57a:	4b0f      	ldr	r3, [pc, #60]	@ (3401b5b8 <__LL_ATON_RT_IrqEpochBlock+0x88>)
3401b57c:	4413      	add	r3, r2
3401b57e:	461a      	mov	r2, r3
3401b580:	68bb      	ldr	r3, [r7, #8]
3401b582:	6013      	str	r3, [r2, #0]
            i, strengIrqs); /* Acknowledge ATON interrupt source (i.e. stream engine #i) - could be more fine grain */

        /* Handle RT integration */
        _tmp_triggered_events |= (1 << i);
3401b584:	2201      	movs	r2, #1
3401b586:	697b      	ldr	r3, [r7, #20]
3401b588:	fa02 f303 	lsl.w	r3, r2, r3
3401b58c:	461a      	mov	r2, r3
3401b58e:	693b      	ldr	r3, [r7, #16]
3401b590:	4313      	orrs	r3, r2
3401b592:	613b      	str	r3, [r7, #16]
    for (i = 0; i < ATON_STRENG_NUM; i++)
3401b594:	697b      	ldr	r3, [r7, #20]
3401b596:	3301      	adds	r3, #1
3401b598:	617b      	str	r3, [r7, #20]
3401b59a:	697b      	ldr	r3, [r7, #20]
3401b59c:	2b09      	cmp	r3, #9
3401b59e:	dddc      	ble.n	3401b55a <__LL_ATON_RT_IrqEpochBlock+0x2a>
      }
    }
    __ll_current_aton_ip_owner->exec_state.triggered_events = _tmp_triggered_events;
3401b5a0:	4b04      	ldr	r3, [pc, #16]	@ (3401b5b4 <__LL_ATON_RT_IrqEpochBlock+0x84>)
3401b5a2:	681b      	ldr	r3, [r3, #0]
3401b5a4:	693a      	ldr	r2, [r7, #16]
3401b5a6:	61da      	str	r2, [r3, #28]
  }
}
3401b5a8:	bf00      	nop
3401b5aa:	371c      	adds	r7, #28
3401b5ac:	46bd      	mov	sp, r7
3401b5ae:	f85d 7b04 	ldr.w	r7, [sp], #4
3401b5b2:	4770      	bx	lr
3401b5b4:	340213a4 	.word	0x340213a4
3401b5b8:	580e503c 	.word	0x580e503c

3401b5bc <__LL_ATON_RT_IrqEpochBlob>:
#if (ATON_INT_NR > 32)
static inline void __LL_ATON_RT_IrqEpochBlob(uint64_t irqs)
#else  //(ATON_INT_NR <= 32)
static inline void __LL_ATON_RT_IrqEpochBlob(uint32_t irqs)
#endif //(ATON_INT_NR <= 32)
{
3401b5bc:	b580      	push	{r7, lr}
3401b5be:	b086      	sub	sp, #24
3401b5c0:	af00      	add	r7, sp, #0
3401b5c2:	6078      	str	r0, [r7, #4]
  uint32_t ecId = EpochBlock_EpochControllerUnit(__ll_current_aton_ip_owner->exec_state.current_epoch_block);
3401b5c4:	4b1d      	ldr	r3, [pc, #116]	@ (3401b63c <__LL_ATON_RT_IrqEpochBlob+0x80>)
3401b5c6:	681b      	ldr	r3, [r3, #0]
3401b5c8:	685b      	ldr	r3, [r3, #4]
3401b5ca:	4618      	mov	r0, r3
3401b5cc:	f7ff f94e 	bl	3401a86c <EpochBlock_EpochControllerUnit>
3401b5d0:	6178      	str	r0, [r7, #20]
  LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3401b5d2:	697b      	ldr	r3, [r7, #20]
3401b5d4:	2b00      	cmp	r3, #0
3401b5d6:	d006      	beq.n	3401b5e6 <__LL_ATON_RT_IrqEpochBlob+0x2a>
3401b5d8:	4b19      	ldr	r3, [pc, #100]	@ (3401b640 <__LL_ATON_RT_IrqEpochBlob+0x84>)
3401b5da:	4a1a      	ldr	r2, [pc, #104]	@ (3401b644 <__LL_ATON_RT_IrqEpochBlob+0x88>)
3401b5dc:	f240 3191 	movw	r1, #913	@ 0x391
3401b5e0:	4819      	ldr	r0, [pc, #100]	@ (3401b648 <__LL_ATON_RT_IrqEpochBlob+0x8c>)
3401b5e2:	f000 f8f3 	bl	3401b7cc <__assert_func>
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_INT_MASK, ecId))
3401b5e6:	697b      	ldr	r3, [r7, #20]
3401b5e8:	2b00      	cmp	r3, #0
3401b5ea:	d007      	beq.n	3401b5fc <__LL_ATON_RT_IrqEpochBlob+0x40>
3401b5ec:	697b      	ldr	r3, [r7, #20]
3401b5ee:	2b01      	cmp	r3, #1
3401b5f0:	d102      	bne.n	3401b5f8 <__LL_ATON_RT_IrqEpochBlob+0x3c>
3401b5f2:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
3401b5f6:	e003      	b.n	3401b600 <__LL_ATON_RT_IrqEpochBlob+0x44>
3401b5f8:	2300      	movs	r3, #0
3401b5fa:	e001      	b.n	3401b600 <__LL_ATON_RT_IrqEpochBlob+0x44>
3401b5fc:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
3401b600:	687a      	ldr	r2, [r7, #4]
3401b602:	4013      	ands	r3, r2
3401b604:	2b00      	cmp	r3, #0
3401b606:	d015      	beq.n	3401b634 <__LL_ATON_RT_IrqEpochBlob+0x78>
  {
    /* Acknowledge interrupts in active epoch controller unit - could be more fine grain */
    uint32_t ecIrqs = ATON_EPOCHCTRL_IRQ_GET(ecId);
3401b608:	4b10      	ldr	r3, [pc, #64]	@ (3401b64c <__LL_ATON_RT_IrqEpochBlob+0x90>)
3401b60a:	681b      	ldr	r3, [r3, #0]
3401b60c:	613b      	str	r3, [r7, #16]
    ATON_EPOCHCTRL_IRQ_SET(ecId, ecIrqs);
3401b60e:	4a0f      	ldr	r2, [pc, #60]	@ (3401b64c <__LL_ATON_RT_IrqEpochBlob+0x90>)
3401b610:	693b      	ldr	r3, [r7, #16]
3401b612:	6013      	str	r3, [r2, #0]

    /* Handle RT integration */
    uint32_t _tmp_triggered_events = __ll_current_aton_ip_owner->exec_state.triggered_events;
3401b614:	4b09      	ldr	r3, [pc, #36]	@ (3401b63c <__LL_ATON_RT_IrqEpochBlob+0x80>)
3401b616:	681b      	ldr	r3, [r3, #0]
3401b618:	69db      	ldr	r3, [r3, #28]
3401b61a:	60fb      	str	r3, [r7, #12]
    _tmp_triggered_events |= (1 << ecId);
3401b61c:	2201      	movs	r2, #1
3401b61e:	697b      	ldr	r3, [r7, #20]
3401b620:	fa02 f303 	lsl.w	r3, r2, r3
3401b624:	461a      	mov	r2, r3
3401b626:	68fb      	ldr	r3, [r7, #12]
3401b628:	4313      	orrs	r3, r2
3401b62a:	60fb      	str	r3, [r7, #12]
    __ll_current_aton_ip_owner->exec_state.triggered_events = _tmp_triggered_events;
3401b62c:	4b03      	ldr	r3, [pc, #12]	@ (3401b63c <__LL_ATON_RT_IrqEpochBlob+0x80>)
3401b62e:	681b      	ldr	r3, [r3, #0]
3401b630:	68fa      	ldr	r2, [r7, #12]
3401b632:	61da      	str	r2, [r3, #28]
  }
}
3401b634:	bf00      	nop
3401b636:	3718      	adds	r7, #24
3401b638:	46bd      	mov	sp, r7
3401b63a:	bd80      	pop	{r7, pc}
3401b63c:	340213a4 	.word	0x340213a4
3401b640:	3401fa68 	.word	0x3401fa68
3401b644:	340201e4 	.word	0x340201e4
3401b648:	3401f9a4 	.word	0x3401f9a4
3401b64c:	580fe00c 	.word	0x580fe00c

3401b650 <NPU0_IRQHandler>:
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

/* ATON ISR
 * ll_aton routes all interrupts to `ATON_STD_IRQ_LINE` interrupt line */
void ATON_STD_IRQHandler(void)
{
3401b650:	b580      	push	{r7, lr}
3401b652:	b082      	sub	sp, #8
3401b654:	af00      	add	r7, sp, #0
#if (ATON_INT_NR > 32)
  uint32_t irqs_l = ATON_INTCTRL_INTREG_GET(0);
  uint32_t irqs_h = ATON_INTCTRL_INTREG_H_GET(0);
  uint64_t irqs = irqs_l | (irqs_h << 32);
#else  //(ATON_INT_NR <= 32)
  uint32_t irqs = ATON_INTCTRL_INTREG_GET(0);
3401b656:	4b3d      	ldr	r3, [pc, #244]	@ (3401b74c <NPU0_IRQHandler+0xfc>)
3401b658:	681b      	ldr	r3, [r3, #0]
3401b65a:	607b      	str	r3, [r7, #4]
#endif //(ATON_INT_NR <= 32)

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  if (__ll_current_aton_ip_owner != NULL)
3401b65c:	4b3c      	ldr	r3, [pc, #240]	@ (3401b750 <NPU0_IRQHandler+0x100>)
3401b65e:	681b      	ldr	r3, [r3, #0]
3401b660:	2b00      	cmp	r3, #0
3401b662:	d045      	beq.n	3401b6f0 <NPU0_IRQHandler+0xa0>
  {
    LL_ATON_ASSERT(__ll_current_aton_ip_owner->exec_state.current_epoch_block != NULL);
3401b664:	4b3a      	ldr	r3, [pc, #232]	@ (3401b750 <NPU0_IRQHandler+0x100>)
3401b666:	681b      	ldr	r3, [r3, #0]
3401b668:	685b      	ldr	r3, [r3, #4]
3401b66a:	2b00      	cmp	r3, #0
3401b66c:	d106      	bne.n	3401b67c <NPU0_IRQHandler+0x2c>
3401b66e:	4b39      	ldr	r3, [pc, #228]	@ (3401b754 <NPU0_IRQHandler+0x104>)
3401b670:	4a39      	ldr	r2, [pc, #228]	@ (3401b758 <NPU0_IRQHandler+0x108>)
3401b672:	f240 31b1 	movw	r1, #945	@ 0x3b1
3401b676:	4839      	ldr	r0, [pc, #228]	@ (3401b75c <NPU0_IRQHandler+0x10c>)
3401b678:	f000 f8a8 	bl	3401b7cc <__assert_func>

    /** OR-mask interrupts MUST be handled first **/
    if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state
3401b67c:	4b34      	ldr	r3, [pc, #208]	@ (3401b750 <NPU0_IRQHandler+0x100>)
3401b67e:	681b      	ldr	r3, [r3, #0]
                                    .current_epoch_block)) // standard epoch block handling based on streaming engines
3401b680:	685b      	ldr	r3, [r3, #4]
    if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state
3401b682:	4618      	mov	r0, r3
3401b684:	f7ff f8a6 	bl	3401a7d4 <EpochBlock_IsEpochBlob>
3401b688:	4603      	mov	r3, r0
3401b68a:	f083 0301 	eor.w	r3, r3, #1
3401b68e:	b2db      	uxtb	r3, r3
3401b690:	2b00      	cmp	r3, #0
3401b692:	d008      	beq.n	3401b6a6 <NPU0_IRQHandler+0x56>
    {
      __LL_ATON_RT_IrqErr(
3401b694:	687b      	ldr	r3, [r7, #4]
3401b696:	f423 737f 	bic.w	r3, r3, #1020	@ 0x3fc
3401b69a:	f023 0303 	bic.w	r3, r3, #3
3401b69e:	4618      	mov	r0, r3
3401b6a0:	f7ff fe76 	bl	3401b390 <__LL_ATON_RT_IrqErr>
3401b6a4:	e027      	b.n	3401b6f6 <NPU0_IRQHandler+0xa6>
          irqs & ~ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0)); /* exclude all streaming engine completion interrupts */
    }
    else // epoch blob handling based on epoch controller
    {
#if defined(ATON_EPOCHCTRL_NUM)
      uint32_t ecId = EpochBlock_EpochControllerUnit(__ll_current_aton_ip_owner->exec_state.current_epoch_block);
3401b6a6:	4b2a      	ldr	r3, [pc, #168]	@ (3401b750 <NPU0_IRQHandler+0x100>)
3401b6a8:	681b      	ldr	r3, [r3, #0]
3401b6aa:	685b      	ldr	r3, [r3, #4]
3401b6ac:	4618      	mov	r0, r3
3401b6ae:	f7ff f8dd 	bl	3401a86c <EpochBlock_EpochControllerUnit>
3401b6b2:	6038      	str	r0, [r7, #0]
      LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3401b6b4:	683b      	ldr	r3, [r7, #0]
3401b6b6:	2b00      	cmp	r3, #0
3401b6b8:	d006      	beq.n	3401b6c8 <NPU0_IRQHandler+0x78>
3401b6ba:	4b29      	ldr	r3, [pc, #164]	@ (3401b760 <NPU0_IRQHandler+0x110>)
3401b6bc:	4a26      	ldr	r2, [pc, #152]	@ (3401b758 <NPU0_IRQHandler+0x108>)
3401b6be:	f240 31be 	movw	r1, #958	@ 0x3be
3401b6c2:	4826      	ldr	r0, [pc, #152]	@ (3401b75c <NPU0_IRQHandler+0x10c>)
3401b6c4:	f000 f882 	bl	3401b7cc <__assert_func>

      // epoch blob handling based on epoch controller interrupt
      __LL_ATON_RT_IrqErr(
          irqs & ~ATON_INT_GET_MASK(ATON_EPOCHCTRL_INT_MASK,
3401b6c8:	683b      	ldr	r3, [r7, #0]
3401b6ca:	2b00      	cmp	r3, #0
3401b6cc:	d008      	beq.n	3401b6e0 <NPU0_IRQHandler+0x90>
3401b6ce:	683b      	ldr	r3, [r7, #0]
3401b6d0:	2b01      	cmp	r3, #1
3401b6d2:	d102      	bne.n	3401b6da <NPU0_IRQHandler+0x8a>
3401b6d4:	f06f 5380 	mvn.w	r3, #268435456	@ 0x10000000
3401b6d8:	e004      	b.n	3401b6e4 <NPU0_IRQHandler+0x94>
3401b6da:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
3401b6de:	e001      	b.n	3401b6e4 <NPU0_IRQHandler+0x94>
3401b6e0:	f06f 5380 	mvn.w	r3, #268435456	@ 0x10000000
      __LL_ATON_RT_IrqErr(
3401b6e4:	687a      	ldr	r2, [r7, #4]
3401b6e6:	4013      	ands	r3, r2
3401b6e8:	4618      	mov	r0, r3
3401b6ea:	f7ff fe51 	bl	3401b390 <__LL_ATON_RT_IrqErr>
3401b6ee:	e002      	b.n	3401b6f6 <NPU0_IRQHandler+0xa6>
#endif                                      // !ATON_EPOCHCTRL_NUM
    }
  }
  else // `__ll_current_aton_ip_owner == NULL`
  {
    __LL_ATON_RT_IrqErr(irqs); /* treat all interrupts as errors */
3401b6f0:	6878      	ldr	r0, [r7, #4]
3401b6f2:	f7ff fe4d 	bl	3401b390 <__LL_ATON_RT_IrqErr>
#else  // (LL_ATON_RT_MODE == LL_ATON_RT_POLLING)
  __LL_ATON_RT_IrqErr(irqs); /* treat all interrupts as errors */
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_POLLING)

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
3401b6f6:	4b16      	ldr	r3, [pc, #88]	@ (3401b750 <NPU0_IRQHandler+0x100>)
3401b6f8:	681b      	ldr	r3, [r3, #0]
3401b6fa:	2b00      	cmp	r3, #0
3401b6fc:	d106      	bne.n	3401b70c <NPU0_IRQHandler+0xbc>
3401b6fe:	4b19      	ldr	r3, [pc, #100]	@ (3401b764 <NPU0_IRQHandler+0x114>)
3401b700:	4a15      	ldr	r2, [pc, #84]	@ (3401b758 <NPU0_IRQHandler+0x108>)
3401b702:	f240 31d2 	movw	r1, #978	@ 0x3d2
3401b706:	4815      	ldr	r0, [pc, #84]	@ (3401b75c <NPU0_IRQHandler+0x10c>)
3401b708:	f000 f860 	bl	3401b7cc <__assert_func>

  if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state.current_epoch_block))
3401b70c:	4b10      	ldr	r3, [pc, #64]	@ (3401b750 <NPU0_IRQHandler+0x100>)
3401b70e:	681b      	ldr	r3, [r3, #0]
3401b710:	685b      	ldr	r3, [r3, #4]
3401b712:	4618      	mov	r0, r3
3401b714:	f7ff f85e 	bl	3401a7d4 <EpochBlock_IsEpochBlob>
3401b718:	4603      	mov	r3, r0
3401b71a:	f083 0301 	eor.w	r3, r3, #1
3401b71e:	b2db      	uxtb	r3, r3
3401b720:	2b00      	cmp	r3, #0
3401b722:	d003      	beq.n	3401b72c <NPU0_IRQHandler+0xdc>
  { // standard epoch block handling based on streaming engines
    __LL_ATON_RT_IrqEpochBlock(irqs);
3401b724:	6878      	ldr	r0, [r7, #4]
3401b726:	f7ff ff03 	bl	3401b530 <__LL_ATON_RT_IrqEpochBlock>
3401b72a:	e002      	b.n	3401b732 <NPU0_IRQHandler+0xe2>
  }
  else
  { // epoch blob handling based on epoch controller
#if defined(ATON_EPOCHCTRL_NUM)
    __LL_ATON_RT_IrqEpochBlob(irqs);
3401b72c:	6878      	ldr	r0, [r7, #4]
3401b72e:	f7ff ff45 	bl	3401b5bc <__LL_ATON_RT_IrqEpochBlob>
  __ASM volatile ("dsb 0xF":::"memory");
3401b732:	f3bf 8f4f 	dsb	sy
}
3401b736:	bf00      	nop
   */
#if (ATON_INT_NR > 32)
  ATON_INTCTRL_INTCLR_SET(0, irqs_l);
  ATON_INTCTRL_INTCLR_H_SET(0, irqs_h);
#else  //(ATON_INT_NR <= 32)
  ATON_INTCTRL_INTCLR_SET(0, irqs);
3401b738:	4a0b      	ldr	r2, [pc, #44]	@ (3401b768 <NPU0_IRQHandler+0x118>)
3401b73a:	687b      	ldr	r3, [r7, #4]
3401b73c:	6013      	str	r3, [r2, #0]
  __ASM volatile ("dsb 0xF":::"memory");
3401b73e:	f3bf 8f4f 	dsb	sy
}
3401b742:	bf00      	nop
  /* Signal event */
  LL_ATON_OSAL_SIGNAL_EVENT();

#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

  return;
3401b744:	bf00      	nop
}
3401b746:	3708      	adds	r7, #8
3401b748:	46bd      	mov	sp, r7
3401b74a:	bd80      	pop	{r7, pc}
3401b74c:	580e1008 	.word	0x580e1008
3401b750:	340213a4 	.word	0x340213a4
3401b754:	3401fe0c 	.word	0x3401fe0c
3401b758:	340201d4 	.word	0x340201d4
3401b75c:	3401f9a4 	.word	0x3401f9a4
3401b760:	3401fa68 	.word	0x3401fa68
3401b764:	3401f83c 	.word	0x3401f83c
3401b768:	580e1010 	.word	0x580e1010

3401b76c <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_sstack
3401b76c:	480f      	ldr	r0, [pc, #60]	@ (3401b7ac <LoopForever+0x4>)
  msr   MSPLIM, r0
3401b76e:	f380 880a 	msr	MSPLIM, r0
  ldr   r0, =_estack
3401b772:	480f      	ldr	r0, [pc, #60]	@ (3401b7b0 <LoopForever+0x8>)
  mov   sp, r0          /* set stack pointer */
3401b774:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
3401b776:	f7e8 f963 	bl	34003a40 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
3401b77a:	480e      	ldr	r0, [pc, #56]	@ (3401b7b4 <LoopForever+0xc>)
  ldr r1, =_edata
3401b77c:	490e      	ldr	r1, [pc, #56]	@ (3401b7b8 <LoopForever+0x10>)
  ldr r2, =_sidata
3401b77e:	4a0f      	ldr	r2, [pc, #60]	@ (3401b7bc <LoopForever+0x14>)
  movs r3, #0
3401b780:	2300      	movs	r3, #0
  b LoopCopyDataInit
3401b782:	e002      	b.n	3401b78a <LoopCopyDataInit>

3401b784 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
3401b784:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
3401b786:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
3401b788:	3304      	adds	r3, #4

3401b78a <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
3401b78a:	18c4      	adds	r4, r0, r3
  cmp r4, r1
3401b78c:	428c      	cmp	r4, r1
  bcc CopyDataInit
3401b78e:	d3f9      	bcc.n	3401b784 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
3401b790:	4a0b      	ldr	r2, [pc, #44]	@ (3401b7c0 <LoopForever+0x18>)
  ldr r4, =_ebss
3401b792:	4c0c      	ldr	r4, [pc, #48]	@ (3401b7c4 <LoopForever+0x1c>)
  movs r3, #0
3401b794:	2300      	movs	r3, #0
  b LoopFillZerobss
3401b796:	e001      	b.n	3401b79c <LoopFillZerobss>

3401b798 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
3401b798:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
3401b79a:	3204      	adds	r2, #4

3401b79c <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
3401b79c:	42a2      	cmp	r2, r4
  bcc FillZerobss
3401b79e:	d3fb      	bcc.n	3401b798 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
3401b7a0:	f001 fa5e 	bl	3401cc60 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
3401b7a4:	f7e6 f834 	bl	34001810 <main>

3401b7a8 <LoopForever>:

LoopForever:
  b LoopForever
3401b7a8:	e7fe      	b.n	3401b7a8 <LoopForever>
3401b7aa:	0000      	.short	0x0000
  ldr   r0, =_sstack
3401b7ac:	340fc000 	.word	0x340fc000
  ldr   r0, =_estack
3401b7b0:	34100000 	.word	0x34100000
  ldr r0, =_sdata
3401b7b4:	34020c1c 	.word	0x34020c1c
  ldr r1, =_edata
3401b7b8:	34020e28 	.word	0x34020e28
  ldr r2, =_sidata
3401b7bc:	34020c1c 	.word	0x34020c1c
  ldr r2, =_sbss
3401b7c0:	34020e28 	.word	0x34020e28
  ldr r4, =_ebss
3401b7c4:	34021500 	.word	0x34021500

3401b7c8 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
3401b7c8:	e7fe      	b.n	3401b7c8 <ADC1_2_IRQHandler>
	...

3401b7cc <__assert_func>:
3401b7cc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
3401b7ce:	4614      	mov	r4, r2
3401b7d0:	461a      	mov	r2, r3
3401b7d2:	4b09      	ldr	r3, [pc, #36]	@ (3401b7f8 <__assert_func+0x2c>)
3401b7d4:	4605      	mov	r5, r0
3401b7d6:	681b      	ldr	r3, [r3, #0]
3401b7d8:	68d8      	ldr	r0, [r3, #12]
3401b7da:	b14c      	cbz	r4, 3401b7f0 <__assert_func+0x24>
3401b7dc:	4b07      	ldr	r3, [pc, #28]	@ (3401b7fc <__assert_func+0x30>)
3401b7de:	9100      	str	r1, [sp, #0]
3401b7e0:	4907      	ldr	r1, [pc, #28]	@ (3401b800 <__assert_func+0x34>)
3401b7e2:	e9cd 3401 	strd	r3, r4, [sp, #4]
3401b7e6:	462b      	mov	r3, r5
3401b7e8:	f000 fe68 	bl	3401c4bc <fiprintf>
3401b7ec:	f001 fa7a 	bl	3401cce4 <abort>
3401b7f0:	4b04      	ldr	r3, [pc, #16]	@ (3401b804 <__assert_func+0x38>)
3401b7f2:	461c      	mov	r4, r3
3401b7f4:	e7f3      	b.n	3401b7de <__assert_func+0x12>
3401b7f6:	bf00      	nop
3401b7f8:	34020c6c 	.word	0x34020c6c
3401b7fc:	340201fe 	.word	0x340201fe
3401b800:	3402020b 	.word	0x3402020b
3401b804:	34020239 	.word	0x34020239

3401b808 <malloc>:
3401b808:	4b02      	ldr	r3, [pc, #8]	@ (3401b814 <malloc+0xc>)
3401b80a:	4601      	mov	r1, r0
3401b80c:	6818      	ldr	r0, [r3, #0]
3401b80e:	f000 b82d 	b.w	3401b86c <_malloc_r>
3401b812:	bf00      	nop
3401b814:	34020c6c 	.word	0x34020c6c

3401b818 <free>:
3401b818:	4b02      	ldr	r3, [pc, #8]	@ (3401b824 <free+0xc>)
3401b81a:	4601      	mov	r1, r0
3401b81c:	6818      	ldr	r0, [r3, #0]
3401b81e:	f002 b855 	b.w	3401d8cc <_free_r>
3401b822:	bf00      	nop
3401b824:	34020c6c 	.word	0x34020c6c

3401b828 <sbrk_aligned>:
3401b828:	b570      	push	{r4, r5, r6, lr}
3401b82a:	4e0f      	ldr	r6, [pc, #60]	@ (3401b868 <sbrk_aligned+0x40>)
3401b82c:	460c      	mov	r4, r1
3401b82e:	4605      	mov	r5, r0
3401b830:	6831      	ldr	r1, [r6, #0]
3401b832:	b911      	cbnz	r1, 3401b83a <sbrk_aligned+0x12>
3401b834:	f001 f9ec 	bl	3401cc10 <_sbrk_r>
3401b838:	6030      	str	r0, [r6, #0]
3401b83a:	4621      	mov	r1, r4
3401b83c:	4628      	mov	r0, r5
3401b83e:	f001 f9e7 	bl	3401cc10 <_sbrk_r>
3401b842:	1c43      	adds	r3, r0, #1
3401b844:	d103      	bne.n	3401b84e <sbrk_aligned+0x26>
3401b846:	f04f 34ff 	mov.w	r4, #4294967295	@ 0xffffffff
3401b84a:	4620      	mov	r0, r4
3401b84c:	bd70      	pop	{r4, r5, r6, pc}
3401b84e:	1cc4      	adds	r4, r0, #3
3401b850:	f024 0403 	bic.w	r4, r4, #3
3401b854:	42a0      	cmp	r0, r4
3401b856:	d0f8      	beq.n	3401b84a <sbrk_aligned+0x22>
3401b858:	1a21      	subs	r1, r4, r0
3401b85a:	4628      	mov	r0, r5
3401b85c:	f001 f9d8 	bl	3401cc10 <_sbrk_r>
3401b860:	3001      	adds	r0, #1
3401b862:	d1f2      	bne.n	3401b84a <sbrk_aligned+0x22>
3401b864:	e7ef      	b.n	3401b846 <sbrk_aligned+0x1e>
3401b866:	bf00      	nop
3401b868:	340213b0 	.word	0x340213b0

3401b86c <_malloc_r>:
3401b86c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
3401b870:	1ccd      	adds	r5, r1, #3
3401b872:	4606      	mov	r6, r0
3401b874:	f025 0503 	bic.w	r5, r5, #3
3401b878:	3508      	adds	r5, #8
3401b87a:	2d0c      	cmp	r5, #12
3401b87c:	bf38      	it	cc
3401b87e:	250c      	movcc	r5, #12
3401b880:	2d00      	cmp	r5, #0
3401b882:	db01      	blt.n	3401b888 <_malloc_r+0x1c>
3401b884:	42a9      	cmp	r1, r5
3401b886:	d904      	bls.n	3401b892 <_malloc_r+0x26>
3401b888:	230c      	movs	r3, #12
3401b88a:	6033      	str	r3, [r6, #0]
3401b88c:	2000      	movs	r0, #0
3401b88e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
3401b892:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 3401b968 <_malloc_r+0xfc>
3401b896:	f000 f869 	bl	3401b96c <__malloc_lock>
3401b89a:	f8d8 3000 	ldr.w	r3, [r8]
3401b89e:	461c      	mov	r4, r3
3401b8a0:	bb44      	cbnz	r4, 3401b8f4 <_malloc_r+0x88>
3401b8a2:	4629      	mov	r1, r5
3401b8a4:	4630      	mov	r0, r6
3401b8a6:	f7ff ffbf 	bl	3401b828 <sbrk_aligned>
3401b8aa:	1c43      	adds	r3, r0, #1
3401b8ac:	4604      	mov	r4, r0
3401b8ae:	d158      	bne.n	3401b962 <_malloc_r+0xf6>
3401b8b0:	f8d8 4000 	ldr.w	r4, [r8]
3401b8b4:	4627      	mov	r7, r4
3401b8b6:	2f00      	cmp	r7, #0
3401b8b8:	d143      	bne.n	3401b942 <_malloc_r+0xd6>
3401b8ba:	2c00      	cmp	r4, #0
3401b8bc:	d04b      	beq.n	3401b956 <_malloc_r+0xea>
3401b8be:	6823      	ldr	r3, [r4, #0]
3401b8c0:	4639      	mov	r1, r7
3401b8c2:	4630      	mov	r0, r6
3401b8c4:	eb04 0903 	add.w	r9, r4, r3
3401b8c8:	f001 f9a2 	bl	3401cc10 <_sbrk_r>
3401b8cc:	4581      	cmp	r9, r0
3401b8ce:	d142      	bne.n	3401b956 <_malloc_r+0xea>
3401b8d0:	6821      	ldr	r1, [r4, #0]
3401b8d2:	4630      	mov	r0, r6
3401b8d4:	1a6d      	subs	r5, r5, r1
3401b8d6:	4629      	mov	r1, r5
3401b8d8:	f7ff ffa6 	bl	3401b828 <sbrk_aligned>
3401b8dc:	3001      	adds	r0, #1
3401b8de:	d03a      	beq.n	3401b956 <_malloc_r+0xea>
3401b8e0:	6823      	ldr	r3, [r4, #0]
3401b8e2:	442b      	add	r3, r5
3401b8e4:	6023      	str	r3, [r4, #0]
3401b8e6:	f8d8 3000 	ldr.w	r3, [r8]
3401b8ea:	685a      	ldr	r2, [r3, #4]
3401b8ec:	bb62      	cbnz	r2, 3401b948 <_malloc_r+0xdc>
3401b8ee:	f8c8 7000 	str.w	r7, [r8]
3401b8f2:	e00f      	b.n	3401b914 <_malloc_r+0xa8>
3401b8f4:	6822      	ldr	r2, [r4, #0]
3401b8f6:	1b52      	subs	r2, r2, r5
3401b8f8:	d420      	bmi.n	3401b93c <_malloc_r+0xd0>
3401b8fa:	2a0b      	cmp	r2, #11
3401b8fc:	d917      	bls.n	3401b92e <_malloc_r+0xc2>
3401b8fe:	1961      	adds	r1, r4, r5
3401b900:	42a3      	cmp	r3, r4
3401b902:	6025      	str	r5, [r4, #0]
3401b904:	bf18      	it	ne
3401b906:	6059      	strne	r1, [r3, #4]
3401b908:	6863      	ldr	r3, [r4, #4]
3401b90a:	bf08      	it	eq
3401b90c:	f8c8 1000 	streq.w	r1, [r8]
3401b910:	5162      	str	r2, [r4, r5]
3401b912:	604b      	str	r3, [r1, #4]
3401b914:	4630      	mov	r0, r6
3401b916:	f000 f82f 	bl	3401b978 <__malloc_unlock>
3401b91a:	f104 000b 	add.w	r0, r4, #11
3401b91e:	1d23      	adds	r3, r4, #4
3401b920:	f020 0007 	bic.w	r0, r0, #7
3401b924:	1ac2      	subs	r2, r0, r3
3401b926:	bf1c      	itt	ne
3401b928:	1a1b      	subne	r3, r3, r0
3401b92a:	50a3      	strne	r3, [r4, r2]
3401b92c:	e7af      	b.n	3401b88e <_malloc_r+0x22>
3401b92e:	6862      	ldr	r2, [r4, #4]
3401b930:	42a3      	cmp	r3, r4
3401b932:	bf0c      	ite	eq
3401b934:	f8c8 2000 	streq.w	r2, [r8]
3401b938:	605a      	strne	r2, [r3, #4]
3401b93a:	e7eb      	b.n	3401b914 <_malloc_r+0xa8>
3401b93c:	4623      	mov	r3, r4
3401b93e:	6864      	ldr	r4, [r4, #4]
3401b940:	e7ae      	b.n	3401b8a0 <_malloc_r+0x34>
3401b942:	463c      	mov	r4, r7
3401b944:	687f      	ldr	r7, [r7, #4]
3401b946:	e7b6      	b.n	3401b8b6 <_malloc_r+0x4a>
3401b948:	461a      	mov	r2, r3
3401b94a:	685b      	ldr	r3, [r3, #4]
3401b94c:	42a3      	cmp	r3, r4
3401b94e:	d1fb      	bne.n	3401b948 <_malloc_r+0xdc>
3401b950:	2300      	movs	r3, #0
3401b952:	6053      	str	r3, [r2, #4]
3401b954:	e7de      	b.n	3401b914 <_malloc_r+0xa8>
3401b956:	230c      	movs	r3, #12
3401b958:	4630      	mov	r0, r6
3401b95a:	6033      	str	r3, [r6, #0]
3401b95c:	f000 f80c 	bl	3401b978 <__malloc_unlock>
3401b960:	e794      	b.n	3401b88c <_malloc_r+0x20>
3401b962:	6005      	str	r5, [r0, #0]
3401b964:	e7d6      	b.n	3401b914 <_malloc_r+0xa8>
3401b966:	bf00      	nop
3401b968:	340213b4 	.word	0x340213b4

3401b96c <__malloc_lock>:
3401b96c:	4801      	ldr	r0, [pc, #4]	@ (3401b974 <__malloc_lock+0x8>)
3401b96e:	f001 b99c 	b.w	3401ccaa <__retarget_lock_acquire_recursive>
3401b972:	bf00      	nop
3401b974:	340214f8 	.word	0x340214f8

3401b978 <__malloc_unlock>:
3401b978:	4801      	ldr	r0, [pc, #4]	@ (3401b980 <__malloc_unlock+0x8>)
3401b97a:	f001 b997 	b.w	3401ccac <__retarget_lock_release_recursive>
3401b97e:	bf00      	nop
3401b980:	340214f8 	.word	0x340214f8

3401b984 <__cvt>:
3401b984:	b5f0      	push	{r4, r5, r6, r7, lr}
3401b986:	ed2d 8b02 	vpush	{d8}
3401b98a:	eeb0 8b40 	vmov.f64	d8, d0
3401b98e:	b085      	sub	sp, #20
3401b990:	4617      	mov	r7, r2
3401b992:	460c      	mov	r4, r1
3401b994:	9d0d      	ldr	r5, [sp, #52]	@ 0x34
3401b996:	ee18 2a90 	vmov	r2, s17
3401b99a:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
3401b99c:	f025 0520 	bic.w	r5, r5, #32
3401b9a0:	2a00      	cmp	r2, #0
3401b9a2:	bfb6      	itet	lt
3401b9a4:	222d      	movlt	r2, #45	@ 0x2d
3401b9a6:	2200      	movge	r2, #0
3401b9a8:	eeb1 8b40 	vneglt.f64	d8, d0
3401b9ac:	2d46      	cmp	r5, #70	@ 0x46
3401b9ae:	701a      	strb	r2, [r3, #0]
3401b9b0:	d004      	beq.n	3401b9bc <__cvt+0x38>
3401b9b2:	2d45      	cmp	r5, #69	@ 0x45
3401b9b4:	d100      	bne.n	3401b9b8 <__cvt+0x34>
3401b9b6:	3401      	adds	r4, #1
3401b9b8:	2102      	movs	r1, #2
3401b9ba:	e000      	b.n	3401b9be <__cvt+0x3a>
3401b9bc:	2103      	movs	r1, #3
3401b9be:	ab03      	add	r3, sp, #12
3401b9c0:	eeb0 0b48 	vmov.f64	d0, d8
3401b9c4:	4622      	mov	r2, r4
3401b9c6:	9301      	str	r3, [sp, #4]
3401b9c8:	ab02      	add	r3, sp, #8
3401b9ca:	9300      	str	r3, [sp, #0]
3401b9cc:	4633      	mov	r3, r6
3401b9ce:	f001 fa1f 	bl	3401ce10 <_dtoa_r>
3401b9d2:	2d47      	cmp	r5, #71	@ 0x47
3401b9d4:	d114      	bne.n	3401ba00 <__cvt+0x7c>
3401b9d6:	07fb      	lsls	r3, r7, #31
3401b9d8:	d50a      	bpl.n	3401b9f0 <__cvt+0x6c>
3401b9da:	1902      	adds	r2, r0, r4
3401b9dc:	eeb5 8b40 	vcmp.f64	d8, #0.0
3401b9e0:	2130      	movs	r1, #48	@ 0x30
3401b9e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b9e6:	bf08      	it	eq
3401b9e8:	9203      	streq	r2, [sp, #12]
3401b9ea:	9b03      	ldr	r3, [sp, #12]
3401b9ec:	4293      	cmp	r3, r2
3401b9ee:	d319      	bcc.n	3401ba24 <__cvt+0xa0>
3401b9f0:	9b03      	ldr	r3, [sp, #12]
3401b9f2:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
3401b9f4:	1a1b      	subs	r3, r3, r0
3401b9f6:	6013      	str	r3, [r2, #0]
3401b9f8:	b005      	add	sp, #20
3401b9fa:	ecbd 8b02 	vpop	{d8}
3401b9fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
3401ba00:	2d46      	cmp	r5, #70	@ 0x46
3401ba02:	eb00 0204 	add.w	r2, r0, r4
3401ba06:	d1e9      	bne.n	3401b9dc <__cvt+0x58>
3401ba08:	7803      	ldrb	r3, [r0, #0]
3401ba0a:	2b30      	cmp	r3, #48	@ 0x30
3401ba0c:	d107      	bne.n	3401ba1e <__cvt+0x9a>
3401ba0e:	eeb5 8b40 	vcmp.f64	d8, #0.0
3401ba12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ba16:	bf1c      	itt	ne
3401ba18:	f1c4 0401 	rsbne	r4, r4, #1
3401ba1c:	6034      	strne	r4, [r6, #0]
3401ba1e:	6833      	ldr	r3, [r6, #0]
3401ba20:	441a      	add	r2, r3
3401ba22:	e7db      	b.n	3401b9dc <__cvt+0x58>
3401ba24:	1c5c      	adds	r4, r3, #1
3401ba26:	9403      	str	r4, [sp, #12]
3401ba28:	7019      	strb	r1, [r3, #0]
3401ba2a:	e7de      	b.n	3401b9ea <__cvt+0x66>

3401ba2c <__exponent>:
3401ba2c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3401ba2e:	2900      	cmp	r1, #0
3401ba30:	7002      	strb	r2, [r0, #0]
3401ba32:	bfba      	itte	lt
3401ba34:	4249      	neglt	r1, r1
3401ba36:	232d      	movlt	r3, #45	@ 0x2d
3401ba38:	232b      	movge	r3, #43	@ 0x2b
3401ba3a:	2909      	cmp	r1, #9
3401ba3c:	7043      	strb	r3, [r0, #1]
3401ba3e:	dd28      	ble.n	3401ba92 <__exponent+0x66>
3401ba40:	f10d 0307 	add.w	r3, sp, #7
3401ba44:	270a      	movs	r7, #10
3401ba46:	461d      	mov	r5, r3
3401ba48:	461a      	mov	r2, r3
3401ba4a:	3b01      	subs	r3, #1
3401ba4c:	fbb1 f6f7 	udiv	r6, r1, r7
3401ba50:	fb07 1416 	mls	r4, r7, r6, r1
3401ba54:	3430      	adds	r4, #48	@ 0x30
3401ba56:	f802 4c01 	strb.w	r4, [r2, #-1]
3401ba5a:	460c      	mov	r4, r1
3401ba5c:	4631      	mov	r1, r6
3401ba5e:	2c63      	cmp	r4, #99	@ 0x63
3401ba60:	dcf2      	bgt.n	3401ba48 <__exponent+0x1c>
3401ba62:	3130      	adds	r1, #48	@ 0x30
3401ba64:	1e94      	subs	r4, r2, #2
3401ba66:	f803 1c01 	strb.w	r1, [r3, #-1]
3401ba6a:	1c41      	adds	r1, r0, #1
3401ba6c:	4623      	mov	r3, r4
3401ba6e:	42ab      	cmp	r3, r5
3401ba70:	d30a      	bcc.n	3401ba88 <__exponent+0x5c>
3401ba72:	f10d 0309 	add.w	r3, sp, #9
3401ba76:	1a9b      	subs	r3, r3, r2
3401ba78:	42ac      	cmp	r4, r5
3401ba7a:	bf88      	it	hi
3401ba7c:	2300      	movhi	r3, #0
3401ba7e:	3302      	adds	r3, #2
3401ba80:	4403      	add	r3, r0
3401ba82:	1a18      	subs	r0, r3, r0
3401ba84:	b003      	add	sp, #12
3401ba86:	bdf0      	pop	{r4, r5, r6, r7, pc}
3401ba88:	f813 6b01 	ldrb.w	r6, [r3], #1
3401ba8c:	f801 6f01 	strb.w	r6, [r1, #1]!
3401ba90:	e7ed      	b.n	3401ba6e <__exponent+0x42>
3401ba92:	2330      	movs	r3, #48	@ 0x30
3401ba94:	3130      	adds	r1, #48	@ 0x30
3401ba96:	7083      	strb	r3, [r0, #2]
3401ba98:	1d03      	adds	r3, r0, #4
3401ba9a:	70c1      	strb	r1, [r0, #3]
3401ba9c:	e7f1      	b.n	3401ba82 <__exponent+0x56>
	...

3401baa0 <_printf_float>:
3401baa0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401baa4:	b08d      	sub	sp, #52	@ 0x34
3401baa6:	460c      	mov	r4, r1
3401baa8:	4616      	mov	r6, r2
3401baaa:	461f      	mov	r7, r3
3401baac:	f8dd 8058 	ldr.w	r8, [sp, #88]	@ 0x58
3401bab0:	4605      	mov	r5, r0
3401bab2:	f001 f875 	bl	3401cba0 <_localeconv_r>
3401bab6:	f8d0 b000 	ldr.w	fp, [r0]
3401baba:	4658      	mov	r0, fp
3401babc:	f7e4 fe68 	bl	34000790 <strlen>
3401bac0:	2300      	movs	r3, #0
3401bac2:	f894 9018 	ldrb.w	r9, [r4, #24]
3401bac6:	930a      	str	r3, [sp, #40]	@ 0x28
3401bac8:	f8d8 3000 	ldr.w	r3, [r8]
3401bacc:	6822      	ldr	r2, [r4, #0]
3401bace:	3307      	adds	r3, #7
3401bad0:	9005      	str	r0, [sp, #20]
3401bad2:	f023 0307 	bic.w	r3, r3, #7
3401bad6:	f103 0108 	add.w	r1, r3, #8
3401bada:	f8c8 1000 	str.w	r1, [r8]
3401bade:	ed93 0b00 	vldr	d0, [r3]
3401bae2:	ed9f 6b97 	vldr	d6, [pc, #604]	@ 3401bd40 <_printf_float+0x2a0>
3401bae6:	eeb0 7bc0 	vabs.f64	d7, d0
3401baea:	ed84 0b12 	vstr	d0, [r4, #72]	@ 0x48
3401baee:	eeb4 7b46 	vcmp.f64	d7, d6
3401baf2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401baf6:	dd24      	ble.n	3401bb42 <_printf_float+0xa2>
3401baf8:	eeb5 0bc0 	vcmpe.f64	d0, #0.0
3401bafc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401bb00:	d502      	bpl.n	3401bb08 <_printf_float+0x68>
3401bb02:	232d      	movs	r3, #45	@ 0x2d
3401bb04:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
3401bb08:	498f      	ldr	r1, [pc, #572]	@ (3401bd48 <_printf_float+0x2a8>)
3401bb0a:	4b90      	ldr	r3, [pc, #576]	@ (3401bd4c <_printf_float+0x2ac>)
3401bb0c:	f1b9 0f47 	cmp.w	r9, #71	@ 0x47
3401bb10:	bf8c      	ite	hi
3401bb12:	4688      	movhi	r8, r1
3401bb14:	4698      	movls	r8, r3
3401bb16:	f022 0204 	bic.w	r2, r2, #4
3401bb1a:	2303      	movs	r3, #3
3401bb1c:	f04f 0a00 	mov.w	sl, #0
3401bb20:	6022      	str	r2, [r4, #0]
3401bb22:	6123      	str	r3, [r4, #16]
3401bb24:	4633      	mov	r3, r6
3401bb26:	aa0b      	add	r2, sp, #44	@ 0x2c
3401bb28:	4621      	mov	r1, r4
3401bb2a:	4628      	mov	r0, r5
3401bb2c:	9700      	str	r7, [sp, #0]
3401bb2e:	f000 f9d1 	bl	3401bed4 <_printf_common>
3401bb32:	3001      	adds	r0, #1
3401bb34:	f040 8089 	bne.w	3401bc4a <_printf_float+0x1aa>
3401bb38:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
3401bb3c:	b00d      	add	sp, #52	@ 0x34
3401bb3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401bb42:	eeb4 0b40 	vcmp.f64	d0, d0
3401bb46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401bb4a:	d709      	bvc.n	3401bb60 <_printf_float+0xc0>
3401bb4c:	ee10 3a90 	vmov	r3, s1
3401bb50:	497f      	ldr	r1, [pc, #508]	@ (3401bd50 <_printf_float+0x2b0>)
3401bb52:	2b00      	cmp	r3, #0
3401bb54:	bfbc      	itt	lt
3401bb56:	232d      	movlt	r3, #45	@ 0x2d
3401bb58:	f884 3043 	strblt.w	r3, [r4, #67]	@ 0x43
3401bb5c:	4b7d      	ldr	r3, [pc, #500]	@ (3401bd54 <_printf_float+0x2b4>)
3401bb5e:	e7d5      	b.n	3401bb0c <_printf_float+0x6c>
3401bb60:	6863      	ldr	r3, [r4, #4]
3401bb62:	f009 0adf 	and.w	sl, r9, #223	@ 0xdf
3401bb66:	1c59      	adds	r1, r3, #1
3401bb68:	d139      	bne.n	3401bbde <_printf_float+0x13e>
3401bb6a:	2306      	movs	r3, #6
3401bb6c:	6063      	str	r3, [r4, #4]
3401bb6e:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
3401bb72:	2300      	movs	r3, #0
3401bb74:	4628      	mov	r0, r5
3401bb76:	6022      	str	r2, [r4, #0]
3401bb78:	9303      	str	r3, [sp, #12]
3401bb7a:	ab0a      	add	r3, sp, #40	@ 0x28
3401bb7c:	e9cd 9301 	strd	r9, r3, [sp, #4]
3401bb80:	ab09      	add	r3, sp, #36	@ 0x24
3401bb82:	9300      	str	r3, [sp, #0]
3401bb84:	f10d 0323 	add.w	r3, sp, #35	@ 0x23
3401bb88:	6861      	ldr	r1, [r4, #4]
3401bb8a:	f7ff fefb 	bl	3401b984 <__cvt>
3401bb8e:	f1ba 0f47 	cmp.w	sl, #71	@ 0x47
3401bb92:	4680      	mov	r8, r0
3401bb94:	9909      	ldr	r1, [sp, #36]	@ 0x24
3401bb96:	d129      	bne.n	3401bbec <_printf_float+0x14c>
3401bb98:	1cc8      	adds	r0, r1, #3
3401bb9a:	db02      	blt.n	3401bba2 <_printf_float+0x102>
3401bb9c:	6863      	ldr	r3, [r4, #4]
3401bb9e:	4299      	cmp	r1, r3
3401bba0:	dd41      	ble.n	3401bc26 <_printf_float+0x186>
3401bba2:	f1a9 0902 	sub.w	r9, r9, #2
3401bba6:	fa5f f989 	uxtb.w	r9, r9
3401bbaa:	3901      	subs	r1, #1
3401bbac:	464a      	mov	r2, r9
3401bbae:	f104 0050 	add.w	r0, r4, #80	@ 0x50
3401bbb2:	9109      	str	r1, [sp, #36]	@ 0x24
3401bbb4:	f7ff ff3a 	bl	3401ba2c <__exponent>
3401bbb8:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
3401bbba:	4682      	mov	sl, r0
3401bbbc:	1813      	adds	r3, r2, r0
3401bbbe:	2a01      	cmp	r2, #1
3401bbc0:	6123      	str	r3, [r4, #16]
3401bbc2:	dc02      	bgt.n	3401bbca <_printf_float+0x12a>
3401bbc4:	6822      	ldr	r2, [r4, #0]
3401bbc6:	07d2      	lsls	r2, r2, #31
3401bbc8:	d501      	bpl.n	3401bbce <_printf_float+0x12e>
3401bbca:	3301      	adds	r3, #1
3401bbcc:	6123      	str	r3, [r4, #16]
3401bbce:	f89d 3023 	ldrb.w	r3, [sp, #35]	@ 0x23
3401bbd2:	2b00      	cmp	r3, #0
3401bbd4:	d0a6      	beq.n	3401bb24 <_printf_float+0x84>
3401bbd6:	232d      	movs	r3, #45	@ 0x2d
3401bbd8:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
3401bbdc:	e7a2      	b.n	3401bb24 <_printf_float+0x84>
3401bbde:	f1ba 0f47 	cmp.w	sl, #71	@ 0x47
3401bbe2:	d1c4      	bne.n	3401bb6e <_printf_float+0xce>
3401bbe4:	2b00      	cmp	r3, #0
3401bbe6:	d1c2      	bne.n	3401bb6e <_printf_float+0xce>
3401bbe8:	2301      	movs	r3, #1
3401bbea:	e7bf      	b.n	3401bb6c <_printf_float+0xcc>
3401bbec:	f1b9 0f65 	cmp.w	r9, #101	@ 0x65
3401bbf0:	d9db      	bls.n	3401bbaa <_printf_float+0x10a>
3401bbf2:	f1b9 0f66 	cmp.w	r9, #102	@ 0x66
3401bbf6:	d118      	bne.n	3401bc2a <_printf_float+0x18a>
3401bbf8:	2900      	cmp	r1, #0
3401bbfa:	6863      	ldr	r3, [r4, #4]
3401bbfc:	dd0b      	ble.n	3401bc16 <_printf_float+0x176>
3401bbfe:	6121      	str	r1, [r4, #16]
3401bc00:	b913      	cbnz	r3, 3401bc08 <_printf_float+0x168>
3401bc02:	6822      	ldr	r2, [r4, #0]
3401bc04:	07d0      	lsls	r0, r2, #31
3401bc06:	d502      	bpl.n	3401bc0e <_printf_float+0x16e>
3401bc08:	3301      	adds	r3, #1
3401bc0a:	440b      	add	r3, r1
3401bc0c:	6123      	str	r3, [r4, #16]
3401bc0e:	f04f 0a00 	mov.w	sl, #0
3401bc12:	65a1      	str	r1, [r4, #88]	@ 0x58
3401bc14:	e7db      	b.n	3401bbce <_printf_float+0x12e>
3401bc16:	b913      	cbnz	r3, 3401bc1e <_printf_float+0x17e>
3401bc18:	6822      	ldr	r2, [r4, #0]
3401bc1a:	07d2      	lsls	r2, r2, #31
3401bc1c:	d501      	bpl.n	3401bc22 <_printf_float+0x182>
3401bc1e:	3302      	adds	r3, #2
3401bc20:	e7f4      	b.n	3401bc0c <_printf_float+0x16c>
3401bc22:	2301      	movs	r3, #1
3401bc24:	e7f2      	b.n	3401bc0c <_printf_float+0x16c>
3401bc26:	f04f 0967 	mov.w	r9, #103	@ 0x67
3401bc2a:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
3401bc2c:	4299      	cmp	r1, r3
3401bc2e:	db05      	blt.n	3401bc3c <_printf_float+0x19c>
3401bc30:	6823      	ldr	r3, [r4, #0]
3401bc32:	6121      	str	r1, [r4, #16]
3401bc34:	07d8      	lsls	r0, r3, #31
3401bc36:	d5ea      	bpl.n	3401bc0e <_printf_float+0x16e>
3401bc38:	1c4b      	adds	r3, r1, #1
3401bc3a:	e7e7      	b.n	3401bc0c <_printf_float+0x16c>
3401bc3c:	2900      	cmp	r1, #0
3401bc3e:	bfd4      	ite	le
3401bc40:	f1c1 0202 	rsble	r2, r1, #2
3401bc44:	2201      	movgt	r2, #1
3401bc46:	4413      	add	r3, r2
3401bc48:	e7e0      	b.n	3401bc0c <_printf_float+0x16c>
3401bc4a:	6823      	ldr	r3, [r4, #0]
3401bc4c:	055a      	lsls	r2, r3, #21
3401bc4e:	d407      	bmi.n	3401bc60 <_printf_float+0x1c0>
3401bc50:	6923      	ldr	r3, [r4, #16]
3401bc52:	4642      	mov	r2, r8
3401bc54:	4631      	mov	r1, r6
3401bc56:	4628      	mov	r0, r5
3401bc58:	47b8      	blx	r7
3401bc5a:	3001      	adds	r0, #1
3401bc5c:	d12a      	bne.n	3401bcb4 <_printf_float+0x214>
3401bc5e:	e76b      	b.n	3401bb38 <_printf_float+0x98>
3401bc60:	f1b9 0f65 	cmp.w	r9, #101	@ 0x65
3401bc64:	f240 80e0 	bls.w	3401be28 <_printf_float+0x388>
3401bc68:	ed94 7b12 	vldr	d7, [r4, #72]	@ 0x48
3401bc6c:	eeb5 7b40 	vcmp.f64	d7, #0.0
3401bc70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401bc74:	d133      	bne.n	3401bcde <_printf_float+0x23e>
3401bc76:	2301      	movs	r3, #1
3401bc78:	4a37      	ldr	r2, [pc, #220]	@ (3401bd58 <_printf_float+0x2b8>)
3401bc7a:	4631      	mov	r1, r6
3401bc7c:	4628      	mov	r0, r5
3401bc7e:	47b8      	blx	r7
3401bc80:	3001      	adds	r0, #1
3401bc82:	f43f af59 	beq.w	3401bb38 <_printf_float+0x98>
3401bc86:	e9dd 3809 	ldrd	r3, r8, [sp, #36]	@ 0x24
3401bc8a:	4543      	cmp	r3, r8
3401bc8c:	db02      	blt.n	3401bc94 <_printf_float+0x1f4>
3401bc8e:	6823      	ldr	r3, [r4, #0]
3401bc90:	07d8      	lsls	r0, r3, #31
3401bc92:	d50f      	bpl.n	3401bcb4 <_printf_float+0x214>
3401bc94:	9b05      	ldr	r3, [sp, #20]
3401bc96:	465a      	mov	r2, fp
3401bc98:	4631      	mov	r1, r6
3401bc9a:	4628      	mov	r0, r5
3401bc9c:	47b8      	blx	r7
3401bc9e:	3001      	adds	r0, #1
3401bca0:	f43f af4a 	beq.w	3401bb38 <_printf_float+0x98>
3401bca4:	f04f 0900 	mov.w	r9, #0
3401bca8:	f108 38ff 	add.w	r8, r8, #4294967295	@ 0xffffffff
3401bcac:	f104 0a1a 	add.w	sl, r4, #26
3401bcb0:	45c8      	cmp	r8, r9
3401bcb2:	dc09      	bgt.n	3401bcc8 <_printf_float+0x228>
3401bcb4:	6823      	ldr	r3, [r4, #0]
3401bcb6:	079b      	lsls	r3, r3, #30
3401bcb8:	f100 8107 	bmi.w	3401beca <_printf_float+0x42a>
3401bcbc:	68e0      	ldr	r0, [r4, #12]
3401bcbe:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
3401bcc0:	4298      	cmp	r0, r3
3401bcc2:	bfb8      	it	lt
3401bcc4:	4618      	movlt	r0, r3
3401bcc6:	e739      	b.n	3401bb3c <_printf_float+0x9c>
3401bcc8:	2301      	movs	r3, #1
3401bcca:	4652      	mov	r2, sl
3401bccc:	4631      	mov	r1, r6
3401bcce:	4628      	mov	r0, r5
3401bcd0:	47b8      	blx	r7
3401bcd2:	3001      	adds	r0, #1
3401bcd4:	f43f af30 	beq.w	3401bb38 <_printf_float+0x98>
3401bcd8:	f109 0901 	add.w	r9, r9, #1
3401bcdc:	e7e8      	b.n	3401bcb0 <_printf_float+0x210>
3401bcde:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401bce0:	2b00      	cmp	r3, #0
3401bce2:	dc3b      	bgt.n	3401bd5c <_printf_float+0x2bc>
3401bce4:	2301      	movs	r3, #1
3401bce6:	4a1c      	ldr	r2, [pc, #112]	@ (3401bd58 <_printf_float+0x2b8>)
3401bce8:	4631      	mov	r1, r6
3401bcea:	4628      	mov	r0, r5
3401bcec:	47b8      	blx	r7
3401bcee:	3001      	adds	r0, #1
3401bcf0:	f43f af22 	beq.w	3401bb38 <_printf_float+0x98>
3401bcf4:	e9dd 3909 	ldrd	r3, r9, [sp, #36]	@ 0x24
3401bcf8:	ea59 0303 	orrs.w	r3, r9, r3
3401bcfc:	d102      	bne.n	3401bd04 <_printf_float+0x264>
3401bcfe:	6823      	ldr	r3, [r4, #0]
3401bd00:	07d9      	lsls	r1, r3, #31
3401bd02:	d5d7      	bpl.n	3401bcb4 <_printf_float+0x214>
3401bd04:	9b05      	ldr	r3, [sp, #20]
3401bd06:	465a      	mov	r2, fp
3401bd08:	4631      	mov	r1, r6
3401bd0a:	4628      	mov	r0, r5
3401bd0c:	47b8      	blx	r7
3401bd0e:	3001      	adds	r0, #1
3401bd10:	f43f af12 	beq.w	3401bb38 <_printf_float+0x98>
3401bd14:	f04f 0a00 	mov.w	sl, #0
3401bd18:	f104 0b1a 	add.w	fp, r4, #26
3401bd1c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401bd1e:	425b      	negs	r3, r3
3401bd20:	4553      	cmp	r3, sl
3401bd22:	dc01      	bgt.n	3401bd28 <_printf_float+0x288>
3401bd24:	464b      	mov	r3, r9
3401bd26:	e794      	b.n	3401bc52 <_printf_float+0x1b2>
3401bd28:	2301      	movs	r3, #1
3401bd2a:	465a      	mov	r2, fp
3401bd2c:	4631      	mov	r1, r6
3401bd2e:	4628      	mov	r0, r5
3401bd30:	47b8      	blx	r7
3401bd32:	3001      	adds	r0, #1
3401bd34:	f43f af00 	beq.w	3401bb38 <_printf_float+0x98>
3401bd38:	f10a 0a01 	add.w	sl, sl, #1
3401bd3c:	e7ee      	b.n	3401bd1c <_printf_float+0x27c>
3401bd3e:	bf00      	nop
3401bd40:	ffffffff 	.word	0xffffffff
3401bd44:	7fefffff 	.word	0x7fefffff
3401bd48:	3402023e 	.word	0x3402023e
3401bd4c:	3402023a 	.word	0x3402023a
3401bd50:	34020246 	.word	0x34020246
3401bd54:	34020242 	.word	0x34020242
3401bd58:	3402024a 	.word	0x3402024a
3401bd5c:	6da3      	ldr	r3, [r4, #88]	@ 0x58
3401bd5e:	f8dd a028 	ldr.w	sl, [sp, #40]	@ 0x28
3401bd62:	4553      	cmp	r3, sl
3401bd64:	bfa8      	it	ge
3401bd66:	4653      	movge	r3, sl
3401bd68:	2b00      	cmp	r3, #0
3401bd6a:	4699      	mov	r9, r3
3401bd6c:	dc37      	bgt.n	3401bdde <_printf_float+0x33e>
3401bd6e:	2300      	movs	r3, #0
3401bd70:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
3401bd74:	f104 021a 	add.w	r2, r4, #26
3401bd78:	9307      	str	r3, [sp, #28]
3401bd7a:	6da3      	ldr	r3, [r4, #88]	@ 0x58
3401bd7c:	9907      	ldr	r1, [sp, #28]
3401bd7e:	9306      	str	r3, [sp, #24]
3401bd80:	eba3 0309 	sub.w	r3, r3, r9
3401bd84:	428b      	cmp	r3, r1
3401bd86:	dc31      	bgt.n	3401bdec <_printf_float+0x34c>
3401bd88:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401bd8a:	459a      	cmp	sl, r3
3401bd8c:	dc3b      	bgt.n	3401be06 <_printf_float+0x366>
3401bd8e:	6823      	ldr	r3, [r4, #0]
3401bd90:	07da      	lsls	r2, r3, #31
3401bd92:	d438      	bmi.n	3401be06 <_printf_float+0x366>
3401bd94:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401bd96:	ebaa 0903 	sub.w	r9, sl, r3
3401bd9a:	9b06      	ldr	r3, [sp, #24]
3401bd9c:	ebaa 0303 	sub.w	r3, sl, r3
3401bda0:	4599      	cmp	r9, r3
3401bda2:	bfa8      	it	ge
3401bda4:	4699      	movge	r9, r3
3401bda6:	f1b9 0f00 	cmp.w	r9, #0
3401bdaa:	dc34      	bgt.n	3401be16 <_printf_float+0x376>
3401bdac:	f04f 0800 	mov.w	r8, #0
3401bdb0:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
3401bdb4:	f104 0b1a 	add.w	fp, r4, #26
3401bdb8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401bdba:	ebaa 0303 	sub.w	r3, sl, r3
3401bdbe:	eba3 0309 	sub.w	r3, r3, r9
3401bdc2:	4543      	cmp	r3, r8
3401bdc4:	f77f af76 	ble.w	3401bcb4 <_printf_float+0x214>
3401bdc8:	2301      	movs	r3, #1
3401bdca:	465a      	mov	r2, fp
3401bdcc:	4631      	mov	r1, r6
3401bdce:	4628      	mov	r0, r5
3401bdd0:	47b8      	blx	r7
3401bdd2:	3001      	adds	r0, #1
3401bdd4:	f43f aeb0 	beq.w	3401bb38 <_printf_float+0x98>
3401bdd8:	f108 0801 	add.w	r8, r8, #1
3401bddc:	e7ec      	b.n	3401bdb8 <_printf_float+0x318>
3401bdde:	4642      	mov	r2, r8
3401bde0:	4631      	mov	r1, r6
3401bde2:	4628      	mov	r0, r5
3401bde4:	47b8      	blx	r7
3401bde6:	3001      	adds	r0, #1
3401bde8:	d1c1      	bne.n	3401bd6e <_printf_float+0x2ce>
3401bdea:	e6a5      	b.n	3401bb38 <_printf_float+0x98>
3401bdec:	2301      	movs	r3, #1
3401bdee:	4631      	mov	r1, r6
3401bdf0:	4628      	mov	r0, r5
3401bdf2:	9206      	str	r2, [sp, #24]
3401bdf4:	47b8      	blx	r7
3401bdf6:	3001      	adds	r0, #1
3401bdf8:	f43f ae9e 	beq.w	3401bb38 <_printf_float+0x98>
3401bdfc:	9b07      	ldr	r3, [sp, #28]
3401bdfe:	9a06      	ldr	r2, [sp, #24]
3401be00:	3301      	adds	r3, #1
3401be02:	9307      	str	r3, [sp, #28]
3401be04:	e7b9      	b.n	3401bd7a <_printf_float+0x2da>
3401be06:	9b05      	ldr	r3, [sp, #20]
3401be08:	465a      	mov	r2, fp
3401be0a:	4631      	mov	r1, r6
3401be0c:	4628      	mov	r0, r5
3401be0e:	47b8      	blx	r7
3401be10:	3001      	adds	r0, #1
3401be12:	d1bf      	bne.n	3401bd94 <_printf_float+0x2f4>
3401be14:	e690      	b.n	3401bb38 <_printf_float+0x98>
3401be16:	9a06      	ldr	r2, [sp, #24]
3401be18:	464b      	mov	r3, r9
3401be1a:	4631      	mov	r1, r6
3401be1c:	4628      	mov	r0, r5
3401be1e:	4442      	add	r2, r8
3401be20:	47b8      	blx	r7
3401be22:	3001      	adds	r0, #1
3401be24:	d1c2      	bne.n	3401bdac <_printf_float+0x30c>
3401be26:	e687      	b.n	3401bb38 <_printf_float+0x98>
3401be28:	f8dd 9028 	ldr.w	r9, [sp, #40]	@ 0x28
3401be2c:	f1b9 0f01 	cmp.w	r9, #1
3401be30:	dc01      	bgt.n	3401be36 <_printf_float+0x396>
3401be32:	07db      	lsls	r3, r3, #31
3401be34:	d536      	bpl.n	3401bea4 <_printf_float+0x404>
3401be36:	2301      	movs	r3, #1
3401be38:	4642      	mov	r2, r8
3401be3a:	4631      	mov	r1, r6
3401be3c:	4628      	mov	r0, r5
3401be3e:	47b8      	blx	r7
3401be40:	3001      	adds	r0, #1
3401be42:	f43f ae79 	beq.w	3401bb38 <_printf_float+0x98>
3401be46:	9b05      	ldr	r3, [sp, #20]
3401be48:	465a      	mov	r2, fp
3401be4a:	4631      	mov	r1, r6
3401be4c:	4628      	mov	r0, r5
3401be4e:	47b8      	blx	r7
3401be50:	3001      	adds	r0, #1
3401be52:	f43f ae71 	beq.w	3401bb38 <_printf_float+0x98>
3401be56:	f109 39ff 	add.w	r9, r9, #4294967295	@ 0xffffffff
3401be5a:	ed94 7b12 	vldr	d7, [r4, #72]	@ 0x48
3401be5e:	eeb5 7b40 	vcmp.f64	d7, #0.0
3401be62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401be66:	d018      	beq.n	3401be9a <_printf_float+0x3fa>
3401be68:	464b      	mov	r3, r9
3401be6a:	f108 0201 	add.w	r2, r8, #1
3401be6e:	4631      	mov	r1, r6
3401be70:	4628      	mov	r0, r5
3401be72:	47b8      	blx	r7
3401be74:	3001      	adds	r0, #1
3401be76:	d10c      	bne.n	3401be92 <_printf_float+0x3f2>
3401be78:	e65e      	b.n	3401bb38 <_printf_float+0x98>
3401be7a:	2301      	movs	r3, #1
3401be7c:	465a      	mov	r2, fp
3401be7e:	4631      	mov	r1, r6
3401be80:	4628      	mov	r0, r5
3401be82:	47b8      	blx	r7
3401be84:	3001      	adds	r0, #1
3401be86:	f43f ae57 	beq.w	3401bb38 <_printf_float+0x98>
3401be8a:	f108 0801 	add.w	r8, r8, #1
3401be8e:	45c8      	cmp	r8, r9
3401be90:	dbf3      	blt.n	3401be7a <_printf_float+0x3da>
3401be92:	4653      	mov	r3, sl
3401be94:	f104 0250 	add.w	r2, r4, #80	@ 0x50
3401be98:	e6dc      	b.n	3401bc54 <_printf_float+0x1b4>
3401be9a:	f04f 0800 	mov.w	r8, #0
3401be9e:	f104 0b1a 	add.w	fp, r4, #26
3401bea2:	e7f4      	b.n	3401be8e <_printf_float+0x3ee>
3401bea4:	2301      	movs	r3, #1
3401bea6:	4642      	mov	r2, r8
3401bea8:	e7e1      	b.n	3401be6e <_printf_float+0x3ce>
3401beaa:	2301      	movs	r3, #1
3401beac:	464a      	mov	r2, r9
3401beae:	4631      	mov	r1, r6
3401beb0:	4628      	mov	r0, r5
3401beb2:	47b8      	blx	r7
3401beb4:	3001      	adds	r0, #1
3401beb6:	f43f ae3f 	beq.w	3401bb38 <_printf_float+0x98>
3401beba:	f108 0801 	add.w	r8, r8, #1
3401bebe:	68e3      	ldr	r3, [r4, #12]
3401bec0:	990b      	ldr	r1, [sp, #44]	@ 0x2c
3401bec2:	1a5b      	subs	r3, r3, r1
3401bec4:	4543      	cmp	r3, r8
3401bec6:	dcf0      	bgt.n	3401beaa <_printf_float+0x40a>
3401bec8:	e6f8      	b.n	3401bcbc <_printf_float+0x21c>
3401beca:	f04f 0800 	mov.w	r8, #0
3401bece:	f104 0919 	add.w	r9, r4, #25
3401bed2:	e7f4      	b.n	3401bebe <_printf_float+0x41e>

3401bed4 <_printf_common>:
3401bed4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
3401bed8:	4616      	mov	r6, r2
3401beda:	4698      	mov	r8, r3
3401bedc:	688a      	ldr	r2, [r1, #8]
3401bede:	4607      	mov	r7, r0
3401bee0:	690b      	ldr	r3, [r1, #16]
3401bee2:	460c      	mov	r4, r1
3401bee4:	f8dd 9020 	ldr.w	r9, [sp, #32]
3401bee8:	4293      	cmp	r3, r2
3401beea:	bfb8      	it	lt
3401beec:	4613      	movlt	r3, r2
3401beee:	6033      	str	r3, [r6, #0]
3401bef0:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
3401bef4:	b10a      	cbz	r2, 3401befa <_printf_common+0x26>
3401bef6:	3301      	adds	r3, #1
3401bef8:	6033      	str	r3, [r6, #0]
3401befa:	6823      	ldr	r3, [r4, #0]
3401befc:	0699      	lsls	r1, r3, #26
3401befe:	bf42      	ittt	mi
3401bf00:	6833      	ldrmi	r3, [r6, #0]
3401bf02:	3302      	addmi	r3, #2
3401bf04:	6033      	strmi	r3, [r6, #0]
3401bf06:	6825      	ldr	r5, [r4, #0]
3401bf08:	f015 0506 	ands.w	r5, r5, #6
3401bf0c:	d106      	bne.n	3401bf1c <_printf_common+0x48>
3401bf0e:	f104 0a19 	add.w	sl, r4, #25
3401bf12:	68e3      	ldr	r3, [r4, #12]
3401bf14:	6832      	ldr	r2, [r6, #0]
3401bf16:	1a9b      	subs	r3, r3, r2
3401bf18:	42ab      	cmp	r3, r5
3401bf1a:	dc2b      	bgt.n	3401bf74 <_printf_common+0xa0>
3401bf1c:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
3401bf20:	6822      	ldr	r2, [r4, #0]
3401bf22:	3b00      	subs	r3, #0
3401bf24:	bf18      	it	ne
3401bf26:	2301      	movne	r3, #1
3401bf28:	0692      	lsls	r2, r2, #26
3401bf2a:	d430      	bmi.n	3401bf8e <_printf_common+0xba>
3401bf2c:	f104 0243 	add.w	r2, r4, #67	@ 0x43
3401bf30:	4641      	mov	r1, r8
3401bf32:	4638      	mov	r0, r7
3401bf34:	47c8      	blx	r9
3401bf36:	3001      	adds	r0, #1
3401bf38:	d023      	beq.n	3401bf82 <_printf_common+0xae>
3401bf3a:	6823      	ldr	r3, [r4, #0]
3401bf3c:	341a      	adds	r4, #26
3401bf3e:	f854 2c0a 	ldr.w	r2, [r4, #-10]
3401bf42:	f003 0306 	and.w	r3, r3, #6
3401bf46:	2b04      	cmp	r3, #4
3401bf48:	bf0a      	itet	eq
3401bf4a:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
3401bf4e:	2500      	movne	r5, #0
3401bf50:	6833      	ldreq	r3, [r6, #0]
3401bf52:	f04f 0600 	mov.w	r6, #0
3401bf56:	bf08      	it	eq
3401bf58:	1aed      	subeq	r5, r5, r3
3401bf5a:	f854 3c12 	ldr.w	r3, [r4, #-18]
3401bf5e:	bf08      	it	eq
3401bf60:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
3401bf64:	4293      	cmp	r3, r2
3401bf66:	bfc4      	itt	gt
3401bf68:	1a9b      	subgt	r3, r3, r2
3401bf6a:	18ed      	addgt	r5, r5, r3
3401bf6c:	42b5      	cmp	r5, r6
3401bf6e:	d11a      	bne.n	3401bfa6 <_printf_common+0xd2>
3401bf70:	2000      	movs	r0, #0
3401bf72:	e008      	b.n	3401bf86 <_printf_common+0xb2>
3401bf74:	2301      	movs	r3, #1
3401bf76:	4652      	mov	r2, sl
3401bf78:	4641      	mov	r1, r8
3401bf7a:	4638      	mov	r0, r7
3401bf7c:	47c8      	blx	r9
3401bf7e:	3001      	adds	r0, #1
3401bf80:	d103      	bne.n	3401bf8a <_printf_common+0xb6>
3401bf82:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
3401bf86:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
3401bf8a:	3501      	adds	r5, #1
3401bf8c:	e7c1      	b.n	3401bf12 <_printf_common+0x3e>
3401bf8e:	18e1      	adds	r1, r4, r3
3401bf90:	1c5a      	adds	r2, r3, #1
3401bf92:	2030      	movs	r0, #48	@ 0x30
3401bf94:	3302      	adds	r3, #2
3401bf96:	4422      	add	r2, r4
3401bf98:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
3401bf9c:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
3401bfa0:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
3401bfa4:	e7c2      	b.n	3401bf2c <_printf_common+0x58>
3401bfa6:	2301      	movs	r3, #1
3401bfa8:	4622      	mov	r2, r4
3401bfaa:	4641      	mov	r1, r8
3401bfac:	4638      	mov	r0, r7
3401bfae:	47c8      	blx	r9
3401bfb0:	3001      	adds	r0, #1
3401bfb2:	d0e6      	beq.n	3401bf82 <_printf_common+0xae>
3401bfb4:	3601      	adds	r6, #1
3401bfb6:	e7d9      	b.n	3401bf6c <_printf_common+0x98>

3401bfb8 <_printf_i>:
3401bfb8:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
3401bfbc:	7e0f      	ldrb	r7, [r1, #24]
3401bfbe:	4691      	mov	r9, r2
3401bfc0:	4680      	mov	r8, r0
3401bfc2:	460c      	mov	r4, r1
3401bfc4:	2f78      	cmp	r7, #120	@ 0x78
3401bfc6:	469a      	mov	sl, r3
3401bfc8:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
3401bfca:	f101 0243 	add.w	r2, r1, #67	@ 0x43
3401bfce:	d807      	bhi.n	3401bfe0 <_printf_i+0x28>
3401bfd0:	2f62      	cmp	r7, #98	@ 0x62
3401bfd2:	d80a      	bhi.n	3401bfea <_printf_i+0x32>
3401bfd4:	2f00      	cmp	r7, #0
3401bfd6:	f000 80d1 	beq.w	3401c17c <_printf_i+0x1c4>
3401bfda:	2f58      	cmp	r7, #88	@ 0x58
3401bfdc:	f000 80b8 	beq.w	3401c150 <_printf_i+0x198>
3401bfe0:	f104 0642 	add.w	r6, r4, #66	@ 0x42
3401bfe4:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
3401bfe8:	e03a      	b.n	3401c060 <_printf_i+0xa8>
3401bfea:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
3401bfee:	2b15      	cmp	r3, #21
3401bff0:	d8f6      	bhi.n	3401bfe0 <_printf_i+0x28>
3401bff2:	a101      	add	r1, pc, #4	@ (adr r1, 3401bff8 <_printf_i+0x40>)
3401bff4:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
3401bff8:	3401c051 	.word	0x3401c051
3401bffc:	3401c065 	.word	0x3401c065
3401c000:	3401bfe1 	.word	0x3401bfe1
3401c004:	3401bfe1 	.word	0x3401bfe1
3401c008:	3401bfe1 	.word	0x3401bfe1
3401c00c:	3401bfe1 	.word	0x3401bfe1
3401c010:	3401c065 	.word	0x3401c065
3401c014:	3401bfe1 	.word	0x3401bfe1
3401c018:	3401bfe1 	.word	0x3401bfe1
3401c01c:	3401bfe1 	.word	0x3401bfe1
3401c020:	3401bfe1 	.word	0x3401bfe1
3401c024:	3401c163 	.word	0x3401c163
3401c028:	3401c08f 	.word	0x3401c08f
3401c02c:	3401c11d 	.word	0x3401c11d
3401c030:	3401bfe1 	.word	0x3401bfe1
3401c034:	3401bfe1 	.word	0x3401bfe1
3401c038:	3401c185 	.word	0x3401c185
3401c03c:	3401bfe1 	.word	0x3401bfe1
3401c040:	3401c08f 	.word	0x3401c08f
3401c044:	3401bfe1 	.word	0x3401bfe1
3401c048:	3401bfe1 	.word	0x3401bfe1
3401c04c:	3401c125 	.word	0x3401c125
3401c050:	6833      	ldr	r3, [r6, #0]
3401c052:	1d1a      	adds	r2, r3, #4
3401c054:	681b      	ldr	r3, [r3, #0]
3401c056:	6032      	str	r2, [r6, #0]
3401c058:	f104 0642 	add.w	r6, r4, #66	@ 0x42
3401c05c:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
3401c060:	2301      	movs	r3, #1
3401c062:	e09c      	b.n	3401c19e <_printf_i+0x1e6>
3401c064:	6833      	ldr	r3, [r6, #0]
3401c066:	6820      	ldr	r0, [r4, #0]
3401c068:	1d19      	adds	r1, r3, #4
3401c06a:	6031      	str	r1, [r6, #0]
3401c06c:	0606      	lsls	r6, r0, #24
3401c06e:	d501      	bpl.n	3401c074 <_printf_i+0xbc>
3401c070:	681d      	ldr	r5, [r3, #0]
3401c072:	e003      	b.n	3401c07c <_printf_i+0xc4>
3401c074:	0645      	lsls	r5, r0, #25
3401c076:	d5fb      	bpl.n	3401c070 <_printf_i+0xb8>
3401c078:	f9b3 5000 	ldrsh.w	r5, [r3]
3401c07c:	2d00      	cmp	r5, #0
3401c07e:	da03      	bge.n	3401c088 <_printf_i+0xd0>
3401c080:	232d      	movs	r3, #45	@ 0x2d
3401c082:	426d      	negs	r5, r5
3401c084:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
3401c088:	4858      	ldr	r0, [pc, #352]	@ (3401c1ec <_printf_i+0x234>)
3401c08a:	230a      	movs	r3, #10
3401c08c:	e011      	b.n	3401c0b2 <_printf_i+0xfa>
3401c08e:	6821      	ldr	r1, [r4, #0]
3401c090:	6833      	ldr	r3, [r6, #0]
3401c092:	0608      	lsls	r0, r1, #24
3401c094:	f853 5b04 	ldr.w	r5, [r3], #4
3401c098:	d402      	bmi.n	3401c0a0 <_printf_i+0xe8>
3401c09a:	0649      	lsls	r1, r1, #25
3401c09c:	bf48      	it	mi
3401c09e:	b2ad      	uxthmi	r5, r5
3401c0a0:	2f6f      	cmp	r7, #111	@ 0x6f
3401c0a2:	6033      	str	r3, [r6, #0]
3401c0a4:	4851      	ldr	r0, [pc, #324]	@ (3401c1ec <_printf_i+0x234>)
3401c0a6:	bf14      	ite	ne
3401c0a8:	230a      	movne	r3, #10
3401c0aa:	2308      	moveq	r3, #8
3401c0ac:	2100      	movs	r1, #0
3401c0ae:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
3401c0b2:	6866      	ldr	r6, [r4, #4]
3401c0b4:	2e00      	cmp	r6, #0
3401c0b6:	60a6      	str	r6, [r4, #8]
3401c0b8:	db05      	blt.n	3401c0c6 <_printf_i+0x10e>
3401c0ba:	6821      	ldr	r1, [r4, #0]
3401c0bc:	432e      	orrs	r6, r5
3401c0be:	f021 0104 	bic.w	r1, r1, #4
3401c0c2:	6021      	str	r1, [r4, #0]
3401c0c4:	d04b      	beq.n	3401c15e <_printf_i+0x1a6>
3401c0c6:	4616      	mov	r6, r2
3401c0c8:	fbb5 f1f3 	udiv	r1, r5, r3
3401c0cc:	fb03 5711 	mls	r7, r3, r1, r5
3401c0d0:	5dc7      	ldrb	r7, [r0, r7]
3401c0d2:	f806 7d01 	strb.w	r7, [r6, #-1]!
3401c0d6:	462f      	mov	r7, r5
3401c0d8:	460d      	mov	r5, r1
3401c0da:	42bb      	cmp	r3, r7
3401c0dc:	d9f4      	bls.n	3401c0c8 <_printf_i+0x110>
3401c0de:	2b08      	cmp	r3, #8
3401c0e0:	d10b      	bne.n	3401c0fa <_printf_i+0x142>
3401c0e2:	6823      	ldr	r3, [r4, #0]
3401c0e4:	07df      	lsls	r7, r3, #31
3401c0e6:	d508      	bpl.n	3401c0fa <_printf_i+0x142>
3401c0e8:	6923      	ldr	r3, [r4, #16]
3401c0ea:	6861      	ldr	r1, [r4, #4]
3401c0ec:	4299      	cmp	r1, r3
3401c0ee:	bfde      	ittt	le
3401c0f0:	2330      	movle	r3, #48	@ 0x30
3401c0f2:	f806 3c01 	strble.w	r3, [r6, #-1]
3401c0f6:	f106 36ff 	addle.w	r6, r6, #4294967295	@ 0xffffffff
3401c0fa:	1b92      	subs	r2, r2, r6
3401c0fc:	6122      	str	r2, [r4, #16]
3401c0fe:	464b      	mov	r3, r9
3401c100:	aa03      	add	r2, sp, #12
3401c102:	4621      	mov	r1, r4
3401c104:	4640      	mov	r0, r8
3401c106:	f8cd a000 	str.w	sl, [sp]
3401c10a:	f7ff fee3 	bl	3401bed4 <_printf_common>
3401c10e:	3001      	adds	r0, #1
3401c110:	d14a      	bne.n	3401c1a8 <_printf_i+0x1f0>
3401c112:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
3401c116:	b004      	add	sp, #16
3401c118:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
3401c11c:	6823      	ldr	r3, [r4, #0]
3401c11e:	f043 0320 	orr.w	r3, r3, #32
3401c122:	6023      	str	r3, [r4, #0]
3401c124:	2778      	movs	r7, #120	@ 0x78
3401c126:	4832      	ldr	r0, [pc, #200]	@ (3401c1f0 <_printf_i+0x238>)
3401c128:	6823      	ldr	r3, [r4, #0]
3401c12a:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
3401c12e:	061f      	lsls	r7, r3, #24
3401c130:	6831      	ldr	r1, [r6, #0]
3401c132:	f851 5b04 	ldr.w	r5, [r1], #4
3401c136:	d402      	bmi.n	3401c13e <_printf_i+0x186>
3401c138:	065f      	lsls	r7, r3, #25
3401c13a:	bf48      	it	mi
3401c13c:	b2ad      	uxthmi	r5, r5
3401c13e:	6031      	str	r1, [r6, #0]
3401c140:	07d9      	lsls	r1, r3, #31
3401c142:	bf44      	itt	mi
3401c144:	f043 0320 	orrmi.w	r3, r3, #32
3401c148:	6023      	strmi	r3, [r4, #0]
3401c14a:	b11d      	cbz	r5, 3401c154 <_printf_i+0x19c>
3401c14c:	2310      	movs	r3, #16
3401c14e:	e7ad      	b.n	3401c0ac <_printf_i+0xf4>
3401c150:	4826      	ldr	r0, [pc, #152]	@ (3401c1ec <_printf_i+0x234>)
3401c152:	e7e9      	b.n	3401c128 <_printf_i+0x170>
3401c154:	6823      	ldr	r3, [r4, #0]
3401c156:	f023 0320 	bic.w	r3, r3, #32
3401c15a:	6023      	str	r3, [r4, #0]
3401c15c:	e7f6      	b.n	3401c14c <_printf_i+0x194>
3401c15e:	4616      	mov	r6, r2
3401c160:	e7bd      	b.n	3401c0de <_printf_i+0x126>
3401c162:	6833      	ldr	r3, [r6, #0]
3401c164:	6825      	ldr	r5, [r4, #0]
3401c166:	1d18      	adds	r0, r3, #4
3401c168:	6961      	ldr	r1, [r4, #20]
3401c16a:	6030      	str	r0, [r6, #0]
3401c16c:	062e      	lsls	r6, r5, #24
3401c16e:	681b      	ldr	r3, [r3, #0]
3401c170:	d501      	bpl.n	3401c176 <_printf_i+0x1be>
3401c172:	6019      	str	r1, [r3, #0]
3401c174:	e002      	b.n	3401c17c <_printf_i+0x1c4>
3401c176:	0668      	lsls	r0, r5, #25
3401c178:	d5fb      	bpl.n	3401c172 <_printf_i+0x1ba>
3401c17a:	8019      	strh	r1, [r3, #0]
3401c17c:	2300      	movs	r3, #0
3401c17e:	4616      	mov	r6, r2
3401c180:	6123      	str	r3, [r4, #16]
3401c182:	e7bc      	b.n	3401c0fe <_printf_i+0x146>
3401c184:	6833      	ldr	r3, [r6, #0]
3401c186:	2100      	movs	r1, #0
3401c188:	1d1a      	adds	r2, r3, #4
3401c18a:	6032      	str	r2, [r6, #0]
3401c18c:	681e      	ldr	r6, [r3, #0]
3401c18e:	6862      	ldr	r2, [r4, #4]
3401c190:	4630      	mov	r0, r6
3401c192:	f000 fd8c 	bl	3401ccae <memchr>
3401c196:	b108      	cbz	r0, 3401c19c <_printf_i+0x1e4>
3401c198:	1b80      	subs	r0, r0, r6
3401c19a:	6060      	str	r0, [r4, #4]
3401c19c:	6863      	ldr	r3, [r4, #4]
3401c19e:	6123      	str	r3, [r4, #16]
3401c1a0:	2300      	movs	r3, #0
3401c1a2:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
3401c1a6:	e7aa      	b.n	3401c0fe <_printf_i+0x146>
3401c1a8:	6923      	ldr	r3, [r4, #16]
3401c1aa:	4632      	mov	r2, r6
3401c1ac:	4649      	mov	r1, r9
3401c1ae:	4640      	mov	r0, r8
3401c1b0:	47d0      	blx	sl
3401c1b2:	3001      	adds	r0, #1
3401c1b4:	d0ad      	beq.n	3401c112 <_printf_i+0x15a>
3401c1b6:	6823      	ldr	r3, [r4, #0]
3401c1b8:	079b      	lsls	r3, r3, #30
3401c1ba:	d413      	bmi.n	3401c1e4 <_printf_i+0x22c>
3401c1bc:	68e0      	ldr	r0, [r4, #12]
3401c1be:	9b03      	ldr	r3, [sp, #12]
3401c1c0:	4298      	cmp	r0, r3
3401c1c2:	bfb8      	it	lt
3401c1c4:	4618      	movlt	r0, r3
3401c1c6:	e7a6      	b.n	3401c116 <_printf_i+0x15e>
3401c1c8:	2301      	movs	r3, #1
3401c1ca:	4632      	mov	r2, r6
3401c1cc:	4649      	mov	r1, r9
3401c1ce:	4640      	mov	r0, r8
3401c1d0:	47d0      	blx	sl
3401c1d2:	3001      	adds	r0, #1
3401c1d4:	d09d      	beq.n	3401c112 <_printf_i+0x15a>
3401c1d6:	3501      	adds	r5, #1
3401c1d8:	68e3      	ldr	r3, [r4, #12]
3401c1da:	9903      	ldr	r1, [sp, #12]
3401c1dc:	1a5b      	subs	r3, r3, r1
3401c1de:	42ab      	cmp	r3, r5
3401c1e0:	dcf2      	bgt.n	3401c1c8 <_printf_i+0x210>
3401c1e2:	e7eb      	b.n	3401c1bc <_printf_i+0x204>
3401c1e4:	2500      	movs	r5, #0
3401c1e6:	f104 0619 	add.w	r6, r4, #25
3401c1ea:	e7f5      	b.n	3401c1d8 <_printf_i+0x220>
3401c1ec:	3402024c 	.word	0x3402024c
3401c1f0:	3402025d 	.word	0x3402025d

3401c1f4 <__sflush_r>:
3401c1f4:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
3401c1f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3401c1fc:	0716      	lsls	r6, r2, #28
3401c1fe:	4605      	mov	r5, r0
3401c200:	460c      	mov	r4, r1
3401c202:	d454      	bmi.n	3401c2ae <__sflush_r+0xba>
3401c204:	684b      	ldr	r3, [r1, #4]
3401c206:	2b00      	cmp	r3, #0
3401c208:	dc02      	bgt.n	3401c210 <__sflush_r+0x1c>
3401c20a:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
3401c20c:	2b00      	cmp	r3, #0
3401c20e:	dd48      	ble.n	3401c2a2 <__sflush_r+0xae>
3401c210:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
3401c212:	2e00      	cmp	r6, #0
3401c214:	d045      	beq.n	3401c2a2 <__sflush_r+0xae>
3401c216:	2300      	movs	r3, #0
3401c218:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
3401c21c:	682f      	ldr	r7, [r5, #0]
3401c21e:	6a21      	ldr	r1, [r4, #32]
3401c220:	602b      	str	r3, [r5, #0]
3401c222:	d030      	beq.n	3401c286 <__sflush_r+0x92>
3401c224:	6d62      	ldr	r2, [r4, #84]	@ 0x54
3401c226:	89a3      	ldrh	r3, [r4, #12]
3401c228:	0759      	lsls	r1, r3, #29
3401c22a:	d505      	bpl.n	3401c238 <__sflush_r+0x44>
3401c22c:	6863      	ldr	r3, [r4, #4]
3401c22e:	1ad2      	subs	r2, r2, r3
3401c230:	6b63      	ldr	r3, [r4, #52]	@ 0x34
3401c232:	b10b      	cbz	r3, 3401c238 <__sflush_r+0x44>
3401c234:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3401c236:	1ad2      	subs	r2, r2, r3
3401c238:	2300      	movs	r3, #0
3401c23a:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
3401c23c:	6a21      	ldr	r1, [r4, #32]
3401c23e:	4628      	mov	r0, r5
3401c240:	47b0      	blx	r6
3401c242:	1c43      	adds	r3, r0, #1
3401c244:	89a3      	ldrh	r3, [r4, #12]
3401c246:	d106      	bne.n	3401c256 <__sflush_r+0x62>
3401c248:	6829      	ldr	r1, [r5, #0]
3401c24a:	291d      	cmp	r1, #29
3401c24c:	d82b      	bhi.n	3401c2a6 <__sflush_r+0xb2>
3401c24e:	4a2a      	ldr	r2, [pc, #168]	@ (3401c2f8 <__sflush_r+0x104>)
3401c250:	40ca      	lsrs	r2, r1
3401c252:	07d6      	lsls	r6, r2, #31
3401c254:	d527      	bpl.n	3401c2a6 <__sflush_r+0xb2>
3401c256:	2200      	movs	r2, #0
3401c258:	04d9      	lsls	r1, r3, #19
3401c25a:	6062      	str	r2, [r4, #4]
3401c25c:	6922      	ldr	r2, [r4, #16]
3401c25e:	6022      	str	r2, [r4, #0]
3401c260:	d504      	bpl.n	3401c26c <__sflush_r+0x78>
3401c262:	1c42      	adds	r2, r0, #1
3401c264:	d101      	bne.n	3401c26a <__sflush_r+0x76>
3401c266:	682b      	ldr	r3, [r5, #0]
3401c268:	b903      	cbnz	r3, 3401c26c <__sflush_r+0x78>
3401c26a:	6560      	str	r0, [r4, #84]	@ 0x54
3401c26c:	6b61      	ldr	r1, [r4, #52]	@ 0x34
3401c26e:	602f      	str	r7, [r5, #0]
3401c270:	b1b9      	cbz	r1, 3401c2a2 <__sflush_r+0xae>
3401c272:	f104 0344 	add.w	r3, r4, #68	@ 0x44
3401c276:	4299      	cmp	r1, r3
3401c278:	d002      	beq.n	3401c280 <__sflush_r+0x8c>
3401c27a:	4628      	mov	r0, r5
3401c27c:	f001 fb26 	bl	3401d8cc <_free_r>
3401c280:	2300      	movs	r3, #0
3401c282:	6363      	str	r3, [r4, #52]	@ 0x34
3401c284:	e00d      	b.n	3401c2a2 <__sflush_r+0xae>
3401c286:	2301      	movs	r3, #1
3401c288:	4628      	mov	r0, r5
3401c28a:	47b0      	blx	r6
3401c28c:	4602      	mov	r2, r0
3401c28e:	1c50      	adds	r0, r2, #1
3401c290:	d1c9      	bne.n	3401c226 <__sflush_r+0x32>
3401c292:	682b      	ldr	r3, [r5, #0]
3401c294:	2b00      	cmp	r3, #0
3401c296:	d0c6      	beq.n	3401c226 <__sflush_r+0x32>
3401c298:	2b1d      	cmp	r3, #29
3401c29a:	d001      	beq.n	3401c2a0 <__sflush_r+0xac>
3401c29c:	2b16      	cmp	r3, #22
3401c29e:	d11d      	bne.n	3401c2dc <__sflush_r+0xe8>
3401c2a0:	602f      	str	r7, [r5, #0]
3401c2a2:	2000      	movs	r0, #0
3401c2a4:	e021      	b.n	3401c2ea <__sflush_r+0xf6>
3401c2a6:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3401c2aa:	b21b      	sxth	r3, r3
3401c2ac:	e01a      	b.n	3401c2e4 <__sflush_r+0xf0>
3401c2ae:	690f      	ldr	r7, [r1, #16]
3401c2b0:	2f00      	cmp	r7, #0
3401c2b2:	d0f6      	beq.n	3401c2a2 <__sflush_r+0xae>
3401c2b4:	0793      	lsls	r3, r2, #30
3401c2b6:	680e      	ldr	r6, [r1, #0]
3401c2b8:	600f      	str	r7, [r1, #0]
3401c2ba:	bf0c      	ite	eq
3401c2bc:	694b      	ldreq	r3, [r1, #20]
3401c2be:	2300      	movne	r3, #0
3401c2c0:	eba6 0807 	sub.w	r8, r6, r7
3401c2c4:	608b      	str	r3, [r1, #8]
3401c2c6:	f1b8 0f00 	cmp.w	r8, #0
3401c2ca:	ddea      	ble.n	3401c2a2 <__sflush_r+0xae>
3401c2cc:	4643      	mov	r3, r8
3401c2ce:	463a      	mov	r2, r7
3401c2d0:	6a21      	ldr	r1, [r4, #32]
3401c2d2:	4628      	mov	r0, r5
3401c2d4:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
3401c2d6:	47b0      	blx	r6
3401c2d8:	2800      	cmp	r0, #0
3401c2da:	dc08      	bgt.n	3401c2ee <__sflush_r+0xfa>
3401c2dc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3401c2e0:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3401c2e4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
3401c2e8:	81a3      	strh	r3, [r4, #12]
3401c2ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
3401c2ee:	4407      	add	r7, r0
3401c2f0:	eba8 0800 	sub.w	r8, r8, r0
3401c2f4:	e7e7      	b.n	3401c2c6 <__sflush_r+0xd2>
3401c2f6:	bf00      	nop
3401c2f8:	20400001 	.word	0x20400001

3401c2fc <_fflush_r>:
3401c2fc:	b538      	push	{r3, r4, r5, lr}
3401c2fe:	690b      	ldr	r3, [r1, #16]
3401c300:	4605      	mov	r5, r0
3401c302:	460c      	mov	r4, r1
3401c304:	b913      	cbnz	r3, 3401c30c <_fflush_r+0x10>
3401c306:	2500      	movs	r5, #0
3401c308:	4628      	mov	r0, r5
3401c30a:	bd38      	pop	{r3, r4, r5, pc}
3401c30c:	b118      	cbz	r0, 3401c316 <_fflush_r+0x1a>
3401c30e:	6a03      	ldr	r3, [r0, #32]
3401c310:	b90b      	cbnz	r3, 3401c316 <_fflush_r+0x1a>
3401c312:	f000 f8bb 	bl	3401c48c <__sinit>
3401c316:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3401c31a:	2b00      	cmp	r3, #0
3401c31c:	d0f3      	beq.n	3401c306 <_fflush_r+0xa>
3401c31e:	6e62      	ldr	r2, [r4, #100]	@ 0x64
3401c320:	07d0      	lsls	r0, r2, #31
3401c322:	d404      	bmi.n	3401c32e <_fflush_r+0x32>
3401c324:	0599      	lsls	r1, r3, #22
3401c326:	d402      	bmi.n	3401c32e <_fflush_r+0x32>
3401c328:	6da0      	ldr	r0, [r4, #88]	@ 0x58
3401c32a:	f000 fcbe 	bl	3401ccaa <__retarget_lock_acquire_recursive>
3401c32e:	4628      	mov	r0, r5
3401c330:	4621      	mov	r1, r4
3401c332:	f7ff ff5f 	bl	3401c1f4 <__sflush_r>
3401c336:	6e63      	ldr	r3, [r4, #100]	@ 0x64
3401c338:	4605      	mov	r5, r0
3401c33a:	07da      	lsls	r2, r3, #31
3401c33c:	d4e4      	bmi.n	3401c308 <_fflush_r+0xc>
3401c33e:	89a3      	ldrh	r3, [r4, #12]
3401c340:	059b      	lsls	r3, r3, #22
3401c342:	d4e1      	bmi.n	3401c308 <_fflush_r+0xc>
3401c344:	6da0      	ldr	r0, [r4, #88]	@ 0x58
3401c346:	f000 fcb1 	bl	3401ccac <__retarget_lock_release_recursive>
3401c34a:	e7dd      	b.n	3401c308 <_fflush_r+0xc>

3401c34c <fflush>:
3401c34c:	4601      	mov	r1, r0
3401c34e:	b920      	cbnz	r0, 3401c35a <fflush+0xe>
3401c350:	4a04      	ldr	r2, [pc, #16]	@ (3401c364 <fflush+0x18>)
3401c352:	4905      	ldr	r1, [pc, #20]	@ (3401c368 <fflush+0x1c>)
3401c354:	4805      	ldr	r0, [pc, #20]	@ (3401c36c <fflush+0x20>)
3401c356:	f000 b8c3 	b.w	3401c4e0 <_fwalk_sglue>
3401c35a:	4b05      	ldr	r3, [pc, #20]	@ (3401c370 <fflush+0x24>)
3401c35c:	6818      	ldr	r0, [r3, #0]
3401c35e:	f7ff bfcd 	b.w	3401c2fc <_fflush_r>
3401c362:	bf00      	nop
3401c364:	34020c60 	.word	0x34020c60
3401c368:	3401c2fd 	.word	0x3401c2fd
3401c36c:	34020c70 	.word	0x34020c70
3401c370:	34020c6c 	.word	0x34020c6c

3401c374 <std>:
3401c374:	2300      	movs	r3, #0
3401c376:	b510      	push	{r4, lr}
3401c378:	4604      	mov	r4, r0
3401c37a:	6083      	str	r3, [r0, #8]
3401c37c:	8181      	strh	r1, [r0, #12]
3401c37e:	4619      	mov	r1, r3
3401c380:	6643      	str	r3, [r0, #100]	@ 0x64
3401c382:	81c2      	strh	r2, [r0, #14]
3401c384:	2208      	movs	r2, #8
3401c386:	6183      	str	r3, [r0, #24]
3401c388:	e9c0 3300 	strd	r3, r3, [r0]
3401c38c:	e9c0 3304 	strd	r3, r3, [r0, #16]
3401c390:	305c      	adds	r0, #92	@ 0x5c
3401c392:	f000 fa0b 	bl	3401c7ac <memset>
3401c396:	4b0d      	ldr	r3, [pc, #52]	@ (3401c3cc <std+0x58>)
3401c398:	6224      	str	r4, [r4, #32]
3401c39a:	6263      	str	r3, [r4, #36]	@ 0x24
3401c39c:	4b0c      	ldr	r3, [pc, #48]	@ (3401c3d0 <std+0x5c>)
3401c39e:	62a3      	str	r3, [r4, #40]	@ 0x28
3401c3a0:	4b0c      	ldr	r3, [pc, #48]	@ (3401c3d4 <std+0x60>)
3401c3a2:	62e3      	str	r3, [r4, #44]	@ 0x2c
3401c3a4:	4b0c      	ldr	r3, [pc, #48]	@ (3401c3d8 <std+0x64>)
3401c3a6:	6323      	str	r3, [r4, #48]	@ 0x30
3401c3a8:	4b0c      	ldr	r3, [pc, #48]	@ (3401c3dc <std+0x68>)
3401c3aa:	429c      	cmp	r4, r3
3401c3ac:	d006      	beq.n	3401c3bc <std+0x48>
3401c3ae:	f103 0268 	add.w	r2, r3, #104	@ 0x68
3401c3b2:	4294      	cmp	r4, r2
3401c3b4:	d002      	beq.n	3401c3bc <std+0x48>
3401c3b6:	33d0      	adds	r3, #208	@ 0xd0
3401c3b8:	429c      	cmp	r4, r3
3401c3ba:	d105      	bne.n	3401c3c8 <std+0x54>
3401c3bc:	f104 0058 	add.w	r0, r4, #88	@ 0x58
3401c3c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
3401c3c4:	f000 bc70 	b.w	3401cca8 <__retarget_lock_init_recursive>
3401c3c8:	bd10      	pop	{r4, pc}
3401c3ca:	bf00      	nop
3401c3cc:	3401c5fd 	.word	0x3401c5fd
3401c3d0:	3401c61f 	.word	0x3401c61f
3401c3d4:	3401c657 	.word	0x3401c657
3401c3d8:	3401c67b 	.word	0x3401c67b
3401c3dc:	340213b8 	.word	0x340213b8

3401c3e0 <stdio_exit_handler>:
3401c3e0:	4a02      	ldr	r2, [pc, #8]	@ (3401c3ec <stdio_exit_handler+0xc>)
3401c3e2:	4903      	ldr	r1, [pc, #12]	@ (3401c3f0 <stdio_exit_handler+0x10>)
3401c3e4:	4803      	ldr	r0, [pc, #12]	@ (3401c3f4 <stdio_exit_handler+0x14>)
3401c3e6:	f000 b87b 	b.w	3401c4e0 <_fwalk_sglue>
3401c3ea:	bf00      	nop
3401c3ec:	34020c60 	.word	0x34020c60
3401c3f0:	3401c2fd 	.word	0x3401c2fd
3401c3f4:	34020c70 	.word	0x34020c70

3401c3f8 <cleanup_stdio>:
3401c3f8:	6841      	ldr	r1, [r0, #4]
3401c3fa:	4b0c      	ldr	r3, [pc, #48]	@ (3401c42c <cleanup_stdio+0x34>)
3401c3fc:	4299      	cmp	r1, r3
3401c3fe:	b510      	push	{r4, lr}
3401c400:	4604      	mov	r4, r0
3401c402:	d001      	beq.n	3401c408 <cleanup_stdio+0x10>
3401c404:	f7ff ff7a 	bl	3401c2fc <_fflush_r>
3401c408:	68a1      	ldr	r1, [r4, #8]
3401c40a:	4b09      	ldr	r3, [pc, #36]	@ (3401c430 <cleanup_stdio+0x38>)
3401c40c:	4299      	cmp	r1, r3
3401c40e:	d002      	beq.n	3401c416 <cleanup_stdio+0x1e>
3401c410:	4620      	mov	r0, r4
3401c412:	f7ff ff73 	bl	3401c2fc <_fflush_r>
3401c416:	68e1      	ldr	r1, [r4, #12]
3401c418:	4b06      	ldr	r3, [pc, #24]	@ (3401c434 <cleanup_stdio+0x3c>)
3401c41a:	4299      	cmp	r1, r3
3401c41c:	d004      	beq.n	3401c428 <cleanup_stdio+0x30>
3401c41e:	4620      	mov	r0, r4
3401c420:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
3401c424:	f7ff bf6a 	b.w	3401c2fc <_fflush_r>
3401c428:	bd10      	pop	{r4, pc}
3401c42a:	bf00      	nop
3401c42c:	340213b8 	.word	0x340213b8
3401c430:	34021420 	.word	0x34021420
3401c434:	34021488 	.word	0x34021488

3401c438 <global_stdio_init.part.0>:
3401c438:	b510      	push	{r4, lr}
3401c43a:	4b0b      	ldr	r3, [pc, #44]	@ (3401c468 <global_stdio_init.part.0+0x30>)
3401c43c:	2104      	movs	r1, #4
3401c43e:	4c0b      	ldr	r4, [pc, #44]	@ (3401c46c <global_stdio_init.part.0+0x34>)
3401c440:	4a0b      	ldr	r2, [pc, #44]	@ (3401c470 <global_stdio_init.part.0+0x38>)
3401c442:	4620      	mov	r0, r4
3401c444:	601a      	str	r2, [r3, #0]
3401c446:	2200      	movs	r2, #0
3401c448:	f7ff ff94 	bl	3401c374 <std>
3401c44c:	f104 0068 	add.w	r0, r4, #104	@ 0x68
3401c450:	2201      	movs	r2, #1
3401c452:	2109      	movs	r1, #9
3401c454:	f7ff ff8e 	bl	3401c374 <std>
3401c458:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
3401c45c:	2202      	movs	r2, #2
3401c45e:	2112      	movs	r1, #18
3401c460:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
3401c464:	f7ff bf86 	b.w	3401c374 <std>
3401c468:	340214f0 	.word	0x340214f0
3401c46c:	340213b8 	.word	0x340213b8
3401c470:	3401c3e1 	.word	0x3401c3e1

3401c474 <__sfp_lock_acquire>:
3401c474:	4801      	ldr	r0, [pc, #4]	@ (3401c47c <__sfp_lock_acquire+0x8>)
3401c476:	f000 bc18 	b.w	3401ccaa <__retarget_lock_acquire_recursive>
3401c47a:	bf00      	nop
3401c47c:	340214f9 	.word	0x340214f9

3401c480 <__sfp_lock_release>:
3401c480:	4801      	ldr	r0, [pc, #4]	@ (3401c488 <__sfp_lock_release+0x8>)
3401c482:	f000 bc13 	b.w	3401ccac <__retarget_lock_release_recursive>
3401c486:	bf00      	nop
3401c488:	340214f9 	.word	0x340214f9

3401c48c <__sinit>:
3401c48c:	b510      	push	{r4, lr}
3401c48e:	4604      	mov	r4, r0
3401c490:	f7ff fff0 	bl	3401c474 <__sfp_lock_acquire>
3401c494:	6a23      	ldr	r3, [r4, #32]
3401c496:	b11b      	cbz	r3, 3401c4a0 <__sinit+0x14>
3401c498:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
3401c49c:	f7ff bff0 	b.w	3401c480 <__sfp_lock_release>
3401c4a0:	4b04      	ldr	r3, [pc, #16]	@ (3401c4b4 <__sinit+0x28>)
3401c4a2:	6223      	str	r3, [r4, #32]
3401c4a4:	4b04      	ldr	r3, [pc, #16]	@ (3401c4b8 <__sinit+0x2c>)
3401c4a6:	681b      	ldr	r3, [r3, #0]
3401c4a8:	2b00      	cmp	r3, #0
3401c4aa:	d1f5      	bne.n	3401c498 <__sinit+0xc>
3401c4ac:	f7ff ffc4 	bl	3401c438 <global_stdio_init.part.0>
3401c4b0:	e7f2      	b.n	3401c498 <__sinit+0xc>
3401c4b2:	bf00      	nop
3401c4b4:	3401c3f9 	.word	0x3401c3f9
3401c4b8:	340214f0 	.word	0x340214f0

3401c4bc <fiprintf>:
3401c4bc:	b40e      	push	{r1, r2, r3}
3401c4be:	b503      	push	{r0, r1, lr}
3401c4c0:	ab03      	add	r3, sp, #12
3401c4c2:	4601      	mov	r1, r0
3401c4c4:	4805      	ldr	r0, [pc, #20]	@ (3401c4dc <fiprintf+0x20>)
3401c4c6:	f853 2b04 	ldr.w	r2, [r3], #4
3401c4ca:	6800      	ldr	r0, [r0, #0]
3401c4cc:	9301      	str	r3, [sp, #4]
3401c4ce:	f001 fdf3 	bl	3401e0b8 <_vfiprintf_r>
3401c4d2:	b002      	add	sp, #8
3401c4d4:	f85d eb04 	ldr.w	lr, [sp], #4
3401c4d8:	b003      	add	sp, #12
3401c4da:	4770      	bx	lr
3401c4dc:	34020c6c 	.word	0x34020c6c

3401c4e0 <_fwalk_sglue>:
3401c4e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
3401c4e4:	4607      	mov	r7, r0
3401c4e6:	4688      	mov	r8, r1
3401c4e8:	4614      	mov	r4, r2
3401c4ea:	2600      	movs	r6, #0
3401c4ec:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
3401c4f0:	f1b9 0901 	subs.w	r9, r9, #1
3401c4f4:	d505      	bpl.n	3401c502 <_fwalk_sglue+0x22>
3401c4f6:	6824      	ldr	r4, [r4, #0]
3401c4f8:	2c00      	cmp	r4, #0
3401c4fa:	d1f7      	bne.n	3401c4ec <_fwalk_sglue+0xc>
3401c4fc:	4630      	mov	r0, r6
3401c4fe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
3401c502:	89ab      	ldrh	r3, [r5, #12]
3401c504:	2b01      	cmp	r3, #1
3401c506:	d907      	bls.n	3401c518 <_fwalk_sglue+0x38>
3401c508:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
3401c50c:	3301      	adds	r3, #1
3401c50e:	d003      	beq.n	3401c518 <_fwalk_sglue+0x38>
3401c510:	4629      	mov	r1, r5
3401c512:	4638      	mov	r0, r7
3401c514:	47c0      	blx	r8
3401c516:	4306      	orrs	r6, r0
3401c518:	3568      	adds	r5, #104	@ 0x68
3401c51a:	e7e9      	b.n	3401c4f0 <_fwalk_sglue+0x10>

3401c51c <iprintf>:
3401c51c:	b40f      	push	{r0, r1, r2, r3}
3401c51e:	b507      	push	{r0, r1, r2, lr}
3401c520:	4906      	ldr	r1, [pc, #24]	@ (3401c53c <iprintf+0x20>)
3401c522:	ab04      	add	r3, sp, #16
3401c524:	6808      	ldr	r0, [r1, #0]
3401c526:	f853 2b04 	ldr.w	r2, [r3], #4
3401c52a:	6881      	ldr	r1, [r0, #8]
3401c52c:	9301      	str	r3, [sp, #4]
3401c52e:	f001 fdc3 	bl	3401e0b8 <_vfiprintf_r>
3401c532:	b003      	add	sp, #12
3401c534:	f85d eb04 	ldr.w	lr, [sp], #4
3401c538:	b004      	add	sp, #16
3401c53a:	4770      	bx	lr
3401c53c:	34020c6c 	.word	0x34020c6c

3401c540 <_puts_r>:
3401c540:	6a03      	ldr	r3, [r0, #32]
3401c542:	b570      	push	{r4, r5, r6, lr}
3401c544:	4605      	mov	r5, r0
3401c546:	460e      	mov	r6, r1
3401c548:	6884      	ldr	r4, [r0, #8]
3401c54a:	b90b      	cbnz	r3, 3401c550 <_puts_r+0x10>
3401c54c:	f7ff ff9e 	bl	3401c48c <__sinit>
3401c550:	6e63      	ldr	r3, [r4, #100]	@ 0x64
3401c552:	07db      	lsls	r3, r3, #31
3401c554:	d405      	bmi.n	3401c562 <_puts_r+0x22>
3401c556:	89a3      	ldrh	r3, [r4, #12]
3401c558:	0598      	lsls	r0, r3, #22
3401c55a:	d402      	bmi.n	3401c562 <_puts_r+0x22>
3401c55c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
3401c55e:	f000 fba4 	bl	3401ccaa <__retarget_lock_acquire_recursive>
3401c562:	89a3      	ldrh	r3, [r4, #12]
3401c564:	0719      	lsls	r1, r3, #28
3401c566:	d502      	bpl.n	3401c56e <_puts_r+0x2e>
3401c568:	6923      	ldr	r3, [r4, #16]
3401c56a:	2b00      	cmp	r3, #0
3401c56c:	d135      	bne.n	3401c5da <_puts_r+0x9a>
3401c56e:	4621      	mov	r1, r4
3401c570:	4628      	mov	r0, r5
3401c572:	f000 f8c5 	bl	3401c700 <__swsetup_r>
3401c576:	b380      	cbz	r0, 3401c5da <_puts_r+0x9a>
3401c578:	f04f 35ff 	mov.w	r5, #4294967295	@ 0xffffffff
3401c57c:	6e63      	ldr	r3, [r4, #100]	@ 0x64
3401c57e:	07da      	lsls	r2, r3, #31
3401c580:	d405      	bmi.n	3401c58e <_puts_r+0x4e>
3401c582:	89a3      	ldrh	r3, [r4, #12]
3401c584:	059b      	lsls	r3, r3, #22
3401c586:	d402      	bmi.n	3401c58e <_puts_r+0x4e>
3401c588:	6da0      	ldr	r0, [r4, #88]	@ 0x58
3401c58a:	f000 fb8f 	bl	3401ccac <__retarget_lock_release_recursive>
3401c58e:	4628      	mov	r0, r5
3401c590:	bd70      	pop	{r4, r5, r6, pc}
3401c592:	2b00      	cmp	r3, #0
3401c594:	da04      	bge.n	3401c5a0 <_puts_r+0x60>
3401c596:	69a2      	ldr	r2, [r4, #24]
3401c598:	429a      	cmp	r2, r3
3401c59a:	dc17      	bgt.n	3401c5cc <_puts_r+0x8c>
3401c59c:	290a      	cmp	r1, #10
3401c59e:	d015      	beq.n	3401c5cc <_puts_r+0x8c>
3401c5a0:	6823      	ldr	r3, [r4, #0]
3401c5a2:	1c5a      	adds	r2, r3, #1
3401c5a4:	6022      	str	r2, [r4, #0]
3401c5a6:	7019      	strb	r1, [r3, #0]
3401c5a8:	68a3      	ldr	r3, [r4, #8]
3401c5aa:	f816 1f01 	ldrb.w	r1, [r6, #1]!
3401c5ae:	3b01      	subs	r3, #1
3401c5b0:	60a3      	str	r3, [r4, #8]
3401c5b2:	2900      	cmp	r1, #0
3401c5b4:	d1ed      	bne.n	3401c592 <_puts_r+0x52>
3401c5b6:	2b00      	cmp	r3, #0
3401c5b8:	da11      	bge.n	3401c5de <_puts_r+0x9e>
3401c5ba:	4622      	mov	r2, r4
3401c5bc:	210a      	movs	r1, #10
3401c5be:	4628      	mov	r0, r5
3401c5c0:	f000 f85f 	bl	3401c682 <__swbuf_r>
3401c5c4:	3001      	adds	r0, #1
3401c5c6:	d0d7      	beq.n	3401c578 <_puts_r+0x38>
3401c5c8:	250a      	movs	r5, #10
3401c5ca:	e7d7      	b.n	3401c57c <_puts_r+0x3c>
3401c5cc:	4622      	mov	r2, r4
3401c5ce:	4628      	mov	r0, r5
3401c5d0:	f000 f857 	bl	3401c682 <__swbuf_r>
3401c5d4:	3001      	adds	r0, #1
3401c5d6:	d1e7      	bne.n	3401c5a8 <_puts_r+0x68>
3401c5d8:	e7ce      	b.n	3401c578 <_puts_r+0x38>
3401c5da:	3e01      	subs	r6, #1
3401c5dc:	e7e4      	b.n	3401c5a8 <_puts_r+0x68>
3401c5de:	6823      	ldr	r3, [r4, #0]
3401c5e0:	1c5a      	adds	r2, r3, #1
3401c5e2:	6022      	str	r2, [r4, #0]
3401c5e4:	220a      	movs	r2, #10
3401c5e6:	701a      	strb	r2, [r3, #0]
3401c5e8:	e7ee      	b.n	3401c5c8 <_puts_r+0x88>
	...

3401c5ec <puts>:
3401c5ec:	4b02      	ldr	r3, [pc, #8]	@ (3401c5f8 <puts+0xc>)
3401c5ee:	4601      	mov	r1, r0
3401c5f0:	6818      	ldr	r0, [r3, #0]
3401c5f2:	f7ff bfa5 	b.w	3401c540 <_puts_r>
3401c5f6:	bf00      	nop
3401c5f8:	34020c6c 	.word	0x34020c6c

3401c5fc <__sread>:
3401c5fc:	b510      	push	{r4, lr}
3401c5fe:	460c      	mov	r4, r1
3401c600:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
3401c604:	f000 faf2 	bl	3401cbec <_read_r>
3401c608:	2800      	cmp	r0, #0
3401c60a:	bfab      	itete	ge
3401c60c:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
3401c60e:	89a3      	ldrhlt	r3, [r4, #12]
3401c610:	181b      	addge	r3, r3, r0
3401c612:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
3401c616:	bfac      	ite	ge
3401c618:	6563      	strge	r3, [r4, #84]	@ 0x54
3401c61a:	81a3      	strhlt	r3, [r4, #12]
3401c61c:	bd10      	pop	{r4, pc}

3401c61e <__swrite>:
3401c61e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3401c622:	461f      	mov	r7, r3
3401c624:	898b      	ldrh	r3, [r1, #12]
3401c626:	4605      	mov	r5, r0
3401c628:	460c      	mov	r4, r1
3401c62a:	05db      	lsls	r3, r3, #23
3401c62c:	4616      	mov	r6, r2
3401c62e:	d505      	bpl.n	3401c63c <__swrite+0x1e>
3401c630:	2302      	movs	r3, #2
3401c632:	2200      	movs	r2, #0
3401c634:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
3401c638:	f000 fac6 	bl	3401cbc8 <_lseek_r>
3401c63c:	89a3      	ldrh	r3, [r4, #12]
3401c63e:	4632      	mov	r2, r6
3401c640:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
3401c644:	4628      	mov	r0, r5
3401c646:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
3401c64a:	81a3      	strh	r3, [r4, #12]
3401c64c:	463b      	mov	r3, r7
3401c64e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
3401c652:	f000 baed 	b.w	3401cc30 <_write_r>

3401c656 <__sseek>:
3401c656:	b510      	push	{r4, lr}
3401c658:	460c      	mov	r4, r1
3401c65a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
3401c65e:	f000 fab3 	bl	3401cbc8 <_lseek_r>
3401c662:	1c43      	adds	r3, r0, #1
3401c664:	89a3      	ldrh	r3, [r4, #12]
3401c666:	bf15      	itete	ne
3401c668:	6560      	strne	r0, [r4, #84]	@ 0x54
3401c66a:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
3401c66e:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
3401c672:	81a3      	strheq	r3, [r4, #12]
3401c674:	bf18      	it	ne
3401c676:	81a3      	strhne	r3, [r4, #12]
3401c678:	bd10      	pop	{r4, pc}

3401c67a <__sclose>:
3401c67a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
3401c67e:	f000 ba93 	b.w	3401cba8 <_close_r>

3401c682 <__swbuf_r>:
3401c682:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3401c684:	460e      	mov	r6, r1
3401c686:	4614      	mov	r4, r2
3401c688:	4605      	mov	r5, r0
3401c68a:	b118      	cbz	r0, 3401c694 <__swbuf_r+0x12>
3401c68c:	6a03      	ldr	r3, [r0, #32]
3401c68e:	b90b      	cbnz	r3, 3401c694 <__swbuf_r+0x12>
3401c690:	f7ff fefc 	bl	3401c48c <__sinit>
3401c694:	69a3      	ldr	r3, [r4, #24]
3401c696:	60a3      	str	r3, [r4, #8]
3401c698:	89a3      	ldrh	r3, [r4, #12]
3401c69a:	071a      	lsls	r2, r3, #28
3401c69c:	d501      	bpl.n	3401c6a2 <__swbuf_r+0x20>
3401c69e:	6923      	ldr	r3, [r4, #16]
3401c6a0:	b943      	cbnz	r3, 3401c6b4 <__swbuf_r+0x32>
3401c6a2:	4621      	mov	r1, r4
3401c6a4:	4628      	mov	r0, r5
3401c6a6:	f000 f82b 	bl	3401c700 <__swsetup_r>
3401c6aa:	b118      	cbz	r0, 3401c6b4 <__swbuf_r+0x32>
3401c6ac:	f04f 37ff 	mov.w	r7, #4294967295	@ 0xffffffff
3401c6b0:	4638      	mov	r0, r7
3401c6b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
3401c6b4:	6823      	ldr	r3, [r4, #0]
3401c6b6:	b2f6      	uxtb	r6, r6
3401c6b8:	6922      	ldr	r2, [r4, #16]
3401c6ba:	4637      	mov	r7, r6
3401c6bc:	1a98      	subs	r0, r3, r2
3401c6be:	6963      	ldr	r3, [r4, #20]
3401c6c0:	4283      	cmp	r3, r0
3401c6c2:	dc05      	bgt.n	3401c6d0 <__swbuf_r+0x4e>
3401c6c4:	4621      	mov	r1, r4
3401c6c6:	4628      	mov	r0, r5
3401c6c8:	f7ff fe18 	bl	3401c2fc <_fflush_r>
3401c6cc:	2800      	cmp	r0, #0
3401c6ce:	d1ed      	bne.n	3401c6ac <__swbuf_r+0x2a>
3401c6d0:	68a3      	ldr	r3, [r4, #8]
3401c6d2:	3b01      	subs	r3, #1
3401c6d4:	60a3      	str	r3, [r4, #8]
3401c6d6:	6823      	ldr	r3, [r4, #0]
3401c6d8:	1c5a      	adds	r2, r3, #1
3401c6da:	6022      	str	r2, [r4, #0]
3401c6dc:	701e      	strb	r6, [r3, #0]
3401c6de:	1c43      	adds	r3, r0, #1
3401c6e0:	6962      	ldr	r2, [r4, #20]
3401c6e2:	429a      	cmp	r2, r3
3401c6e4:	d004      	beq.n	3401c6f0 <__swbuf_r+0x6e>
3401c6e6:	89a3      	ldrh	r3, [r4, #12]
3401c6e8:	07db      	lsls	r3, r3, #31
3401c6ea:	d5e1      	bpl.n	3401c6b0 <__swbuf_r+0x2e>
3401c6ec:	2e0a      	cmp	r6, #10
3401c6ee:	d1df      	bne.n	3401c6b0 <__swbuf_r+0x2e>
3401c6f0:	4621      	mov	r1, r4
3401c6f2:	4628      	mov	r0, r5
3401c6f4:	f7ff fe02 	bl	3401c2fc <_fflush_r>
3401c6f8:	2800      	cmp	r0, #0
3401c6fa:	d0d9      	beq.n	3401c6b0 <__swbuf_r+0x2e>
3401c6fc:	e7d6      	b.n	3401c6ac <__swbuf_r+0x2a>
	...

3401c700 <__swsetup_r>:
3401c700:	b538      	push	{r3, r4, r5, lr}
3401c702:	4b29      	ldr	r3, [pc, #164]	@ (3401c7a8 <__swsetup_r+0xa8>)
3401c704:	4605      	mov	r5, r0
3401c706:	460c      	mov	r4, r1
3401c708:	6818      	ldr	r0, [r3, #0]
3401c70a:	b118      	cbz	r0, 3401c714 <__swsetup_r+0x14>
3401c70c:	6a03      	ldr	r3, [r0, #32]
3401c70e:	b90b      	cbnz	r3, 3401c714 <__swsetup_r+0x14>
3401c710:	f7ff febc 	bl	3401c48c <__sinit>
3401c714:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3401c718:	0719      	lsls	r1, r3, #28
3401c71a:	d422      	bmi.n	3401c762 <__swsetup_r+0x62>
3401c71c:	06da      	lsls	r2, r3, #27
3401c71e:	d407      	bmi.n	3401c730 <__swsetup_r+0x30>
3401c720:	2209      	movs	r2, #9
3401c722:	602a      	str	r2, [r5, #0]
3401c724:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3401c728:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
3401c72c:	81a3      	strh	r3, [r4, #12]
3401c72e:	e033      	b.n	3401c798 <__swsetup_r+0x98>
3401c730:	0758      	lsls	r0, r3, #29
3401c732:	d512      	bpl.n	3401c75a <__swsetup_r+0x5a>
3401c734:	6b61      	ldr	r1, [r4, #52]	@ 0x34
3401c736:	b141      	cbz	r1, 3401c74a <__swsetup_r+0x4a>
3401c738:	f104 0344 	add.w	r3, r4, #68	@ 0x44
3401c73c:	4299      	cmp	r1, r3
3401c73e:	d002      	beq.n	3401c746 <__swsetup_r+0x46>
3401c740:	4628      	mov	r0, r5
3401c742:	f001 f8c3 	bl	3401d8cc <_free_r>
3401c746:	2300      	movs	r3, #0
3401c748:	6363      	str	r3, [r4, #52]	@ 0x34
3401c74a:	89a3      	ldrh	r3, [r4, #12]
3401c74c:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
3401c750:	81a3      	strh	r3, [r4, #12]
3401c752:	2300      	movs	r3, #0
3401c754:	6063      	str	r3, [r4, #4]
3401c756:	6923      	ldr	r3, [r4, #16]
3401c758:	6023      	str	r3, [r4, #0]
3401c75a:	89a3      	ldrh	r3, [r4, #12]
3401c75c:	f043 0308 	orr.w	r3, r3, #8
3401c760:	81a3      	strh	r3, [r4, #12]
3401c762:	6923      	ldr	r3, [r4, #16]
3401c764:	b94b      	cbnz	r3, 3401c77a <__swsetup_r+0x7a>
3401c766:	89a3      	ldrh	r3, [r4, #12]
3401c768:	f403 7320 	and.w	r3, r3, #640	@ 0x280
3401c76c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3401c770:	d003      	beq.n	3401c77a <__swsetup_r+0x7a>
3401c772:	4621      	mov	r1, r4
3401c774:	4628      	mov	r0, r5
3401c776:	f001 fddc 	bl	3401e332 <__smakebuf_r>
3401c77a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3401c77e:	f013 0201 	ands.w	r2, r3, #1
3401c782:	d00a      	beq.n	3401c79a <__swsetup_r+0x9a>
3401c784:	2200      	movs	r2, #0
3401c786:	60a2      	str	r2, [r4, #8]
3401c788:	6962      	ldr	r2, [r4, #20]
3401c78a:	4252      	negs	r2, r2
3401c78c:	61a2      	str	r2, [r4, #24]
3401c78e:	6922      	ldr	r2, [r4, #16]
3401c790:	b942      	cbnz	r2, 3401c7a4 <__swsetup_r+0xa4>
3401c792:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
3401c796:	d1c5      	bne.n	3401c724 <__swsetup_r+0x24>
3401c798:	bd38      	pop	{r3, r4, r5, pc}
3401c79a:	0799      	lsls	r1, r3, #30
3401c79c:	bf58      	it	pl
3401c79e:	6962      	ldrpl	r2, [r4, #20]
3401c7a0:	60a2      	str	r2, [r4, #8]
3401c7a2:	e7f4      	b.n	3401c78e <__swsetup_r+0x8e>
3401c7a4:	2000      	movs	r0, #0
3401c7a6:	e7f7      	b.n	3401c798 <__swsetup_r+0x98>
3401c7a8:	34020c6c 	.word	0x34020c6c

3401c7ac <memset>:
3401c7ac:	4402      	add	r2, r0
3401c7ae:	4603      	mov	r3, r0
3401c7b0:	4293      	cmp	r3, r2
3401c7b2:	d100      	bne.n	3401c7b6 <memset+0xa>
3401c7b4:	4770      	bx	lr
3401c7b6:	f803 1b01 	strb.w	r1, [r3], #1
3401c7ba:	e7f9      	b.n	3401c7b0 <memset+0x4>

3401c7bc <_strerror_r>:
3401c7bc:	b510      	push	{r4, lr}
3401c7be:	4604      	mov	r4, r0
3401c7c0:	4608      	mov	r0, r1
3401c7c2:	4611      	mov	r1, r2
3401c7c4:	461a      	mov	r2, r3
3401c7c6:	288e      	cmp	r0, #142	@ 0x8e
3401c7c8:	f200 8130 	bhi.w	3401ca2c <_strerror_r+0x270>
3401c7cc:	e8df f010 	tbh	[pc, r0, lsl #1]
3401c7d0:	0138008f 	.word	0x0138008f
3401c7d4:	00940092 	.word	0x00940092
3401c7d8:	00980096 	.word	0x00980096
3401c7dc:	009c009a 	.word	0x009c009a
3401c7e0:	00a2009e 	.word	0x00a2009e
3401c7e4:	00a800a4 	.word	0x00a800a4
3401c7e8:	00ac00aa 	.word	0x00ac00aa
3401c7ec:	012e00ae 	.word	0x012e00ae
3401c7f0:	00b200b0 	.word	0x00b200b0
3401c7f4:	00b600b4 	.word	0x00b600b4
3401c7f8:	00be00b8 	.word	0x00be00b8
3401c7fc:	00c600c0 	.word	0x00c600c0
3401c800:	00ca00c8 	.word	0x00ca00c8
3401c804:	00ce00cc 	.word	0x00ce00cc
3401c808:	00d600d2 	.word	0x00d600d2
3401c80c:	00da00d8 	.word	0x00da00d8
3401c810:	00de00dc 	.word	0x00de00dc
3401c814:	00e200e0 	.word	0x00e200e0
3401c818:	012e00e4 	.word	0x012e00e4
3401c81c:	012e012e 	.word	0x012e012e
3401c820:	012e012e 	.word	0x012e012e
3401c824:	012e012e 	.word	0x012e012e
3401c828:	00e8012e 	.word	0x00e8012e
3401c82c:	012e00ec 	.word	0x012e00ec
3401c830:	012e012e 	.word	0x012e012e
3401c834:	012e012e 	.word	0x012e012e
3401c838:	012e012e 	.word	0x012e012e
3401c83c:	012e012e 	.word	0x012e012e
3401c840:	012e012e 	.word	0x012e012e
3401c844:	012e012e 	.word	0x012e012e
3401c848:	010800ee 	.word	0x010800ee
3401c84c:	00f200f0 	.word	0x00f200f0
3401c850:	012e012e 	.word	0x012e012e
3401c854:	00f4012e 	.word	0x00f4012e
3401c858:	012e012e 	.word	0x012e012e
3401c85c:	00f6012e 	.word	0x00f6012e
3401c860:	012e012e 	.word	0x012e012e
3401c864:	012e00fa 	.word	0x012e00fa
3401c868:	00fc012e 	.word	0x00fc012e
3401c86c:	012e012e 	.word	0x012e012e
3401c870:	012e012e 	.word	0x012e012e
3401c874:	012e012e 	.word	0x012e012e
3401c878:	012e012e 	.word	0x012e012e
3401c87c:	012e012e 	.word	0x012e012e
3401c880:	012e00fe 	.word	0x012e00fe
3401c884:	01020100 	.word	0x01020100
3401c888:	012e0104 	.word	0x012e0104
3401c88c:	0126012e 	.word	0x0126012e
3401c890:	012e012e 	.word	0x012e012e
3401c894:	012e012e 	.word	0x012e012e
3401c898:	012e012e 	.word	0x012e012e
3401c89c:	012e012e 	.word	0x012e012e
3401c8a0:	01060114 	.word	0x01060114
3401c8a4:	010c010a 	.word	0x010c010a
3401c8a8:	0110010e 	.word	0x0110010e
3401c8ac:	0112012e 	.word	0x0112012e
3401c8b0:	011a0116 	.word	0x011a0116
3401c8b4:	00c200ea 	.word	0x00c200ea
3401c8b8:	00ba012c 	.word	0x00ba012c
3401c8bc:	00bc00d0 	.word	0x00bc00d0
3401c8c0:	00a600a0 	.word	0x00a600a0
3401c8c4:	00f8012a 	.word	0x00f8012a
3401c8c8:	0118012e 	.word	0x0118012e
3401c8cc:	011e00c4 	.word	0x011e00c4
3401c8d0:	012e011c 	.word	0x012e011c
3401c8d4:	012e012e 	.word	0x012e012e
3401c8d8:	012e012e 	.word	0x012e012e
3401c8dc:	012e00d4 	.word	0x012e00d4
3401c8e0:	012e012e 	.word	0x012e012e
3401c8e4:	012800e6 	.word	0x012800e6
3401c8e8:	01220120 	.word	0x01220120
3401c8ec:	0124      	.short	0x0124
3401c8ee:	4b55      	ldr	r3, [pc, #340]	@ (3401ca44 <_strerror_r+0x288>)
3401c8f0:	4618      	mov	r0, r3
3401c8f2:	bd10      	pop	{r4, pc}
3401c8f4:	4b54      	ldr	r3, [pc, #336]	@ (3401ca48 <_strerror_r+0x28c>)
3401c8f6:	e7fb      	b.n	3401c8f0 <_strerror_r+0x134>
3401c8f8:	4b54      	ldr	r3, [pc, #336]	@ (3401ca4c <_strerror_r+0x290>)
3401c8fa:	e7f9      	b.n	3401c8f0 <_strerror_r+0x134>
3401c8fc:	4b54      	ldr	r3, [pc, #336]	@ (3401ca50 <_strerror_r+0x294>)
3401c8fe:	e7f7      	b.n	3401c8f0 <_strerror_r+0x134>
3401c900:	4b54      	ldr	r3, [pc, #336]	@ (3401ca54 <_strerror_r+0x298>)
3401c902:	e7f5      	b.n	3401c8f0 <_strerror_r+0x134>
3401c904:	4b54      	ldr	r3, [pc, #336]	@ (3401ca58 <_strerror_r+0x29c>)
3401c906:	e7f3      	b.n	3401c8f0 <_strerror_r+0x134>
3401c908:	4b54      	ldr	r3, [pc, #336]	@ (3401ca5c <_strerror_r+0x2a0>)
3401c90a:	e7f1      	b.n	3401c8f0 <_strerror_r+0x134>
3401c90c:	4b54      	ldr	r3, [pc, #336]	@ (3401ca60 <_strerror_r+0x2a4>)
3401c90e:	e7ef      	b.n	3401c8f0 <_strerror_r+0x134>
3401c910:	4b54      	ldr	r3, [pc, #336]	@ (3401ca64 <_strerror_r+0x2a8>)
3401c912:	e7ed      	b.n	3401c8f0 <_strerror_r+0x134>
3401c914:	4b54      	ldr	r3, [pc, #336]	@ (3401ca68 <_strerror_r+0x2ac>)
3401c916:	e7eb      	b.n	3401c8f0 <_strerror_r+0x134>
3401c918:	4b54      	ldr	r3, [pc, #336]	@ (3401ca6c <_strerror_r+0x2b0>)
3401c91a:	e7e9      	b.n	3401c8f0 <_strerror_r+0x134>
3401c91c:	4b54      	ldr	r3, [pc, #336]	@ (3401ca70 <_strerror_r+0x2b4>)
3401c91e:	e7e7      	b.n	3401c8f0 <_strerror_r+0x134>
3401c920:	4b54      	ldr	r3, [pc, #336]	@ (3401ca74 <_strerror_r+0x2b8>)
3401c922:	e7e5      	b.n	3401c8f0 <_strerror_r+0x134>
3401c924:	4b54      	ldr	r3, [pc, #336]	@ (3401ca78 <_strerror_r+0x2bc>)
3401c926:	e7e3      	b.n	3401c8f0 <_strerror_r+0x134>
3401c928:	4b54      	ldr	r3, [pc, #336]	@ (3401ca7c <_strerror_r+0x2c0>)
3401c92a:	e7e1      	b.n	3401c8f0 <_strerror_r+0x134>
3401c92c:	4b54      	ldr	r3, [pc, #336]	@ (3401ca80 <_strerror_r+0x2c4>)
3401c92e:	e7df      	b.n	3401c8f0 <_strerror_r+0x134>
3401c930:	4b54      	ldr	r3, [pc, #336]	@ (3401ca84 <_strerror_r+0x2c8>)
3401c932:	e7dd      	b.n	3401c8f0 <_strerror_r+0x134>
3401c934:	4b54      	ldr	r3, [pc, #336]	@ (3401ca88 <_strerror_r+0x2cc>)
3401c936:	e7db      	b.n	3401c8f0 <_strerror_r+0x134>
3401c938:	4b54      	ldr	r3, [pc, #336]	@ (3401ca8c <_strerror_r+0x2d0>)
3401c93a:	e7d9      	b.n	3401c8f0 <_strerror_r+0x134>
3401c93c:	4b54      	ldr	r3, [pc, #336]	@ (3401ca90 <_strerror_r+0x2d4>)
3401c93e:	e7d7      	b.n	3401c8f0 <_strerror_r+0x134>
3401c940:	4b54      	ldr	r3, [pc, #336]	@ (3401ca94 <_strerror_r+0x2d8>)
3401c942:	e7d5      	b.n	3401c8f0 <_strerror_r+0x134>
3401c944:	4b54      	ldr	r3, [pc, #336]	@ (3401ca98 <_strerror_r+0x2dc>)
3401c946:	e7d3      	b.n	3401c8f0 <_strerror_r+0x134>
3401c948:	4b54      	ldr	r3, [pc, #336]	@ (3401ca9c <_strerror_r+0x2e0>)
3401c94a:	e7d1      	b.n	3401c8f0 <_strerror_r+0x134>
3401c94c:	4b54      	ldr	r3, [pc, #336]	@ (3401caa0 <_strerror_r+0x2e4>)
3401c94e:	e7cf      	b.n	3401c8f0 <_strerror_r+0x134>
3401c950:	4b54      	ldr	r3, [pc, #336]	@ (3401caa4 <_strerror_r+0x2e8>)
3401c952:	e7cd      	b.n	3401c8f0 <_strerror_r+0x134>
3401c954:	4b54      	ldr	r3, [pc, #336]	@ (3401caa8 <_strerror_r+0x2ec>)
3401c956:	e7cb      	b.n	3401c8f0 <_strerror_r+0x134>
3401c958:	4b54      	ldr	r3, [pc, #336]	@ (3401caac <_strerror_r+0x2f0>)
3401c95a:	e7c9      	b.n	3401c8f0 <_strerror_r+0x134>
3401c95c:	4b54      	ldr	r3, [pc, #336]	@ (3401cab0 <_strerror_r+0x2f4>)
3401c95e:	e7c7      	b.n	3401c8f0 <_strerror_r+0x134>
3401c960:	4b54      	ldr	r3, [pc, #336]	@ (3401cab4 <_strerror_r+0x2f8>)
3401c962:	e7c5      	b.n	3401c8f0 <_strerror_r+0x134>
3401c964:	4b54      	ldr	r3, [pc, #336]	@ (3401cab8 <_strerror_r+0x2fc>)
3401c966:	e7c3      	b.n	3401c8f0 <_strerror_r+0x134>
3401c968:	4b54      	ldr	r3, [pc, #336]	@ (3401cabc <_strerror_r+0x300>)
3401c96a:	e7c1      	b.n	3401c8f0 <_strerror_r+0x134>
3401c96c:	4b54      	ldr	r3, [pc, #336]	@ (3401cac0 <_strerror_r+0x304>)
3401c96e:	e7bf      	b.n	3401c8f0 <_strerror_r+0x134>
3401c970:	4b54      	ldr	r3, [pc, #336]	@ (3401cac4 <_strerror_r+0x308>)
3401c972:	e7bd      	b.n	3401c8f0 <_strerror_r+0x134>
3401c974:	4b54      	ldr	r3, [pc, #336]	@ (3401cac8 <_strerror_r+0x30c>)
3401c976:	e7bb      	b.n	3401c8f0 <_strerror_r+0x134>
3401c978:	4b54      	ldr	r3, [pc, #336]	@ (3401cacc <_strerror_r+0x310>)
3401c97a:	e7b9      	b.n	3401c8f0 <_strerror_r+0x134>
3401c97c:	4b54      	ldr	r3, [pc, #336]	@ (3401cad0 <_strerror_r+0x314>)
3401c97e:	e7b7      	b.n	3401c8f0 <_strerror_r+0x134>
3401c980:	4b54      	ldr	r3, [pc, #336]	@ (3401cad4 <_strerror_r+0x318>)
3401c982:	e7b5      	b.n	3401c8f0 <_strerror_r+0x134>
3401c984:	4b54      	ldr	r3, [pc, #336]	@ (3401cad8 <_strerror_r+0x31c>)
3401c986:	e7b3      	b.n	3401c8f0 <_strerror_r+0x134>
3401c988:	4b54      	ldr	r3, [pc, #336]	@ (3401cadc <_strerror_r+0x320>)
3401c98a:	e7b1      	b.n	3401c8f0 <_strerror_r+0x134>
3401c98c:	4b54      	ldr	r3, [pc, #336]	@ (3401cae0 <_strerror_r+0x324>)
3401c98e:	e7af      	b.n	3401c8f0 <_strerror_r+0x134>
3401c990:	4b54      	ldr	r3, [pc, #336]	@ (3401cae4 <_strerror_r+0x328>)
3401c992:	e7ad      	b.n	3401c8f0 <_strerror_r+0x134>
3401c994:	4b54      	ldr	r3, [pc, #336]	@ (3401cae8 <_strerror_r+0x32c>)
3401c996:	e7ab      	b.n	3401c8f0 <_strerror_r+0x134>
3401c998:	4b54      	ldr	r3, [pc, #336]	@ (3401caec <_strerror_r+0x330>)
3401c99a:	e7a9      	b.n	3401c8f0 <_strerror_r+0x134>
3401c99c:	4b54      	ldr	r3, [pc, #336]	@ (3401caf0 <_strerror_r+0x334>)
3401c99e:	e7a7      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9a0:	4b54      	ldr	r3, [pc, #336]	@ (3401caf4 <_strerror_r+0x338>)
3401c9a2:	e7a5      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9a4:	4b54      	ldr	r3, [pc, #336]	@ (3401caf8 <_strerror_r+0x33c>)
3401c9a6:	e7a3      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9a8:	4b54      	ldr	r3, [pc, #336]	@ (3401cafc <_strerror_r+0x340>)
3401c9aa:	e7a1      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9ac:	4b54      	ldr	r3, [pc, #336]	@ (3401cb00 <_strerror_r+0x344>)
3401c9ae:	e79f      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9b0:	4b54      	ldr	r3, [pc, #336]	@ (3401cb04 <_strerror_r+0x348>)
3401c9b2:	e79d      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9b4:	4b54      	ldr	r3, [pc, #336]	@ (3401cb08 <_strerror_r+0x34c>)
3401c9b6:	e79b      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9b8:	4b54      	ldr	r3, [pc, #336]	@ (3401cb0c <_strerror_r+0x350>)
3401c9ba:	e799      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9bc:	4b54      	ldr	r3, [pc, #336]	@ (3401cb10 <_strerror_r+0x354>)
3401c9be:	e797      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9c0:	4b54      	ldr	r3, [pc, #336]	@ (3401cb14 <_strerror_r+0x358>)
3401c9c2:	e795      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9c4:	4b54      	ldr	r3, [pc, #336]	@ (3401cb18 <_strerror_r+0x35c>)
3401c9c6:	e793      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9c8:	4b54      	ldr	r3, [pc, #336]	@ (3401cb1c <_strerror_r+0x360>)
3401c9ca:	e791      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9cc:	4b54      	ldr	r3, [pc, #336]	@ (3401cb20 <_strerror_r+0x364>)
3401c9ce:	e78f      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9d0:	4b54      	ldr	r3, [pc, #336]	@ (3401cb24 <_strerror_r+0x368>)
3401c9d2:	e78d      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9d4:	4b54      	ldr	r3, [pc, #336]	@ (3401cb28 <_strerror_r+0x36c>)
3401c9d6:	e78b      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9d8:	4b54      	ldr	r3, [pc, #336]	@ (3401cb2c <_strerror_r+0x370>)
3401c9da:	e789      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9dc:	4b54      	ldr	r3, [pc, #336]	@ (3401cb30 <_strerror_r+0x374>)
3401c9de:	e787      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9e0:	4b54      	ldr	r3, [pc, #336]	@ (3401cb34 <_strerror_r+0x378>)
3401c9e2:	e785      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9e4:	4b54      	ldr	r3, [pc, #336]	@ (3401cb38 <_strerror_r+0x37c>)
3401c9e6:	e783      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9e8:	4b54      	ldr	r3, [pc, #336]	@ (3401cb3c <_strerror_r+0x380>)
3401c9ea:	e781      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9ec:	4b54      	ldr	r3, [pc, #336]	@ (3401cb40 <_strerror_r+0x384>)
3401c9ee:	e77f      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9f0:	4b54      	ldr	r3, [pc, #336]	@ (3401cb44 <_strerror_r+0x388>)
3401c9f2:	e77d      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9f4:	4b54      	ldr	r3, [pc, #336]	@ (3401cb48 <_strerror_r+0x38c>)
3401c9f6:	e77b      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9f8:	4b54      	ldr	r3, [pc, #336]	@ (3401cb4c <_strerror_r+0x390>)
3401c9fa:	e779      	b.n	3401c8f0 <_strerror_r+0x134>
3401c9fc:	4b54      	ldr	r3, [pc, #336]	@ (3401cb50 <_strerror_r+0x394>)
3401c9fe:	e777      	b.n	3401c8f0 <_strerror_r+0x134>
3401ca00:	4b54      	ldr	r3, [pc, #336]	@ (3401cb54 <_strerror_r+0x398>)
3401ca02:	e775      	b.n	3401c8f0 <_strerror_r+0x134>
3401ca04:	4b54      	ldr	r3, [pc, #336]	@ (3401cb58 <_strerror_r+0x39c>)
3401ca06:	e773      	b.n	3401c8f0 <_strerror_r+0x134>
3401ca08:	4b54      	ldr	r3, [pc, #336]	@ (3401cb5c <_strerror_r+0x3a0>)
3401ca0a:	e771      	b.n	3401c8f0 <_strerror_r+0x134>
3401ca0c:	4b54      	ldr	r3, [pc, #336]	@ (3401cb60 <_strerror_r+0x3a4>)
3401ca0e:	e76f      	b.n	3401c8f0 <_strerror_r+0x134>
3401ca10:	4b54      	ldr	r3, [pc, #336]	@ (3401cb64 <_strerror_r+0x3a8>)
3401ca12:	e76d      	b.n	3401c8f0 <_strerror_r+0x134>
3401ca14:	4b54      	ldr	r3, [pc, #336]	@ (3401cb68 <_strerror_r+0x3ac>)
3401ca16:	e76b      	b.n	3401c8f0 <_strerror_r+0x134>
3401ca18:	4b54      	ldr	r3, [pc, #336]	@ (3401cb6c <_strerror_r+0x3b0>)
3401ca1a:	e769      	b.n	3401c8f0 <_strerror_r+0x134>
3401ca1c:	4b54      	ldr	r3, [pc, #336]	@ (3401cb70 <_strerror_r+0x3b4>)
3401ca1e:	e767      	b.n	3401c8f0 <_strerror_r+0x134>
3401ca20:	4b54      	ldr	r3, [pc, #336]	@ (3401cb74 <_strerror_r+0x3b8>)
3401ca22:	e765      	b.n	3401c8f0 <_strerror_r+0x134>
3401ca24:	4b54      	ldr	r3, [pc, #336]	@ (3401cb78 <_strerror_r+0x3bc>)
3401ca26:	e763      	b.n	3401c8f0 <_strerror_r+0x134>
3401ca28:	4b54      	ldr	r3, [pc, #336]	@ (3401cb7c <_strerror_r+0x3c0>)
3401ca2a:	e761      	b.n	3401c8f0 <_strerror_r+0x134>
3401ca2c:	2a00      	cmp	r2, #0
3401ca2e:	bf08      	it	eq
3401ca30:	4622      	moveq	r2, r4
3401ca32:	f000 f8b3 	bl	3401cb9c <_user_strerror>
3401ca36:	4b52      	ldr	r3, [pc, #328]	@ (3401cb80 <_strerror_r+0x3c4>)
3401ca38:	2800      	cmp	r0, #0
3401ca3a:	bf18      	it	ne
3401ca3c:	4603      	movne	r3, r0
3401ca3e:	e757      	b.n	3401c8f0 <_strerror_r+0x134>
3401ca40:	4b50      	ldr	r3, [pc, #320]	@ (3401cb84 <_strerror_r+0x3c8>)
3401ca42:	e755      	b.n	3401c8f0 <_strerror_r+0x134>
3401ca44:	3402026e 	.word	0x3402026e
3401ca48:	34020280 	.word	0x34020280
3401ca4c:	3402029a 	.word	0x3402029a
3401ca50:	340202aa 	.word	0x340202aa
3401ca54:	340202c2 	.word	0x340202c2
3401ca58:	340202cc 	.word	0x340202cc
3401ca5c:	340202e6 	.word	0x340202e6
3401ca60:	340202f8 	.word	0x340202f8
3401ca64:	3402030a 	.word	0x3402030a
3401ca68:	34020323 	.word	0x34020323
3401ca6c:	34020333 	.word	0x34020333
3401ca70:	3402033f 	.word	0x3402033f
3401ca74:	3402035c 	.word	0x3402035c
3401ca78:	3402036e 	.word	0x3402036e
3401ca7c:	3402037f 	.word	0x3402037f
3401ca80:	34020391 	.word	0x34020391
3401ca84:	3402039d 	.word	0x3402039d
3401ca88:	340203b5 	.word	0x340203b5
3401ca8c:	340203c1 	.word	0x340203c1
3401ca90:	340203d3 	.word	0x340203d3
3401ca94:	340203e2 	.word	0x340203e2
3401ca98:	340203f2 	.word	0x340203f2
3401ca9c:	340203ff 	.word	0x340203ff
3401caa0:	3402041e 	.word	0x3402041e
3401caa4:	3402042d 	.word	0x3402042d
3401caa8:	3402043e 	.word	0x3402043e
3401caac:	34020462 	.word	0x34020462
3401cab0:	34020480 	.word	0x34020480
3401cab4:	3402049e 	.word	0x3402049e
3401cab8:	340204be 	.word	0x340204be
3401cabc:	340204d5 	.word	0x340204d5
3401cac0:	340204e4 	.word	0x340204e4
3401cac4:	340204f3 	.word	0x340204f3
3401cac8:	34020507 	.word	0x34020507
3401cacc:	3402051f 	.word	0x3402051f
3401cad0:	3402052d 	.word	0x3402052d
3401cad4:	3402053a 	.word	0x3402053a
3401cad8:	34020550 	.word	0x34020550
3401cadc:	3402055f 	.word	0x3402055f
3401cae0:	3402056b 	.word	0x3402056b
3401cae4:	3402059a 	.word	0x3402059a
3401cae8:	340205ab 	.word	0x340205ab
3401caec:	340205c6 	.word	0x340205c6
3401caf0:	340205d9 	.word	0x340205d9
3401caf4:	340205ef 	.word	0x340205ef
3401caf8:	340205f8 	.word	0x340205f8
3401cafc:	3402060f 	.word	0x3402060f
3401cb00:	34020617 	.word	0x34020617
3401cb04:	34020624 	.word	0x34020624
3401cb08:	34020639 	.word	0x34020639
3401cb0c:	3402064d 	.word	0x3402064d
3401cb10:	34020665 	.word	0x34020665
3401cb14:	34020674 	.word	0x34020674
3401cb18:	34020685 	.word	0x34020685
3401cb1c:	34020698 	.word	0x34020698
3401cb20:	340206a4 	.word	0x340206a4
3401cb24:	340206bd 	.word	0x340206bd
3401cb28:	340206d1 	.word	0x340206d1
3401cb2c:	340206ec 	.word	0x340206ec
3401cb30:	34020704 	.word	0x34020704
3401cb34:	3402071e 	.word	0x3402071e
3401cb38:	34020726 	.word	0x34020726
3401cb3c:	34020756 	.word	0x34020756
3401cb40:	34020775 	.word	0x34020775
3401cb44:	34020794 	.word	0x34020794
3401cb48:	340207ab 	.word	0x340207ab
3401cb4c:	340207be 	.word	0x340207be
3401cb50:	340207d7 	.word	0x340207d7
3401cb54:	340207ee 	.word	0x340207ee
3401cb58:	34020804 	.word	0x34020804
3401cb5c:	34020825 	.word	0x34020825
3401cb60:	3402083d 	.word	0x3402083d
3401cb64:	34020859 	.word	0x34020859
3401cb68:	3402086c 	.word	0x3402086c
3401cb6c:	34020882 	.word	0x34020882
3401cb70:	34020896 	.word	0x34020896
3401cb74:	340208b8 	.word	0x340208b8
3401cb78:	340208de 	.word	0x340208de
3401cb7c:	340208ef 	.word	0x340208ef
3401cb80:	34020239 	.word	0x34020239
3401cb84:	34020276 	.word	0x34020276

3401cb88 <strerror>:
3401cb88:	4601      	mov	r1, r0
3401cb8a:	2300      	movs	r3, #0
3401cb8c:	4802      	ldr	r0, [pc, #8]	@ (3401cb98 <strerror+0x10>)
3401cb8e:	461a      	mov	r2, r3
3401cb90:	6800      	ldr	r0, [r0, #0]
3401cb92:	f7ff be13 	b.w	3401c7bc <_strerror_r>
3401cb96:	bf00      	nop
3401cb98:	34020c6c 	.word	0x34020c6c

3401cb9c <_user_strerror>:
3401cb9c:	2000      	movs	r0, #0
3401cb9e:	4770      	bx	lr

3401cba0 <_localeconv_r>:
3401cba0:	4800      	ldr	r0, [pc, #0]	@ (3401cba4 <_localeconv_r+0x4>)
3401cba2:	4770      	bx	lr
3401cba4:	34020dac 	.word	0x34020dac

3401cba8 <_close_r>:
3401cba8:	b538      	push	{r3, r4, r5, lr}
3401cbaa:	2300      	movs	r3, #0
3401cbac:	4d05      	ldr	r5, [pc, #20]	@ (3401cbc4 <_close_r+0x1c>)
3401cbae:	4604      	mov	r4, r0
3401cbb0:	4608      	mov	r0, r1
3401cbb2:	602b      	str	r3, [r5, #0]
3401cbb4:	f7e5 fb20 	bl	340021f8 <_close>
3401cbb8:	1c43      	adds	r3, r0, #1
3401cbba:	d102      	bne.n	3401cbc2 <_close_r+0x1a>
3401cbbc:	682b      	ldr	r3, [r5, #0]
3401cbbe:	b103      	cbz	r3, 3401cbc2 <_close_r+0x1a>
3401cbc0:	6023      	str	r3, [r4, #0]
3401cbc2:	bd38      	pop	{r3, r4, r5, pc}
3401cbc4:	340214f4 	.word	0x340214f4

3401cbc8 <_lseek_r>:
3401cbc8:	b538      	push	{r3, r4, r5, lr}
3401cbca:	4604      	mov	r4, r0
3401cbcc:	4d06      	ldr	r5, [pc, #24]	@ (3401cbe8 <_lseek_r+0x20>)
3401cbce:	4608      	mov	r0, r1
3401cbd0:	4611      	mov	r1, r2
3401cbd2:	2200      	movs	r2, #0
3401cbd4:	602a      	str	r2, [r5, #0]
3401cbd6:	461a      	mov	r2, r3
3401cbd8:	f7e5 fb35 	bl	34002246 <_lseek>
3401cbdc:	1c43      	adds	r3, r0, #1
3401cbde:	d102      	bne.n	3401cbe6 <_lseek_r+0x1e>
3401cbe0:	682b      	ldr	r3, [r5, #0]
3401cbe2:	b103      	cbz	r3, 3401cbe6 <_lseek_r+0x1e>
3401cbe4:	6023      	str	r3, [r4, #0]
3401cbe6:	bd38      	pop	{r3, r4, r5, pc}
3401cbe8:	340214f4 	.word	0x340214f4

3401cbec <_read_r>:
3401cbec:	b538      	push	{r3, r4, r5, lr}
3401cbee:	4604      	mov	r4, r0
3401cbf0:	4d06      	ldr	r5, [pc, #24]	@ (3401cc0c <_read_r+0x20>)
3401cbf2:	4608      	mov	r0, r1
3401cbf4:	4611      	mov	r1, r2
3401cbf6:	2200      	movs	r2, #0
3401cbf8:	602a      	str	r2, [r5, #0]
3401cbfa:	461a      	mov	r2, r3
3401cbfc:	f7e5 fadf 	bl	340021be <_read>
3401cc00:	1c43      	adds	r3, r0, #1
3401cc02:	d102      	bne.n	3401cc0a <_read_r+0x1e>
3401cc04:	682b      	ldr	r3, [r5, #0]
3401cc06:	b103      	cbz	r3, 3401cc0a <_read_r+0x1e>
3401cc08:	6023      	str	r3, [r4, #0]
3401cc0a:	bd38      	pop	{r3, r4, r5, pc}
3401cc0c:	340214f4 	.word	0x340214f4

3401cc10 <_sbrk_r>:
3401cc10:	b538      	push	{r3, r4, r5, lr}
3401cc12:	2300      	movs	r3, #0
3401cc14:	4d05      	ldr	r5, [pc, #20]	@ (3401cc2c <_sbrk_r+0x1c>)
3401cc16:	4604      	mov	r4, r0
3401cc18:	4608      	mov	r0, r1
3401cc1a:	602b      	str	r3, [r5, #0]
3401cc1c:	f001 fc60 	bl	3401e4e0 <_sbrk>
3401cc20:	1c43      	adds	r3, r0, #1
3401cc22:	d102      	bne.n	3401cc2a <_sbrk_r+0x1a>
3401cc24:	682b      	ldr	r3, [r5, #0]
3401cc26:	b103      	cbz	r3, 3401cc2a <_sbrk_r+0x1a>
3401cc28:	6023      	str	r3, [r4, #0]
3401cc2a:	bd38      	pop	{r3, r4, r5, pc}
3401cc2c:	340214f4 	.word	0x340214f4

3401cc30 <_write_r>:
3401cc30:	b538      	push	{r3, r4, r5, lr}
3401cc32:	4604      	mov	r4, r0
3401cc34:	4d06      	ldr	r5, [pc, #24]	@ (3401cc50 <_write_r+0x20>)
3401cc36:	4608      	mov	r0, r1
3401cc38:	4611      	mov	r1, r2
3401cc3a:	2200      	movs	r2, #0
3401cc3c:	602a      	str	r2, [r5, #0]
3401cc3e:	461a      	mov	r2, r3
3401cc40:	f7e4 ffb0 	bl	34001ba4 <_write>
3401cc44:	1c43      	adds	r3, r0, #1
3401cc46:	d102      	bne.n	3401cc4e <_write_r+0x1e>
3401cc48:	682b      	ldr	r3, [r5, #0]
3401cc4a:	b103      	cbz	r3, 3401cc4e <_write_r+0x1e>
3401cc4c:	6023      	str	r3, [r4, #0]
3401cc4e:	bd38      	pop	{r3, r4, r5, pc}
3401cc50:	340214f4 	.word	0x340214f4

3401cc54 <__errno>:
3401cc54:	4b01      	ldr	r3, [pc, #4]	@ (3401cc5c <__errno+0x8>)
3401cc56:	6818      	ldr	r0, [r3, #0]
3401cc58:	4770      	bx	lr
3401cc5a:	bf00      	nop
3401cc5c:	34020c6c 	.word	0x34020c6c

3401cc60 <__libc_init_array>:
3401cc60:	b570      	push	{r4, r5, r6, lr}
3401cc62:	4d0d      	ldr	r5, [pc, #52]	@ (3401cc98 <__libc_init_array+0x38>)
3401cc64:	2600      	movs	r6, #0
3401cc66:	4c0d      	ldr	r4, [pc, #52]	@ (3401cc9c <__libc_init_array+0x3c>)
3401cc68:	1b64      	subs	r4, r4, r5
3401cc6a:	10a4      	asrs	r4, r4, #2
3401cc6c:	42a6      	cmp	r6, r4
3401cc6e:	d109      	bne.n	3401cc84 <__libc_init_array+0x24>
3401cc70:	4d0b      	ldr	r5, [pc, #44]	@ (3401cca0 <__libc_init_array+0x40>)
3401cc72:	2600      	movs	r6, #0
3401cc74:	4c0b      	ldr	r4, [pc, #44]	@ (3401cca4 <__libc_init_array+0x44>)
3401cc76:	f001 fc41 	bl	3401e4fc <_init>
3401cc7a:	1b64      	subs	r4, r4, r5
3401cc7c:	10a4      	asrs	r4, r4, #2
3401cc7e:	42a6      	cmp	r6, r4
3401cc80:	d105      	bne.n	3401cc8e <__libc_init_array+0x2e>
3401cc82:	bd70      	pop	{r4, r5, r6, pc}
3401cc84:	f855 3b04 	ldr.w	r3, [r5], #4
3401cc88:	3601      	adds	r6, #1
3401cc8a:	4798      	blx	r3
3401cc8c:	e7ee      	b.n	3401cc6c <__libc_init_array+0xc>
3401cc8e:	f855 3b04 	ldr.w	r3, [r5], #4
3401cc92:	3601      	adds	r6, #1
3401cc94:	4798      	blx	r3
3401cc96:	e7f2      	b.n	3401cc7e <__libc_init_array+0x1e>
3401cc98:	34020c14 	.word	0x34020c14
3401cc9c:	34020c14 	.word	0x34020c14
3401cca0:	34020c14 	.word	0x34020c14
3401cca4:	34020c18 	.word	0x34020c18

3401cca8 <__retarget_lock_init_recursive>:
3401cca8:	4770      	bx	lr

3401ccaa <__retarget_lock_acquire_recursive>:
3401ccaa:	4770      	bx	lr

3401ccac <__retarget_lock_release_recursive>:
3401ccac:	4770      	bx	lr

3401ccae <memchr>:
3401ccae:	b2c9      	uxtb	r1, r1
3401ccb0:	4603      	mov	r3, r0
3401ccb2:	4402      	add	r2, r0
3401ccb4:	b510      	push	{r4, lr}
3401ccb6:	4293      	cmp	r3, r2
3401ccb8:	4618      	mov	r0, r3
3401ccba:	d101      	bne.n	3401ccc0 <memchr+0x12>
3401ccbc:	2000      	movs	r0, #0
3401ccbe:	e003      	b.n	3401ccc8 <memchr+0x1a>
3401ccc0:	7804      	ldrb	r4, [r0, #0]
3401ccc2:	3301      	adds	r3, #1
3401ccc4:	428c      	cmp	r4, r1
3401ccc6:	d1f6      	bne.n	3401ccb6 <memchr+0x8>
3401ccc8:	bd10      	pop	{r4, pc}

3401ccca <memcpy>:
3401ccca:	440a      	add	r2, r1
3401cccc:	1e43      	subs	r3, r0, #1
3401ccce:	4291      	cmp	r1, r2
3401ccd0:	d100      	bne.n	3401ccd4 <memcpy+0xa>
3401ccd2:	4770      	bx	lr
3401ccd4:	b510      	push	{r4, lr}
3401ccd6:	f811 4b01 	ldrb.w	r4, [r1], #1
3401ccda:	4291      	cmp	r1, r2
3401ccdc:	f803 4f01 	strb.w	r4, [r3, #1]!
3401cce0:	d1f9      	bne.n	3401ccd6 <memcpy+0xc>
3401cce2:	bd10      	pop	{r4, pc}

3401cce4 <abort>:
3401cce4:	2006      	movs	r0, #6
3401cce6:	b508      	push	{r3, lr}
3401cce8:	f001 fb88 	bl	3401e3fc <raise>
3401ccec:	2001      	movs	r0, #1
3401ccee:	f7e5 fa5b 	bl	340021a8 <_exit>

3401ccf2 <quorem>:
3401ccf2:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401ccf6:	6903      	ldr	r3, [r0, #16]
3401ccf8:	4607      	mov	r7, r0
3401ccfa:	690c      	ldr	r4, [r1, #16]
3401ccfc:	42a3      	cmp	r3, r4
3401ccfe:	f2c0 8083 	blt.w	3401ce08 <quorem+0x116>
3401cd02:	3c01      	subs	r4, #1
3401cd04:	f100 0514 	add.w	r5, r0, #20
3401cd08:	f101 0814 	add.w	r8, r1, #20
3401cd0c:	00a3      	lsls	r3, r4, #2
3401cd0e:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
3401cd12:	eb08 0984 	add.w	r9, r8, r4, lsl #2
3401cd16:	9300      	str	r3, [sp, #0]
3401cd18:	eb05 0384 	add.w	r3, r5, r4, lsl #2
3401cd1c:	9301      	str	r3, [sp, #4]
3401cd1e:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
3401cd22:	3301      	adds	r3, #1
3401cd24:	429a      	cmp	r2, r3
3401cd26:	fbb2 f6f3 	udiv	r6, r2, r3
3401cd2a:	d331      	bcc.n	3401cd90 <quorem+0x9e>
3401cd2c:	f04f 0a00 	mov.w	sl, #0
3401cd30:	46c4      	mov	ip, r8
3401cd32:	46ae      	mov	lr, r5
3401cd34:	46d3      	mov	fp, sl
3401cd36:	f85c 3b04 	ldr.w	r3, [ip], #4
3401cd3a:	b298      	uxth	r0, r3
3401cd3c:	45e1      	cmp	r9, ip
3401cd3e:	ea4f 4313 	mov.w	r3, r3, lsr #16
3401cd42:	fb06 a000 	mla	r0, r6, r0, sl
3401cd46:	ea4f 4210 	mov.w	r2, r0, lsr #16
3401cd4a:	b280      	uxth	r0, r0
3401cd4c:	fb06 2303 	mla	r3, r6, r3, r2
3401cd50:	f8de 2000 	ldr.w	r2, [lr]
3401cd54:	b292      	uxth	r2, r2
3401cd56:	ea4f 4a13 	mov.w	sl, r3, lsr #16
3401cd5a:	eba2 0200 	sub.w	r2, r2, r0
3401cd5e:	b29b      	uxth	r3, r3
3401cd60:	f8de 0000 	ldr.w	r0, [lr]
3401cd64:	445a      	add	r2, fp
3401cd66:	ebc3 4322 	rsb	r3, r3, r2, asr #16
3401cd6a:	b292      	uxth	r2, r2
3401cd6c:	eb03 4310 	add.w	r3, r3, r0, lsr #16
3401cd70:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
3401cd74:	ea4f 4b23 	mov.w	fp, r3, asr #16
3401cd78:	f84e 2b04 	str.w	r2, [lr], #4
3401cd7c:	d2db      	bcs.n	3401cd36 <quorem+0x44>
3401cd7e:	9b00      	ldr	r3, [sp, #0]
3401cd80:	58eb      	ldr	r3, [r5, r3]
3401cd82:	b92b      	cbnz	r3, 3401cd90 <quorem+0x9e>
3401cd84:	9b01      	ldr	r3, [sp, #4]
3401cd86:	3b04      	subs	r3, #4
3401cd88:	429d      	cmp	r5, r3
3401cd8a:	461a      	mov	r2, r3
3401cd8c:	d330      	bcc.n	3401cdf0 <quorem+0xfe>
3401cd8e:	613c      	str	r4, [r7, #16]
3401cd90:	4638      	mov	r0, r7
3401cd92:	f001 f85b 	bl	3401de4c <__mcmp>
3401cd96:	2800      	cmp	r0, #0
3401cd98:	db26      	blt.n	3401cde8 <quorem+0xf6>
3401cd9a:	4629      	mov	r1, r5
3401cd9c:	2000      	movs	r0, #0
3401cd9e:	f858 2b04 	ldr.w	r2, [r8], #4
3401cda2:	f8d1 c000 	ldr.w	ip, [r1]
3401cda6:	fa1f fe82 	uxth.w	lr, r2
3401cdaa:	45c1      	cmp	r9, r8
3401cdac:	fa1f f38c 	uxth.w	r3, ip
3401cdb0:	ea4f 4212 	mov.w	r2, r2, lsr #16
3401cdb4:	eba3 030e 	sub.w	r3, r3, lr
3401cdb8:	4403      	add	r3, r0
3401cdba:	ebc2 4223 	rsb	r2, r2, r3, asr #16
3401cdbe:	b29b      	uxth	r3, r3
3401cdc0:	eb02 421c 	add.w	r2, r2, ip, lsr #16
3401cdc4:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
3401cdc8:	ea4f 4022 	mov.w	r0, r2, asr #16
3401cdcc:	f841 3b04 	str.w	r3, [r1], #4
3401cdd0:	d2e5      	bcs.n	3401cd9e <quorem+0xac>
3401cdd2:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
3401cdd6:	eb05 0384 	add.w	r3, r5, r4, lsl #2
3401cdda:	b922      	cbnz	r2, 3401cde6 <quorem+0xf4>
3401cddc:	3b04      	subs	r3, #4
3401cdde:	429d      	cmp	r5, r3
3401cde0:	461a      	mov	r2, r3
3401cde2:	d30b      	bcc.n	3401cdfc <quorem+0x10a>
3401cde4:	613c      	str	r4, [r7, #16]
3401cde6:	3601      	adds	r6, #1
3401cde8:	4630      	mov	r0, r6
3401cdea:	b003      	add	sp, #12
3401cdec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401cdf0:	6812      	ldr	r2, [r2, #0]
3401cdf2:	3b04      	subs	r3, #4
3401cdf4:	2a00      	cmp	r2, #0
3401cdf6:	d1ca      	bne.n	3401cd8e <quorem+0x9c>
3401cdf8:	3c01      	subs	r4, #1
3401cdfa:	e7c5      	b.n	3401cd88 <quorem+0x96>
3401cdfc:	6812      	ldr	r2, [r2, #0]
3401cdfe:	3b04      	subs	r3, #4
3401ce00:	2a00      	cmp	r2, #0
3401ce02:	d1ef      	bne.n	3401cde4 <quorem+0xf2>
3401ce04:	3c01      	subs	r4, #1
3401ce06:	e7ea      	b.n	3401cdde <quorem+0xec>
3401ce08:	2000      	movs	r0, #0
3401ce0a:	e7ee      	b.n	3401cdea <quorem+0xf8>
3401ce0c:	0000      	movs	r0, r0
	...

3401ce10 <_dtoa_r>:
3401ce10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401ce14:	69c7      	ldr	r7, [r0, #28]
3401ce16:	4681      	mov	r9, r0
3401ce18:	ed2d 8b02 	vpush	{d8}
3401ce1c:	b091      	sub	sp, #68	@ 0x44
3401ce1e:	ec55 4b10 	vmov	r4, r5, d0
3401ce22:	9e1c      	ldr	r6, [sp, #112]	@ 0x70
3401ce24:	9107      	str	r1, [sp, #28]
3401ce26:	9209      	str	r2, [sp, #36]	@ 0x24
3401ce28:	930d      	str	r3, [sp, #52]	@ 0x34
3401ce2a:	ed8d 0b02 	vstr	d0, [sp, #8]
3401ce2e:	b97f      	cbnz	r7, 3401ce50 <_dtoa_r+0x40>
3401ce30:	2010      	movs	r0, #16
3401ce32:	f7fe fce9 	bl	3401b808 <malloc>
3401ce36:	4602      	mov	r2, r0
3401ce38:	f8c9 001c 	str.w	r0, [r9, #28]
3401ce3c:	b920      	cbnz	r0, 3401ce48 <_dtoa_r+0x38>
3401ce3e:	4ba0      	ldr	r3, [pc, #640]	@ (3401d0c0 <_dtoa_r+0x2b0>)
3401ce40:	21ef      	movs	r1, #239	@ 0xef
3401ce42:	48a0      	ldr	r0, [pc, #640]	@ (3401d0c4 <_dtoa_r+0x2b4>)
3401ce44:	f7fe fcc2 	bl	3401b7cc <__assert_func>
3401ce48:	e9c0 7701 	strd	r7, r7, [r0, #4]
3401ce4c:	6007      	str	r7, [r0, #0]
3401ce4e:	60c7      	str	r7, [r0, #12]
3401ce50:	f8d9 301c 	ldr.w	r3, [r9, #28]
3401ce54:	6819      	ldr	r1, [r3, #0]
3401ce56:	b159      	cbz	r1, 3401ce70 <_dtoa_r+0x60>
3401ce58:	685a      	ldr	r2, [r3, #4]
3401ce5a:	2301      	movs	r3, #1
3401ce5c:	4648      	mov	r0, r9
3401ce5e:	4093      	lsls	r3, r2
3401ce60:	604a      	str	r2, [r1, #4]
3401ce62:	608b      	str	r3, [r1, #8]
3401ce64:	f000 fdbc 	bl	3401d9e0 <_Bfree>
3401ce68:	f8d9 301c 	ldr.w	r3, [r9, #28]
3401ce6c:	2200      	movs	r2, #0
3401ce6e:	601a      	str	r2, [r3, #0]
3401ce70:	1e2b      	subs	r3, r5, #0
3401ce72:	bfb7      	itett	lt
3401ce74:	f023 4300 	biclt.w	r3, r3, #2147483648	@ 0x80000000
3401ce78:	2300      	movge	r3, #0
3401ce7a:	2201      	movlt	r2, #1
3401ce7c:	9303      	strlt	r3, [sp, #12]
3401ce7e:	bfac      	ite	ge
3401ce80:	6033      	strge	r3, [r6, #0]
3401ce82:	6032      	strlt	r2, [r6, #0]
3401ce84:	4b90      	ldr	r3, [pc, #576]	@ (3401d0c8 <_dtoa_r+0x2b8>)
3401ce86:	9e03      	ldr	r6, [sp, #12]
3401ce88:	43b3      	bics	r3, r6
3401ce8a:	d110      	bne.n	3401ceae <_dtoa_r+0x9e>
3401ce8c:	f242 730f 	movw	r3, #9999	@ 0x270f
3401ce90:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
3401ce92:	6013      	str	r3, [r2, #0]
3401ce94:	f3c6 0313 	ubfx	r3, r6, #0, #20
3401ce98:	4323      	orrs	r3, r4
3401ce9a:	f000 84e6 	beq.w	3401d86a <_dtoa_r+0xa5a>
3401ce9e:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
3401cea0:	4f8a      	ldr	r7, [pc, #552]	@ (3401d0cc <_dtoa_r+0x2bc>)
3401cea2:	2b00      	cmp	r3, #0
3401cea4:	f000 84e8 	beq.w	3401d878 <_dtoa_r+0xa68>
3401cea8:	1cfb      	adds	r3, r7, #3
3401ceaa:	f000 bce3 	b.w	3401d874 <_dtoa_r+0xa64>
3401ceae:	ed9d 8b02 	vldr	d8, [sp, #8]
3401ceb2:	eeb5 8b40 	vcmp.f64	d8, #0.0
3401ceb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ceba:	d10a      	bne.n	3401ced2 <_dtoa_r+0xc2>
3401cebc:	2301      	movs	r3, #1
3401cebe:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
3401cec0:	6013      	str	r3, [r2, #0]
3401cec2:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
3401cec4:	b113      	cbz	r3, 3401cecc <_dtoa_r+0xbc>
3401cec6:	4b82      	ldr	r3, [pc, #520]	@ (3401d0d0 <_dtoa_r+0x2c0>)
3401cec8:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
3401ceca:	6013      	str	r3, [r2, #0]
3401cecc:	4f81      	ldr	r7, [pc, #516]	@ (3401d0d4 <_dtoa_r+0x2c4>)
3401cece:	f000 bcd3 	b.w	3401d878 <_dtoa_r+0xa68>
3401ced2:	aa0e      	add	r2, sp, #56	@ 0x38
3401ced4:	eeb0 0b48 	vmov.f64	d0, d8
3401ced8:	a90f      	add	r1, sp, #60	@ 0x3c
3401ceda:	4648      	mov	r0, r9
3401cedc:	f001 f86a 	bl	3401dfb4 <__d2b>
3401cee0:	f3c6 530a 	ubfx	r3, r6, #20, #11
3401cee4:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
3401cee6:	9001      	str	r0, [sp, #4]
3401cee8:	2b00      	cmp	r3, #0
3401ceea:	d045      	beq.n	3401cf78 <_dtoa_r+0x168>
3401ceec:	ee18 1a90 	vmov	r1, s17
3401cef0:	eeb0 7b48 	vmov.f64	d7, d8
3401cef4:	f2a3 33ff 	subw	r3, r3, #1023	@ 0x3ff
3401cef8:	2500      	movs	r5, #0
3401cefa:	f3c1 0113 	ubfx	r1, r1, #0, #20
3401cefe:	f041 517f 	orr.w	r1, r1, #1069547520	@ 0x3fc00000
3401cf02:	f441 1140 	orr.w	r1, r1, #3145728	@ 0x300000
3401cf06:	eeb7 6b08 	vmov.f64	d6, #120	@ 0x3fc00000  1.5
3401cf0a:	ee07 1a90 	vmov	s15, r1
3401cf0e:	ed9f 5b66 	vldr	d5, [pc, #408]	@ 3401d0a8 <_dtoa_r+0x298>
3401cf12:	ee37 7b46 	vsub.f64	d7, d7, d6
3401cf16:	ed9f 6b66 	vldr	d6, [pc, #408]	@ 3401d0b0 <_dtoa_r+0x2a0>
3401cf1a:	eea7 6b05 	vfma.f64	d6, d7, d5
3401cf1e:	ee07 3a90 	vmov	s15, r3
3401cf22:	eeb8 4be7 	vcvt.f64.s32	d4, s15
3401cf26:	ed9f 5b64 	vldr	d5, [pc, #400]	@ 3401d0b8 <_dtoa_r+0x2a8>
3401cf2a:	eeb0 7b46 	vmov.f64	d7, d6
3401cf2e:	eea4 7b05 	vfma.f64	d7, d4, d5
3401cf32:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
3401cf36:	eefd 6bc7 	vcvt.s32.f64	s13, d7
3401cf3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401cf3e:	ee16 8a90 	vmov	r8, s13
3401cf42:	d508      	bpl.n	3401cf56 <_dtoa_r+0x146>
3401cf44:	eeb8 6be6 	vcvt.f64.s32	d6, s13
3401cf48:	eeb4 6b47 	vcmp.f64	d6, d7
3401cf4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401cf50:	bf18      	it	ne
3401cf52:	f108 38ff 	addne.w	r8, r8, #4294967295	@ 0xffffffff
3401cf56:	f1b8 0f16 	cmp.w	r8, #22
3401cf5a:	d82d      	bhi.n	3401cfb8 <_dtoa_r+0x1a8>
3401cf5c:	495e      	ldr	r1, [pc, #376]	@ (3401d0d8 <_dtoa_r+0x2c8>)
3401cf5e:	eb01 01c8 	add.w	r1, r1, r8, lsl #3
3401cf62:	ed91 7b00 	vldr	d7, [r1]
3401cf66:	eeb4 8bc7 	vcmpe.f64	d8, d7
3401cf6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401cf6e:	d501      	bpl.n	3401cf74 <_dtoa_r+0x164>
3401cf70:	f108 38ff 	add.w	r8, r8, #4294967295	@ 0xffffffff
3401cf74:	2100      	movs	r1, #0
3401cf76:	e020      	b.n	3401cfba <_dtoa_r+0x1aa>
3401cf78:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
3401cf7a:	2501      	movs	r5, #1
3401cf7c:	4413      	add	r3, r2
3401cf7e:	f203 4132 	addw	r1, r3, #1074	@ 0x432
3401cf82:	2920      	cmp	r1, #32
3401cf84:	bfc9      	itett	gt
3401cf86:	f1c1 0140 	rsbgt	r1, r1, #64	@ 0x40
3401cf8a:	f1c1 0120 	rsble	r1, r1, #32
3401cf8e:	408e      	lslgt	r6, r1
3401cf90:	f203 4112 	addwgt	r1, r3, #1042	@ 0x412
3401cf94:	bfd8      	it	le
3401cf96:	fa04 f101 	lslle.w	r1, r4, r1
3401cf9a:	f103 33ff 	add.w	r3, r3, #4294967295	@ 0xffffffff
3401cf9e:	bfc4      	itt	gt
3401cfa0:	fa24 f101 	lsrgt.w	r1, r4, r1
3401cfa4:	4331      	orrgt	r1, r6
3401cfa6:	ee07 1a90 	vmov	s15, r1
3401cfaa:	eeb8 7b67 	vcvt.f64.u32	d7, s15
3401cfae:	ee17 1a90 	vmov	r1, s15
3401cfb2:	f1a1 71f8 	sub.w	r1, r1, #32505856	@ 0x1f00000
3401cfb6:	e7a6      	b.n	3401cf06 <_dtoa_r+0xf6>
3401cfb8:	2101      	movs	r1, #1
3401cfba:	1ad2      	subs	r2, r2, r3
3401cfbc:	910c      	str	r1, [sp, #48]	@ 0x30
3401cfbe:	1e53      	subs	r3, r2, #1
3401cfc0:	9306      	str	r3, [sp, #24]
3401cfc2:	bf49      	itett	mi
3401cfc4:	f1c2 0301 	rsbmi	r3, r2, #1
3401cfc8:	2300      	movpl	r3, #0
3401cfca:	9304      	strmi	r3, [sp, #16]
3401cfcc:	2300      	movmi	r3, #0
3401cfce:	bf54      	ite	pl
3401cfd0:	9304      	strpl	r3, [sp, #16]
3401cfd2:	9306      	strmi	r3, [sp, #24]
3401cfd4:	f1b8 0f00 	cmp.w	r8, #0
3401cfd8:	db16      	blt.n	3401d008 <_dtoa_r+0x1f8>
3401cfda:	9b06      	ldr	r3, [sp, #24]
3401cfdc:	f8cd 8028 	str.w	r8, [sp, #40]	@ 0x28
3401cfe0:	4443      	add	r3, r8
3401cfe2:	9306      	str	r3, [sp, #24]
3401cfe4:	2300      	movs	r3, #0
3401cfe6:	9a07      	ldr	r2, [sp, #28]
3401cfe8:	2a09      	cmp	r2, #9
3401cfea:	d843      	bhi.n	3401d074 <_dtoa_r+0x264>
3401cfec:	2a05      	cmp	r2, #5
3401cfee:	bfc5      	ittet	gt
3401cff0:	3a04      	subgt	r2, #4
3401cff2:	2400      	movgt	r4, #0
3401cff4:	2401      	movle	r4, #1
3401cff6:	9207      	strgt	r2, [sp, #28]
3401cff8:	9a07      	ldr	r2, [sp, #28]
3401cffa:	3a02      	subs	r2, #2
3401cffc:	2a03      	cmp	r2, #3
3401cffe:	d844      	bhi.n	3401d08a <_dtoa_r+0x27a>
3401d000:	e8df f002 	tbb	[pc, r2]
3401d004:	0b173634 	.word	0x0b173634
3401d008:	9b04      	ldr	r3, [sp, #16]
3401d00a:	2200      	movs	r2, #0
3401d00c:	eba3 0308 	sub.w	r3, r3, r8
3401d010:	920a      	str	r2, [sp, #40]	@ 0x28
3401d012:	9304      	str	r3, [sp, #16]
3401d014:	f1c8 0300 	rsb	r3, r8, #0
3401d018:	e7e5      	b.n	3401cfe6 <_dtoa_r+0x1d6>
3401d01a:	2201      	movs	r2, #1
3401d01c:	9208      	str	r2, [sp, #32]
3401d01e:	9a09      	ldr	r2, [sp, #36]	@ 0x24
3401d020:	eb08 0b02 	add.w	fp, r8, r2
3401d024:	f10b 0a01 	add.w	sl, fp, #1
3401d028:	4652      	mov	r2, sl
3401d02a:	2a01      	cmp	r2, #1
3401d02c:	bfb8      	it	lt
3401d02e:	2201      	movlt	r2, #1
3401d030:	e006      	b.n	3401d040 <_dtoa_r+0x230>
3401d032:	2201      	movs	r2, #1
3401d034:	9208      	str	r2, [sp, #32]
3401d036:	9a09      	ldr	r2, [sp, #36]	@ 0x24
3401d038:	2a00      	cmp	r2, #0
3401d03a:	dd29      	ble.n	3401d090 <_dtoa_r+0x280>
3401d03c:	4693      	mov	fp, r2
3401d03e:	4692      	mov	sl, r2
3401d040:	f8d9 701c 	ldr.w	r7, [r9, #28]
3401d044:	2100      	movs	r1, #0
3401d046:	2004      	movs	r0, #4
3401d048:	f100 0614 	add.w	r6, r0, #20
3401d04c:	4296      	cmp	r6, r2
3401d04e:	d926      	bls.n	3401d09e <_dtoa_r+0x28e>
3401d050:	6079      	str	r1, [r7, #4]
3401d052:	4648      	mov	r0, r9
3401d054:	9305      	str	r3, [sp, #20]
3401d056:	f000 fc83 	bl	3401d960 <_Balloc>
3401d05a:	9b05      	ldr	r3, [sp, #20]
3401d05c:	4607      	mov	r7, r0
3401d05e:	2800      	cmp	r0, #0
3401d060:	d13e      	bne.n	3401d0e0 <_dtoa_r+0x2d0>
3401d062:	4b1e      	ldr	r3, [pc, #120]	@ (3401d0dc <_dtoa_r+0x2cc>)
3401d064:	4602      	mov	r2, r0
3401d066:	f240 11af 	movw	r1, #431	@ 0x1af
3401d06a:	e6ea      	b.n	3401ce42 <_dtoa_r+0x32>
3401d06c:	2200      	movs	r2, #0
3401d06e:	e7e1      	b.n	3401d034 <_dtoa_r+0x224>
3401d070:	2200      	movs	r2, #0
3401d072:	e7d3      	b.n	3401d01c <_dtoa_r+0x20c>
3401d074:	2401      	movs	r4, #1
3401d076:	2200      	movs	r2, #0
3401d078:	e9cd 2407 	strd	r2, r4, [sp, #28]
3401d07c:	f04f 3bff 	mov.w	fp, #4294967295	@ 0xffffffff
3401d080:	2100      	movs	r1, #0
3401d082:	2212      	movs	r2, #18
3401d084:	46da      	mov	sl, fp
3401d086:	9109      	str	r1, [sp, #36]	@ 0x24
3401d088:	e7da      	b.n	3401d040 <_dtoa_r+0x230>
3401d08a:	2201      	movs	r2, #1
3401d08c:	9208      	str	r2, [sp, #32]
3401d08e:	e7f5      	b.n	3401d07c <_dtoa_r+0x26c>
3401d090:	f04f 0b01 	mov.w	fp, #1
3401d094:	46da      	mov	sl, fp
3401d096:	465a      	mov	r2, fp
3401d098:	f8cd b024 	str.w	fp, [sp, #36]	@ 0x24
3401d09c:	e7d0      	b.n	3401d040 <_dtoa_r+0x230>
3401d09e:	3101      	adds	r1, #1
3401d0a0:	0040      	lsls	r0, r0, #1
3401d0a2:	e7d1      	b.n	3401d048 <_dtoa_r+0x238>
3401d0a4:	f3af 8000 	nop.w
3401d0a8:	636f4361 	.word	0x636f4361
3401d0ac:	3fd287a7 	.word	0x3fd287a7
3401d0b0:	8b60c8b3 	.word	0x8b60c8b3
3401d0b4:	3fc68a28 	.word	0x3fc68a28
3401d0b8:	509f79fb 	.word	0x509f79fb
3401d0bc:	3fd34413 	.word	0x3fd34413
3401d0c0:	34020911 	.word	0x34020911
3401d0c4:	34020928 	.word	0x34020928
3401d0c8:	7ff00000 	.word	0x7ff00000
3401d0cc:	3402090d 	.word	0x3402090d
3401d0d0:	3402024b 	.word	0x3402024b
3401d0d4:	3402024a 	.word	0x3402024a
3401d0d8:	34020a40 	.word	0x34020a40
3401d0dc:	34020980 	.word	0x34020980
3401d0e0:	f8d9 201c 	ldr.w	r2, [r9, #28]
3401d0e4:	f1ba 0f0e 	cmp.w	sl, #14
3401d0e8:	6010      	str	r0, [r2, #0]
3401d0ea:	d86e      	bhi.n	3401d1ca <_dtoa_r+0x3ba>
3401d0ec:	2c00      	cmp	r4, #0
3401d0ee:	d06c      	beq.n	3401d1ca <_dtoa_r+0x3ba>
3401d0f0:	f1b8 0f00 	cmp.w	r8, #0
3401d0f4:	f340 80b4 	ble.w	3401d260 <_dtoa_r+0x450>
3401d0f8:	f008 010f 	and.w	r1, r8, #15
3401d0fc:	4ac7      	ldr	r2, [pc, #796]	@ (3401d41c <_dtoa_r+0x60c>)
3401d0fe:	f418 7f80 	tst.w	r8, #256	@ 0x100
3401d102:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
3401d106:	ea4f 1128 	mov.w	r1, r8, asr #4
3401d10a:	ed92 7b00 	vldr	d7, [r2]
3401d10e:	f000 809b 	beq.w	3401d248 <_dtoa_r+0x438>
3401d112:	4ac3      	ldr	r2, [pc, #780]	@ (3401d420 <_dtoa_r+0x610>)
3401d114:	f001 010f 	and.w	r1, r1, #15
3401d118:	ed92 6b08 	vldr	d6, [r2, #32]
3401d11c:	2203      	movs	r2, #3
3401d11e:	ee88 6b06 	vdiv.f64	d6, d8, d6
3401d122:	ed8d 6b02 	vstr	d6, [sp, #8]
3401d126:	48be      	ldr	r0, [pc, #760]	@ (3401d420 <_dtoa_r+0x610>)
3401d128:	2900      	cmp	r1, #0
3401d12a:	f040 808f 	bne.w	3401d24c <_dtoa_r+0x43c>
3401d12e:	ed9d 6b02 	vldr	d6, [sp, #8]
3401d132:	ee86 7b07 	vdiv.f64	d7, d6, d7
3401d136:	ed8d 7b02 	vstr	d7, [sp, #8]
3401d13a:	990c      	ldr	r1, [sp, #48]	@ 0x30
3401d13c:	ed9d 7b02 	vldr	d7, [sp, #8]
3401d140:	2900      	cmp	r1, #0
3401d142:	f000 80b3 	beq.w	3401d2ac <_dtoa_r+0x49c>
3401d146:	eeb7 6b00 	vmov.f64	d6, #112	@ 0x3f800000  1.0
3401d14a:	eeb4 7bc6 	vcmpe.f64	d7, d6
3401d14e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401d152:	f140 80ab 	bpl.w	3401d2ac <_dtoa_r+0x49c>
3401d156:	f1ba 0f00 	cmp.w	sl, #0
3401d15a:	f000 80a7 	beq.w	3401d2ac <_dtoa_r+0x49c>
3401d15e:	f1bb 0f00 	cmp.w	fp, #0
3401d162:	dd30      	ble.n	3401d1c6 <_dtoa_r+0x3b6>
3401d164:	eeb2 6b04 	vmov.f64	d6, #36	@ 0x41200000  10.0
3401d168:	f108 31ff 	add.w	r1, r8, #4294967295	@ 0xffffffff
3401d16c:	3201      	adds	r2, #1
3401d16e:	465c      	mov	r4, fp
3401d170:	9105      	str	r1, [sp, #20]
3401d172:	ee27 7b06 	vmul.f64	d7, d7, d6
3401d176:	ed8d 7b02 	vstr	d7, [sp, #8]
3401d17a:	ee07 2a90 	vmov	s15, r2
3401d17e:	eeb1 5b0c 	vmov.f64	d5, #28	@ 0x40e00000  7.0
3401d182:	ed9d 6b02 	vldr	d6, [sp, #8]
3401d186:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3401d18a:	eea7 5b06 	vfma.f64	d5, d7, d6
3401d18e:	ee15 2a90 	vmov	r2, s11
3401d192:	ec51 0b15 	vmov	r0, r1, d5
3401d196:	f1a2 7150 	sub.w	r1, r2, #54525952	@ 0x3400000
3401d19a:	2c00      	cmp	r4, #0
3401d19c:	f040 808a 	bne.w	3401d2b4 <_dtoa_r+0x4a4>
3401d1a0:	eeb1 7b04 	vmov.f64	d7, #20	@ 0x40a00000  5.0
3401d1a4:	ee36 6b47 	vsub.f64	d6, d6, d7
3401d1a8:	ec41 0b17 	vmov	d7, r0, r1
3401d1ac:	eeb4 6bc7 	vcmpe.f64	d6, d7
3401d1b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401d1b4:	f300 826a 	bgt.w	3401d68c <_dtoa_r+0x87c>
3401d1b8:	eeb1 7b47 	vneg.f64	d7, d7
3401d1bc:	eeb4 6bc7 	vcmpe.f64	d6, d7
3401d1c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401d1c4:	d423      	bmi.n	3401d20e <_dtoa_r+0x3fe>
3401d1c6:	ed8d 8b02 	vstr	d8, [sp, #8]
3401d1ca:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
3401d1cc:	2a00      	cmp	r2, #0
3401d1ce:	f2c0 8129 	blt.w	3401d424 <_dtoa_r+0x614>
3401d1d2:	f1b8 0f0e 	cmp.w	r8, #14
3401d1d6:	f300 8125 	bgt.w	3401d424 <_dtoa_r+0x614>
3401d1da:	4b90      	ldr	r3, [pc, #576]	@ (3401d41c <_dtoa_r+0x60c>)
3401d1dc:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
3401d1e0:	ed93 6b00 	vldr	d6, [r3]
3401d1e4:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401d1e6:	2b00      	cmp	r3, #0
3401d1e8:	f280 80c8 	bge.w	3401d37c <_dtoa_r+0x56c>
3401d1ec:	f1ba 0f00 	cmp.w	sl, #0
3401d1f0:	f300 80c4 	bgt.w	3401d37c <_dtoa_r+0x56c>
3401d1f4:	d10b      	bne.n	3401d20e <_dtoa_r+0x3fe>
3401d1f6:	eeb1 7b04 	vmov.f64	d7, #20	@ 0x40a00000  5.0
3401d1fa:	ee26 6b07 	vmul.f64	d6, d6, d7
3401d1fe:	ed9d 7b02 	vldr	d7, [sp, #8]
3401d202:	eeb4 6bc7 	vcmpe.f64	d6, d7
3401d206:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401d20a:	f2c0 823c 	blt.w	3401d686 <_dtoa_r+0x876>
3401d20e:	2400      	movs	r4, #0
3401d210:	4625      	mov	r5, r4
3401d212:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401d214:	463e      	mov	r6, r7
3401d216:	43db      	mvns	r3, r3
3401d218:	9305      	str	r3, [sp, #20]
3401d21a:	f04f 0800 	mov.w	r8, #0
3401d21e:	4621      	mov	r1, r4
3401d220:	4648      	mov	r0, r9
3401d222:	f000 fbdd 	bl	3401d9e0 <_Bfree>
3401d226:	2d00      	cmp	r5, #0
3401d228:	f000 80a2 	beq.w	3401d370 <_dtoa_r+0x560>
3401d22c:	f1b8 0f00 	cmp.w	r8, #0
3401d230:	d005      	beq.n	3401d23e <_dtoa_r+0x42e>
3401d232:	45a8      	cmp	r8, r5
3401d234:	d003      	beq.n	3401d23e <_dtoa_r+0x42e>
3401d236:	4641      	mov	r1, r8
3401d238:	4648      	mov	r0, r9
3401d23a:	f000 fbd1 	bl	3401d9e0 <_Bfree>
3401d23e:	4629      	mov	r1, r5
3401d240:	4648      	mov	r0, r9
3401d242:	f000 fbcd 	bl	3401d9e0 <_Bfree>
3401d246:	e093      	b.n	3401d370 <_dtoa_r+0x560>
3401d248:	2202      	movs	r2, #2
3401d24a:	e76c      	b.n	3401d126 <_dtoa_r+0x316>
3401d24c:	07cc      	lsls	r4, r1, #31
3401d24e:	d504      	bpl.n	3401d25a <_dtoa_r+0x44a>
3401d250:	3201      	adds	r2, #1
3401d252:	ed90 6b00 	vldr	d6, [r0]
3401d256:	ee27 7b06 	vmul.f64	d7, d7, d6
3401d25a:	1049      	asrs	r1, r1, #1
3401d25c:	3008      	adds	r0, #8
3401d25e:	e763      	b.n	3401d128 <_dtoa_r+0x318>
3401d260:	d022      	beq.n	3401d2a8 <_dtoa_r+0x498>
3401d262:	f1c8 0100 	rsb	r1, r8, #0
3401d266:	4a6d      	ldr	r2, [pc, #436]	@ (3401d41c <_dtoa_r+0x60c>)
3401d268:	2400      	movs	r4, #0
3401d26a:	f001 000f 	and.w	r0, r1, #15
3401d26e:	1109      	asrs	r1, r1, #4
3401d270:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
3401d274:	486a      	ldr	r0, [pc, #424]	@ (3401d420 <_dtoa_r+0x610>)
3401d276:	ed92 7b00 	vldr	d7, [r2]
3401d27a:	2202      	movs	r2, #2
3401d27c:	ee28 7b07 	vmul.f64	d7, d8, d7
3401d280:	ed8d 7b02 	vstr	d7, [sp, #8]
3401d284:	b929      	cbnz	r1, 3401d292 <_dtoa_r+0x482>
3401d286:	2c00      	cmp	r4, #0
3401d288:	f43f af57 	beq.w	3401d13a <_dtoa_r+0x32a>
3401d28c:	ed8d 7b02 	vstr	d7, [sp, #8]
3401d290:	e753      	b.n	3401d13a <_dtoa_r+0x32a>
3401d292:	07ce      	lsls	r6, r1, #31
3401d294:	d505      	bpl.n	3401d2a2 <_dtoa_r+0x492>
3401d296:	3201      	adds	r2, #1
3401d298:	2401      	movs	r4, #1
3401d29a:	ed90 6b00 	vldr	d6, [r0]
3401d29e:	ee27 7b06 	vmul.f64	d7, d7, d6
3401d2a2:	1049      	asrs	r1, r1, #1
3401d2a4:	3008      	adds	r0, #8
3401d2a6:	e7ed      	b.n	3401d284 <_dtoa_r+0x474>
3401d2a8:	2202      	movs	r2, #2
3401d2aa:	e746      	b.n	3401d13a <_dtoa_r+0x32a>
3401d2ac:	4654      	mov	r4, sl
3401d2ae:	f8cd 8014 	str.w	r8, [sp, #20]
3401d2b2:	e762      	b.n	3401d17a <_dtoa_r+0x36a>
3401d2b4:	4a59      	ldr	r2, [pc, #356]	@ (3401d41c <_dtoa_r+0x60c>)
3401d2b6:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
3401d2ba:	443c      	add	r4, r7
3401d2bc:	ed12 4b02 	vldr	d4, [r2, #-8]
3401d2c0:	9a08      	ldr	r2, [sp, #32]
3401d2c2:	ec41 0b17 	vmov	d7, r0, r1
3401d2c6:	b34a      	cbz	r2, 3401d31c <_dtoa_r+0x50c>
3401d2c8:	eeb6 3b00 	vmov.f64	d3, #96	@ 0x3f000000  0.5
3401d2cc:	463e      	mov	r6, r7
3401d2ce:	eeb7 2b00 	vmov.f64	d2, #112	@ 0x3f800000  1.0
3401d2d2:	ee83 5b04 	vdiv.f64	d5, d3, d4
3401d2d6:	eeb2 3b04 	vmov.f64	d3, #36	@ 0x41200000  10.0
3401d2da:	ee35 7b47 	vsub.f64	d7, d5, d7
3401d2de:	eefd 4bc6 	vcvt.s32.f64	s9, d6
3401d2e2:	eeb8 5be4 	vcvt.f64.s32	d5, s9
3401d2e6:	ee14 2a90 	vmov	r2, s9
3401d2ea:	3230      	adds	r2, #48	@ 0x30
3401d2ec:	ee36 6b45 	vsub.f64	d6, d6, d5
3401d2f0:	f806 2b01 	strb.w	r2, [r6], #1
3401d2f4:	eeb4 6bc7 	vcmpe.f64	d6, d7
3401d2f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401d2fc:	d438      	bmi.n	3401d370 <_dtoa_r+0x560>
3401d2fe:	ee32 5b46 	vsub.f64	d5, d2, d6
3401d302:	eeb4 5bc7 	vcmpe.f64	d5, d7
3401d306:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401d30a:	d46e      	bmi.n	3401d3ea <_dtoa_r+0x5da>
3401d30c:	42a6      	cmp	r6, r4
3401d30e:	f43f af5a 	beq.w	3401d1c6 <_dtoa_r+0x3b6>
3401d312:	ee27 7b03 	vmul.f64	d7, d7, d3
3401d316:	ee26 6b03 	vmul.f64	d6, d6, d3
3401d31a:	e7e0      	b.n	3401d2de <_dtoa_r+0x4ce>
3401d31c:	ee27 7b04 	vmul.f64	d7, d7, d4
3401d320:	4621      	mov	r1, r4
3401d322:	463e      	mov	r6, r7
3401d324:	eeb2 3b04 	vmov.f64	d3, #36	@ 0x41200000  10.0
3401d328:	eefd 4bc6 	vcvt.s32.f64	s9, d6
3401d32c:	ee14 2a90 	vmov	r2, s9
3401d330:	eeb8 5be4 	vcvt.f64.s32	d5, s9
3401d334:	3230      	adds	r2, #48	@ 0x30
3401d336:	ee36 6b45 	vsub.f64	d6, d6, d5
3401d33a:	f806 2b01 	strb.w	r2, [r6], #1
3401d33e:	42a6      	cmp	r6, r4
3401d340:	d119      	bne.n	3401d376 <_dtoa_r+0x566>
3401d342:	eeb6 5b00 	vmov.f64	d5, #96	@ 0x3f000000  0.5
3401d346:	ee37 4b05 	vadd.f64	d4, d7, d5
3401d34a:	eeb4 6bc4 	vcmpe.f64	d6, d4
3401d34e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401d352:	dc4a      	bgt.n	3401d3ea <_dtoa_r+0x5da>
3401d354:	ee35 5b47 	vsub.f64	d5, d5, d7
3401d358:	eeb4 6bc5 	vcmpe.f64	d6, d5
3401d35c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401d360:	f57f af31 	bpl.w	3401d1c6 <_dtoa_r+0x3b6>
3401d364:	460e      	mov	r6, r1
3401d366:	3901      	subs	r1, #1
3401d368:	f816 3c01 	ldrb.w	r3, [r6, #-1]
3401d36c:	2b30      	cmp	r3, #48	@ 0x30
3401d36e:	d0f9      	beq.n	3401d364 <_dtoa_r+0x554>
3401d370:	f8dd 8014 	ldr.w	r8, [sp, #20]
3401d374:	e027      	b.n	3401d3c6 <_dtoa_r+0x5b6>
3401d376:	ee26 6b03 	vmul.f64	d6, d6, d3
3401d37a:	e7d5      	b.n	3401d328 <_dtoa_r+0x518>
3401d37c:	ed9d 7b02 	vldr	d7, [sp, #8]
3401d380:	eeb2 4b04 	vmov.f64	d4, #36	@ 0x41200000  10.0
3401d384:	463e      	mov	r6, r7
3401d386:	ee87 5b06 	vdiv.f64	d5, d7, d6
3401d38a:	eebd 5bc5 	vcvt.s32.f64	s10, d5
3401d38e:	ee15 3a10 	vmov	r3, s10
3401d392:	eeb8 3bc5 	vcvt.f64.s32	d3, s10
3401d396:	3330      	adds	r3, #48	@ 0x30
3401d398:	eea3 7b46 	vfms.f64	d7, d3, d6
3401d39c:	f806 3b01 	strb.w	r3, [r6], #1
3401d3a0:	1bf3      	subs	r3, r6, r7
3401d3a2:	459a      	cmp	sl, r3
3401d3a4:	d132      	bne.n	3401d40c <_dtoa_r+0x5fc>
3401d3a6:	ee37 7b07 	vadd.f64	d7, d7, d7
3401d3aa:	eeb4 7bc6 	vcmpe.f64	d7, d6
3401d3ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401d3b2:	dc18      	bgt.n	3401d3e6 <_dtoa_r+0x5d6>
3401d3b4:	eeb4 7b46 	vcmp.f64	d7, d6
3401d3b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401d3bc:	d103      	bne.n	3401d3c6 <_dtoa_r+0x5b6>
3401d3be:	ee15 3a10 	vmov	r3, s10
3401d3c2:	07db      	lsls	r3, r3, #31
3401d3c4:	d40f      	bmi.n	3401d3e6 <_dtoa_r+0x5d6>
3401d3c6:	9901      	ldr	r1, [sp, #4]
3401d3c8:	4648      	mov	r0, r9
3401d3ca:	f000 fb09 	bl	3401d9e0 <_Bfree>
3401d3ce:	2300      	movs	r3, #0
3401d3d0:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
3401d3d2:	7033      	strb	r3, [r6, #0]
3401d3d4:	f108 0301 	add.w	r3, r8, #1
3401d3d8:	6013      	str	r3, [r2, #0]
3401d3da:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
3401d3dc:	2b00      	cmp	r3, #0
3401d3de:	f000 824b 	beq.w	3401d878 <_dtoa_r+0xa68>
3401d3e2:	601e      	str	r6, [r3, #0]
3401d3e4:	e248      	b.n	3401d878 <_dtoa_r+0xa68>
3401d3e6:	f8cd 8014 	str.w	r8, [sp, #20]
3401d3ea:	4633      	mov	r3, r6
3401d3ec:	461e      	mov	r6, r3
3401d3ee:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
3401d3f2:	2a39      	cmp	r2, #57	@ 0x39
3401d3f4:	d106      	bne.n	3401d404 <_dtoa_r+0x5f4>
3401d3f6:	429f      	cmp	r7, r3
3401d3f8:	d1f8      	bne.n	3401d3ec <_dtoa_r+0x5dc>
3401d3fa:	9a05      	ldr	r2, [sp, #20]
3401d3fc:	3201      	adds	r2, #1
3401d3fe:	9205      	str	r2, [sp, #20]
3401d400:	2230      	movs	r2, #48	@ 0x30
3401d402:	703a      	strb	r2, [r7, #0]
3401d404:	781a      	ldrb	r2, [r3, #0]
3401d406:	3201      	adds	r2, #1
3401d408:	701a      	strb	r2, [r3, #0]
3401d40a:	e7b1      	b.n	3401d370 <_dtoa_r+0x560>
3401d40c:	ee27 7b04 	vmul.f64	d7, d7, d4
3401d410:	eeb5 7b40 	vcmp.f64	d7, #0.0
3401d414:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401d418:	d1b5      	bne.n	3401d386 <_dtoa_r+0x576>
3401d41a:	e7d4      	b.n	3401d3c6 <_dtoa_r+0x5b6>
3401d41c:	34020a40 	.word	0x34020a40
3401d420:	34020a18 	.word	0x34020a18
3401d424:	9908      	ldr	r1, [sp, #32]
3401d426:	2900      	cmp	r1, #0
3401d428:	f000 80e9 	beq.w	3401d5fe <_dtoa_r+0x7ee>
3401d42c:	9907      	ldr	r1, [sp, #28]
3401d42e:	2901      	cmp	r1, #1
3401d430:	f300 80cb 	bgt.w	3401d5ca <_dtoa_r+0x7ba>
3401d434:	2d00      	cmp	r5, #0
3401d436:	f000 80c4 	beq.w	3401d5c2 <_dtoa_r+0x7b2>
3401d43a:	f202 4233 	addw	r2, r2, #1075	@ 0x433
3401d43e:	461c      	mov	r4, r3
3401d440:	9e04      	ldr	r6, [sp, #16]
3401d442:	9305      	str	r3, [sp, #20]
3401d444:	2101      	movs	r1, #1
3401d446:	9b04      	ldr	r3, [sp, #16]
3401d448:	4648      	mov	r0, r9
3401d44a:	4413      	add	r3, r2
3401d44c:	9304      	str	r3, [sp, #16]
3401d44e:	9b06      	ldr	r3, [sp, #24]
3401d450:	4413      	add	r3, r2
3401d452:	9306      	str	r3, [sp, #24]
3401d454:	f000 fb7a 	bl	3401db4c <__i2b>
3401d458:	9b05      	ldr	r3, [sp, #20]
3401d45a:	4605      	mov	r5, r0
3401d45c:	b166      	cbz	r6, 3401d478 <_dtoa_r+0x668>
3401d45e:	9a06      	ldr	r2, [sp, #24]
3401d460:	2a00      	cmp	r2, #0
3401d462:	dd09      	ble.n	3401d478 <_dtoa_r+0x668>
3401d464:	42b2      	cmp	r2, r6
3401d466:	9904      	ldr	r1, [sp, #16]
3401d468:	bfa8      	it	ge
3401d46a:	4632      	movge	r2, r6
3401d46c:	1a89      	subs	r1, r1, r2
3401d46e:	1ab6      	subs	r6, r6, r2
3401d470:	9104      	str	r1, [sp, #16]
3401d472:	9906      	ldr	r1, [sp, #24]
3401d474:	1a8a      	subs	r2, r1, r2
3401d476:	9206      	str	r2, [sp, #24]
3401d478:	b30b      	cbz	r3, 3401d4be <_dtoa_r+0x6ae>
3401d47a:	9a08      	ldr	r2, [sp, #32]
3401d47c:	2a00      	cmp	r2, #0
3401d47e:	f000 80c5 	beq.w	3401d60c <_dtoa_r+0x7fc>
3401d482:	2c00      	cmp	r4, #0
3401d484:	f000 80bf 	beq.w	3401d606 <_dtoa_r+0x7f6>
3401d488:	4629      	mov	r1, r5
3401d48a:	4622      	mov	r2, r4
3401d48c:	4648      	mov	r0, r9
3401d48e:	930b      	str	r3, [sp, #44]	@ 0x2c
3401d490:	f000 fc16 	bl	3401dcc0 <__pow5mult>
3401d494:	9a01      	ldr	r2, [sp, #4]
3401d496:	4601      	mov	r1, r0
3401d498:	4605      	mov	r5, r0
3401d49a:	4648      	mov	r0, r9
3401d49c:	f000 fb6c 	bl	3401db78 <__multiply>
3401d4a0:	9901      	ldr	r1, [sp, #4]
3401d4a2:	9005      	str	r0, [sp, #20]
3401d4a4:	4648      	mov	r0, r9
3401d4a6:	f000 fa9b 	bl	3401d9e0 <_Bfree>
3401d4aa:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
3401d4ac:	1b1b      	subs	r3, r3, r4
3401d4ae:	f000 80b0 	beq.w	3401d612 <_dtoa_r+0x802>
3401d4b2:	461a      	mov	r2, r3
3401d4b4:	9905      	ldr	r1, [sp, #20]
3401d4b6:	4648      	mov	r0, r9
3401d4b8:	f000 fc02 	bl	3401dcc0 <__pow5mult>
3401d4bc:	9001      	str	r0, [sp, #4]
3401d4be:	2101      	movs	r1, #1
3401d4c0:	4648      	mov	r0, r9
3401d4c2:	f000 fb43 	bl	3401db4c <__i2b>
3401d4c6:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
3401d4c8:	4604      	mov	r4, r0
3401d4ca:	2b00      	cmp	r3, #0
3401d4cc:	f000 81da 	beq.w	3401d884 <_dtoa_r+0xa74>
3401d4d0:	461a      	mov	r2, r3
3401d4d2:	4601      	mov	r1, r0
3401d4d4:	4648      	mov	r0, r9
3401d4d6:	f000 fbf3 	bl	3401dcc0 <__pow5mult>
3401d4da:	9b07      	ldr	r3, [sp, #28]
3401d4dc:	4604      	mov	r4, r0
3401d4de:	2b01      	cmp	r3, #1
3401d4e0:	f300 80a0 	bgt.w	3401d624 <_dtoa_r+0x814>
3401d4e4:	9b02      	ldr	r3, [sp, #8]
3401d4e6:	2b00      	cmp	r3, #0
3401d4e8:	f040 8096 	bne.w	3401d618 <_dtoa_r+0x808>
3401d4ec:	9b03      	ldr	r3, [sp, #12]
3401d4ee:	f3c3 0213 	ubfx	r2, r3, #0, #20
3401d4f2:	2a00      	cmp	r2, #0
3401d4f4:	f040 8092 	bne.w	3401d61c <_dtoa_r+0x80c>
3401d4f8:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
3401d4fc:	0d12      	lsrs	r2, r2, #20
3401d4fe:	0512      	lsls	r2, r2, #20
3401d500:	2a00      	cmp	r2, #0
3401d502:	f000 808d 	beq.w	3401d620 <_dtoa_r+0x810>
3401d506:	9b04      	ldr	r3, [sp, #16]
3401d508:	3301      	adds	r3, #1
3401d50a:	9304      	str	r3, [sp, #16]
3401d50c:	9b06      	ldr	r3, [sp, #24]
3401d50e:	3301      	adds	r3, #1
3401d510:	9306      	str	r3, [sp, #24]
3401d512:	2301      	movs	r3, #1
3401d514:	930b      	str	r3, [sp, #44]	@ 0x2c
3401d516:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
3401d518:	2b00      	cmp	r3, #0
3401d51a:	f000 81b9 	beq.w	3401d890 <_dtoa_r+0xa80>
3401d51e:	6922      	ldr	r2, [r4, #16]
3401d520:	eb04 0282 	add.w	r2, r4, r2, lsl #2
3401d524:	6910      	ldr	r0, [r2, #16]
3401d526:	f000 fac5 	bl	3401dab4 <__hi0bits>
3401d52a:	f1c0 0020 	rsb	r0, r0, #32
3401d52e:	9b06      	ldr	r3, [sp, #24]
3401d530:	4418      	add	r0, r3
3401d532:	f010 001f 	ands.w	r0, r0, #31
3401d536:	f000 8081 	beq.w	3401d63c <_dtoa_r+0x82c>
3401d53a:	f1c0 0220 	rsb	r2, r0, #32
3401d53e:	2a04      	cmp	r2, #4
3401d540:	dd73      	ble.n	3401d62a <_dtoa_r+0x81a>
3401d542:	f1c0 001c 	rsb	r0, r0, #28
3401d546:	9b04      	ldr	r3, [sp, #16]
3401d548:	4403      	add	r3, r0
3401d54a:	4406      	add	r6, r0
3401d54c:	9304      	str	r3, [sp, #16]
3401d54e:	9b06      	ldr	r3, [sp, #24]
3401d550:	4403      	add	r3, r0
3401d552:	9306      	str	r3, [sp, #24]
3401d554:	9b04      	ldr	r3, [sp, #16]
3401d556:	2b00      	cmp	r3, #0
3401d558:	dd05      	ble.n	3401d566 <_dtoa_r+0x756>
3401d55a:	461a      	mov	r2, r3
3401d55c:	9901      	ldr	r1, [sp, #4]
3401d55e:	4648      	mov	r0, r9
3401d560:	f000 fc08 	bl	3401dd74 <__lshift>
3401d564:	9001      	str	r0, [sp, #4]
3401d566:	9b06      	ldr	r3, [sp, #24]
3401d568:	2b00      	cmp	r3, #0
3401d56a:	dd05      	ble.n	3401d578 <_dtoa_r+0x768>
3401d56c:	4621      	mov	r1, r4
3401d56e:	461a      	mov	r2, r3
3401d570:	4648      	mov	r0, r9
3401d572:	f000 fbff 	bl	3401dd74 <__lshift>
3401d576:	4604      	mov	r4, r0
3401d578:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
3401d57a:	2b00      	cmp	r3, #0
3401d57c:	d060      	beq.n	3401d640 <_dtoa_r+0x830>
3401d57e:	4621      	mov	r1, r4
3401d580:	9801      	ldr	r0, [sp, #4]
3401d582:	f000 fc63 	bl	3401de4c <__mcmp>
3401d586:	2800      	cmp	r0, #0
3401d588:	da5a      	bge.n	3401d640 <_dtoa_r+0x830>
3401d58a:	f108 33ff 	add.w	r3, r8, #4294967295	@ 0xffffffff
3401d58e:	220a      	movs	r2, #10
3401d590:	9901      	ldr	r1, [sp, #4]
3401d592:	4648      	mov	r0, r9
3401d594:	9305      	str	r3, [sp, #20]
3401d596:	2300      	movs	r3, #0
3401d598:	f000 fa44 	bl	3401da24 <__multadd>
3401d59c:	9b08      	ldr	r3, [sp, #32]
3401d59e:	9001      	str	r0, [sp, #4]
3401d5a0:	2b00      	cmp	r3, #0
3401d5a2:	f000 8177 	beq.w	3401d894 <_dtoa_r+0xa84>
3401d5a6:	4629      	mov	r1, r5
3401d5a8:	2300      	movs	r3, #0
3401d5aa:	220a      	movs	r2, #10
3401d5ac:	4648      	mov	r0, r9
3401d5ae:	f000 fa39 	bl	3401da24 <__multadd>
3401d5b2:	f1bb 0f00 	cmp.w	fp, #0
3401d5b6:	4605      	mov	r5, r0
3401d5b8:	dc6e      	bgt.n	3401d698 <_dtoa_r+0x888>
3401d5ba:	9b07      	ldr	r3, [sp, #28]
3401d5bc:	2b02      	cmp	r3, #2
3401d5be:	dc48      	bgt.n	3401d652 <_dtoa_r+0x842>
3401d5c0:	e06a      	b.n	3401d698 <_dtoa_r+0x888>
3401d5c2:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
3401d5c4:	f1c2 0236 	rsb	r2, r2, #54	@ 0x36
3401d5c8:	e739      	b.n	3401d43e <_dtoa_r+0x62e>
3401d5ca:	f10a 34ff 	add.w	r4, sl, #4294967295	@ 0xffffffff
3401d5ce:	42a3      	cmp	r3, r4
3401d5d0:	db07      	blt.n	3401d5e2 <_dtoa_r+0x7d2>
3401d5d2:	f1ba 0f00 	cmp.w	sl, #0
3401d5d6:	eba3 0404 	sub.w	r4, r3, r4
3401d5da:	db0b      	blt.n	3401d5f4 <_dtoa_r+0x7e4>
3401d5dc:	9e04      	ldr	r6, [sp, #16]
3401d5de:	4652      	mov	r2, sl
3401d5e0:	e72f      	b.n	3401d442 <_dtoa_r+0x632>
3401d5e2:	1ae2      	subs	r2, r4, r3
3401d5e4:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
3401d5e6:	9e04      	ldr	r6, [sp, #16]
3401d5e8:	4413      	add	r3, r2
3401d5ea:	4652      	mov	r2, sl
3401d5ec:	930a      	str	r3, [sp, #40]	@ 0x28
3401d5ee:	4623      	mov	r3, r4
3401d5f0:	2400      	movs	r4, #0
3401d5f2:	e726      	b.n	3401d442 <_dtoa_r+0x632>
3401d5f4:	9a04      	ldr	r2, [sp, #16]
3401d5f6:	eba2 060a 	sub.w	r6, r2, sl
3401d5fa:	2200      	movs	r2, #0
3401d5fc:	e721      	b.n	3401d442 <_dtoa_r+0x632>
3401d5fe:	461c      	mov	r4, r3
3401d600:	9e04      	ldr	r6, [sp, #16]
3401d602:	9d08      	ldr	r5, [sp, #32]
3401d604:	e72a      	b.n	3401d45c <_dtoa_r+0x64c>
3401d606:	9a01      	ldr	r2, [sp, #4]
3401d608:	9205      	str	r2, [sp, #20]
3401d60a:	e752      	b.n	3401d4b2 <_dtoa_r+0x6a2>
3401d60c:	461a      	mov	r2, r3
3401d60e:	9901      	ldr	r1, [sp, #4]
3401d610:	e751      	b.n	3401d4b6 <_dtoa_r+0x6a6>
3401d612:	9b05      	ldr	r3, [sp, #20]
3401d614:	9301      	str	r3, [sp, #4]
3401d616:	e752      	b.n	3401d4be <_dtoa_r+0x6ae>
3401d618:	2300      	movs	r3, #0
3401d61a:	e77b      	b.n	3401d514 <_dtoa_r+0x704>
3401d61c:	9b02      	ldr	r3, [sp, #8]
3401d61e:	e779      	b.n	3401d514 <_dtoa_r+0x704>
3401d620:	920b      	str	r2, [sp, #44]	@ 0x2c
3401d622:	e778      	b.n	3401d516 <_dtoa_r+0x706>
3401d624:	2300      	movs	r3, #0
3401d626:	930b      	str	r3, [sp, #44]	@ 0x2c
3401d628:	e779      	b.n	3401d51e <_dtoa_r+0x70e>
3401d62a:	d093      	beq.n	3401d554 <_dtoa_r+0x744>
3401d62c:	321c      	adds	r2, #28
3401d62e:	9b04      	ldr	r3, [sp, #16]
3401d630:	4413      	add	r3, r2
3401d632:	4416      	add	r6, r2
3401d634:	9304      	str	r3, [sp, #16]
3401d636:	9b06      	ldr	r3, [sp, #24]
3401d638:	4413      	add	r3, r2
3401d63a:	e78a      	b.n	3401d552 <_dtoa_r+0x742>
3401d63c:	4602      	mov	r2, r0
3401d63e:	e7f5      	b.n	3401d62c <_dtoa_r+0x81c>
3401d640:	f1ba 0f00 	cmp.w	sl, #0
3401d644:	46d3      	mov	fp, sl
3401d646:	f8cd 8014 	str.w	r8, [sp, #20]
3401d64a:	dc21      	bgt.n	3401d690 <_dtoa_r+0x880>
3401d64c:	9b07      	ldr	r3, [sp, #28]
3401d64e:	2b02      	cmp	r3, #2
3401d650:	dd1e      	ble.n	3401d690 <_dtoa_r+0x880>
3401d652:	f1bb 0f00 	cmp.w	fp, #0
3401d656:	f47f addc 	bne.w	3401d212 <_dtoa_r+0x402>
3401d65a:	4621      	mov	r1, r4
3401d65c:	465b      	mov	r3, fp
3401d65e:	2205      	movs	r2, #5
3401d660:	4648      	mov	r0, r9
3401d662:	f000 f9df 	bl	3401da24 <__multadd>
3401d666:	4601      	mov	r1, r0
3401d668:	4604      	mov	r4, r0
3401d66a:	9801      	ldr	r0, [sp, #4]
3401d66c:	f000 fbee 	bl	3401de4c <__mcmp>
3401d670:	2800      	cmp	r0, #0
3401d672:	f77f adce 	ble.w	3401d212 <_dtoa_r+0x402>
3401d676:	2331      	movs	r3, #49	@ 0x31
3401d678:	463e      	mov	r6, r7
3401d67a:	f806 3b01 	strb.w	r3, [r6], #1
3401d67e:	9b05      	ldr	r3, [sp, #20]
3401d680:	3301      	adds	r3, #1
3401d682:	9305      	str	r3, [sp, #20]
3401d684:	e5c9      	b.n	3401d21a <_dtoa_r+0x40a>
3401d686:	4654      	mov	r4, sl
3401d688:	f8cd 8014 	str.w	r8, [sp, #20]
3401d68c:	4625      	mov	r5, r4
3401d68e:	e7f2      	b.n	3401d676 <_dtoa_r+0x866>
3401d690:	9b08      	ldr	r3, [sp, #32]
3401d692:	2b00      	cmp	r3, #0
3401d694:	f000 8102 	beq.w	3401d89c <_dtoa_r+0xa8c>
3401d698:	2e00      	cmp	r6, #0
3401d69a:	dd05      	ble.n	3401d6a8 <_dtoa_r+0x898>
3401d69c:	4629      	mov	r1, r5
3401d69e:	4632      	mov	r2, r6
3401d6a0:	4648      	mov	r0, r9
3401d6a2:	f000 fb67 	bl	3401dd74 <__lshift>
3401d6a6:	4605      	mov	r5, r0
3401d6a8:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
3401d6aa:	2b00      	cmp	r3, #0
3401d6ac:	d058      	beq.n	3401d760 <_dtoa_r+0x950>
3401d6ae:	6869      	ldr	r1, [r5, #4]
3401d6b0:	4648      	mov	r0, r9
3401d6b2:	f000 f955 	bl	3401d960 <_Balloc>
3401d6b6:	4606      	mov	r6, r0
3401d6b8:	b928      	cbnz	r0, 3401d6c6 <_dtoa_r+0x8b6>
3401d6ba:	4b82      	ldr	r3, [pc, #520]	@ (3401d8c4 <_dtoa_r+0xab4>)
3401d6bc:	4602      	mov	r2, r0
3401d6be:	f240 21ef 	movw	r1, #751	@ 0x2ef
3401d6c2:	f7ff bbbe 	b.w	3401ce42 <_dtoa_r+0x32>
3401d6c6:	692a      	ldr	r2, [r5, #16]
3401d6c8:	f105 010c 	add.w	r1, r5, #12
3401d6cc:	300c      	adds	r0, #12
3401d6ce:	3202      	adds	r2, #2
3401d6d0:	0092      	lsls	r2, r2, #2
3401d6d2:	f7ff fafa 	bl	3401ccca <memcpy>
3401d6d6:	2201      	movs	r2, #1
3401d6d8:	4631      	mov	r1, r6
3401d6da:	4648      	mov	r0, r9
3401d6dc:	f000 fb4a 	bl	3401dd74 <__lshift>
3401d6e0:	1c7b      	adds	r3, r7, #1
3401d6e2:	46a8      	mov	r8, r5
3401d6e4:	4605      	mov	r5, r0
3401d6e6:	9304      	str	r3, [sp, #16]
3401d6e8:	eb07 030b 	add.w	r3, r7, fp
3401d6ec:	9309      	str	r3, [sp, #36]	@ 0x24
3401d6ee:	9b02      	ldr	r3, [sp, #8]
3401d6f0:	f003 0301 	and.w	r3, r3, #1
3401d6f4:	9308      	str	r3, [sp, #32]
3401d6f6:	9b04      	ldr	r3, [sp, #16]
3401d6f8:	4621      	mov	r1, r4
3401d6fa:	9801      	ldr	r0, [sp, #4]
3401d6fc:	f103 3bff 	add.w	fp, r3, #4294967295	@ 0xffffffff
3401d700:	f7ff faf7 	bl	3401ccf2 <quorem>
3401d704:	4641      	mov	r1, r8
3401d706:	9002      	str	r0, [sp, #8]
3401d708:	f100 0a30 	add.w	sl, r0, #48	@ 0x30
3401d70c:	9801      	ldr	r0, [sp, #4]
3401d70e:	f000 fb9d 	bl	3401de4c <__mcmp>
3401d712:	462a      	mov	r2, r5
3401d714:	9006      	str	r0, [sp, #24]
3401d716:	4621      	mov	r1, r4
3401d718:	4648      	mov	r0, r9
3401d71a:	f000 fbb3 	bl	3401de84 <__mdiff>
3401d71e:	68c2      	ldr	r2, [r0, #12]
3401d720:	4606      	mov	r6, r0
3401d722:	b9fa      	cbnz	r2, 3401d764 <_dtoa_r+0x954>
3401d724:	4601      	mov	r1, r0
3401d726:	9801      	ldr	r0, [sp, #4]
3401d728:	f000 fb90 	bl	3401de4c <__mcmp>
3401d72c:	4602      	mov	r2, r0
3401d72e:	4631      	mov	r1, r6
3401d730:	4648      	mov	r0, r9
3401d732:	920a      	str	r2, [sp, #40]	@ 0x28
3401d734:	f000 f954 	bl	3401d9e0 <_Bfree>
3401d738:	9b07      	ldr	r3, [sp, #28]
3401d73a:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
3401d73c:	9e04      	ldr	r6, [sp, #16]
3401d73e:	ea42 0103 	orr.w	r1, r2, r3
3401d742:	9b08      	ldr	r3, [sp, #32]
3401d744:	4319      	orrs	r1, r3
3401d746:	d10f      	bne.n	3401d768 <_dtoa_r+0x958>
3401d748:	f1ba 0f39 	cmp.w	sl, #57	@ 0x39
3401d74c:	d028      	beq.n	3401d7a0 <_dtoa_r+0x990>
3401d74e:	9b06      	ldr	r3, [sp, #24]
3401d750:	2b00      	cmp	r3, #0
3401d752:	dd02      	ble.n	3401d75a <_dtoa_r+0x94a>
3401d754:	9b02      	ldr	r3, [sp, #8]
3401d756:	f103 0a31 	add.w	sl, r3, #49	@ 0x31
3401d75a:	f88b a000 	strb.w	sl, [fp]
3401d75e:	e55e      	b.n	3401d21e <_dtoa_r+0x40e>
3401d760:	4628      	mov	r0, r5
3401d762:	e7bd      	b.n	3401d6e0 <_dtoa_r+0x8d0>
3401d764:	2201      	movs	r2, #1
3401d766:	e7e2      	b.n	3401d72e <_dtoa_r+0x91e>
3401d768:	9b06      	ldr	r3, [sp, #24]
3401d76a:	2b00      	cmp	r3, #0
3401d76c:	db04      	blt.n	3401d778 <_dtoa_r+0x968>
3401d76e:	9907      	ldr	r1, [sp, #28]
3401d770:	430b      	orrs	r3, r1
3401d772:	9908      	ldr	r1, [sp, #32]
3401d774:	430b      	orrs	r3, r1
3401d776:	d120      	bne.n	3401d7ba <_dtoa_r+0x9aa>
3401d778:	2a00      	cmp	r2, #0
3401d77a:	ddee      	ble.n	3401d75a <_dtoa_r+0x94a>
3401d77c:	2201      	movs	r2, #1
3401d77e:	9901      	ldr	r1, [sp, #4]
3401d780:	4648      	mov	r0, r9
3401d782:	f000 faf7 	bl	3401dd74 <__lshift>
3401d786:	4621      	mov	r1, r4
3401d788:	9001      	str	r0, [sp, #4]
3401d78a:	f000 fb5f 	bl	3401de4c <__mcmp>
3401d78e:	2800      	cmp	r0, #0
3401d790:	dc03      	bgt.n	3401d79a <_dtoa_r+0x98a>
3401d792:	d1e2      	bne.n	3401d75a <_dtoa_r+0x94a>
3401d794:	f01a 0f01 	tst.w	sl, #1
3401d798:	d0df      	beq.n	3401d75a <_dtoa_r+0x94a>
3401d79a:	f1ba 0f39 	cmp.w	sl, #57	@ 0x39
3401d79e:	d1d9      	bne.n	3401d754 <_dtoa_r+0x944>
3401d7a0:	2339      	movs	r3, #57	@ 0x39
3401d7a2:	f88b 3000 	strb.w	r3, [fp]
3401d7a6:	4633      	mov	r3, r6
3401d7a8:	461e      	mov	r6, r3
3401d7aa:	3b01      	subs	r3, #1
3401d7ac:	f816 2c01 	ldrb.w	r2, [r6, #-1]
3401d7b0:	2a39      	cmp	r2, #57	@ 0x39
3401d7b2:	d052      	beq.n	3401d85a <_dtoa_r+0xa4a>
3401d7b4:	3201      	adds	r2, #1
3401d7b6:	701a      	strb	r2, [r3, #0]
3401d7b8:	e531      	b.n	3401d21e <_dtoa_r+0x40e>
3401d7ba:	2a00      	cmp	r2, #0
3401d7bc:	dd07      	ble.n	3401d7ce <_dtoa_r+0x9be>
3401d7be:	f1ba 0f39 	cmp.w	sl, #57	@ 0x39
3401d7c2:	d0ed      	beq.n	3401d7a0 <_dtoa_r+0x990>
3401d7c4:	f10a 0301 	add.w	r3, sl, #1
3401d7c8:	f88b 3000 	strb.w	r3, [fp]
3401d7cc:	e527      	b.n	3401d21e <_dtoa_r+0x40e>
3401d7ce:	9b04      	ldr	r3, [sp, #16]
3401d7d0:	9a09      	ldr	r2, [sp, #36]	@ 0x24
3401d7d2:	f803 ac01 	strb.w	sl, [r3, #-1]
3401d7d6:	4293      	cmp	r3, r2
3401d7d8:	d029      	beq.n	3401d82e <_dtoa_r+0xa1e>
3401d7da:	2300      	movs	r3, #0
3401d7dc:	220a      	movs	r2, #10
3401d7de:	9901      	ldr	r1, [sp, #4]
3401d7e0:	4648      	mov	r0, r9
3401d7e2:	f000 f91f 	bl	3401da24 <__multadd>
3401d7e6:	45a8      	cmp	r8, r5
3401d7e8:	9001      	str	r0, [sp, #4]
3401d7ea:	f04f 0300 	mov.w	r3, #0
3401d7ee:	f04f 020a 	mov.w	r2, #10
3401d7f2:	4641      	mov	r1, r8
3401d7f4:	4648      	mov	r0, r9
3401d7f6:	d107      	bne.n	3401d808 <_dtoa_r+0x9f8>
3401d7f8:	f000 f914 	bl	3401da24 <__multadd>
3401d7fc:	4680      	mov	r8, r0
3401d7fe:	4605      	mov	r5, r0
3401d800:	9b04      	ldr	r3, [sp, #16]
3401d802:	3301      	adds	r3, #1
3401d804:	9304      	str	r3, [sp, #16]
3401d806:	e776      	b.n	3401d6f6 <_dtoa_r+0x8e6>
3401d808:	f000 f90c 	bl	3401da24 <__multadd>
3401d80c:	4629      	mov	r1, r5
3401d80e:	4680      	mov	r8, r0
3401d810:	2300      	movs	r3, #0
3401d812:	220a      	movs	r2, #10
3401d814:	4648      	mov	r0, r9
3401d816:	f000 f905 	bl	3401da24 <__multadd>
3401d81a:	4605      	mov	r5, r0
3401d81c:	e7f0      	b.n	3401d800 <_dtoa_r+0x9f0>
3401d81e:	f1bb 0f00 	cmp.w	fp, #0
3401d822:	f04f 0800 	mov.w	r8, #0
3401d826:	bfcc      	ite	gt
3401d828:	465e      	movgt	r6, fp
3401d82a:	2601      	movle	r6, #1
3401d82c:	443e      	add	r6, r7
3401d82e:	2201      	movs	r2, #1
3401d830:	9901      	ldr	r1, [sp, #4]
3401d832:	4648      	mov	r0, r9
3401d834:	f000 fa9e 	bl	3401dd74 <__lshift>
3401d838:	4621      	mov	r1, r4
3401d83a:	9001      	str	r0, [sp, #4]
3401d83c:	f000 fb06 	bl	3401de4c <__mcmp>
3401d840:	2800      	cmp	r0, #0
3401d842:	dcb0      	bgt.n	3401d7a6 <_dtoa_r+0x996>
3401d844:	d102      	bne.n	3401d84c <_dtoa_r+0xa3c>
3401d846:	f01a 0f01 	tst.w	sl, #1
3401d84a:	d1ac      	bne.n	3401d7a6 <_dtoa_r+0x996>
3401d84c:	4633      	mov	r3, r6
3401d84e:	461e      	mov	r6, r3
3401d850:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
3401d854:	2a30      	cmp	r2, #48	@ 0x30
3401d856:	d0fa      	beq.n	3401d84e <_dtoa_r+0xa3e>
3401d858:	e4e1      	b.n	3401d21e <_dtoa_r+0x40e>
3401d85a:	429f      	cmp	r7, r3
3401d85c:	d1a4      	bne.n	3401d7a8 <_dtoa_r+0x998>
3401d85e:	9b05      	ldr	r3, [sp, #20]
3401d860:	3301      	adds	r3, #1
3401d862:	9305      	str	r3, [sp, #20]
3401d864:	2331      	movs	r3, #49	@ 0x31
3401d866:	703b      	strb	r3, [r7, #0]
3401d868:	e4d9      	b.n	3401d21e <_dtoa_r+0x40e>
3401d86a:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
3401d86c:	4f16      	ldr	r7, [pc, #88]	@ (3401d8c8 <_dtoa_r+0xab8>)
3401d86e:	b11b      	cbz	r3, 3401d878 <_dtoa_r+0xa68>
3401d870:	f107 0308 	add.w	r3, r7, #8
3401d874:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
3401d876:	6013      	str	r3, [r2, #0]
3401d878:	4638      	mov	r0, r7
3401d87a:	b011      	add	sp, #68	@ 0x44
3401d87c:	ecbd 8b02 	vpop	{d8}
3401d880:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401d884:	9b07      	ldr	r3, [sp, #28]
3401d886:	2b01      	cmp	r3, #1
3401d888:	f77f ae2c 	ble.w	3401d4e4 <_dtoa_r+0x6d4>
3401d88c:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
3401d88e:	930b      	str	r3, [sp, #44]	@ 0x2c
3401d890:	2001      	movs	r0, #1
3401d892:	e64c      	b.n	3401d52e <_dtoa_r+0x71e>
3401d894:	f1bb 0f00 	cmp.w	fp, #0
3401d898:	f77f aed8 	ble.w	3401d64c <_dtoa_r+0x83c>
3401d89c:	463e      	mov	r6, r7
3401d89e:	4621      	mov	r1, r4
3401d8a0:	9801      	ldr	r0, [sp, #4]
3401d8a2:	f7ff fa26 	bl	3401ccf2 <quorem>
3401d8a6:	f100 0a30 	add.w	sl, r0, #48	@ 0x30
3401d8aa:	f806 ab01 	strb.w	sl, [r6], #1
3401d8ae:	1bf2      	subs	r2, r6, r7
3401d8b0:	4593      	cmp	fp, r2
3401d8b2:	ddb4      	ble.n	3401d81e <_dtoa_r+0xa0e>
3401d8b4:	2300      	movs	r3, #0
3401d8b6:	220a      	movs	r2, #10
3401d8b8:	9901      	ldr	r1, [sp, #4]
3401d8ba:	4648      	mov	r0, r9
3401d8bc:	f000 f8b2 	bl	3401da24 <__multadd>
3401d8c0:	9001      	str	r0, [sp, #4]
3401d8c2:	e7ec      	b.n	3401d89e <_dtoa_r+0xa8e>
3401d8c4:	34020980 	.word	0x34020980
3401d8c8:	34020904 	.word	0x34020904

3401d8cc <_free_r>:
3401d8cc:	b538      	push	{r3, r4, r5, lr}
3401d8ce:	4605      	mov	r5, r0
3401d8d0:	2900      	cmp	r1, #0
3401d8d2:	d041      	beq.n	3401d958 <_free_r+0x8c>
3401d8d4:	f851 3c04 	ldr.w	r3, [r1, #-4]
3401d8d8:	1f0c      	subs	r4, r1, #4
3401d8da:	2b00      	cmp	r3, #0
3401d8dc:	bfb8      	it	lt
3401d8de:	18e4      	addlt	r4, r4, r3
3401d8e0:	f7fe f844 	bl	3401b96c <__malloc_lock>
3401d8e4:	4a1d      	ldr	r2, [pc, #116]	@ (3401d95c <_free_r+0x90>)
3401d8e6:	6813      	ldr	r3, [r2, #0]
3401d8e8:	b933      	cbnz	r3, 3401d8f8 <_free_r+0x2c>
3401d8ea:	6063      	str	r3, [r4, #4]
3401d8ec:	6014      	str	r4, [r2, #0]
3401d8ee:	4628      	mov	r0, r5
3401d8f0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
3401d8f4:	f7fe b840 	b.w	3401b978 <__malloc_unlock>
3401d8f8:	42a3      	cmp	r3, r4
3401d8fa:	d908      	bls.n	3401d90e <_free_r+0x42>
3401d8fc:	6820      	ldr	r0, [r4, #0]
3401d8fe:	1821      	adds	r1, r4, r0
3401d900:	428b      	cmp	r3, r1
3401d902:	bf01      	itttt	eq
3401d904:	6819      	ldreq	r1, [r3, #0]
3401d906:	685b      	ldreq	r3, [r3, #4]
3401d908:	1809      	addeq	r1, r1, r0
3401d90a:	6021      	streq	r1, [r4, #0]
3401d90c:	e7ed      	b.n	3401d8ea <_free_r+0x1e>
3401d90e:	461a      	mov	r2, r3
3401d910:	685b      	ldr	r3, [r3, #4]
3401d912:	b10b      	cbz	r3, 3401d918 <_free_r+0x4c>
3401d914:	42a3      	cmp	r3, r4
3401d916:	d9fa      	bls.n	3401d90e <_free_r+0x42>
3401d918:	6811      	ldr	r1, [r2, #0]
3401d91a:	1850      	adds	r0, r2, r1
3401d91c:	42a0      	cmp	r0, r4
3401d91e:	d10b      	bne.n	3401d938 <_free_r+0x6c>
3401d920:	6820      	ldr	r0, [r4, #0]
3401d922:	4401      	add	r1, r0
3401d924:	1850      	adds	r0, r2, r1
3401d926:	6011      	str	r1, [r2, #0]
3401d928:	4283      	cmp	r3, r0
3401d92a:	d1e0      	bne.n	3401d8ee <_free_r+0x22>
3401d92c:	6818      	ldr	r0, [r3, #0]
3401d92e:	685b      	ldr	r3, [r3, #4]
3401d930:	4408      	add	r0, r1
3401d932:	6053      	str	r3, [r2, #4]
3401d934:	6010      	str	r0, [r2, #0]
3401d936:	e7da      	b.n	3401d8ee <_free_r+0x22>
3401d938:	d902      	bls.n	3401d940 <_free_r+0x74>
3401d93a:	230c      	movs	r3, #12
3401d93c:	602b      	str	r3, [r5, #0]
3401d93e:	e7d6      	b.n	3401d8ee <_free_r+0x22>
3401d940:	6820      	ldr	r0, [r4, #0]
3401d942:	1821      	adds	r1, r4, r0
3401d944:	428b      	cmp	r3, r1
3401d946:	bf02      	ittt	eq
3401d948:	6819      	ldreq	r1, [r3, #0]
3401d94a:	685b      	ldreq	r3, [r3, #4]
3401d94c:	1809      	addeq	r1, r1, r0
3401d94e:	6063      	str	r3, [r4, #4]
3401d950:	bf08      	it	eq
3401d952:	6021      	streq	r1, [r4, #0]
3401d954:	6054      	str	r4, [r2, #4]
3401d956:	e7ca      	b.n	3401d8ee <_free_r+0x22>
3401d958:	bd38      	pop	{r3, r4, r5, pc}
3401d95a:	bf00      	nop
3401d95c:	340213b4 	.word	0x340213b4

3401d960 <_Balloc>:
3401d960:	b570      	push	{r4, r5, r6, lr}
3401d962:	69c6      	ldr	r6, [r0, #28]
3401d964:	4604      	mov	r4, r0
3401d966:	460d      	mov	r5, r1
3401d968:	b976      	cbnz	r6, 3401d988 <_Balloc+0x28>
3401d96a:	2010      	movs	r0, #16
3401d96c:	f7fd ff4c 	bl	3401b808 <malloc>
3401d970:	4602      	mov	r2, r0
3401d972:	61e0      	str	r0, [r4, #28]
3401d974:	b920      	cbnz	r0, 3401d980 <_Balloc+0x20>
3401d976:	4b18      	ldr	r3, [pc, #96]	@ (3401d9d8 <_Balloc+0x78>)
3401d978:	216b      	movs	r1, #107	@ 0x6b
3401d97a:	4818      	ldr	r0, [pc, #96]	@ (3401d9dc <_Balloc+0x7c>)
3401d97c:	f7fd ff26 	bl	3401b7cc <__assert_func>
3401d980:	e9c0 6601 	strd	r6, r6, [r0, #4]
3401d984:	6006      	str	r6, [r0, #0]
3401d986:	60c6      	str	r6, [r0, #12]
3401d988:	69e6      	ldr	r6, [r4, #28]
3401d98a:	68f3      	ldr	r3, [r6, #12]
3401d98c:	b183      	cbz	r3, 3401d9b0 <_Balloc+0x50>
3401d98e:	69e3      	ldr	r3, [r4, #28]
3401d990:	68db      	ldr	r3, [r3, #12]
3401d992:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
3401d996:	b9b8      	cbnz	r0, 3401d9c8 <_Balloc+0x68>
3401d998:	2101      	movs	r1, #1
3401d99a:	4620      	mov	r0, r4
3401d99c:	fa01 f605 	lsl.w	r6, r1, r5
3401d9a0:	1d72      	adds	r2, r6, #5
3401d9a2:	0092      	lsls	r2, r2, #2
3401d9a4:	f000 fd68 	bl	3401e478 <_calloc_r>
3401d9a8:	b160      	cbz	r0, 3401d9c4 <_Balloc+0x64>
3401d9aa:	e9c0 5601 	strd	r5, r6, [r0, #4]
3401d9ae:	e00e      	b.n	3401d9ce <_Balloc+0x6e>
3401d9b0:	2221      	movs	r2, #33	@ 0x21
3401d9b2:	2104      	movs	r1, #4
3401d9b4:	4620      	mov	r0, r4
3401d9b6:	f000 fd5f 	bl	3401e478 <_calloc_r>
3401d9ba:	69e3      	ldr	r3, [r4, #28]
3401d9bc:	60f0      	str	r0, [r6, #12]
3401d9be:	68db      	ldr	r3, [r3, #12]
3401d9c0:	2b00      	cmp	r3, #0
3401d9c2:	d1e4      	bne.n	3401d98e <_Balloc+0x2e>
3401d9c4:	2000      	movs	r0, #0
3401d9c6:	bd70      	pop	{r4, r5, r6, pc}
3401d9c8:	6802      	ldr	r2, [r0, #0]
3401d9ca:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
3401d9ce:	2300      	movs	r3, #0
3401d9d0:	e9c0 3303 	strd	r3, r3, [r0, #12]
3401d9d4:	e7f7      	b.n	3401d9c6 <_Balloc+0x66>
3401d9d6:	bf00      	nop
3401d9d8:	34020911 	.word	0x34020911
3401d9dc:	34020991 	.word	0x34020991

3401d9e0 <_Bfree>:
3401d9e0:	b570      	push	{r4, r5, r6, lr}
3401d9e2:	69c6      	ldr	r6, [r0, #28]
3401d9e4:	4605      	mov	r5, r0
3401d9e6:	460c      	mov	r4, r1
3401d9e8:	b976      	cbnz	r6, 3401da08 <_Bfree+0x28>
3401d9ea:	2010      	movs	r0, #16
3401d9ec:	f7fd ff0c 	bl	3401b808 <malloc>
3401d9f0:	4602      	mov	r2, r0
3401d9f2:	61e8      	str	r0, [r5, #28]
3401d9f4:	b920      	cbnz	r0, 3401da00 <_Bfree+0x20>
3401d9f6:	4b09      	ldr	r3, [pc, #36]	@ (3401da1c <_Bfree+0x3c>)
3401d9f8:	218f      	movs	r1, #143	@ 0x8f
3401d9fa:	4809      	ldr	r0, [pc, #36]	@ (3401da20 <_Bfree+0x40>)
3401d9fc:	f7fd fee6 	bl	3401b7cc <__assert_func>
3401da00:	e9c0 6601 	strd	r6, r6, [r0, #4]
3401da04:	6006      	str	r6, [r0, #0]
3401da06:	60c6      	str	r6, [r0, #12]
3401da08:	b13c      	cbz	r4, 3401da1a <_Bfree+0x3a>
3401da0a:	69eb      	ldr	r3, [r5, #28]
3401da0c:	6862      	ldr	r2, [r4, #4]
3401da0e:	68db      	ldr	r3, [r3, #12]
3401da10:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
3401da14:	6021      	str	r1, [r4, #0]
3401da16:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
3401da1a:	bd70      	pop	{r4, r5, r6, pc}
3401da1c:	34020911 	.word	0x34020911
3401da20:	34020991 	.word	0x34020991

3401da24 <__multadd>:
3401da24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3401da28:	f101 0c14 	add.w	ip, r1, #20
3401da2c:	4607      	mov	r7, r0
3401da2e:	460c      	mov	r4, r1
3401da30:	461e      	mov	r6, r3
3401da32:	690d      	ldr	r5, [r1, #16]
3401da34:	2000      	movs	r0, #0
3401da36:	f8dc 3000 	ldr.w	r3, [ip]
3401da3a:	3001      	adds	r0, #1
3401da3c:	b299      	uxth	r1, r3
3401da3e:	4285      	cmp	r5, r0
3401da40:	fb02 6101 	mla	r1, r2, r1, r6
3401da44:	ea4f 4613 	mov.w	r6, r3, lsr #16
3401da48:	ea4f 4311 	mov.w	r3, r1, lsr #16
3401da4c:	b289      	uxth	r1, r1
3401da4e:	fb02 3306 	mla	r3, r2, r6, r3
3401da52:	eb01 4103 	add.w	r1, r1, r3, lsl #16
3401da56:	ea4f 4613 	mov.w	r6, r3, lsr #16
3401da5a:	f84c 1b04 	str.w	r1, [ip], #4
3401da5e:	dcea      	bgt.n	3401da36 <__multadd+0x12>
3401da60:	b30e      	cbz	r6, 3401daa6 <__multadd+0x82>
3401da62:	68a3      	ldr	r3, [r4, #8]
3401da64:	42ab      	cmp	r3, r5
3401da66:	dc19      	bgt.n	3401da9c <__multadd+0x78>
3401da68:	6861      	ldr	r1, [r4, #4]
3401da6a:	4638      	mov	r0, r7
3401da6c:	3101      	adds	r1, #1
3401da6e:	f7ff ff77 	bl	3401d960 <_Balloc>
3401da72:	4680      	mov	r8, r0
3401da74:	b928      	cbnz	r0, 3401da82 <__multadd+0x5e>
3401da76:	4602      	mov	r2, r0
3401da78:	4b0c      	ldr	r3, [pc, #48]	@ (3401daac <__multadd+0x88>)
3401da7a:	21ba      	movs	r1, #186	@ 0xba
3401da7c:	480c      	ldr	r0, [pc, #48]	@ (3401dab0 <__multadd+0x8c>)
3401da7e:	f7fd fea5 	bl	3401b7cc <__assert_func>
3401da82:	6922      	ldr	r2, [r4, #16]
3401da84:	f104 010c 	add.w	r1, r4, #12
3401da88:	300c      	adds	r0, #12
3401da8a:	3202      	adds	r2, #2
3401da8c:	0092      	lsls	r2, r2, #2
3401da8e:	f7ff f91c 	bl	3401ccca <memcpy>
3401da92:	4621      	mov	r1, r4
3401da94:	4644      	mov	r4, r8
3401da96:	4638      	mov	r0, r7
3401da98:	f7ff ffa2 	bl	3401d9e0 <_Bfree>
3401da9c:	eb04 0385 	add.w	r3, r4, r5, lsl #2
3401daa0:	3501      	adds	r5, #1
3401daa2:	615e      	str	r6, [r3, #20]
3401daa4:	6125      	str	r5, [r4, #16]
3401daa6:	4620      	mov	r0, r4
3401daa8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
3401daac:	34020980 	.word	0x34020980
3401dab0:	34020991 	.word	0x34020991

3401dab4 <__hi0bits>:
3401dab4:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
3401dab8:	4603      	mov	r3, r0
3401daba:	bf36      	itet	cc
3401dabc:	0403      	lslcc	r3, r0, #16
3401dabe:	2000      	movcs	r0, #0
3401dac0:	2010      	movcc	r0, #16
3401dac2:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
3401dac6:	bf3c      	itt	cc
3401dac8:	021b      	lslcc	r3, r3, #8
3401daca:	3008      	addcc	r0, #8
3401dacc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401dad0:	bf3c      	itt	cc
3401dad2:	011b      	lslcc	r3, r3, #4
3401dad4:	3004      	addcc	r0, #4
3401dad6:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3401dada:	bf3c      	itt	cc
3401dadc:	009b      	lslcc	r3, r3, #2
3401dade:	3002      	addcc	r0, #2
3401dae0:	2b00      	cmp	r3, #0
3401dae2:	db05      	blt.n	3401daf0 <__hi0bits+0x3c>
3401dae4:	f013 4f80 	tst.w	r3, #1073741824	@ 0x40000000
3401dae8:	f100 0001 	add.w	r0, r0, #1
3401daec:	bf08      	it	eq
3401daee:	2020      	moveq	r0, #32
3401daf0:	4770      	bx	lr

3401daf2 <__lo0bits>:
3401daf2:	6803      	ldr	r3, [r0, #0]
3401daf4:	4602      	mov	r2, r0
3401daf6:	f013 0007 	ands.w	r0, r3, #7
3401dafa:	d00b      	beq.n	3401db14 <__lo0bits+0x22>
3401dafc:	07d9      	lsls	r1, r3, #31
3401dafe:	d421      	bmi.n	3401db44 <__lo0bits+0x52>
3401db00:	0798      	lsls	r0, r3, #30
3401db02:	bf47      	ittee	mi
3401db04:	085b      	lsrmi	r3, r3, #1
3401db06:	2001      	movmi	r0, #1
3401db08:	089b      	lsrpl	r3, r3, #2
3401db0a:	2002      	movpl	r0, #2
3401db0c:	bf4c      	ite	mi
3401db0e:	6013      	strmi	r3, [r2, #0]
3401db10:	6013      	strpl	r3, [r2, #0]
3401db12:	4770      	bx	lr
3401db14:	b299      	uxth	r1, r3
3401db16:	b909      	cbnz	r1, 3401db1c <__lo0bits+0x2a>
3401db18:	0c1b      	lsrs	r3, r3, #16
3401db1a:	2010      	movs	r0, #16
3401db1c:	b2d9      	uxtb	r1, r3
3401db1e:	b909      	cbnz	r1, 3401db24 <__lo0bits+0x32>
3401db20:	3008      	adds	r0, #8
3401db22:	0a1b      	lsrs	r3, r3, #8
3401db24:	0719      	lsls	r1, r3, #28
3401db26:	bf04      	itt	eq
3401db28:	091b      	lsreq	r3, r3, #4
3401db2a:	3004      	addeq	r0, #4
3401db2c:	0799      	lsls	r1, r3, #30
3401db2e:	bf04      	itt	eq
3401db30:	089b      	lsreq	r3, r3, #2
3401db32:	3002      	addeq	r0, #2
3401db34:	07d9      	lsls	r1, r3, #31
3401db36:	d403      	bmi.n	3401db40 <__lo0bits+0x4e>
3401db38:	085b      	lsrs	r3, r3, #1
3401db3a:	f100 0001 	add.w	r0, r0, #1
3401db3e:	d003      	beq.n	3401db48 <__lo0bits+0x56>
3401db40:	6013      	str	r3, [r2, #0]
3401db42:	4770      	bx	lr
3401db44:	2000      	movs	r0, #0
3401db46:	4770      	bx	lr
3401db48:	2020      	movs	r0, #32
3401db4a:	4770      	bx	lr

3401db4c <__i2b>:
3401db4c:	b510      	push	{r4, lr}
3401db4e:	460c      	mov	r4, r1
3401db50:	2101      	movs	r1, #1
3401db52:	f7ff ff05 	bl	3401d960 <_Balloc>
3401db56:	4602      	mov	r2, r0
3401db58:	b928      	cbnz	r0, 3401db66 <__i2b+0x1a>
3401db5a:	4b05      	ldr	r3, [pc, #20]	@ (3401db70 <__i2b+0x24>)
3401db5c:	f240 1145 	movw	r1, #325	@ 0x145
3401db60:	4804      	ldr	r0, [pc, #16]	@ (3401db74 <__i2b+0x28>)
3401db62:	f7fd fe33 	bl	3401b7cc <__assert_func>
3401db66:	2301      	movs	r3, #1
3401db68:	6144      	str	r4, [r0, #20]
3401db6a:	6103      	str	r3, [r0, #16]
3401db6c:	bd10      	pop	{r4, pc}
3401db6e:	bf00      	nop
3401db70:	34020980 	.word	0x34020980
3401db74:	34020991 	.word	0x34020991

3401db78 <__multiply>:
3401db78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401db7c:	4617      	mov	r7, r2
3401db7e:	690a      	ldr	r2, [r1, #16]
3401db80:	4689      	mov	r9, r1
3401db82:	b085      	sub	sp, #20
3401db84:	693b      	ldr	r3, [r7, #16]
3401db86:	429a      	cmp	r2, r3
3401db88:	bfa2      	ittt	ge
3401db8a:	463b      	movge	r3, r7
3401db8c:	460f      	movge	r7, r1
3401db8e:	4699      	movge	r9, r3
3401db90:	693d      	ldr	r5, [r7, #16]
3401db92:	68bb      	ldr	r3, [r7, #8]
3401db94:	f8d9 a010 	ldr.w	sl, [r9, #16]
3401db98:	6879      	ldr	r1, [r7, #4]
3401db9a:	eb05 060a 	add.w	r6, r5, sl
3401db9e:	42b3      	cmp	r3, r6
3401dba0:	bfb8      	it	lt
3401dba2:	3101      	addlt	r1, #1
3401dba4:	f7ff fedc 	bl	3401d960 <_Balloc>
3401dba8:	b930      	cbnz	r0, 3401dbb8 <__multiply+0x40>
3401dbaa:	4602      	mov	r2, r0
3401dbac:	4b42      	ldr	r3, [pc, #264]	@ (3401dcb8 <__multiply+0x140>)
3401dbae:	f44f 71b1 	mov.w	r1, #354	@ 0x162
3401dbb2:	4842      	ldr	r0, [pc, #264]	@ (3401dcbc <__multiply+0x144>)
3401dbb4:	f7fd fe0a 	bl	3401b7cc <__assert_func>
3401dbb8:	f100 0414 	add.w	r4, r0, #20
3401dbbc:	2200      	movs	r2, #0
3401dbbe:	eb04 0e86 	add.w	lr, r4, r6, lsl #2
3401dbc2:	4623      	mov	r3, r4
3401dbc4:	4573      	cmp	r3, lr
3401dbc6:	d320      	bcc.n	3401dc0a <__multiply+0x92>
3401dbc8:	f107 0814 	add.w	r8, r7, #20
3401dbcc:	f109 0114 	add.w	r1, r9, #20
3401dbd0:	eb08 0585 	add.w	r5, r8, r5, lsl #2
3401dbd4:	eb01 038a 	add.w	r3, r1, sl, lsl #2
3401dbd8:	9302      	str	r3, [sp, #8]
3401dbda:	1beb      	subs	r3, r5, r7
3401dbdc:	3715      	adds	r7, #21
3401dbde:	3b15      	subs	r3, #21
3401dbe0:	f023 0303 	bic.w	r3, r3, #3
3401dbe4:	3304      	adds	r3, #4
3401dbe6:	42bd      	cmp	r5, r7
3401dbe8:	bf38      	it	cc
3401dbea:	2304      	movcc	r3, #4
3401dbec:	9301      	str	r3, [sp, #4]
3401dbee:	9b02      	ldr	r3, [sp, #8]
3401dbf0:	9103      	str	r1, [sp, #12]
3401dbf2:	428b      	cmp	r3, r1
3401dbf4:	d80c      	bhi.n	3401dc10 <__multiply+0x98>
3401dbf6:	2e00      	cmp	r6, #0
3401dbf8:	dd03      	ble.n	3401dc02 <__multiply+0x8a>
3401dbfa:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
3401dbfe:	2b00      	cmp	r3, #0
3401dc00:	d057      	beq.n	3401dcb2 <__multiply+0x13a>
3401dc02:	6106      	str	r6, [r0, #16]
3401dc04:	b005      	add	sp, #20
3401dc06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401dc0a:	f843 2b04 	str.w	r2, [r3], #4
3401dc0e:	e7d9      	b.n	3401dbc4 <__multiply+0x4c>
3401dc10:	f8b1 a000 	ldrh.w	sl, [r1]
3401dc14:	f1ba 0f00 	cmp.w	sl, #0
3401dc18:	d021      	beq.n	3401dc5e <__multiply+0xe6>
3401dc1a:	46c4      	mov	ip, r8
3401dc1c:	46a1      	mov	r9, r4
3401dc1e:	2700      	movs	r7, #0
3401dc20:	f85c 2b04 	ldr.w	r2, [ip], #4
3401dc24:	f8d9 3000 	ldr.w	r3, [r9]
3401dc28:	fa1f fb82 	uxth.w	fp, r2
3401dc2c:	4565      	cmp	r5, ip
3401dc2e:	b29b      	uxth	r3, r3
3401dc30:	ea4f 4212 	mov.w	r2, r2, lsr #16
3401dc34:	fb0a 330b 	mla	r3, sl, fp, r3
3401dc38:	443b      	add	r3, r7
3401dc3a:	f8d9 7000 	ldr.w	r7, [r9]
3401dc3e:	ea4f 4717 	mov.w	r7, r7, lsr #16
3401dc42:	fb0a 7202 	mla	r2, sl, r2, r7
3401dc46:	eb02 4213 	add.w	r2, r2, r3, lsr #16
3401dc4a:	b29b      	uxth	r3, r3
3401dc4c:	ea4f 4712 	mov.w	r7, r2, lsr #16
3401dc50:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
3401dc54:	f849 3b04 	str.w	r3, [r9], #4
3401dc58:	d8e2      	bhi.n	3401dc20 <__multiply+0xa8>
3401dc5a:	9b01      	ldr	r3, [sp, #4]
3401dc5c:	50e7      	str	r7, [r4, r3]
3401dc5e:	9b03      	ldr	r3, [sp, #12]
3401dc60:	3104      	adds	r1, #4
3401dc62:	f8b3 9002 	ldrh.w	r9, [r3, #2]
3401dc66:	f1b9 0f00 	cmp.w	r9, #0
3401dc6a:	d020      	beq.n	3401dcae <__multiply+0x136>
3401dc6c:	6823      	ldr	r3, [r4, #0]
3401dc6e:	4647      	mov	r7, r8
3401dc70:	46a4      	mov	ip, r4
3401dc72:	f04f 0a00 	mov.w	sl, #0
3401dc76:	f8b7 b000 	ldrh.w	fp, [r7]
3401dc7a:	b29b      	uxth	r3, r3
3401dc7c:	f8bc 2002 	ldrh.w	r2, [ip, #2]
3401dc80:	fb09 220b 	mla	r2, r9, fp, r2
3401dc84:	4452      	add	r2, sl
3401dc86:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
3401dc8a:	f84c 3b04 	str.w	r3, [ip], #4
3401dc8e:	f857 3b04 	ldr.w	r3, [r7], #4
3401dc92:	ea4f 4a13 	mov.w	sl, r3, lsr #16
3401dc96:	f8bc 3000 	ldrh.w	r3, [ip]
3401dc9a:	42bd      	cmp	r5, r7
3401dc9c:	fb09 330a 	mla	r3, r9, sl, r3
3401dca0:	eb03 4312 	add.w	r3, r3, r2, lsr #16
3401dca4:	ea4f 4a13 	mov.w	sl, r3, lsr #16
3401dca8:	d8e5      	bhi.n	3401dc76 <__multiply+0xfe>
3401dcaa:	9a01      	ldr	r2, [sp, #4]
3401dcac:	50a3      	str	r3, [r4, r2]
3401dcae:	3404      	adds	r4, #4
3401dcb0:	e79d      	b.n	3401dbee <__multiply+0x76>
3401dcb2:	3e01      	subs	r6, #1
3401dcb4:	e79f      	b.n	3401dbf6 <__multiply+0x7e>
3401dcb6:	bf00      	nop
3401dcb8:	34020980 	.word	0x34020980
3401dcbc:	34020991 	.word	0x34020991

3401dcc0 <__pow5mult>:
3401dcc0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
3401dcc4:	4615      	mov	r5, r2
3401dcc6:	f012 0203 	ands.w	r2, r2, #3
3401dcca:	4607      	mov	r7, r0
3401dccc:	460e      	mov	r6, r1
3401dcce:	d007      	beq.n	3401dce0 <__pow5mult+0x20>
3401dcd0:	3a01      	subs	r2, #1
3401dcd2:	4c25      	ldr	r4, [pc, #148]	@ (3401dd68 <__pow5mult+0xa8>)
3401dcd4:	2300      	movs	r3, #0
3401dcd6:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
3401dcda:	f7ff fea3 	bl	3401da24 <__multadd>
3401dcde:	4606      	mov	r6, r0
3401dce0:	10ad      	asrs	r5, r5, #2
3401dce2:	d03d      	beq.n	3401dd60 <__pow5mult+0xa0>
3401dce4:	69fc      	ldr	r4, [r7, #28]
3401dce6:	b97c      	cbnz	r4, 3401dd08 <__pow5mult+0x48>
3401dce8:	2010      	movs	r0, #16
3401dcea:	f7fd fd8d 	bl	3401b808 <malloc>
3401dcee:	4602      	mov	r2, r0
3401dcf0:	61f8      	str	r0, [r7, #28]
3401dcf2:	b928      	cbnz	r0, 3401dd00 <__pow5mult+0x40>
3401dcf4:	4b1d      	ldr	r3, [pc, #116]	@ (3401dd6c <__pow5mult+0xac>)
3401dcf6:	f240 11b3 	movw	r1, #435	@ 0x1b3
3401dcfa:	481d      	ldr	r0, [pc, #116]	@ (3401dd70 <__pow5mult+0xb0>)
3401dcfc:	f7fd fd66 	bl	3401b7cc <__assert_func>
3401dd00:	e9c0 4401 	strd	r4, r4, [r0, #4]
3401dd04:	6004      	str	r4, [r0, #0]
3401dd06:	60c4      	str	r4, [r0, #12]
3401dd08:	f8d7 801c 	ldr.w	r8, [r7, #28]
3401dd0c:	f8d8 4008 	ldr.w	r4, [r8, #8]
3401dd10:	b94c      	cbnz	r4, 3401dd26 <__pow5mult+0x66>
3401dd12:	f240 2171 	movw	r1, #625	@ 0x271
3401dd16:	4638      	mov	r0, r7
3401dd18:	f7ff ff18 	bl	3401db4c <__i2b>
3401dd1c:	2300      	movs	r3, #0
3401dd1e:	4604      	mov	r4, r0
3401dd20:	f8c8 0008 	str.w	r0, [r8, #8]
3401dd24:	6003      	str	r3, [r0, #0]
3401dd26:	f04f 0900 	mov.w	r9, #0
3401dd2a:	07eb      	lsls	r3, r5, #31
3401dd2c:	d50a      	bpl.n	3401dd44 <__pow5mult+0x84>
3401dd2e:	4631      	mov	r1, r6
3401dd30:	4622      	mov	r2, r4
3401dd32:	4638      	mov	r0, r7
3401dd34:	f7ff ff20 	bl	3401db78 <__multiply>
3401dd38:	4680      	mov	r8, r0
3401dd3a:	4631      	mov	r1, r6
3401dd3c:	4638      	mov	r0, r7
3401dd3e:	4646      	mov	r6, r8
3401dd40:	f7ff fe4e 	bl	3401d9e0 <_Bfree>
3401dd44:	106d      	asrs	r5, r5, #1
3401dd46:	d00b      	beq.n	3401dd60 <__pow5mult+0xa0>
3401dd48:	6820      	ldr	r0, [r4, #0]
3401dd4a:	b938      	cbnz	r0, 3401dd5c <__pow5mult+0x9c>
3401dd4c:	4622      	mov	r2, r4
3401dd4e:	4621      	mov	r1, r4
3401dd50:	4638      	mov	r0, r7
3401dd52:	f7ff ff11 	bl	3401db78 <__multiply>
3401dd56:	6020      	str	r0, [r4, #0]
3401dd58:	f8c0 9000 	str.w	r9, [r0]
3401dd5c:	4604      	mov	r4, r0
3401dd5e:	e7e4      	b.n	3401dd2a <__pow5mult+0x6a>
3401dd60:	4630      	mov	r0, r6
3401dd62:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
3401dd66:	bf00      	nop
3401dd68:	34020a08 	.word	0x34020a08
3401dd6c:	34020911 	.word	0x34020911
3401dd70:	34020991 	.word	0x34020991

3401dd74 <__lshift>:
3401dd74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
3401dd78:	460c      	mov	r4, r1
3401dd7a:	4607      	mov	r7, r0
3401dd7c:	4691      	mov	r9, r2
3401dd7e:	ea4f 1a62 	mov.w	sl, r2, asr #5
3401dd82:	6923      	ldr	r3, [r4, #16]
3401dd84:	6849      	ldr	r1, [r1, #4]
3401dd86:	eb03 1862 	add.w	r8, r3, r2, asr #5
3401dd8a:	68a3      	ldr	r3, [r4, #8]
3401dd8c:	f108 0601 	add.w	r6, r8, #1
3401dd90:	42b3      	cmp	r3, r6
3401dd92:	db0b      	blt.n	3401ddac <__lshift+0x38>
3401dd94:	4638      	mov	r0, r7
3401dd96:	f7ff fde3 	bl	3401d960 <_Balloc>
3401dd9a:	4605      	mov	r5, r0
3401dd9c:	b948      	cbnz	r0, 3401ddb2 <__lshift+0x3e>
3401dd9e:	4602      	mov	r2, r0
3401dda0:	4b28      	ldr	r3, [pc, #160]	@ (3401de44 <__lshift+0xd0>)
3401dda2:	f44f 71ef 	mov.w	r1, #478	@ 0x1de
3401dda6:	4828      	ldr	r0, [pc, #160]	@ (3401de48 <__lshift+0xd4>)
3401dda8:	f7fd fd10 	bl	3401b7cc <__assert_func>
3401ddac:	3101      	adds	r1, #1
3401ddae:	005b      	lsls	r3, r3, #1
3401ddb0:	e7ee      	b.n	3401dd90 <__lshift+0x1c>
3401ddb2:	2300      	movs	r3, #0
3401ddb4:	f100 0114 	add.w	r1, r0, #20
3401ddb8:	f100 0210 	add.w	r2, r0, #16
3401ddbc:	4618      	mov	r0, r3
3401ddbe:	4553      	cmp	r3, sl
3401ddc0:	db33      	blt.n	3401de2a <__lshift+0xb6>
3401ddc2:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
3401ddc6:	f104 0314 	add.w	r3, r4, #20
3401ddca:	6920      	ldr	r0, [r4, #16]
3401ddcc:	f019 091f 	ands.w	r9, r9, #31
3401ddd0:	eb01 018a 	add.w	r1, r1, sl, lsl #2
3401ddd4:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
3401ddd8:	d02b      	beq.n	3401de32 <__lshift+0xbe>
3401ddda:	f1c9 0e20 	rsb	lr, r9, #32
3401ddde:	468a      	mov	sl, r1
3401dde0:	2200      	movs	r2, #0
3401dde2:	6818      	ldr	r0, [r3, #0]
3401dde4:	fa00 f009 	lsl.w	r0, r0, r9
3401dde8:	4310      	orrs	r0, r2
3401ddea:	f84a 0b04 	str.w	r0, [sl], #4
3401ddee:	f853 2b04 	ldr.w	r2, [r3], #4
3401ddf2:	459c      	cmp	ip, r3
3401ddf4:	fa22 f20e 	lsr.w	r2, r2, lr
3401ddf8:	d8f3      	bhi.n	3401dde2 <__lshift+0x6e>
3401ddfa:	ebac 0304 	sub.w	r3, ip, r4
3401ddfe:	f104 0015 	add.w	r0, r4, #21
3401de02:	3b15      	subs	r3, #21
3401de04:	f023 0303 	bic.w	r3, r3, #3
3401de08:	3304      	adds	r3, #4
3401de0a:	4560      	cmp	r0, ip
3401de0c:	bf88      	it	hi
3401de0e:	2304      	movhi	r3, #4
3401de10:	50ca      	str	r2, [r1, r3]
3401de12:	b10a      	cbz	r2, 3401de18 <__lshift+0xa4>
3401de14:	f108 0602 	add.w	r6, r8, #2
3401de18:	3e01      	subs	r6, #1
3401de1a:	4638      	mov	r0, r7
3401de1c:	4621      	mov	r1, r4
3401de1e:	612e      	str	r6, [r5, #16]
3401de20:	f7ff fdde 	bl	3401d9e0 <_Bfree>
3401de24:	4628      	mov	r0, r5
3401de26:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
3401de2a:	3301      	adds	r3, #1
3401de2c:	f842 0f04 	str.w	r0, [r2, #4]!
3401de30:	e7c5      	b.n	3401ddbe <__lshift+0x4a>
3401de32:	3904      	subs	r1, #4
3401de34:	f853 2b04 	ldr.w	r2, [r3], #4
3401de38:	459c      	cmp	ip, r3
3401de3a:	f841 2f04 	str.w	r2, [r1, #4]!
3401de3e:	d8f9      	bhi.n	3401de34 <__lshift+0xc0>
3401de40:	e7ea      	b.n	3401de18 <__lshift+0xa4>
3401de42:	bf00      	nop
3401de44:	34020980 	.word	0x34020980
3401de48:	34020991 	.word	0x34020991

3401de4c <__mcmp>:
3401de4c:	4603      	mov	r3, r0
3401de4e:	690a      	ldr	r2, [r1, #16]
3401de50:	6900      	ldr	r0, [r0, #16]
3401de52:	1a80      	subs	r0, r0, r2
3401de54:	b530      	push	{r4, r5, lr}
3401de56:	d10e      	bne.n	3401de76 <__mcmp+0x2a>
3401de58:	3314      	adds	r3, #20
3401de5a:	3114      	adds	r1, #20
3401de5c:	eb03 0482 	add.w	r4, r3, r2, lsl #2
3401de60:	eb01 0182 	add.w	r1, r1, r2, lsl #2
3401de64:	f854 5d04 	ldr.w	r5, [r4, #-4]!
3401de68:	f851 2d04 	ldr.w	r2, [r1, #-4]!
3401de6c:	4295      	cmp	r5, r2
3401de6e:	d003      	beq.n	3401de78 <__mcmp+0x2c>
3401de70:	d205      	bcs.n	3401de7e <__mcmp+0x32>
3401de72:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
3401de76:	bd30      	pop	{r4, r5, pc}
3401de78:	42a3      	cmp	r3, r4
3401de7a:	d3f3      	bcc.n	3401de64 <__mcmp+0x18>
3401de7c:	e7fb      	b.n	3401de76 <__mcmp+0x2a>
3401de7e:	2001      	movs	r0, #1
3401de80:	e7f9      	b.n	3401de76 <__mcmp+0x2a>
	...

3401de84 <__mdiff>:
3401de84:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401de88:	4689      	mov	r9, r1
3401de8a:	4606      	mov	r6, r0
3401de8c:	4611      	mov	r1, r2
3401de8e:	4614      	mov	r4, r2
3401de90:	4648      	mov	r0, r9
3401de92:	f7ff ffdb 	bl	3401de4c <__mcmp>
3401de96:	1e05      	subs	r5, r0, #0
3401de98:	d112      	bne.n	3401dec0 <__mdiff+0x3c>
3401de9a:	4629      	mov	r1, r5
3401de9c:	4630      	mov	r0, r6
3401de9e:	f7ff fd5f 	bl	3401d960 <_Balloc>
3401dea2:	4602      	mov	r2, r0
3401dea4:	b928      	cbnz	r0, 3401deb2 <__mdiff+0x2e>
3401dea6:	4b41      	ldr	r3, [pc, #260]	@ (3401dfac <__mdiff+0x128>)
3401dea8:	f240 2137 	movw	r1, #567	@ 0x237
3401deac:	4840      	ldr	r0, [pc, #256]	@ (3401dfb0 <__mdiff+0x12c>)
3401deae:	f7fd fc8d 	bl	3401b7cc <__assert_func>
3401deb2:	2301      	movs	r3, #1
3401deb4:	e9c0 3504 	strd	r3, r5, [r0, #16]
3401deb8:	4610      	mov	r0, r2
3401deba:	b003      	add	sp, #12
3401debc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401dec0:	bfbc      	itt	lt
3401dec2:	464b      	movlt	r3, r9
3401dec4:	46a1      	movlt	r9, r4
3401dec6:	4630      	mov	r0, r6
3401dec8:	bfb8      	it	lt
3401deca:	2501      	movlt	r5, #1
3401decc:	f8d9 1004 	ldr.w	r1, [r9, #4]
3401ded0:	bfb4      	ite	lt
3401ded2:	461c      	movlt	r4, r3
3401ded4:	2500      	movge	r5, #0
3401ded6:	f7ff fd43 	bl	3401d960 <_Balloc>
3401deda:	4602      	mov	r2, r0
3401dedc:	b918      	cbnz	r0, 3401dee6 <__mdiff+0x62>
3401dede:	4b33      	ldr	r3, [pc, #204]	@ (3401dfac <__mdiff+0x128>)
3401dee0:	f240 2145 	movw	r1, #581	@ 0x245
3401dee4:	e7e2      	b.n	3401deac <__mdiff+0x28>
3401dee6:	f8d9 7010 	ldr.w	r7, [r9, #16]
3401deea:	f104 0e14 	add.w	lr, r4, #20
3401deee:	6926      	ldr	r6, [r4, #16]
3401def0:	f100 0b14 	add.w	fp, r0, #20
3401def4:	60c5      	str	r5, [r0, #12]
3401def6:	f109 0514 	add.w	r5, r9, #20
3401defa:	f109 0310 	add.w	r3, r9, #16
3401defe:	eb0e 0686 	add.w	r6, lr, r6, lsl #2
3401df02:	eb05 0887 	add.w	r8, r5, r7, lsl #2
3401df06:	46d9      	mov	r9, fp
3401df08:	f04f 0c00 	mov.w	ip, #0
3401df0c:	9301      	str	r3, [sp, #4]
3401df0e:	9b01      	ldr	r3, [sp, #4]
3401df10:	f85e 0b04 	ldr.w	r0, [lr], #4
3401df14:	f853 af04 	ldr.w	sl, [r3, #4]!
3401df18:	4576      	cmp	r6, lr
3401df1a:	9301      	str	r3, [sp, #4]
3401df1c:	fa1f f38a 	uxth.w	r3, sl
3401df20:	4619      	mov	r1, r3
3401df22:	b283      	uxth	r3, r0
3401df24:	ea4f 4010 	mov.w	r0, r0, lsr #16
3401df28:	eba1 0303 	sub.w	r3, r1, r3
3401df2c:	ebc0 401a 	rsb	r0, r0, sl, lsr #16
3401df30:	4463      	add	r3, ip
3401df32:	eb00 4023 	add.w	r0, r0, r3, asr #16
3401df36:	b29b      	uxth	r3, r3
3401df38:	ea4f 4c20 	mov.w	ip, r0, asr #16
3401df3c:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3401df40:	f849 3b04 	str.w	r3, [r9], #4
3401df44:	d8e3      	bhi.n	3401df0e <__mdiff+0x8a>
3401df46:	1b33      	subs	r3, r6, r4
3401df48:	3415      	adds	r4, #21
3401df4a:	3b15      	subs	r3, #21
3401df4c:	f023 0303 	bic.w	r3, r3, #3
3401df50:	3304      	adds	r3, #4
3401df52:	42a6      	cmp	r6, r4
3401df54:	bf38      	it	cc
3401df56:	2304      	movcc	r3, #4
3401df58:	441d      	add	r5, r3
3401df5a:	445b      	add	r3, fp
3401df5c:	462c      	mov	r4, r5
3401df5e:	461e      	mov	r6, r3
3401df60:	4544      	cmp	r4, r8
3401df62:	d30e      	bcc.n	3401df82 <__mdiff+0xfe>
3401df64:	f108 0103 	add.w	r1, r8, #3
3401df68:	1b49      	subs	r1, r1, r5
3401df6a:	3d03      	subs	r5, #3
3401df6c:	f021 0103 	bic.w	r1, r1, #3
3401df70:	45a8      	cmp	r8, r5
3401df72:	bf38      	it	cc
3401df74:	2100      	movcc	r1, #0
3401df76:	440b      	add	r3, r1
3401df78:	f853 1d04 	ldr.w	r1, [r3, #-4]!
3401df7c:	b199      	cbz	r1, 3401dfa6 <__mdiff+0x122>
3401df7e:	6117      	str	r7, [r2, #16]
3401df80:	e79a      	b.n	3401deb8 <__mdiff+0x34>
3401df82:	f854 1b04 	ldr.w	r1, [r4], #4
3401df86:	46e6      	mov	lr, ip
3401df88:	fa1f fc81 	uxth.w	ip, r1
3401df8c:	0c08      	lsrs	r0, r1, #16
3401df8e:	4471      	add	r1, lr
3401df90:	44f4      	add	ip, lr
3401df92:	b289      	uxth	r1, r1
3401df94:	eb00 402c 	add.w	r0, r0, ip, asr #16
3401df98:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
3401df9c:	ea4f 4c20 	mov.w	ip, r0, asr #16
3401dfa0:	f846 1b04 	str.w	r1, [r6], #4
3401dfa4:	e7dc      	b.n	3401df60 <__mdiff+0xdc>
3401dfa6:	3f01      	subs	r7, #1
3401dfa8:	e7e6      	b.n	3401df78 <__mdiff+0xf4>
3401dfaa:	bf00      	nop
3401dfac:	34020980 	.word	0x34020980
3401dfb0:	34020991 	.word	0x34020991

3401dfb4 <__d2b>:
3401dfb4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
3401dfb8:	460f      	mov	r7, r1
3401dfba:	2101      	movs	r1, #1
3401dfbc:	4616      	mov	r6, r2
3401dfbe:	ec59 8b10 	vmov	r8, r9, d0
3401dfc2:	f7ff fccd 	bl	3401d960 <_Balloc>
3401dfc6:	4604      	mov	r4, r0
3401dfc8:	b930      	cbnz	r0, 3401dfd8 <__d2b+0x24>
3401dfca:	4602      	mov	r2, r0
3401dfcc:	4b23      	ldr	r3, [pc, #140]	@ (3401e05c <__d2b+0xa8>)
3401dfce:	f240 310f 	movw	r1, #783	@ 0x30f
3401dfd2:	4823      	ldr	r0, [pc, #140]	@ (3401e060 <__d2b+0xac>)
3401dfd4:	f7fd fbfa 	bl	3401b7cc <__assert_func>
3401dfd8:	f3c9 550a 	ubfx	r5, r9, #20, #11
3401dfdc:	f3c9 0313 	ubfx	r3, r9, #0, #20
3401dfe0:	b10d      	cbz	r5, 3401dfe6 <__d2b+0x32>
3401dfe2:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
3401dfe6:	9301      	str	r3, [sp, #4]
3401dfe8:	f1b8 0300 	subs.w	r3, r8, #0
3401dfec:	d023      	beq.n	3401e036 <__d2b+0x82>
3401dfee:	4668      	mov	r0, sp
3401dff0:	9300      	str	r3, [sp, #0]
3401dff2:	f7ff fd7e 	bl	3401daf2 <__lo0bits>
3401dff6:	e9dd 1200 	ldrd	r1, r2, [sp]
3401dffa:	b1d0      	cbz	r0, 3401e032 <__d2b+0x7e>
3401dffc:	f1c0 0320 	rsb	r3, r0, #32
3401e000:	fa02 f303 	lsl.w	r3, r2, r3
3401e004:	40c2      	lsrs	r2, r0
3401e006:	430b      	orrs	r3, r1
3401e008:	9201      	str	r2, [sp, #4]
3401e00a:	6163      	str	r3, [r4, #20]
3401e00c:	9b01      	ldr	r3, [sp, #4]
3401e00e:	2b00      	cmp	r3, #0
3401e010:	61a3      	str	r3, [r4, #24]
3401e012:	bf0c      	ite	eq
3401e014:	2201      	moveq	r2, #1
3401e016:	2202      	movne	r2, #2
3401e018:	6122      	str	r2, [r4, #16]
3401e01a:	b1a5      	cbz	r5, 3401e046 <__d2b+0x92>
3401e01c:	f2a5 4533 	subw	r5, r5, #1075	@ 0x433
3401e020:	4405      	add	r5, r0
3401e022:	f1c0 0035 	rsb	r0, r0, #53	@ 0x35
3401e026:	603d      	str	r5, [r7, #0]
3401e028:	6030      	str	r0, [r6, #0]
3401e02a:	4620      	mov	r0, r4
3401e02c:	b003      	add	sp, #12
3401e02e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
3401e032:	6161      	str	r1, [r4, #20]
3401e034:	e7ea      	b.n	3401e00c <__d2b+0x58>
3401e036:	a801      	add	r0, sp, #4
3401e038:	f7ff fd5b 	bl	3401daf2 <__lo0bits>
3401e03c:	9b01      	ldr	r3, [sp, #4]
3401e03e:	3020      	adds	r0, #32
3401e040:	2201      	movs	r2, #1
3401e042:	6163      	str	r3, [r4, #20]
3401e044:	e7e8      	b.n	3401e018 <__d2b+0x64>
3401e046:	f2a0 4032 	subw	r0, r0, #1074	@ 0x432
3401e04a:	eb04 0382 	add.w	r3, r4, r2, lsl #2
3401e04e:	6038      	str	r0, [r7, #0]
3401e050:	6918      	ldr	r0, [r3, #16]
3401e052:	f7ff fd2f 	bl	3401dab4 <__hi0bits>
3401e056:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
3401e05a:	e7e5      	b.n	3401e028 <__d2b+0x74>
3401e05c:	34020980 	.word	0x34020980
3401e060:	34020991 	.word	0x34020991

3401e064 <__sfputc_r>:
3401e064:	6893      	ldr	r3, [r2, #8]
3401e066:	3b01      	subs	r3, #1
3401e068:	2b00      	cmp	r3, #0
3401e06a:	b410      	push	{r4}
3401e06c:	6093      	str	r3, [r2, #8]
3401e06e:	da08      	bge.n	3401e082 <__sfputc_r+0x1e>
3401e070:	6994      	ldr	r4, [r2, #24]
3401e072:	42a3      	cmp	r3, r4
3401e074:	db01      	blt.n	3401e07a <__sfputc_r+0x16>
3401e076:	290a      	cmp	r1, #10
3401e078:	d103      	bne.n	3401e082 <__sfputc_r+0x1e>
3401e07a:	f85d 4b04 	ldr.w	r4, [sp], #4
3401e07e:	f7fe bb00 	b.w	3401c682 <__swbuf_r>
3401e082:	6813      	ldr	r3, [r2, #0]
3401e084:	1c58      	adds	r0, r3, #1
3401e086:	6010      	str	r0, [r2, #0]
3401e088:	4608      	mov	r0, r1
3401e08a:	7019      	strb	r1, [r3, #0]
3401e08c:	f85d 4b04 	ldr.w	r4, [sp], #4
3401e090:	4770      	bx	lr

3401e092 <__sfputs_r>:
3401e092:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3401e094:	4606      	mov	r6, r0
3401e096:	460f      	mov	r7, r1
3401e098:	4614      	mov	r4, r2
3401e09a:	18d5      	adds	r5, r2, r3
3401e09c:	42ac      	cmp	r4, r5
3401e09e:	d101      	bne.n	3401e0a4 <__sfputs_r+0x12>
3401e0a0:	2000      	movs	r0, #0
3401e0a2:	e007      	b.n	3401e0b4 <__sfputs_r+0x22>
3401e0a4:	463a      	mov	r2, r7
3401e0a6:	f814 1b01 	ldrb.w	r1, [r4], #1
3401e0aa:	4630      	mov	r0, r6
3401e0ac:	f7ff ffda 	bl	3401e064 <__sfputc_r>
3401e0b0:	1c43      	adds	r3, r0, #1
3401e0b2:	d1f3      	bne.n	3401e09c <__sfputs_r+0xa>
3401e0b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

3401e0b8 <_vfiprintf_r>:
3401e0b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401e0bc:	460d      	mov	r5, r1
3401e0be:	b09d      	sub	sp, #116	@ 0x74
3401e0c0:	4614      	mov	r4, r2
3401e0c2:	4698      	mov	r8, r3
3401e0c4:	4606      	mov	r6, r0
3401e0c6:	b118      	cbz	r0, 3401e0d0 <_vfiprintf_r+0x18>
3401e0c8:	6a03      	ldr	r3, [r0, #32]
3401e0ca:	b90b      	cbnz	r3, 3401e0d0 <_vfiprintf_r+0x18>
3401e0cc:	f7fe f9de 	bl	3401c48c <__sinit>
3401e0d0:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
3401e0d2:	07d9      	lsls	r1, r3, #31
3401e0d4:	d405      	bmi.n	3401e0e2 <_vfiprintf_r+0x2a>
3401e0d6:	89ab      	ldrh	r3, [r5, #12]
3401e0d8:	059a      	lsls	r2, r3, #22
3401e0da:	d402      	bmi.n	3401e0e2 <_vfiprintf_r+0x2a>
3401e0dc:	6da8      	ldr	r0, [r5, #88]	@ 0x58
3401e0de:	f7fe fde4 	bl	3401ccaa <__retarget_lock_acquire_recursive>
3401e0e2:	89ab      	ldrh	r3, [r5, #12]
3401e0e4:	071b      	lsls	r3, r3, #28
3401e0e6:	d501      	bpl.n	3401e0ec <_vfiprintf_r+0x34>
3401e0e8:	692b      	ldr	r3, [r5, #16]
3401e0ea:	b99b      	cbnz	r3, 3401e114 <_vfiprintf_r+0x5c>
3401e0ec:	4629      	mov	r1, r5
3401e0ee:	4630      	mov	r0, r6
3401e0f0:	f7fe fb06 	bl	3401c700 <__swsetup_r>
3401e0f4:	b170      	cbz	r0, 3401e114 <_vfiprintf_r+0x5c>
3401e0f6:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
3401e0f8:	07dc      	lsls	r4, r3, #31
3401e0fa:	d504      	bpl.n	3401e106 <_vfiprintf_r+0x4e>
3401e0fc:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
3401e100:	b01d      	add	sp, #116	@ 0x74
3401e102:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401e106:	89ab      	ldrh	r3, [r5, #12]
3401e108:	0598      	lsls	r0, r3, #22
3401e10a:	d4f7      	bmi.n	3401e0fc <_vfiprintf_r+0x44>
3401e10c:	6da8      	ldr	r0, [r5, #88]	@ 0x58
3401e10e:	f7fe fdcd 	bl	3401ccac <__retarget_lock_release_recursive>
3401e112:	e7f3      	b.n	3401e0fc <_vfiprintf_r+0x44>
3401e114:	2300      	movs	r3, #0
3401e116:	f8cd 800c 	str.w	r8, [sp, #12]
3401e11a:	f04f 0901 	mov.w	r9, #1
3401e11e:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 3401e2d4 <_vfiprintf_r+0x21c>
3401e122:	9309      	str	r3, [sp, #36]	@ 0x24
3401e124:	2320      	movs	r3, #32
3401e126:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
3401e12a:	2330      	movs	r3, #48	@ 0x30
3401e12c:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
3401e130:	4623      	mov	r3, r4
3401e132:	469a      	mov	sl, r3
3401e134:	f813 2b01 	ldrb.w	r2, [r3], #1
3401e138:	b10a      	cbz	r2, 3401e13e <_vfiprintf_r+0x86>
3401e13a:	2a25      	cmp	r2, #37	@ 0x25
3401e13c:	d1f9      	bne.n	3401e132 <_vfiprintf_r+0x7a>
3401e13e:	ebba 0b04 	subs.w	fp, sl, r4
3401e142:	d00b      	beq.n	3401e15c <_vfiprintf_r+0xa4>
3401e144:	465b      	mov	r3, fp
3401e146:	4622      	mov	r2, r4
3401e148:	4629      	mov	r1, r5
3401e14a:	4630      	mov	r0, r6
3401e14c:	f7ff ffa1 	bl	3401e092 <__sfputs_r>
3401e150:	3001      	adds	r0, #1
3401e152:	f000 80a7 	beq.w	3401e2a4 <_vfiprintf_r+0x1ec>
3401e156:	9a09      	ldr	r2, [sp, #36]	@ 0x24
3401e158:	445a      	add	r2, fp
3401e15a:	9209      	str	r2, [sp, #36]	@ 0x24
3401e15c:	f89a 3000 	ldrb.w	r3, [sl]
3401e160:	2b00      	cmp	r3, #0
3401e162:	f000 809f 	beq.w	3401e2a4 <_vfiprintf_r+0x1ec>
3401e166:	2300      	movs	r3, #0
3401e168:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
3401e16c:	f10a 0a01 	add.w	sl, sl, #1
3401e170:	9304      	str	r3, [sp, #16]
3401e172:	9307      	str	r3, [sp, #28]
3401e174:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
3401e178:	931a      	str	r3, [sp, #104]	@ 0x68
3401e17a:	e9cd 2305 	strd	r2, r3, [sp, #20]
3401e17e:	4654      	mov	r4, sl
3401e180:	2205      	movs	r2, #5
3401e182:	4854      	ldr	r0, [pc, #336]	@ (3401e2d4 <_vfiprintf_r+0x21c>)
3401e184:	f814 1b01 	ldrb.w	r1, [r4], #1
3401e188:	f7fe fd91 	bl	3401ccae <memchr>
3401e18c:	9a04      	ldr	r2, [sp, #16]
3401e18e:	b9d8      	cbnz	r0, 3401e1c8 <_vfiprintf_r+0x110>
3401e190:	06d1      	lsls	r1, r2, #27
3401e192:	bf44      	itt	mi
3401e194:	2320      	movmi	r3, #32
3401e196:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3401e19a:	0713      	lsls	r3, r2, #28
3401e19c:	bf44      	itt	mi
3401e19e:	232b      	movmi	r3, #43	@ 0x2b
3401e1a0:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3401e1a4:	f89a 3000 	ldrb.w	r3, [sl]
3401e1a8:	2b2a      	cmp	r3, #42	@ 0x2a
3401e1aa:	d015      	beq.n	3401e1d8 <_vfiprintf_r+0x120>
3401e1ac:	9a07      	ldr	r2, [sp, #28]
3401e1ae:	4654      	mov	r4, sl
3401e1b0:	2000      	movs	r0, #0
3401e1b2:	f04f 0c0a 	mov.w	ip, #10
3401e1b6:	4621      	mov	r1, r4
3401e1b8:	f811 3b01 	ldrb.w	r3, [r1], #1
3401e1bc:	3b30      	subs	r3, #48	@ 0x30
3401e1be:	2b09      	cmp	r3, #9
3401e1c0:	d94b      	bls.n	3401e25a <_vfiprintf_r+0x1a2>
3401e1c2:	b1b0      	cbz	r0, 3401e1f2 <_vfiprintf_r+0x13a>
3401e1c4:	9207      	str	r2, [sp, #28]
3401e1c6:	e014      	b.n	3401e1f2 <_vfiprintf_r+0x13a>
3401e1c8:	eba0 0308 	sub.w	r3, r0, r8
3401e1cc:	46a2      	mov	sl, r4
3401e1ce:	fa09 f303 	lsl.w	r3, r9, r3
3401e1d2:	4313      	orrs	r3, r2
3401e1d4:	9304      	str	r3, [sp, #16]
3401e1d6:	e7d2      	b.n	3401e17e <_vfiprintf_r+0xc6>
3401e1d8:	9b03      	ldr	r3, [sp, #12]
3401e1da:	1d19      	adds	r1, r3, #4
3401e1dc:	681b      	ldr	r3, [r3, #0]
3401e1de:	2b00      	cmp	r3, #0
3401e1e0:	9103      	str	r1, [sp, #12]
3401e1e2:	bfbb      	ittet	lt
3401e1e4:	425b      	neglt	r3, r3
3401e1e6:	f042 0202 	orrlt.w	r2, r2, #2
3401e1ea:	9307      	strge	r3, [sp, #28]
3401e1ec:	9307      	strlt	r3, [sp, #28]
3401e1ee:	bfb8      	it	lt
3401e1f0:	9204      	strlt	r2, [sp, #16]
3401e1f2:	7823      	ldrb	r3, [r4, #0]
3401e1f4:	2b2e      	cmp	r3, #46	@ 0x2e
3401e1f6:	d10a      	bne.n	3401e20e <_vfiprintf_r+0x156>
3401e1f8:	7863      	ldrb	r3, [r4, #1]
3401e1fa:	2b2a      	cmp	r3, #42	@ 0x2a
3401e1fc:	d132      	bne.n	3401e264 <_vfiprintf_r+0x1ac>
3401e1fe:	9b03      	ldr	r3, [sp, #12]
3401e200:	3402      	adds	r4, #2
3401e202:	1d1a      	adds	r2, r3, #4
3401e204:	681b      	ldr	r3, [r3, #0]
3401e206:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
3401e20a:	9203      	str	r2, [sp, #12]
3401e20c:	9305      	str	r3, [sp, #20]
3401e20e:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 3401e2e4 <_vfiprintf_r+0x22c>
3401e212:	2203      	movs	r2, #3
3401e214:	7821      	ldrb	r1, [r4, #0]
3401e216:	4650      	mov	r0, sl
3401e218:	f7fe fd49 	bl	3401ccae <memchr>
3401e21c:	b138      	cbz	r0, 3401e22e <_vfiprintf_r+0x176>
3401e21e:	eba0 000a 	sub.w	r0, r0, sl
3401e222:	2240      	movs	r2, #64	@ 0x40
3401e224:	9b04      	ldr	r3, [sp, #16]
3401e226:	3401      	adds	r4, #1
3401e228:	4082      	lsls	r2, r0
3401e22a:	4313      	orrs	r3, r2
3401e22c:	9304      	str	r3, [sp, #16]
3401e22e:	f814 1b01 	ldrb.w	r1, [r4], #1
3401e232:	2206      	movs	r2, #6
3401e234:	4828      	ldr	r0, [pc, #160]	@ (3401e2d8 <_vfiprintf_r+0x220>)
3401e236:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
3401e23a:	f7fe fd38 	bl	3401ccae <memchr>
3401e23e:	2800      	cmp	r0, #0
3401e240:	d03f      	beq.n	3401e2c2 <_vfiprintf_r+0x20a>
3401e242:	4b26      	ldr	r3, [pc, #152]	@ (3401e2dc <_vfiprintf_r+0x224>)
3401e244:	bb1b      	cbnz	r3, 3401e28e <_vfiprintf_r+0x1d6>
3401e246:	9b03      	ldr	r3, [sp, #12]
3401e248:	3307      	adds	r3, #7
3401e24a:	f023 0307 	bic.w	r3, r3, #7
3401e24e:	3308      	adds	r3, #8
3401e250:	9303      	str	r3, [sp, #12]
3401e252:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401e254:	443b      	add	r3, r7
3401e256:	9309      	str	r3, [sp, #36]	@ 0x24
3401e258:	e76a      	b.n	3401e130 <_vfiprintf_r+0x78>
3401e25a:	fb0c 3202 	mla	r2, ip, r2, r3
3401e25e:	460c      	mov	r4, r1
3401e260:	2001      	movs	r0, #1
3401e262:	e7a8      	b.n	3401e1b6 <_vfiprintf_r+0xfe>
3401e264:	2300      	movs	r3, #0
3401e266:	3401      	adds	r4, #1
3401e268:	f04f 0c0a 	mov.w	ip, #10
3401e26c:	4619      	mov	r1, r3
3401e26e:	9305      	str	r3, [sp, #20]
3401e270:	4620      	mov	r0, r4
3401e272:	f810 2b01 	ldrb.w	r2, [r0], #1
3401e276:	3a30      	subs	r2, #48	@ 0x30
3401e278:	2a09      	cmp	r2, #9
3401e27a:	d903      	bls.n	3401e284 <_vfiprintf_r+0x1cc>
3401e27c:	2b00      	cmp	r3, #0
3401e27e:	d0c6      	beq.n	3401e20e <_vfiprintf_r+0x156>
3401e280:	9105      	str	r1, [sp, #20]
3401e282:	e7c4      	b.n	3401e20e <_vfiprintf_r+0x156>
3401e284:	fb0c 2101 	mla	r1, ip, r1, r2
3401e288:	4604      	mov	r4, r0
3401e28a:	2301      	movs	r3, #1
3401e28c:	e7f0      	b.n	3401e270 <_vfiprintf_r+0x1b8>
3401e28e:	ab03      	add	r3, sp, #12
3401e290:	462a      	mov	r2, r5
3401e292:	a904      	add	r1, sp, #16
3401e294:	4630      	mov	r0, r6
3401e296:	9300      	str	r3, [sp, #0]
3401e298:	4b11      	ldr	r3, [pc, #68]	@ (3401e2e0 <_vfiprintf_r+0x228>)
3401e29a:	f7fd fc01 	bl	3401baa0 <_printf_float>
3401e29e:	4607      	mov	r7, r0
3401e2a0:	1c78      	adds	r0, r7, #1
3401e2a2:	d1d6      	bne.n	3401e252 <_vfiprintf_r+0x19a>
3401e2a4:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
3401e2a6:	07d9      	lsls	r1, r3, #31
3401e2a8:	d405      	bmi.n	3401e2b6 <_vfiprintf_r+0x1fe>
3401e2aa:	89ab      	ldrh	r3, [r5, #12]
3401e2ac:	059a      	lsls	r2, r3, #22
3401e2ae:	d402      	bmi.n	3401e2b6 <_vfiprintf_r+0x1fe>
3401e2b0:	6da8      	ldr	r0, [r5, #88]	@ 0x58
3401e2b2:	f7fe fcfb 	bl	3401ccac <__retarget_lock_release_recursive>
3401e2b6:	89ab      	ldrh	r3, [r5, #12]
3401e2b8:	065b      	lsls	r3, r3, #25
3401e2ba:	f53f af1f 	bmi.w	3401e0fc <_vfiprintf_r+0x44>
3401e2be:	9809      	ldr	r0, [sp, #36]	@ 0x24
3401e2c0:	e71e      	b.n	3401e100 <_vfiprintf_r+0x48>
3401e2c2:	ab03      	add	r3, sp, #12
3401e2c4:	462a      	mov	r2, r5
3401e2c6:	a904      	add	r1, sp, #16
3401e2c8:	4630      	mov	r0, r6
3401e2ca:	9300      	str	r3, [sp, #0]
3401e2cc:	4b04      	ldr	r3, [pc, #16]	@ (3401e2e0 <_vfiprintf_r+0x228>)
3401e2ce:	f7fd fe73 	bl	3401bfb8 <_printf_i>
3401e2d2:	e7e4      	b.n	3401e29e <_vfiprintf_r+0x1e6>
3401e2d4:	340209ea 	.word	0x340209ea
3401e2d8:	340209f4 	.word	0x340209f4
3401e2dc:	3401baa1 	.word	0x3401baa1
3401e2e0:	3401e093 	.word	0x3401e093
3401e2e4:	340209f0 	.word	0x340209f0

3401e2e8 <__swhatbuf_r>:
3401e2e8:	b570      	push	{r4, r5, r6, lr}
3401e2ea:	460c      	mov	r4, r1
3401e2ec:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
3401e2f0:	b096      	sub	sp, #88	@ 0x58
3401e2f2:	4615      	mov	r5, r2
3401e2f4:	2900      	cmp	r1, #0
3401e2f6:	461e      	mov	r6, r3
3401e2f8:	da0c      	bge.n	3401e314 <__swhatbuf_r+0x2c>
3401e2fa:	89a3      	ldrh	r3, [r4, #12]
3401e2fc:	2100      	movs	r1, #0
3401e2fe:	f013 0f80 	tst.w	r3, #128	@ 0x80
3401e302:	bf14      	ite	ne
3401e304:	2340      	movne	r3, #64	@ 0x40
3401e306:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
3401e30a:	2000      	movs	r0, #0
3401e30c:	6031      	str	r1, [r6, #0]
3401e30e:	602b      	str	r3, [r5, #0]
3401e310:	b016      	add	sp, #88	@ 0x58
3401e312:	bd70      	pop	{r4, r5, r6, pc}
3401e314:	466a      	mov	r2, sp
3401e316:	f000 f879 	bl	3401e40c <_fstat_r>
3401e31a:	2800      	cmp	r0, #0
3401e31c:	dbed      	blt.n	3401e2fa <__swhatbuf_r+0x12>
3401e31e:	9901      	ldr	r1, [sp, #4]
3401e320:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
3401e324:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
3401e328:	4259      	negs	r1, r3
3401e32a:	4159      	adcs	r1, r3
3401e32c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3401e330:	e7eb      	b.n	3401e30a <__swhatbuf_r+0x22>

3401e332 <__smakebuf_r>:
3401e332:	898b      	ldrh	r3, [r1, #12]
3401e334:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3401e336:	079d      	lsls	r5, r3, #30
3401e338:	4606      	mov	r6, r0
3401e33a:	460c      	mov	r4, r1
3401e33c:	d507      	bpl.n	3401e34e <__smakebuf_r+0x1c>
3401e33e:	f104 0347 	add.w	r3, r4, #71	@ 0x47
3401e342:	6023      	str	r3, [r4, #0]
3401e344:	6123      	str	r3, [r4, #16]
3401e346:	2301      	movs	r3, #1
3401e348:	6163      	str	r3, [r4, #20]
3401e34a:	b003      	add	sp, #12
3401e34c:	bdf0      	pop	{r4, r5, r6, r7, pc}
3401e34e:	ab01      	add	r3, sp, #4
3401e350:	466a      	mov	r2, sp
3401e352:	f7ff ffc9 	bl	3401e2e8 <__swhatbuf_r>
3401e356:	9f00      	ldr	r7, [sp, #0]
3401e358:	4605      	mov	r5, r0
3401e35a:	4630      	mov	r0, r6
3401e35c:	4639      	mov	r1, r7
3401e35e:	f7fd fa85 	bl	3401b86c <_malloc_r>
3401e362:	b948      	cbnz	r0, 3401e378 <__smakebuf_r+0x46>
3401e364:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3401e368:	059a      	lsls	r2, r3, #22
3401e36a:	d4ee      	bmi.n	3401e34a <__smakebuf_r+0x18>
3401e36c:	f023 0303 	bic.w	r3, r3, #3
3401e370:	f043 0302 	orr.w	r3, r3, #2
3401e374:	81a3      	strh	r3, [r4, #12]
3401e376:	e7e2      	b.n	3401e33e <__smakebuf_r+0xc>
3401e378:	89a3      	ldrh	r3, [r4, #12]
3401e37a:	6020      	str	r0, [r4, #0]
3401e37c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
3401e380:	81a3      	strh	r3, [r4, #12]
3401e382:	9b01      	ldr	r3, [sp, #4]
3401e384:	e9c4 0704 	strd	r0, r7, [r4, #16]
3401e388:	b15b      	cbz	r3, 3401e3a2 <__smakebuf_r+0x70>
3401e38a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
3401e38e:	4630      	mov	r0, r6
3401e390:	f000 f84e 	bl	3401e430 <_isatty_r>
3401e394:	b128      	cbz	r0, 3401e3a2 <__smakebuf_r+0x70>
3401e396:	89a3      	ldrh	r3, [r4, #12]
3401e398:	f023 0303 	bic.w	r3, r3, #3
3401e39c:	f043 0301 	orr.w	r3, r3, #1
3401e3a0:	81a3      	strh	r3, [r4, #12]
3401e3a2:	89a3      	ldrh	r3, [r4, #12]
3401e3a4:	431d      	orrs	r5, r3
3401e3a6:	81a5      	strh	r5, [r4, #12]
3401e3a8:	e7cf      	b.n	3401e34a <__smakebuf_r+0x18>

3401e3aa <_raise_r>:
3401e3aa:	291f      	cmp	r1, #31
3401e3ac:	b538      	push	{r3, r4, r5, lr}
3401e3ae:	4605      	mov	r5, r0
3401e3b0:	460c      	mov	r4, r1
3401e3b2:	d904      	bls.n	3401e3be <_raise_r+0x14>
3401e3b4:	2316      	movs	r3, #22
3401e3b6:	6003      	str	r3, [r0, #0]
3401e3b8:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
3401e3bc:	bd38      	pop	{r3, r4, r5, pc}
3401e3be:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
3401e3c0:	b112      	cbz	r2, 3401e3c8 <_raise_r+0x1e>
3401e3c2:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
3401e3c6:	b94b      	cbnz	r3, 3401e3dc <_raise_r+0x32>
3401e3c8:	4628      	mov	r0, r5
3401e3ca:	f000 f853 	bl	3401e474 <_getpid_r>
3401e3ce:	4622      	mov	r2, r4
3401e3d0:	4601      	mov	r1, r0
3401e3d2:	4628      	mov	r0, r5
3401e3d4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
3401e3d8:	f000 b83a 	b.w	3401e450 <_kill_r>
3401e3dc:	2b01      	cmp	r3, #1
3401e3de:	d00a      	beq.n	3401e3f6 <_raise_r+0x4c>
3401e3e0:	1c59      	adds	r1, r3, #1
3401e3e2:	d103      	bne.n	3401e3ec <_raise_r+0x42>
3401e3e4:	2316      	movs	r3, #22
3401e3e6:	6003      	str	r3, [r0, #0]
3401e3e8:	2001      	movs	r0, #1
3401e3ea:	e7e7      	b.n	3401e3bc <_raise_r+0x12>
3401e3ec:	2100      	movs	r1, #0
3401e3ee:	4620      	mov	r0, r4
3401e3f0:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
3401e3f4:	4798      	blx	r3
3401e3f6:	2000      	movs	r0, #0
3401e3f8:	e7e0      	b.n	3401e3bc <_raise_r+0x12>
	...

3401e3fc <raise>:
3401e3fc:	4b02      	ldr	r3, [pc, #8]	@ (3401e408 <raise+0xc>)
3401e3fe:	4601      	mov	r1, r0
3401e400:	6818      	ldr	r0, [r3, #0]
3401e402:	f7ff bfd2 	b.w	3401e3aa <_raise_r>
3401e406:	bf00      	nop
3401e408:	34020c6c 	.word	0x34020c6c

3401e40c <_fstat_r>:
3401e40c:	b538      	push	{r3, r4, r5, lr}
3401e40e:	2300      	movs	r3, #0
3401e410:	4d06      	ldr	r5, [pc, #24]	@ (3401e42c <_fstat_r+0x20>)
3401e412:	4604      	mov	r4, r0
3401e414:	4608      	mov	r0, r1
3401e416:	4611      	mov	r1, r2
3401e418:	602b      	str	r3, [r5, #0]
3401e41a:	f7e3 fef9 	bl	34002210 <_fstat>
3401e41e:	1c43      	adds	r3, r0, #1
3401e420:	d102      	bne.n	3401e428 <_fstat_r+0x1c>
3401e422:	682b      	ldr	r3, [r5, #0]
3401e424:	b103      	cbz	r3, 3401e428 <_fstat_r+0x1c>
3401e426:	6023      	str	r3, [r4, #0]
3401e428:	bd38      	pop	{r3, r4, r5, pc}
3401e42a:	bf00      	nop
3401e42c:	340214f4 	.word	0x340214f4

3401e430 <_isatty_r>:
3401e430:	b538      	push	{r3, r4, r5, lr}
3401e432:	2300      	movs	r3, #0
3401e434:	4d05      	ldr	r5, [pc, #20]	@ (3401e44c <_isatty_r+0x1c>)
3401e436:	4604      	mov	r4, r0
3401e438:	4608      	mov	r0, r1
3401e43a:	602b      	str	r3, [r5, #0]
3401e43c:	f7e3 fef8 	bl	34002230 <_isatty>
3401e440:	1c43      	adds	r3, r0, #1
3401e442:	d102      	bne.n	3401e44a <_isatty_r+0x1a>
3401e444:	682b      	ldr	r3, [r5, #0]
3401e446:	b103      	cbz	r3, 3401e44a <_isatty_r+0x1a>
3401e448:	6023      	str	r3, [r4, #0]
3401e44a:	bd38      	pop	{r3, r4, r5, pc}
3401e44c:	340214f4 	.word	0x340214f4

3401e450 <_kill_r>:
3401e450:	b538      	push	{r3, r4, r5, lr}
3401e452:	2300      	movs	r3, #0
3401e454:	4d06      	ldr	r5, [pc, #24]	@ (3401e470 <_kill_r+0x20>)
3401e456:	4604      	mov	r4, r0
3401e458:	4608      	mov	r0, r1
3401e45a:	4611      	mov	r1, r2
3401e45c:	602b      	str	r3, [r5, #0]
3401e45e:	f7e3 fe93 	bl	34002188 <_kill>
3401e462:	1c43      	adds	r3, r0, #1
3401e464:	d102      	bne.n	3401e46c <_kill_r+0x1c>
3401e466:	682b      	ldr	r3, [r5, #0]
3401e468:	b103      	cbz	r3, 3401e46c <_kill_r+0x1c>
3401e46a:	6023      	str	r3, [r4, #0]
3401e46c:	bd38      	pop	{r3, r4, r5, pc}
3401e46e:	bf00      	nop
3401e470:	340214f4 	.word	0x340214f4

3401e474 <_getpid_r>:
3401e474:	f7e3 be80 	b.w	34002178 <_getpid>

3401e478 <_calloc_r>:
3401e478:	b570      	push	{r4, r5, r6, lr}
3401e47a:	fba1 5402 	umull	r5, r4, r1, r2
3401e47e:	b934      	cbnz	r4, 3401e48e <_calloc_r+0x16>
3401e480:	4629      	mov	r1, r5
3401e482:	f7fd f9f3 	bl	3401b86c <_malloc_r>
3401e486:	4606      	mov	r6, r0
3401e488:	b928      	cbnz	r0, 3401e496 <_calloc_r+0x1e>
3401e48a:	4630      	mov	r0, r6
3401e48c:	bd70      	pop	{r4, r5, r6, pc}
3401e48e:	220c      	movs	r2, #12
3401e490:	2600      	movs	r6, #0
3401e492:	6002      	str	r2, [r0, #0]
3401e494:	e7f9      	b.n	3401e48a <_calloc_r+0x12>
3401e496:	462a      	mov	r2, r5
3401e498:	4621      	mov	r1, r4
3401e49a:	f7fe f987 	bl	3401c7ac <memset>
3401e49e:	e7f4      	b.n	3401e48a <_calloc_r+0x12>

3401e4a0 <__ascii_mbtowc>:
3401e4a0:	b082      	sub	sp, #8
3401e4a2:	b901      	cbnz	r1, 3401e4a6 <__ascii_mbtowc+0x6>
3401e4a4:	a901      	add	r1, sp, #4
3401e4a6:	b142      	cbz	r2, 3401e4ba <__ascii_mbtowc+0x1a>
3401e4a8:	b14b      	cbz	r3, 3401e4be <__ascii_mbtowc+0x1e>
3401e4aa:	7813      	ldrb	r3, [r2, #0]
3401e4ac:	600b      	str	r3, [r1, #0]
3401e4ae:	7812      	ldrb	r2, [r2, #0]
3401e4b0:	1e10      	subs	r0, r2, #0
3401e4b2:	bf18      	it	ne
3401e4b4:	2001      	movne	r0, #1
3401e4b6:	b002      	add	sp, #8
3401e4b8:	4770      	bx	lr
3401e4ba:	4610      	mov	r0, r2
3401e4bc:	e7fb      	b.n	3401e4b6 <__ascii_mbtowc+0x16>
3401e4be:	f06f 0001 	mvn.w	r0, #1
3401e4c2:	e7f8      	b.n	3401e4b6 <__ascii_mbtowc+0x16>

3401e4c4 <__ascii_wctomb>:
3401e4c4:	4603      	mov	r3, r0
3401e4c6:	4608      	mov	r0, r1
3401e4c8:	b141      	cbz	r1, 3401e4dc <__ascii_wctomb+0x18>
3401e4ca:	2aff      	cmp	r2, #255	@ 0xff
3401e4cc:	d904      	bls.n	3401e4d8 <__ascii_wctomb+0x14>
3401e4ce:	228a      	movs	r2, #138	@ 0x8a
3401e4d0:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
3401e4d4:	601a      	str	r2, [r3, #0]
3401e4d6:	4770      	bx	lr
3401e4d8:	2001      	movs	r0, #1
3401e4da:	700a      	strb	r2, [r1, #0]
3401e4dc:	4770      	bx	lr
	...

3401e4e0 <_sbrk>:
3401e4e0:	4a04      	ldr	r2, [pc, #16]	@ (3401e4f4 <_sbrk+0x14>)
3401e4e2:	4603      	mov	r3, r0
3401e4e4:	6811      	ldr	r1, [r2, #0]
3401e4e6:	b909      	cbnz	r1, 3401e4ec <_sbrk+0xc>
3401e4e8:	4903      	ldr	r1, [pc, #12]	@ (3401e4f8 <_sbrk+0x18>)
3401e4ea:	6011      	str	r1, [r2, #0]
3401e4ec:	6810      	ldr	r0, [r2, #0]
3401e4ee:	4403      	add	r3, r0
3401e4f0:	6013      	str	r3, [r2, #0]
3401e4f2:	4770      	bx	lr
3401e4f4:	340214fc 	.word	0x340214fc
3401e4f8:	34021500 	.word	0x34021500

3401e4fc <_init>:
3401e4fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3401e4fe:	bf00      	nop
3401e500:	bcf8      	pop	{r3, r4, r5, r6, r7}
3401e502:	bc08      	pop	{r3}
3401e504:	469e      	mov	lr, r3
3401e506:	4770      	bx	lr

3401e508 <_fini>:
3401e508:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3401e50a:	bf00      	nop
3401e50c:	bcf8      	pop	{r3, r4, r5, r6, r7}
3401e50e:	bc08      	pop	{r3}
3401e510:	469e      	mov	lr, r3
3401e512:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

3401e520 <SECURE_SystemCoreClockUpdate>:
3401e520:	e97f e97f 	sg
3401e524:	f7e5 bd1a 	b.w	34003f5c <__acle_se_SECURE_SystemCoreClockUpdate>
	...
